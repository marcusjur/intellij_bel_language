### META-INF/scala-plugin-common.xml
scala.notification.group.id.general=Scala(일반)
scala.notification.group.id.java.to.scala.converter=Java에서 Scala로 변환하는 컨버터
scala.notification.group.id.sbt.project.import=SBT 프로젝트 가져오기
scala.notification.group.id.sbt.shell=SBT 셸
scala.notification.group.id.plugin.verifier=Scala 플러그인 검증기
scala.notification.group.id.plugin.updater=Scala 플러그인 업데이터
scala.notification.group.id.scala3.disclaimer=Scala 3 면책조항
scala.notification.group.id.features.advertiser=Scala 기능 애드버타이저
scala.notification.group.id.scalafmt=Scalafmt
scala.notification.group.id.scalafmt.fatal.errors=Scalafmt 치명적인 오류
scala.notification.group.id.scalafmt.format.errors=Scalafmt 서식 오류

### org/jetbrains/plugins/scala/DesktopUtils.scala
title.problem.opening.web.page=웹 페이지 열기 문제
html.unable.to.launch.web.browser=웹 브라우저를 실행할 수 없습니다. 수동으로 실행하세요. {0}
copy.link.to.clipboard=링크를 클립보드에 복사

### org/jetbrains/plugins/scala/actions/EditPackagePrefixAction.scala
edit.package.prefix=패키지 접두사 편집...

### org/jetbrains/plugins/scala/actions/MakeExplicitAction.scala
make.implicit.conversion.explicit.action.text=묵시적 변환을 명시적으로 만들기
make.implicit.conversion.explicit.action.description=묵시적 변환을 명시적으로 만듭니다
title.choose.implicit.conversion.method=묵시적 변환 메서드 선택\:
press.alt.enter=Alt+Enter 누르기
make.explicit=명시적으로 설정
make.explicit.and.import.method=명시적으로 설정(메서드 가져오기)

### org/jetbrains/plugins/scala/actions/NewPackageObjectAction.scala
new.packageobject.menu.action.text=패키지 객체
new.packageobject.menu.action.description=새 Scala 패키지 객체 생성

### org/jetbrains/plugins/scala/actions/NewScalaFileAction.scala
newclass.menu.action.text=Scala 클래스
newclass.menu.action.description=새 Scala 클래스 생성
create.new.scala.class=새 Scala 클래스 생성
newclassorfile.menu.action.text=Scala 클래스/파일
newclassorfile.menu.action.description=새 Scala 클래스 또는 파일을 생성합니다
create.new.scala.class.or.file=새 Scala 클래스/파일 생성
this.is.not.a.valid.scala.qualified.name=올바른 Scala 정규화된 이름이 아닙니다

### org/jetbrains/plugins/scala/actions/ScalaExpressionTypeProvider.scala
unknown.type=<알 수 없음>

### org/jetbrains/plugins/scala/actions/ShowTypeInfoAction.scala
type.info.text=타입 정보
type.info.description=타입 정보 표시
could.not.find.type.for.selection=선택 항목의 타입을 찾을 수 없습니다
hint.label.non.singleton=비 싱글턴
hint.label.simplified=단순화됨
hint.label.original=원본
hint.label.expected=필요

### org/jetbrains/plugins/scala/actions/ToggleTypeAwareHighlightingAction.scala
toggle.type.aware.highlighting.menu.action.text=타입 정보를 사용하는 강조표시 전환
toggle.type.aware.highlighting.menu.action.description=타입 인식 강조 표시 전환

### org/jetbrains/plugins/scala/actions/implicitArguments/ImplicitArgumentNodes.scala
implicit.argument.is.applicable=묵시적 인수를 적용할 수 있습니다
implicit.is.diverged=Implicit이 분기됩니다
can.t.infer.proper.types.for.type.parameters=타입 매개변수의 적절한 타입을 추론할 수 없습니다
can.t.find.implicit.argument.for.this.definition=이 정의에 대한 묵시적 인수를 찾을 수 없습니다
no.implicits.applicable.by.type=타입별로 적용 가능한 묵시적 항목이 없습니다
reason.prefix.applicable=적용 가능\: 
reason.prefix.diverged=분기됨\: 
reason.prefix.cannot.infer.type=타입을 추론할 수 없음\: 
reason.prefix.candidate=후보\: 
problem.prefix.ambiguous=(모호함)
problem.prefix.not.found=(찾을 수 없음)
location.description.parameter.of.name={0}의 매개변수
location.description.parameter.of.getclassnametext={0}의 매개변수
location.description.anonymous.class=익명 클래스
location.description.containing.block=포함 블록
location.description.body.of.name={0}의 본문

### org/jetbrains/plugins/scala/actions/implicitArguments/ShowImplicitArgumentsAction.scala
show.implicit.arguments.action.text=묵시적 인수 표시
show.implicit.arguments.action.description=묵시적 인수를 표시합니다
no.implicit.arguments=묵시적 인수 없음
title.expressions=표현식
navigate=탐색
implicit.arguments.for.implicit.conversion=묵시적 변환에 대한 묵시적 인수\:
implicit.arguments=묵시적 인수\:

### org/jetbrains/plugins/scala/actions/implicitConversions/ShowImplicitConversionsAction.scala
implicit.conversions.action.text=묵시적 변환 표시
implicit.conversions.action.description=묵시적 변환 표시

### org/jetbrains/plugins/scala/annotator/AnnotatorUtils.scala
# TODO unify type mismatch messages
type.mismatch.found.required=타입이 불일치합니다. 발견\: {0}, 필요\: {1}
# TODO unify type mismatch messages
type.mismatch.expected.actual=타입이 불일치합니다. 필요\: {0}, 실제\: {1}
abstract.member.not.have.private.modifier=추상 멤버는 private 제어자를 가질 수 없습니다
illegal.inheritance.from.sealed.kind=sealed {0} ''{1}''(으)로부터의 올바르지 않은 상속

### org/jetbrains/plugins/scala/annotator/ByNameParameter.scala
passed.as.by.name.parameter=이름에 의한 호출 매개변수로 전달되었습니다

### org/jetbrains/plugins/scala/annotator/FunctionAnnotator.scala
function.must.define.type.explicitly=메서드 {0}에 return 문이 있으므로 결과 타입이 필요합니다
function.recursive.need.result.type=재귀 메서드 {0}에 결과 타입이 필요합니다
family.name.remove.tailrec.annotation=@tailrec 어노테이션 제거
method.annotated.with.tailrec.is.neither.private.nor.final=@tailrec로 어노테이션 추가된 메서드가 비공개도 아니고 최종도 아닙니다(재정의될 수 있음)
method.annotated.with.tailrec.contains.no.recursive.calls=@tailrec 어노테이션이 추가된 메서드가 재귀 호출을 포함하지 않습니다
recursive.call.not.in.tail.position=재귀 호출이 꼬리 위치에 없습니다(@tailrec 어노테이션이 추가된 메서드 내)

### org/jetbrains/plugins/scala/annotator/OverridingAnnotator.scala
member.needs.override.modifier={0} ''{1}''에 재정의 제어자가 필요합니다
member.overrides.nothing={0} ''{1}''이(가) 아무것도 재정의하지 않습니다
can.not.override.final={0} ''{1}''이(가) final 멤버를 재정의할 수 없습니다
member.cannot.override.val=메서드 {0}에 안정적인 변경 불가한 값이 필요합니다
var.cannot.override.val=변수 {0}이(가) 변경 불가한 값을 재정의할 수 없습니다
override.types.not.conforming=재정의 타입 {0}이(가) 기본 타입 {1}을(를) 준수하지 않습니다
regular.method.overrides.extension=메서드 {0}은(는) 일반 메서드이므로 확장 메서드를 재정의할 수 없습니다.
extension.method.overrides.regular=메서드 {0}은(는) 확장 메서드이므로 일반 메서드를 재정의할 수 없습니다.

### org/jetbrains/plugins/scala/annotator/ScalaAnnotator.scala
covariant.type.contravariant.position.of.method=공변성 타입 {0}이(가) 메서드 {2}의 타입 {1} 내 반공변성 위치에 나타납니다
covariant.type.contravariant.position.of.value=공변성 타입 {0}이(가) 값 {2}의 타입 {1} 내 반공변성 위치에 나타납니다
covariant.type.invariant.position.of.method=공변성 타입 {0}이(가) 메서드 {2}의 타입 {1} 내 무공변성 위치에 나타납니다
covariant.type.invariant.position.of.value=공변성 타입 {0}이(가) 값 {2}의 타입 {1} 내 무공변성 위치에 나타납니다
contravariant.type.covariant.position.of.method=반공변성 타입 {0}이(가) 메서드 {2}의 타입 {1} 내 공변성 위치에 나타납니다
contravariant.type.covariant.position.of.value=반공변성 타입 {0}이(가) 값 {2}의 타입 {1} 내 공변성 위치에 나타납니다
contravariant.type.invariant.position.of.method=반공변성 타입 {0}이(가) 메서드 {2}의 타입 {1} 내 무공변성 위치에 나타납니다
contravariant.type.invariant.position.of.value=반공변성 타입 {0}이(가) 값 {2}의 타입 {1} 내 무공변성 위치에 나타납니다

### org/jetbrains/plugins/scala/annotator/ScopeAnnotator.scala
id.is.already.defined={0}이(가) 범위 안에 이미 정의되어 있습니다

### org/jetbrains/plugins/scala/annotator/TypeMismatchError.scala
# TODO unify type mismatch messages
type.mismatch.message=타입이 불일치합니다. 필요\: {0}, 발견\: {1}

### org/jetbrains/plugins/scala/annotator/TypeMismatchToggleAction.scala
type.mismatch.hints.action.text=타입 불일치 힌트
type.mismatch.hints.action.description=타입 불일치 힌트를 전환합니다

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateApplyQuickFix.scala
family.name.create.apply.method=''apply'' 메서드 생성
create.apply.method.in={0} 내 ''apply'' 메서드 생성

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateEntityQuickFix.scala
error.message.title.create.entity.quickfix=엔티티 빠른 수정 생성

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateExtractorObjectQuickFix.scala
family.name.create.extractor.object=추출기 객체 생성
create.extractor.object.named=추출기 객체 ''{0}'' 생성

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateParameterQuickFix.scala
family.name.create.parameter=매개변수 생성
create.parameter.named=매개변수 {0} 생성

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateParameterlessMethodQuickFix.scala
family.name.create.parameterless.method=매개변수 없는 메서드 생성
create.parameterless.method.named=매개변수 없는 메서드 ''{0}'' 생성
family.name.create.variable=변수 생성
create.variable.named=변수 ''{0}'' 생성
family.name.create.value=값 생성
create.value.named=값 ''{0}'' 생성
family.name.create.method=메서드 생성
create.method.named=메서드 ''{0}'' 생성

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateTypeDefinitionQuickFix.scala
family.name.create.object=객체 생성
family.name.create.trait=특성 생성
family.name.create.class=클래스 생성
family.name.create.annotation.class=어노테이션 클래스 생성
family.name.create.case.class=케이스 클래스 생성
create.object.named=객제 ''{0}'' 생성
create.trait.named=특성 ''{0}'' 생성
create.class.named=클래스 ''{0}'' 생성
create.annotation.class.named=어노테이션 클래스 ''{0}'' 생성
create.case.class.named=케이스 클래스 ''{0}'' 생성
choose.level.popup.title=수준 선택
new.class.location.new.file=새 파일
new.class.location.top.level.in.this.file=이 파일의 최상위 수준
new.class.location.inner.in.class={0}의 내부
new.class.location.local.scope=로컬 범위

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateUnapplyQuickFix.scala
family.name.create.unapply.method=''unapply'' 메서드 생성
create.unapply.method.in={0} 내 ''unapply'' 메서드 생성

### org/jetbrains/plugins/scala/annotator/element/ScAnnotationAnnotator.scala
annotator.error.annotation.type.expected=어노테이션 타입이 필요합니다

### org/jetbrains/plugins/scala/annotator/element/ScAssignmentAnnotator.scala
annotator.error.wrong.right.assignment.side=대입의 오른쪽이 잘못되었습니다
annotator.error.reassignment.to.val=val에 다시 대입
illegal.assignment.target=잘못된 대입 타깃

### org/jetbrains/plugins/scala/annotator/element/ScCatchBlockAnnotator.scala
# TODO unify type mismatch messages
expr.type.does.not.conform.expected.type=타입 {0} 표현식이 필요 타입 {1}을(를) 준수하지 않습니다
method.is.not.member=메서드 {0}이(가) 타입 {1}의 멤버가 아닙니다
expected.type.boolean=메서드 {0} 반환 타입으로 부울 타입이 필요합니다

### org/jetbrains/plugins/scala/annotator/element/ScCharLiteralAnnotator.scala
missing.char.value=문자 값 누락

### org/jetbrains/plugins/scala/annotator/element/ScClassAnnotator.scala
illegal.secondary.constructors.value.class=보조 생성자는 값 클래스에서 허용되지 않습니다
value.class.can.have.only.one.parameter=값 클래스는 하나의 매개변수만 가질 수 있습니다
value.class.can.have.only.val.parameter=값 클래스는 비공개가 아닌 val 매개변수 한 개만 가질 수 있습니다
type.parameter.value.class.may.not.be.specialized=값 클래스의 타입 매개변수는 특수화될 수 없습니다
value.classes.cannot.have.nested.objects=값 클래스는 중첩 클래스, 객체 또는 특성을 가질 수 없습니다
value.classes.cannot.redefine.equals.hashcode=값 클래스는 equals 및 hashCode를 재정의할 수 없습니다
value.classes.can.have.only.defs=값 클래스에서는 필드 정의가 허용되지 않습니다
value.classes.may.not.be.member.of.another.class=값 클래스는 다른 클래스의 멤버일 수 없습니다

### org/jetbrains/plugins/scala/annotator/element/ScConstrBlockExprAnnotator.scala
constructor.invocation.expected=보조 생성자는 ''this'' 호출로 시작해야 합니다

### org/jetbrains/plugins/scala/annotator/element/ScConstructorInvocationAnnotator.scala
# TODO unify type mismatch messages
type.mismatch.default.args.expected.actual=디폴트 인수 관련 타입이 불일치합니다. 필요\: {0}, 실제\: {1}
annotator.error.class.type.required.but.found=클래스 타입이 필요하나 ({0})이(가) 발견되었습니다
annotator.error.constructor.has.malformed.definition=생성자의 정의 형식이 잘못되었습니다
annotator.error.no.constructor.accessible=여기에서 액세스 가능한 생성자가 없습니다
annotator.error.cannot.resolve.overloaded.constructor=오버로드된 생성자 ''{0}''을(를) 해결할 수 없습니다
annotator.error.trait.has.no.constructor=특성 {0}은(는) 특성이므로 생성자 인수를 취하지 않습니다
annotator.error.too.many.arguments.for.constructor=생성자 {0}의 인수가 너무 많습니다
annotator.error.missing.argument.list.for.constructor=생성자 {0}의 인수 목록이 누락되었습니다
annotator.error.expansion.for.non.repeated.parameter=반복되지 않는 매개변수 확장
annotator.error.positional.after.named.argument=명명된 인수 뒤 위치 인수
annotator.error.parameter.specified.multiple.times=매개변수가 여러 번 지정되었습니다
annotator.error.cannot.apply.constructor=생성자 {0}을(를) 적용할 수 없습니다

### org/jetbrains/plugins/scala/annotator/element/ScEnumCaseAnnotator.scala
annotator.error.enum.nonvariant.type.param,in.enum=열거형 클래스의 상위 {0}의 타입 인수를 파악할 수 없습니다. 타입 매개변수 {1}이(가) 무공변성입니다
annotator.error.enum.case.must.extend.parent=열거형 case는 해당 열거형 클래스 {0}을(를) 확장해야 합니다
annotator.error.enum.two.type.parameter.clauses=열거형 case 및 열거형 클래스 모두 타입 매개변수를 포함하므로 명시적 extends 절이 필요합니다

### org/jetbrains/plugins/scala/annotator/element/ScEnumeratorsAnnotator.scala
semicolon.not.allowed.here=세미콜론은 여기에서 허용되지 않습니다
remove.all.erroneous.semicolons.from.forexpression=for 표현식의 모든 잘못된 세미콜론 제거

### org/jetbrains/plugins/scala/annotator/element/ScExpressionAnnotator.scala
else.expected=''else'' 가 필요합니다

### org/jetbrains/plugins/scala/annotator/element/ScForAnnotator.scala
for.pattern.bindings.require.scala3=''for'' 패턴 바인딩 내 ''case'' 구문을 사용하려면 Scala 3.0이 필요합니다
enumerators.generator.val.keyword.found=패턴이 필요하나 ''val''이 발견되었습니다

### org/jetbrains/plugins/scala/annotator/element/ScForBindingAnnotator.scala
enumerators.binding.val.keyword.deprecated=열거자 내 ''val'' 키워드는 지원 중단됩니다
enumerators.binding.case.keyword.found=패턴이 필요하나 ''case''가 발견되었습니다
remove.case=''case'' 제거
family.name.remove.case.from.enumerator=열거자에서 ''case'' 제거

### org/jetbrains/plugins/scala/annotator/element/ScFunctionAnnotator.scala
transparent.method.must.be.inline=''transparent'' 키워드는 인라인 메서드에만 사용할 수 있습니다
only.inline.methods.may.have.inline.args=''inline'' 제어자는 인라인 메서드의 인수에만 사용할 수 있습니다

### org/jetbrains/plugins/scala/annotator/element/ScFunctionExprAnnotator.scala
annotator.error.too.many.parameters=매개변수가 너무 많습니다
annotator.error.missing.parameter.type=매개변수 타입이 누락되었습니다
type.mismatch.expected=타입이 불일치합니다. 필요\: {0}, 실제\: {1}

### org/jetbrains/plugins/scala/annotator/element/ScFunctionalTypeElementAnnotator.scala
repeated.param.non.method=반복 매개변수는 메서드 시그니처에서만 허용됩니다. 대신 ''Seq''를 사용하세요

### org/jetbrains/plugins/scala/annotator/element/ScGivenAliasDeclarationAnnotator.scala
family.name.give.a.name.to.anonymous.abstract.given=익명 추상 given의 이름 지정
family.name.implement.anonymous.abstract.given=익명 추상 given 구현
given.alias.declaration.must.be.named=익명 given은 추상적일 수 없습니다

### org/jetbrains/plugins/scala/annotator/element/ScImportExprAnnotator.scala
import.expr.should.be.qualified=import 표현식이 정규화되어야 합니다

### org/jetbrains/plugins/scala/annotator/element/ScInterpolatedStringLiteralAnnotator.scala
cannot.resolve.in.StringContext=값 ''{0}''이(가) StringContext의 멤버가 아닙니다

### org/jetbrains/plugins/scala/annotator/element/ScLiteralTypeElementAnnotator.scala
wrong.type.no.literal.types=타입 ''{0}''이(가) 잘못되었습니다. 리터럴 타입 지원을 위해 Scala 2.13 또는 ''-Yliteral-types'' 컴파일러 플래그가 있는 Typelevel Scala를 사용하세요
identifier.expected.but.0.found=식별자가 필요하나 {0}이(가) 발견되었습니다

### org/jetbrains/plugins/scala/annotator/element/ScMacroDefAnnotator.scala
macro.defs.must.have.explicit.return.type=매크로 정의에는 명시적으로 지정된 반환 타입이 있어야 합니다

### org/jetbrains/plugins/scala/annotator/element/ScMethodInvocationAnnotator.scala
#TODO "argument(s)" not "parameter(s)"
annotator.error.unspecified.value.parameters=지정되지 않은 값 매개변수\: {0}
annotator.error.cannot.resolve.overloaded.method=오버로드된 메서드를 해결할 수 없습니다
annotator.error.too.many.arguments=인수가 너무 많습니다
annotator.error.target.does.not.take.parameters={0}은(는) 매개변수를 취하지 않습니다
missing.argument.list.for.method.with.explicit.list=메서드 {1}의 인수 목록 {0} 누락
missing.argument.list.for.method=메서드 {0}의 인수 목록 누락
does.not.take.parameter.default.target=애플리케이션
annotator.error.too.many.arguments.method=메서드 {0}의 인수가 너무 많습니다
annotator.error.name.has.malformed.definition=''{0}''에 형식이 잘못된 정의가 있습니다

### org/jetbrains/plugins/scala/annotator/element/ScNewTemplateDefinitionAnnotator.scala
illegal.instantiation={0} ''{1}''은(는) abstract이므로 인스턴스화할 수 없습니다

### org/jetbrains/plugins/scala/annotator/element/ScNumericLiteralAnnotator.scala
octal.literals.removed=Scala 2.11 이후 8진수 리터럴 구문을 사용할 수 없습니다
trailing.underscore.separator=후행 밑줄 구분 기호가 허용되지 않습니다
illegal.underscore.separator=밑줄 구분 기호를 사용할려면 Scala 2.13이 필요합니다
long.literal.is.out.of.range=정수가 Long 타입의 범위조차 벗어납니다
integer.literal.is.out.of.range=정수 리터럴이 int 타입의 범위를 벗어납니다
lowercase.long.marker=소문자로 쓰인 long 리터럴 마커

### org/jetbrains/plugins/scala/annotator/element/ScOverriddenVarAnnotator.scala
var.cannot.be.overridden=가변 변수는 재정의할 수 없습니다
missing.setter.implementation=setter에 대한 구현 누락\: {0}
missing.getter.implementation=getter에 대한 구현 누락\: {0}

### org/jetbrains/plugins/scala/annotator/element/ScParameterAnnotator.scala
annotator.error.parameter.without.an.owner.name=소유자가 없는 매개변수\: {0}
annotator.error.missing.type.annotation.for.parameter=매개변수의 타입 어노테이션이 누락되었습니다. {0}
missing.parameter.type.name=매개변수 타입 누락\: {0}
topic.parameters.may.not.be.call.by.name={0} 매개변수는 이름에 의한 호출(call-by-name)이 아닐 수 있습니다

### org/jetbrains/plugins/scala/annotator/element/ScParameterizedTypeElementAnnotator.scala
unspecified.type.parameters=지정되지 않은 값 매개변수\: {0}
too.many.type.arguments.for.typeparamowner={0}의 타입 인수가 너무 많습니다. {1}개가 필요하나 {2}개가 발견되었습니다
type.arg.does.not.conform.to.upper.bound=타입 {0}이(가) 타입 매개변수 {2}의 상위 바운드 {1}을(를) 준수하지 않습니다
type.arg.does.not.conform.to.lower.bound=타입 {0}이(가) 타입 매개변수 {2}의 하위 바운드 {1}을(를) 준수하지 않습니다
name.does.not.take.type.arguments={0}은(는) 타입 인수를 취하지 않습니다
expected.type.constructor=타입 생성자 {0}이(가) 필요합니다
type.constructor.does.not.conform=타입 생성자 {0}이(가) {1}을(를) 준수하지 않습니다
type.constructor.mismatch=타입 생성자가 일치하지 않습니다.

### org/jetbrains/plugins/scala/annotator/element/ScParametersAnnotator.scala
annotator.error.repeated.parameter.must.be.last=*-매개변수가 마지막에 와야 합니다
annotator.error.repeated.or.default=*-매개변수가 있는 매개변수 섹션에 디폴트 인수가 있으면 안 됩니다

### org/jetbrains/plugins/scala/annotator/element/ScPatternAnnotator.scala
pattern.on.refinement.unchecked=구체화 타입의 패턴 일치가 검사되지 않았습니다
type.cannot.be.used.in.type.pattern=타입 {0}은(는) 타입 패턴 또는 isInstanceOf 테스트에서 사용할 수 없습니다
scrutinee.incompatible.pattern.type=Scrutinee가 패턴 타입과 호환되지 않습니다. 발견\: {0}, 필요\: {1}
pattern.type.incompatible.with.expected=패턴 타입이 필요 타입과 호환되지 않습니다. 발견\: {0}, 필요\: {1}
constructor.cannot.be.instantiated.to.expected.type=생성자를 필요 타입으로 인스턴스화할 수 없습니다. 발견\: {0}, 필요\: {1}
fruitless.type.test=fruitless type test\: 타입 {0} 값이 {1} 일 수 없습니다.
erasure.warning= (여전히 해당 이레이저와 일치할 수는 있음)
wrong.number.arguments.extractor=추출기의 잘못된 인수 개수, 발견\: {0}, 필요\: {1}
wrong.number.arguments.extractor.unapplySeq=추출기의 잘못된 인수 개수, 발견\: {0}, 필요\: {1} 이상
stable.identifier.required=안정적 식별자가 필요하나 {0}이(가) 발견되었습니다
better.monadic.for.invalid.pattern=인수에 명시적 타입 어노테이션이 추가되어야 합니다

### org/jetbrains/plugins/scala/annotator/element/ScPatternArgumentListAnnotator.scala
vararg.pattern.must.be.last.pattern=_*는 마지막 인수에만 사용할 수 있습니다

### org/jetbrains/plugins/scala/annotator/element/ScPatternTypeUnawareAnnotator.scala
vararg.pattern.with.colon.requires.scala3=vararg 패턴 내 ''\:'' 구문을 사용하려면 Scala 3.0이 필요합니다
vararg.pattern.with.at.deprecated.since.scala3=vararg 패턴 내 ''@'' 구문은 Scala 3.0 이후 버전에서 지원 중단됩니다
family.name.replace.type.with.type.in.vararg.pattern=vararg 패턴 내 ''\:''을 ''@''으로 바꾸기
family.name.replace.with.scala3.vararg.pattern=''\:'' 구문을 Scala 3.0 vararg 패턴으로 바꾸기
replace.with.type=''{0}''(으)로 바꾸기

### org/jetbrains/plugins/scala/annotator/element/ScPolyFunctionExprAnnotator.scala
poly.function.without.parameters=다형 함수 {0}은(는) 값 매개변수를 가져야 합니다

### org/jetbrains/plugins/scala/annotator/element/ScReferenceAnnotator.scala
cannot.resolve=심볼 {0}을(를) 해결할 수 없습니다
cannot.resolve.overloaded=오버로드된 메서드 ''{0}''을(를) 해결할 수 없습니다
forward.reference.detected=잘못된 전방 참조
cannot.resolve.apply.method=메서드 {0}.apply를 해결할 수 없습니다
cannot.resolve.unapply.method=메서드 {0}.unapply를 해결할 수 없습니다
annotator.error.missing.arguments.for.method=메서드 {0}의 인수가 누락되었습니다
symbol.is.inaccessible.from.this.place=이 위치에서는 심볼 {0}에 액세스할 수 없습니다

### org/jetbrains/plugins/scala/annotator/element/ScReturnAnnotator.scala
return.expression.is.redundant=Unit 결과 타입을 가진 메서드에서 {0} 반환 중
return.outside.method.definition=메서드 정의 밖에 있는 return 문

### org/jetbrains/plugins/scala/annotator/element/ScSelfInvocationAnnotator.scala
called.constructor.definition.must.precede=호출된 생성자의 정의가 호출한 생성자의 정의보다 선행해야 합니다
annotator.error.cannot.find.constructor.for.this.call=이 호출에 대한 생성자를 찾을 수 없음

### org/jetbrains/plugins/scala/annotator/element/ScSimpleTypeElementAnnotator.scala
type.takes.type.parameters=타입 {0}은(는) 타입 매개변수를 취합니다

### org/jetbrains/plugins/scala/annotator/element/ScStringLiteralAnnotator.scala
string.literal.is.too.long=문자열 리터럴 크기가 컴파일러 제한을 초과합니다
string.literal.invalid.escape.character=잘못된 이스케이프 문자
string.literal.invalid.unicode.escape=잘못된 유니코드 이스케이프

### org/jetbrains/plugins/scala/annotator/element/ScSymbolLiteralAnnotator.scala
symbolliterals.are.deprecated=심볼 리터럴은 Scala 2.13에서 지원 중단됩니다. 대신 Symbol(''{0}'')을 사용하세요.

### org/jetbrains/plugins/scala/annotator/element/ScTemplateDefinitionAnnotator.scala
illegal.inheritance.self.type=올바르지 않은 상속입니다. 자기 타입 {0}이(가) {1}을(를) 준수하지 않습니다
mixin.required=''{3}'' 내 멤버 ''{2}''이(가) ''abstract'' 및 ''override''로 표시되나 기본 클래스에서 구체 구현을 찾을 수 없으므로, {0} ''{1}''은(는) 믹스인이어야 합니다
illegal.undefined.member=선언되었으나 정의되지 않은 멤버는 오직 클래스에만 있을 수 있습니다
illegal.inheritance.from.final.kind=final {0} ''{1}''(으)로부터의 올바르지 않은 상속
illegal.inheritance.from.value.class=값 클래스 ''{0}''(으)로부터의 올바르지 않은 상속
illegal.inheritance.extends.enum=열거형 확장은 금지됩니다
trait.may.not.call.constructor=특성 {0}이(가) {1}의 생성자를 호출하지 않을 수 있습니다
trait.is.already.implemented.by.superclass=특성 {0}은(는) 이미 상위 클래스 {1}에 의해 구현되어 있으므로 해당 생성자는 다시 호출되지 않습니다
parameterised.trait.is.implemented.indirectly=매개변수화된 특성 {0}은(는) 간접적으로 구현됩니다. 인수가 전달되려면 직접 구현되어야 합니다
illegal.inheritance.multiple={0} ''{1}''이(가) 여러 번 상속되었습니다
illegal.mixin={0} ''{1}''은(는) 혼합 가능한 특성이여야 합니다
member.implementation.required={0} ''{1}''이(가) abstract로 선언되거나 ''{3}''에서 abstract 멤버 ''{2}''을(를) 구현해야 합니다
object.creation.impossible.since={0}, 그러므로 객체를 생성할 수 없습니다
member.is.not.defined={1}의 멤버 {0}(이)가 정의되지 않았습니다

### org/jetbrains/plugins/scala/annotator/element/ScTraitAnnotator.scala
trait.parameter.require.scala3=특성 매개변수를 사용하려면 Scala 3.0이 필요합니다

### org/jetbrains/plugins/scala/annotator/element/ScTypeBoundsOwnerAnnotator.scala
lower.bound.conform.to.upper=하위 바운드가 상위 바운드를 준수하지 않습니다

### org/jetbrains/plugins/scala/annotator/element/ScTypedExpressionAnnotator.scala
cannot.upcast.type.to.other.type={0}을(를) {1}(으)로 업캐스트할 수 없습니다

### org/jetbrains/plugins/scala/annotator/element/ScUnderscoreSectionAnnotator.scala
unbound.placeholder.parameter=바인드되지 않은 자리표시자 매개변수
local.variables.must.be.initialized=지역 변수가 초기화되어야 합니다
default.init.prohibited.literal.types=디폴트 초기화는 리터럴 타입 var에서 금지됩니다

### org/jetbrains/plugins/scala/annotator/element/ScValueOrVariableAnnotator.scala
annotation.ascriptions.in.pattern.definitions.require.scala3=패턴 정의 내 어노테이션 귀속을 사용하려면 Scala 3.0이 필요합니다

### org/jetbrains/plugins/scala/annotator/gutter/ScalaGoToSuperActionHandler.scala
goto.super.member.chooser.title=상위 멤버 선택
goto.super.class.chooser.title=상위 클래스 선택
goto.super.class.or.member.chooser.title=상위 클래스/상위 멤버 선택

### org/jetbrains/plugins/scala/annotator/gutter/ScalaLineMarkerProvider.scala
companion.class=클래스
companion.object=객체
companion.trait=특성
companion.enum=열거형
go.to.companion=컴패니언 {0}(으)로 이동
go.to.implementation=구현으로 이동
go.to.super.method=상위 멤버로 이동
gutter.companion=컴패니언
gutter.implemented=구현된 멤버
gutter.implementing=멤버 구현
gutter.overridden=재정의된 멤버
gutter.overriding=멤버 재정의
gutter.recursion=재귀 타입
gutter.sam=SAM 구현
has.companion=컴패니언 {0} 포함
multiple.overriding.tooltip=여러 개의 재정의하는 멤버
multiple.overriden.tooltip=여러 개의 재정의된 멤버
scala.line.markers=Scala 줄 마커

### org/jetbrains/plugins/scala/annotator/gutter/ScalaMarkerType.scala
implements.member.prefix=멤버 구현
implements.member.from.prefix=다음에서 멤버 구현
implements.member.from.several.classes={0} 클래스에서 멤버 구현
overrides.member.from.prefix=다음에서 멤버 재정의
overrides.member.from.several.classes={0} 클래스에서 멤버 재정의
overrides.type.prefix=타입 재정의
overrides.type.from.super.several.classes={0} 클래스의 타입 재정의
navigation.title.super.members={0}의 상위 멤버 선택
navigation.findUsages.title.super.members={0}의 상위 멤버
navigation.title.super.types={0}의 상위 타입 멤버 선택
navigation.findUsages.title.super.types={0}의 상위 타입 멤버
trait.has.implementations=다음으로 혼합
trait.has.several.implementations={0} 클래스로 혼합됨
class.has.subclasses=확장 기준
class.has.several.subclasses={0} 하위 클래스별로 확장
has.implementations=멤버에 구현이 있습니다
is.overridden.by=멤버에 재정의가 있습니다
navigation.title.inheritors.trait=<html><b>{0}</b>의 구현 선택({1}개 클래스 발견)</html>
navigation.findUsages.title.inheritors.trait={0}의 구현
navigation.title.inheritors.class=<html><b>{0}</b>의 하위 클래스 선택({1}개 클래스 발견)</html>
navigation.findUsages.title.inheritors.class={0}의 하위 클래스
navigation.title.implementing.member=<html><b>{0}</b>의 구현 멤버 선택({1}개 멤버 발견)</html>
navigation.findUsages.title.implementing.member={0}의 구현 멤버
navigation.title.overriding.member=<html><b>{0}</b> 의 재정의 멤버 선택({1} 멤버 발견)</html>
navigation.findUsages.title.overriding.member={0}의 재정의 멤버
notification.navigation.to.overriding.members=색인 업데이트 중에는 재정의하는 멤버로 이동할 수 없습니다
searching.for.overriding.members=재정의 멤버 검색

### org/jetbrains/plugins/scala/annotator/gutter/ScalaRecursiveCallLineMarkerProvider.scala
call.is.recursive=재귀 호출

### org/jetbrains/plugins/scala/annotator/gutter/ScalaRecursiveFunctionLineMarkerProvider.scala
method.is.recursive=메서드 ''{0}''이(가) 재귀적입니다
method.is.tail.recursive=메서드 ''{0}''이(가) 꼬리 재귀입니다

### org/jetbrains/plugins/scala/annotator/hints/HintUI.scala
type.mismatch.dot=타입 불일치.

### org/jetbrains/plugins/scala/annotator/modifiers/ModifierChecker.scala
lazy.modifier.is.not.allowed.here=''lazy'' 제어자는 값 정의에만 허용됨
lazy.modifier.is.not.allowed.with.param=''lazy'' 제어자는 허용되지 않으므로, 대신 call-by-name 매개변수를 사용하세요
lazy.values.may.not.be.abstract=lazy 값이 abstract일 수 없습니다
final.modifier.not.with.declarations=''final'' 제어자는 불완전한 멤버와 사용될 수 없습니다
final.modifier.not.with.trait=''final'' 제어자는 특성에 허용되지 않음
final.modifier.is.redundant.with.final.parents=''final'' 제어자는 객체 또는 final 클래스 멤버와 중복됩니다
final.modifier.is.not.allowed.here=''final'' 제어자는 허용되지 않습니다
access.modifier.is.not.allowed.here=''{0}'' 제어자는 허용되지 않습니다
abstract.modifier.redundant.fot.traits=''abstract'' 제어자는 특성과 중복됩니다
abstract.modifier.is.not.allowed=''abstract'' 제어자는 클래스 또는 ''override'' 제어자가 있는 정의에만 허용됩니다
abstract.override.modifier.is.not.allowed=''abstract override'' 제어자는 특성 멤버에만 허용됨
override.modifier.is.not.allowed.for.classes=''override'' 제어자는 타입 정의 멤버에만 허용됨
override.modifier.is.not.allowed=''override'' 제어자는 허용되지 않습니다
sealed.modifier.is.not.allowed.here=''sealed'' 제어자는 허용되지 않습니다
illegal.modifiers.combination=올바르지 않은 제어자 조합\: {0} 및 {1}
implicit.modifier.cannot.be.used.for.top.level.objects=''implicit'' 제어자는 최상위 객체에 사용할 수 없습니다
implicit.class.must.have.a.primary.constructor.with.one.argument=묵시적 클래스에는 첫 번째 매개변수 목록에 정확히 하나의 인수가 있는 기본 생성자가 있어야 합니다
implicit.modifier.can.be.used.only.for=''implicit'' 제어자는 값, 변수, 메서드, 클래스에만 사용할 수 있습니다
modifier.is.redundant.for.this.definition=''{0}'' 제어자는 이 정의에 불필요합니다
only.classes.can.be.open=클래스만 열 수 있습니다
class.is.abstract.it.cannot.be.instantiated=클래스 ''{0}''은(는) abstract이므로 인스턴스화할 수 없습니다
opaque.modifier.allowed.only.for.type.aliases=''opaque'' 제어자는 타입 별칭에만 허용됩니다

### org/jetbrains/plugins/scala/annotator/package.scala
tree.mismatch.tooltip=<html><body>{0}<table><tr><td>필요\:</td>{1}</tr><tr><td>발견\:</td>{2}</tr></table></body></html>

### org/jetbrains/plugins/scala/annotator/quickfix/AddBreakoutQuickFix.scala
add.collection.breakout.argument=''collection.breakOut'' 인수 추가
family.name.add.collection.breakout=''collection.breakOut'' 추가

### org/jetbrains/plugins/scala/annotator/quickfix/AddReturnTypeFix.scala
add.return.type=반환 타입 추가

### org/jetbrains/plugins/scala/annotator/quickfix/ChangeTypeFix.scala
family.name.change.type=타입 변경
change.type.to=타입 ''{0}''을(를) ''{1}''(으)로 변경

### org/jetbrains/plugins/scala/annotator/quickfix/ConvertToExplicitSymbolQuickFix.scala
convert.to.explicit.symbol=심볼(''{0}'')로 변환
convert.to.explicit.symbol.family=명시적 심볼로 변환

### org/jetbrains/plugins/scala/annotator/quickfix/EnableTypeMismatchHints.scala
family.name.enable.type.mismatch.hints=타입 불일치 힌트 활성화

### org/jetbrains/plugins/scala/annotator/quickfix/ImplementMembersQuickFix.scala
implement.members.fix=멤버 구현

### org/jetbrains/plugins/scala/annotator/quickfix/ModifierQuickFix.scala
make.non.private.title=프로퍼티를 비공개가 아닌것으로 만들기
add.modifier.fix.without.name=''{0}'' 제어자를 추가합니다
remove.named.modifier.fix=''{0}'' 제어자를 제거합니다
make.protected.fix=프로퍼티를 protected로 만들기
make.public.fix=프로퍼티를 공개로 만들기

### org/jetbrains/plugins/scala/annotator/quickfix/NumberLiteralQuickFix.scala
numeric.literal.family=숫자 리터럴
convert.to.hex.fix=8진 리터럴을 16진수로 변환
convert.to.long.fix=long 리터럴로 변환
lowercase.long.marker.fix=long 리터럴 마커를 대문자로 변환

### org/jetbrains/plugins/scala/annotator/quickfix/PullUpQuickFix.scala
pull.method.to=메서드 ''{0}''을(를) 다음으로 풀...
pull.value.to=값 ''{0}''을(를) 다음으로 풀...
pull.variable.to=변수 ''{0}''을(를) 다음으로 풀...

### org/jetbrains/plugins/scala/annotator/quickfix/ReportHighlightingErrorQuickFix.scala
report.highlighting.error.fix=강조 표시 오류 보고...

### org/jetbrains/plugins/scala/annotator/quickfix/WrapInOptionQuickFix.scala
wrap.in.option.name=Option으로 래핑
wrap.in.option.hint=Option(...)으로 표현식을 래핑하시겠어요?

### org/jetbrains/plugins/scala/annotator/template/CaseClassWithoutParamList.scala
family.name.add.empty.parentheses=빈 소괄호 추가
family.name.convert.to.object=객체로 변환
case.classes.without.parameter.list.not.allowed=매개변수 목록이 없는 케이스 클래스는 허용되지 않습니다
case.classes.without.parameter.list.deprecated=매개변수 목록이 없는 케이스 클래스는 지원 중단되었습니다

### org/jetbrains/plugins/scala/annotator/template/ImplicitParametersAnnotator.scala
no.implicit.arguments.of.type=타입의 묵시적 인수가 없습니다. {0}

### org/jetbrains/plugins/scala/annotator/template/PrivateBeanProperty.scala
annotator.error.bean.property.should.not.be.private=Bean 프로퍼티가 비공개면 안 됩니다.

### org/jetbrains/plugins/scala/annotator/template/TraitHasImplicitBound.scala
traits.cannot.have.type.parameters.with.context.bounds=특성은 컨텍스트 바운드가 있는 타입 매개변수를 가질 수 없습니다
traits.cannot.have.type.parameters.with.view.bounds=특성은 뷰 바운드가 있는 타입 매개변수를 가질 수 없습니다

### org/jetbrains/plugins/scala/autoImport/quickFix/ImportExtensionMethodFix.scala
import.extension.method=확장 메서드 가져오기...

### org/jetbrains/plugins/scala/autoImport/quickFix/ImportImplicitConversionFix.scala
import.with=''{0}'' 가져오기
import.implicit.conversion=변환 가져오기...

### org/jetbrains/plugins/scala/autoImport/quickFix/ImportImplicitInstanceFix.scala
import.implicit=묵시적 항목 가져오기...

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaAddImportAction.scala
import.class.chooser.title=가져올 클래스
import.package.chooser.title=가져올 패키지
import.something.chooser.title=가져올 이륾
import.conversion.chooser.title=가져올 변환
import.implicit.chooser.title=가져올 묵시적 항목
import.extension.method.chooser.title=가져올 확장 메서드
add.import.action=가져오기 액션 추가
exclude.value.from.auto.import=자동 가져오기에서 ''{0}'' 제외

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportElementFix.scala
import.hint.text={0}? Alt+Enter {1}
import.multiple.choices=(다중 선택...)

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportGlobalMemberFix.scala
import.global.member=전역 멤버 가져오기
import.as=''{0}''로서 가져오기
import.with.prefix.ellipsis=접두사 포함 가져오기...
import.with.prefix=접두사 포함 가져오기
import.something=가져오기...

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportTypeFix.scala
import.class=클래스 가져오기
import.package=패키지 가져오기

### org/jetbrains/plugins/scala/codeInsight/intention/AddBracesIntention.scala
family.name.add.braces=중괄호 추가
add.braces.around.single.line.expression=단일 줄 표현식 주위에 중괄호 추가

### org/jetbrains/plugins/scala/codeInsight/intention/CreateCompanionObjectIntention.scala
create.companion.object.for.class=클래스에 대한 컴패니언 객체 생성
family.name.create.companion.object=컴패니언 객체 생성

### org/jetbrains/plugins/scala/codeInsight/intention/RemoveBracesIntention.scala
family.name.remove.braces=중괄호 제거

### org/jetbrains/plugins/scala/codeInsight/intention/collections/ComparingLengthIntention.scala
family.name.comparing.length=.sizeIs로 바꾸기

### org/jetbrains/plugins/scala/codeInsight/intention/collections/FilterSetContainsIntention.scala
family.name.filter.set.contains=필터 내 불필요한 ''contains'' 제거

### org/jetbrains/plugins/scala/codeInsight/intention/collections/SomeToOptionIntention.scala
family.name.some.to.option=Some에서 Option으로

### org/jetbrains/plugins/scala/codeInsight/intention/comprehension/ConvertToCurlyBracesIntention.scala
family.name.convert.to.curly.braces=중괄호로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/comprehension/ConvertToParenthesesIntention.scala
intention.for.comprehension.convert.to.parentheses=소괄호로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/comprehension/DesugarForIntention.scala
desugar.for.comprehension=for comprehension 디슈가
family.name.convert.to.desugared.expression=디슈가된 표현식으로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertFromInfixExpressionIntention.scala
family.name.convert.from.infix.expression=infix 표현식에서 변환

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertParameterToUnderscoreIntention.scala
family.name.convert.parameter.to.underscore.section=매개변수를 밑줄 섹션으로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertToInfixExpressionIntention.scala
family.name.convert.to.infix.expression=infix 표현식으로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertUnderscoreToParameterIntention.scala
family.name.convert.underscore.section.to.parameter=밑줄 섹션을 매개변수로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/expression/MakeImplicitConversionExplicit.scala
family.name.make.implicit.conversion.explicit=묵시적 변환을 명시적으로 만들기

### org/jetbrains/plugins/scala/codeInsight/intention/expression/RemoveApplyIntention.scala
family.name.remove.unnecessary.apply=불필요한 apply 제거

### org/jetbrains/plugins/scala/codeInsight/intention/expression/RemoveUnnecessaryParenthesesIntention.scala
remove.unnecessary.parentheses=불필요한 소괄호 제거

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ReplaceTypeCheckWithMatchIntention.scala
family.name.replace.type.check.with.pattern.matching=타입 검사를 패턴 매칭으로 바꾸기

### org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportAdditionalIdentifiersIntention.scala
family.name.import.additional.identifiers=추가 식별자 가져오기
import.additional.identifiers.from.qualifier=한정자에서 추가 식별자 가져오기

### org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportAllMembersIntention.scala
family.name.import.all.members=모든 멤버 가져오기
import.all.members.of.reference={0}의 모든 멤버 가져오기

### org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportStableMemberIntention.scala
family.name.import.member.with.stable.path=안정적 경로로 멤버 가져오기
import.stable.member={0} 가져오기

### org/jetbrains/plugins/scala/codeInsight/intention/lists/ScalaListSplitJoinContexts.scala
intention.family.put.on.one.line={0}을(를) 하나의 줄에 배치
intention.family.put.on.separate.lines={0}을(를) 별도의 줄에 배치

### org/jetbrains/plugins/scala/codeInsight/intention/matcher/ConvertToTypedPatternIntention.scala
convert.to.typed.pattern=타입이 지정된 패턴으로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/matcher/ExpandPatternIntention.scala
family.name.expand.to.constructor.pattern=생성자 패턴으로 확장
expand.to.new.pattern=다음으로 확장\: {0}

### org/jetbrains/plugins/scala/codeInsight/intention/types/AddUnitTypeAnnotationIntention.scala
intention.add.explicit.unit.type.annotation=묵시적 Unit 타입 어노테이션 추가
intention.type.annotation.function.add.text=함수 정의에 타입 어노테이션 추가

### org/jetbrains/plugins/scala/codeInsight/intention/types/AdjustTypesIntention.scala
family.name.adjust.types=타입 조정

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertFromInfixIntention.scala
family.name.use.prefix.type.syntax=접두사 타입 구문 사용

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertImplicitBoundsToImplicitParameter.scala
family.name.convert.implicit.bounds=묵시적 바운드 변환
convert.view.and.context.bounds.to.implicit.parameters=컨텍스트 바운드를 묵시적 매개변수로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertJavaToScalaCollectionIntention.scala
convert.java.to.scala.collection.hint=asScala를 사용하여 Scala 컬렉션으로 변환하시겠어요?
convert.java.to.scala.collection.name=Scala 컬렉션으로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertScalaToJavaCollectionIntention.scala
convert.scala.to.java.collection.hint=asJava를 사용하여 Java 컬렉션으로 변환하시겠어요?
convert.scala.to.java.collection.name=Java 컬렉션으로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertToInfixIntention.scala
family.name.use.infix.type.syntax=Infix 타입 구문 사용

### org/jetbrains/plugins/scala/codeInsight/intention/types/MakeTypeMoreSpecificIntention.scala
make.type.more.specific.fun=반환 타입을 더 구체적으로 만들기
make.type.more.specific=선언된 타입을 더 구체적으로 만들기

### org/jetbrains/plugins/scala/codeInsight/intention/types/RegenerateTypeAnnotation.scala
intention.type.annotation.regen.family=타입 어노테이션 다시 생성
intention.type.annotation.function.regenerate.text=함수 정의에 대한 타입 어노테이션 다시 생성
intention.type.annotation.value.regenerate.text=값 정의에 대한 타입 어노테이션 다시 생성
intention.type.annotation.variable.regenerate.text=변수 정의에 대한 타입 어노테이션 다시 생성

### org/jetbrains/plugins/scala/codeInsight/intention/types/ToggleTypeAnnotation.scala
intention.type.annotation.toggle.family=타입 어노테이션 전환
intention.type.annotation.function.remove.text=함수 정의에서 타입 어노테이션 제거
intention.type.annotation.value.add.text=값 정의에 타입 어노테이션 추가
intention.type.annotation.value.remove.text=값 정의에서 타입 어노테이션 제거
intention.type.annotation.variable.add.text=변수 정의에 타입 어노테이션 추가
intention.type.annotation.variable.remove.text=변수 정의에서 타입 어노테이션 제거
intention.type.annotation.pattern.add.text=패턴 정의에 타입 어노테이션 추가
intention.type.annotation.pattern.remove.text=패턴 정의에서 타입 어노테이션 제거
intention.type.annotation.parameter.add.text=매개변수에 타입 어노테이션 추가
intention.type.annotation.parameter.remove.text=매개변수에서 타입 어노테이션 제거
intention.type.annotation.underscore.add.text=밑줄 매개변수에 타입 어노테이션 추가
intention.type.annotation.underscore.remove.text=밑줄 매개변수에서 타입 어노테이션 제거

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaCaseClauseRemover.scala
remove.case.clause=case 절 제거

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaCatchOrFinallyRemover.scala
remove.finally=finally 블록 제거
remove.catch=catch 블록 제거

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaInterpolatedStringUnwrapper.scala
unwrap.interpolated.string.injection=보간된 문자열 삽입 래핑 해제

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaMatchUnwrapper.scala
unwrap.case.clause=case 절 래핑 해제

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaTryOrFinallyUnwrapper.scala
unwrap.finally=finally 래핑 해제

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaTryWithFinallyUnwrapper.scala
unwrap.try.with.finally=try/finally 래핑 해제

### org/jetbrains/plugins/scala/codeInspection/caseClassParamInspection/CaseClassParamInspection.scala
val.on.case.class.param.redundant=케이스 클래스 기본 생성자의 매개변수와 ''val'' 제어자가 중복됩니다

### org/jetbrains/plugins/scala/codeInspection/caseClassParamInspection/RemoveValQuickFix.scala
remove.val=''val'' 제거

### org/jetbrains/plugins/scala/codeInspection/catchAll/ReplaceDangerousCatchAllQuickFix.scala
specify.type.of.exception=예외 타입 지정

### org/jetbrains/plugins/scala/codeInspection/forwardReferenceInspection/ForwardReferenceInspection.scala
suspicious.forward.reference.template.body=클래스 내 의심스러운 전방 참조

### org/jetbrains/plugins/scala/codeInspection/imports/SingleImportInspection.scala
remove.braces.from.import=import 문의 중괄호 제거

### org/jetbrains/plugins/scala/codeInspection/quickfix/RemoveReturnKeywordQuickFix.scala
remove.return.keyword=return 키워드 제거

### org/jetbrains/plugins/scala/codeInspection/relativeImports/RelativeImportInspection.scala
make.import.fully.qualified=import 문 정규화하기

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocInlinedTagInspection.scala
delete.inlined.tag=인라인화된 태그 삭제
replace.with.wiki.syntax=인라인화된 태그를 고정폭 wiki 구문으로 바꾸기

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocRemoveElementQuickFix.scala
remove.generic={0} 제거

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnbalancedHeaderInspection.scala
move.text.after.header.to.new.line=헤더 닫기 뒤 텍스트를 새 줄로 이동
balance.header=밸런스 헤더

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnclosedTagWithoutParserInspection.scala
replace.tag.with.esc.seq=태그를 이스케이프 시퀀스로 바꾸기

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnknownTagInspection.scala
delete.unknown.tag=알 수 없는 태그 삭제

### org/jetbrains/plugins/scala/codeInspection/syntacticSimplification/FunctionTupleSyntacticSugarInspection.scala
replace.tuple.type=TupleN[A1, A1, ...,  AN]을 (A1, A1, ...,  AN)으로 바꾸기
replace.fun.type=FunctionN[A1, A1, ...,  AN, R]을 (A1, A1, ...,  AN) \=> R로 바꾸기

### org/jetbrains/plugins/scala/codeInspection/syntacticSimplification/RedundantNewCaseClassInspection.scala
new.on.case.class.instantiation.redundant=''new'' 제어자 제거

### org/jetbrains/plugins/scala/codeInspection/xml/ScalaXmlUnmatchedTagInspection.scala
xml.no.opening.tag=여는 태그 없음
xml.no.closing.tag=닫는 태그 없음
xml.delete.unmatched.tag=일치하지 않는 태그 삭제
xml.rename.opening.tag=여는 태그 이름 변경
xml.rename.closing.tag=닫는 태그 이름 변경

### org/jetbrains/plugins/scala/components/PluginVersionVerifier.scala
incompatible.plugin.detected=호환되지 않는 플러그인 탐지됨

### org/jetbrains/plugins/scala/components/Scala3Disclaimer.scala
scala.3.support.is.experimental=Scala 3 지원은 활발히 개발 중입니다.<br>야간 빌드를 사용해 새 개선사항을 이용해보세요.
configure.updates=업데이트 구성...

### org/jetbrains/plugins/scala/components/ScalaPluginUpdater.scala
idea.is.outdated.please.update=ИСРA가 Scala 플러그인 {0} 브랜치와 함께 사용할 수 있는 오래된 버전입니다.<br/>최신 Scala 플러그인을 사용하려면 ИСРA를 {1} 이상으로 업데이트하세요.
please.select.scala.plugin.update.channel=Scala 플러그인 업데이트 채널을 선택해주세요.
channel.stable.releases=안정화된 릴리스
#NOTE: I removed "Program" suffix from "Early Access Program" in order all three actions fit into notification width
#Otherwise there will be a dropdown which will hide EAP & Nightly options
channel.early.access.program=얼리 액세스
channel.nightly.builds=야간 빌드
scala.plugin.update=Scala 플러그인 업데이트

### org/jetbrains/plugins/scala/components/TypeAwareWidget.scala
type.aware.highlighting.title=Scala 타입 인식 강조 표시
click.or.press.shortcut.to.change=(변경하려면 {0}을(를) 클릭하거나 누르세요)
click.to.change=(클릭하여 변경)
enabled.word=활성화됨
disabled.word=비활성화됨

### org/jetbrains/plugins/scala/components/TypeAwareWidgetFactory.scala
scala.type.aware.highlighting.indicator=Scala 타입 인식 강조 표시 표시기

### org/jetbrains/plugins/scala/components/libextensions/ExtensionDownloader.scala
downloading.url={0} 다운로드 중

### org/jetbrains/plugins/scala/components/libextensions/LibraryExtensionsManager.scala
title.searching.for.library.extensions=라이브러리 확장 검색

### org/jetbrains/plugins/scala/components/libextensions/ui/LibExtensionsSettingsPanelWrapper.scala
select.library.from.the.list.above=위 목록에서 라이브러리 선택
idea.will.try.to.search.for.extra.support.for.particular.libraries=ИСРA가 프로젝트의 특정 라이브러리에 대한 추가 지원을 검색하려 합니다
title.failed.to.load.extension.jar=확장 JAR 로드 실패
no.known.extension.libraries=알려진 확장 라이브러리 없음
known.extension.libraries=알려진 확장 라이브러리
extensions.in.selected.library=선택한 라이브러리 내 확장
enable.loading.external.extensions=외부 확장 로드 활성화
how.to.add.custom.macro.support.help.link.title=사용자 지정 Scala 매크로 지원을 추가하는 방법

### org/jetbrains/plugins/scala/components/libextensions/ui/PopupHelper.scala
title.extensions.available=사용 가능한 확장
additional.support.has.been.found.popup=<p>일부 라이브러리에 대한 추가 지원을 찾았습니다.</p><p>활성화하시겠어요? <a href\="Yes">예</a> / <a href\="No">아니요</a></p>

### org/jetbrains/plugins/scala/console/ScalaLanguageConsole.scala
scala.language.console.placeholder.command.to.execute=실행할 <{0}>

### org/jetbrains/plugins/scala/console/actions/RunConsoleAction.scala
scala.console.actions.scala.repl=Scala REPL
scalarepl.menu.action.text=Scala REPL...
scalarepl.menu.action.description=Scala REPL 실행

### org/jetbrains/plugins/scala/console/actions/ScalaConsoleCleanAction.scala
clean.scala.repl.content.menu.action.text=Scala REPL 내용 정리
clean.scala.repl.content.menu.action.description=Scala REPL 내용을 정리합니다

### org/jetbrains/plugins/scala/console/actions/ScalaConsoleExecuteAction.scala
execute.scala.repl.statement.menu.action.text=Scala REPL 구문 실행
execute.scala.repl.statement.menu.action.description=Scala REPL 구문을 실행합니다

### org/jetbrains/plugins/scala/console/actions/ScalaConsoleNewLineAction.scala
scalaconsole.new.line.in.repl=REPL 내 새 줄

### org/jetbrains/plugins/scala/console/actions/SendSelectionToConsoleAction.scala
send.selection.to.scala.repl.menu.action.text=Scala REPL에 선택 항목 전송
send.selection.to.scala.repl.menu.action.description=Scala REPL에 선택 항목을 전송합니다

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleConfigurationType.scala
scala.console.config.display.name=Scala REPL
scala.console.config.scala.repl.run.configurations=Scala REPL 실행 구성

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfiguration.scala
scala.console.config.module.is.not.specified=모듈이 지정되지 않았습니다

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfigurationForm.form
scala.console.config.working.directory=작업 디렉터리\:
scala.console.config.use.classpath.and.sdk.of.module=모듈의 클래스 경로 및 SDK 사용\:

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfigurationForm.java
scala.console.config.vm.options=VM 옵션
scala.console.config.console.arguments=콘솔 인수
scala.console.config.test.run.config.choose.working.directory=작업 디렉터리 선택

### org/jetbrains/plugins/scala/console/configuration/ScalaSdkJLineFixer.scala
scala.console.configure.scala.sdk.classpath=Scala SDK 클래스 경로 구성 [&C]
#parameters:
# 0 - subsystem name (e.g. Console)
# 1 - jline jar name
subsystem.requires.jline={0}에 {1}이(가) 필요합니다\n\
컴파일러 클래스 경로에 추가하세요

### org/jetbrains/plugins/scala/editor/autoimport/ScalaAutoImportOptionsProvider.scala
options.scala.display.name=Scala
auto.import.show.import.popup.for=다음 경우에 import 문 팝업 표시\:
auto.import.add.unambiguous.imports.on.the.fly.for=다음에서 모호하지 않은 import 문 즉시 추가\:
auto.import.optimize.imports.on.the.fly=import 문 즉시 최적화
auto.import.show.popup.classes=클래스
auto.import.show.popup.methods=static 멤버
auto.import.show.popup.conversions=묵시적 변환
auto.import.show.popup.implicits=묵시적 정의
auto.import.show.popup.extension.methods=확장 메서드
auto.import.find.more.configuration.options=<a>코드 스타일</a>에서 더 많은 구성 옵션 찾아보기

### org/jetbrains/plugins/scala/findUsages/UsageType.scala
bytecode.indices.target.sam.type=SAM 타입
bytecode.indices.target.unapply.method=apply/unapply 메서드
bytecode.indices.target.for.comprehension.method=for-comprehension 메서드
bytecode.indices.target.implicit.definition=묵시적 정의

### org/jetbrains/plugins/scala/findUsages/factory/ScalaFindUsagesHandlerFactory.scala
find.usages.member.has.supers=멤버 {0}이(가) 일부 기본 멤버를 재정의/구현합니다.\n\
기본 멤버의 사용 위치를 찾으시겠어요?
title.warning=경고

### org/jetbrains/plugins/scala/findUsages/factory/ScalaTypeDefinitionUsagesDialog.scala
find.what.members.usages.checkbox=멤버 사용 위치 [&M]
find.what.implementing.type.definitions.checkbox=타입 정의 구현 중 [&D]
find.what.companion.module.checkbox=컴패니언 모듈 사용 위치 [&C]
find.what.new.instances.usages=인스턴스 생성만 [&I]

### org/jetbrains/plugins/scala/highlighter/ScalaColorSchemeAnnotator.scala
scala.mutable.collection=가변 컬렉션
scala.immutable.collection=불변 컬렉션
java.collection=Java 컬렉션

### org/jetbrains/plugins/scala/lang/completion/ScalaCompletionUtil.scala
wrong.top.statement.declaration=잘못된 상단 구문 선언

### org/jetbrains/plugins/scala/lang/completion/ScalaGlobalMembersCompletionContributor.scala
to.import.method.statically.press.hotkey=메서드를 정적으로 가져오려면 {0}(을)를 누릅니다

### org/jetbrains/plugins/scala/lang/completion/lookups/ScalaImportStaticLookupActionProvider.scala
action.import.member=멤버 가져오기

### org/jetbrains/plugins/scala/lang/findUsages/ScalaFindUsagesProvider.scala
method.of.containingclass={1}의 {0}
descriptive.name.anonymous=익명

### org/jetbrains/plugins/scala/lang/findUsages/ScalaUsageTypeProvider.scala
usage.extractor=추출기
usage.typed.pattern=타입이 지정된 패턴
usage.typed.statement=타입이 지정된 구문
usage.method.apply=메서드 ''apply''
usage.this.reference=this 참조
usage.access.modifier=접근 제어자
usage.package.clause=패키지 절
usage.function.expression=함수 표현식
usage.named.parameter=명명된 매개변수
usage.interpolated.string.prefix=보간된 문자열 접두사
usage.parameter.in.pattern=패턴 내 매개변수
usage.self.type=자기 타입
usage.type.bound=타입 바운드
usage.type.alias=타입 별칭
usage.secondary.constructor=보조 생성자
usage.implicit.conversion.parameter=묵시적 변환/매개변수
usage.unresolved.implicit.conversion.parameter=해결되지 않은 묵시적 변환/매개변수
usage.sam.interface.implementation=SAM 인터페이스 구현

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalaFmtSuggesterService.scala
scalafmt.suggester.detected.in.project=프로젝트에서 Scalafmt 구성이 감지되었습니다. Scalafmt 서식 지정 도구를 활성화하시겠어요?
scalafmt.suggester.enable=활성화
scalafmt.suggester.dont.show=표시 안 함

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalafmtDynamicConfigServiceImpl.scala
#Scalafmt
scalafmt.picked.new.config=Scalafmt에 새 스타일 설정(v{0})이 적용되었습니다
scalafmt.can.not.find.config.file=구성 파일을 찾을 수 없습니다. {0}
scalafmt.can.not.find.config.file.go.to.settings=설정...
scalafmt.can.not.find.config.file.create.new=새 파일 생성
scalafmt.can.not.create.config.file=구성 파일을 생성할 수 없습니다
scalafmt.config.load.errors.failed.to.load.config=Scalafmt 구성을 로드하지 못했습니다
scalafmt.config.load.errors.parse.error=분석 오류\: {0}
scalafmt.config.load.errors.cyclic.includes.detected=순환 include가 탐지되었습니다
scalafmt.config.load.actions.open.config.file=구성 파일 열기

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalafmtDynamicServiceImpl.scala
scalafmt.download=다운로드
scalafmt.resolve.again=다시 해결
scalafmt.progress.resolving.scalafmt.version=Scalafmt 버전 {0} 해결 중
scalafmt.progress.downloading.scalafmt.version=Scalafmt 버전 {0} 다운로드 중
scalafmt.progress.resolving.scalafmt.version.cancel=해결 중지
scalafmt.progress.downloading.scalafmt.version.cancel=다운로드 중지
scalafmt.progress.version.was.downloaded=Scalafmt 버전 {0}이(가) 다운로드되었습니다
scalafmt.resolve.errors.cant.resolve.scalafmt.version=Scalafmt 버전 {0}을(를) 해결할 수 없습니다
scalafmt.resolve.errors.version.is.not.downloaded.yet=Scalafmt 버전 ''{0}''이(가) 다운로드되지 않았습니다.<br>다운로드하시겠어요?
scalafmt.resolve.errors.download.is.in.progress=다운로드가 진행 중입니다
scalafmt.resolve.errors.downloading.error.occurred=다운로드 중 오류가 발생했습니다
scalafmt.resolve.errors.classpath.is.corrupted=클래스 경로가 손상되었습니다
scalafmt.resolve.errors.unknown.error=알 수 없는 오류

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/processors/ScalaFmtPreFormatProcessor.scala
#0:file link;1:error message
scalafmt.format.errors.scala.file.parse.error=Scalafmt 분석 오류({0})\:<br>{1}
#0:file link;1:error message
scalafmt.format.errors.failed.to.find.correct.surrounding.code=Scalafmt 오류({0})\:<br> scalafmt에 전달할 올바른 둘러싸는 코드를 찾지 못했습니다. 서식 지정이 수행되지 않습니다

### org/jetbrains/plugins/scala/lang/formatting/settings/CodeGenerationPanel.java
#Code Generation panel
codegeneration.panel.title=코드 생성

### org/jetbrains/plugins/scala/lang/formatting/settings/ImportsPanel.form
imports.panel.class.count.to.use.import.with=''_''로 import 문을 사용하는 클래스 수\:
imports.panel.add.import.statement.in.closest.block=가장 가까운 블록에 import 문 추가
imports.panel.add.fully.qualified.imports=정규화된 import 문 추가
imports.panel.do.not.change.path.during.optimize.imports.for.local.imports=로컬 import 문을 최적화하는 동안 경로 변경 안 함
imports.panel.sort.imports.for.optimize.imports=import 문 정렬(import 문 최적화)\:
imports.panel.lexicographically=사전순
imports.panel.scalastyle.consistent=scalastyle 준수
imports.panel.force.scala2.in.source3=-Xsource\:3\:를 사용할 때 구문 가져오기
#TODO
imports.panel.merge.imports.with.the.same.prefix.into.one.statement=동일한 접두사를 가진 import 문을 한 구문으로 병합
imports.panel.use.the.shortest.path.when.trying.to.import.reference.with.already.imported.name=이미 가져온 이름을 가진 참조를 가져오는 경우 최단 경로 사용 
imports.panel.classes.to.use.only.with.prefix=반드시 접두사를 포함하여 사용할 클래스
imports.panel.import.layout=import 문 레이아웃
imports.panel.imports.always.marked.as.used=항상 사용됨으로 표시된 import 문
except.for.base.package=기본 패키지 제외

### org/jetbrains/plugins/scala/lang/formatting/settings/ImportsPanel.java
# Imports panel
imports.panel.title=import 문
imports.panel.add.pattern.to.use.appropriate.classes.only.with.prefix=패턴을 추가하여 접두사를 이용해서만 적절한 클래스 사용
imports.panel.use.references.with.prefix=접두사를 포함하여 참조 사용\:
imports.panel.no.imports.with.prefix=접두사를 포함하는 import 문이 없습니다
imports.panel.add.package.name=패키지 이름 추가
imports.panel.import.layout.manager=import문 레이아웃 관리자
imports.panel.add.import.to.always.mark.it.as.used=항상 사용됨으로 표시할 import 문 추가
imports.panel.always.mark.as.used=항상 사용됨으로 표시
imports.panel.honestly.mark.imports.as.unused=import 문을 사용 안 됨으로 솔직하게 표시
imports.panel.base.package.help=기본 패키지가 <code>org.example.application</code>인 경우, 클래스 <code>org.example.application.NAME</code>은 <code>import NAME</code>으로 가져와야 합니다

### org/jetbrains/plugins/scala/lang/formatting/settings/MultiLineStringCodeStylePanel.form
multi.line.string.panel.opening.quotes.on.new.line=새 줄에 여는 따옴표 배치 [&O]
multi.line.string.panel.place.closing.quotes.on.new.line.on.enter.press=Enter 입력 시 새 줄에 닫는 따옴표 배치 [&C]
multi.line.string.panel.align.dangling.closing.quotes=허상 닫는 따옴표 할당 [&A]
multi.line.string.panel.insert.margin.char.on.enter=Enter 입력 시 새 줄에 여백 문자 삽입 [&I]
multi.line.string.panel.process.margin.on.copy.paste=복사/붙여넣기 시 여백 제거/삽입 [&S]
multi.line.string.panel.margin.char.value=여백 문자\:
multi.line.string.panel.margin.char.indent=여백 문자 들여쓰기\:

### org/jetbrains/plugins/scala/lang/formatting/settings/MultiLineStringCodeStylePanel.java
#Multi-line strings panel
multi.line.string.panel.title=여러 줄 문자열

### org/jetbrains/plugins/scala/lang/formatting/settings/OtherCodeStylePanel.form
other.panel.enforce.functional.syntax.for.methods.with.unit.return.type=Unit 반환 타입을 가진 메서드에 대한 함수 구문 강제 실행
other.panel.reformat.on.compile=컴파일 시 서식 다시 지정
other.panel.replace.with.unicode.symbol=''\=>''를 유니코드 심볼로 바꾸기
other.panel.replace.with.unicode.symbol1=''->''를 유니코드 심볼로 바꾸기
other.panel.replace.in.for.generator.with.unicode.symbol=\"for\" 제너레이터의 ''<-''를 유니코드 심볼로 바꾸기
other.panel.kind.projector.replace.lambda.with.unicode.symbol=Kind Projector\: ''Lambda''를 유니코드 심볼로 바꾸기
other.panel.alternate.indentation.for.constructor.args.and.parameter.declarations=생성자 인수 및 매개변수 선언에 대한 대체 들여쓰기\:
other.panel.spaces=공백
other.panel.implicit.value.class.prefix.suffix=묵시적 값 클래스 접두사/접미사

### org/jetbrains/plugins/scala/lang/formatting/settings/OtherCodeStylePanel.java
#Other panel
other.panel.title=기타

### org/jetbrains/plugins/scala/lang/formatting/settings/Scala3SettingsPanel.scala
scala3.panel.use.indentation.based.syntax=들여쓰기 기반 구문 사용
scala3.panel.title=Scala 3

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaCodeStyleSettings.java
#align options
wrapping.and.braces.panel.extends.do.not.align=정렬 안 함
wrapping.and.braces.panel.extends.on.first.token=첫 번째 토큰에서
wrapping.and.braces.panel.extends.align.to.extends=''extends''에 대입

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaDocFormattingPanel.scala
#Scaladoc panel
scaladoc.panel.title=ScalaDoc
scaladoc.panel.enable.scaladoc.formatting=scaladoc 서식 지정 활성화
scaladoc.panel.add.additional.space.for.leading.asterisk=선행 별표에 공백 추가
scaladoc.panel.groups.blank.lines=빈 줄
scaladoc.panel.groups.alignment=정렬
scaladoc.panel.groups.other=기타

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaFmtSettingsPanel.scala
scalafmt.default=디폴트
scalafmt.default.path=디폴트\: {0}
#Code style panel
scalafmt.settings.panel.show.warnings.when.formatting.invalid.code=잘못된 코드 서식 지정 시도 시 경고 표시
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting=코드 범위 서식 지정을 위해 IntelliJ 서식 지정 도구 사용
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting.warning.tooltip=코드 범위 서식 지정을 위해 Scalafmt를 사용하면 코드 불일치가 발생할 수 있습니다.<br>Scalafmt는 Scala 코드를 포함하는 전체 파일의 서식을 지정할 때만 사용하도록 설계되었습니다
scalafmt.settings.panel.reformat.on.file.save=저장 시 서식 다시 지정({0})
scalafmt.settings.panel.reformat.on.file.save.tooltip=힌트\: ''코드 서식 다시 지정''을 사용({0})
scalafmt.settings.panel.fallback.to.default.settings=IntelliJ 디폴트 설정으로 되돌리기
scalafmt.settings.panel.configuration.label=구성
scalafmt.settings.panel.scalafmt.version.label=Scalafmt 버전
scalafmt.settings.panel.select.custom.scalafmt.configuration.file=사용자 지정 Scalafmt 구성 파일 선택
scalafmt.settings.panel.no.config.found.under.path.using.default=지정된 경로에서 구성 파일을 찾을 수 없습니다
scalafmt.settings.panel.errors.cant.resolve.version=scalafmt 버전 {0}을(를) 해결할 수 없습니다
scalafmt.settings.panel.errors.failed.to.parse.config=구성을 분석하지 못했습니다.<br> {0}
scalafmt.settings.panel.errors.cant.find.config.file=다음 경로를 가진 Scalafmt 구성 파일을 찾을 수 없습니다.<br> {0}

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaLanguageCodeStyleSettingsProvider.scala
#Spaces
spaces.panel.simple.one.line.block.braces=단순한 한 줄 블록 중괄호
spaces.panel.import.braces=중괄호 가져오기
spaces.panel.self.type.braces=자기 타입 중괄호
spaces.panel.before.context.bound.colon.rest=컨텍스트 바운드 콜론 앞(나머지)
spaces.panel.before.context.bound.colon.leading.higher.kinded=컨텍스트 바운드 콜론 앞(선행 상위 유형)
spaces.panel.before.context.bound.colon.leading=컨텍스트 바운드 콜론 앞(선행)
spaces.panel.before.opening.square.bracket=여는 대괄호 앞
spaces.panel.keep.one.line.comments.on.same.line=같은 줄에 한 줄 주석 유지
spaces.panel.newline.after.annotations=어노테이션 뒤 새 줄
spaces.panel.around.at.in.pattern.bindings=패턴 바인딩 내 ''@'' 주위
spaces.panel.inside.closure.braces=클로저 중괄호 내부
spaces.panel.before.colon.after.declarations.name=콜론 앞, 선언 이름 뒤
spaces.panel.after.colon.before.declarations.type=콜론 뒤, 선언 타입 앞
spaces.panel.method.call.left.brace=메서드 호출 왼쪽 중괄호
spaces.panel.preserve.space.before.method.parentheses=메서드 소괄호 앞 공백 유지
spaces.panel.infix.method.parentheses=inflix 메서드 소괄호
spaces.panel.infix.operator.like.method.call.parentheses=inflix 연산자식 메서드 호출 소괄호
spaces.panel.infix.method.call.parentheses=inflix 메서드 호출 소괄호
spaces.panel.constructor.parameters.with.modifiers=제어자를 가진 생성자 매개변수
#Wrapping and Braces
#custom groups
wrapping.and.braces.panel.groups.method.definition=메서드 정의
wrapping.and.braces.panel.groups.anonymous.method.definition=익명 메서드 정의
wrapping.and.braces.panel.groups.class.definition=클래스 정의
wrapping.and.braces.panel.groups.xml.formatting=XML 서식 지정
wrapping.and.braces.panel.groups.tuple=튜플
wrapping.and.braces.panel.groups.type.arguments=타입 인수
wrapping.and.braces.panel.groups.type.parameters=타입 매개변수
wrapping.and.braces.panel.force.braces=중괄호 강제 적용
wrapping.and.braces.panel.force.try.braces=''try'' 중괄호 강제 적용
wrapping.and.braces.panel.force.case.branch.braces=''case'' 브랜치 중괄호 강제 적용
wrapping.and.braces.panel.force.finally.braces=''finally'' 중괄호 강제 적용
wrapping.and.braces.panel.align.tuple.elements=튜플 요소 정렬
wrapping.and.braces.panel.do.not.indent.tuples.closing.parenthesis=튜플 닫는 소괄호 들여쓰기 안 함
wrapping.and.braces.panel.do.not.align.block.expression.parameters=블록 표현식 매개변수 정렬 안 함
wrapping.and.braces.panel.indent.braced.arguments=중괄호로 묶인 인수 들여쓰기
wrapping.and.braces.panel.simple.one.line.lambdas.in.arg.list=인수 목록 내 단순한 한 줄 람다
wrapping.and.braces.panel.keep.xml.formatting=XML 서식 지정 유지
wrapping.and.braces.panel.place.self.type.on.new.line=새 줄에 자기 타입 배치
wrapping.and.braces.panel.align.multiline.pattern.alternatives=여러 줄 패턴 대체 대입
wrapping.and.braces.panel.align.in.columns.case.branches=''case'' 브랜치 열 정렬
wrapping.and.braces.panel.do.not.indent.case.clause.body=case 절 본문 들여쓰기 안 함
wrapping.and.braces.panel.match.statement=''match'' 문
wrapping.and.braces.panel.indent.first.parameter.clause.if.on.new.line=새 줄에 있는 경우 첫 번째 매개변수 절 들여쓰기
wrapping.and.braces.panel.indent.first.parameter.if.on.new.line=새 줄에 있는 경우 첫 번째 매개변수 들여쓰기
wrapping.and.braces.panel.align.parameter.types.in.multiline.declarations=여러 줄일 경우 매개변수 타입 정렬
wrapping.and.braces.panel.use.normal.indent.for.parameters=매개변수에 일반 들여쓰기 사용
wrapping.and.braces.panel.parameters.on.new.line=새 줄의 매개변수
wrapping.and.braces.panel.wrap.before.with.keyword=''with'' 키워드 앞 줄 바꿈
wrapping.and.braces.panel.align.if.else.statements=if-else 구문 정렬
wrapping.and.braces.panel.indent=들여쓰기
wrapping.and.braces.panel.new.line.options.no.new.line=새 줄 없음
wrapping.and.braces.panel.new.line.options.new.line.always=항상 줄 바꿈
wrapping.and.braces.panel.new.line.options.new.line.for.multiple.arguments=여러 줄 인수 사용 시 줄 바꿈
wrapping.and.braces.panel.renamed.infix.expressions=inflix 표현식
wrapping.and.braces.panel.renamed.extends.with.list=extends/with 목록
wrapping.and.braces.panel.renamed.extends.keyword=extends 키워드
wrapping.and.braces.panel.renamed.force.yield.braces=yield 중괄호 강제 적용
wrapping.and.braces.panel.for.indent.yield.after.one.line.enumerators=한 줄 열거자 뒤 yield 들여쓰기
#Blank Lines
blank.lines.panel.around.method.in.inner.scopes=내부 범위 내 메서드 주위
blank.lines.panel.around.field.in.inner.scopes=내부 범위 내 필드 주위
blank.lines.panel.around.class.in.inner.scopes=내부 범위 내 클래스 주위
scaladoc.panel.align.parameter.descriptions=매개변수 설명 정렬
scaladoc.panel.align.throws.exception.descriptions=던지기 예외 설명 정렬
scaladoc.panel.align.return.value.description=반환 값 설명 정렬
scaladoc.panel.align.other.tags.descriptions=기타 태그 설명 정렬
scaladoc.panel.blank.lines.keep=유지(태그 사이의 빈 줄이 제거되지 않습니다)
scaladoc.panel.between.parameter.descriptions=매개변수 설명 사이
scaladoc.panel.before.parameter.descriptions=매개변수 설명 앞
scaladoc.panel.before.tags=태그 앞
scaladoc.panel.after.tags=반환 뒤
scaladoc.panel.after.parameter.comments=매개변수 설명 뒤
scaladoc.panel.preserve.spaces.in.tags=태그 내 공백 유지
align.list.items.content=목록 항목 내용 정렬

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaTabbedCodeStylePanel.scala
scala.root.code.style.panel.formatter=서식 지정 도구\:

### org/jetbrains/plugins/scala/lang/formatting/settings/TrailingCommaPanel.scala
#Trailing comma
trailing.comma.panel.title=후행 쉼표
trailing.comma.panel.keep=유지
trailing.comma.panel.remove.when.multiline=여러 줄일 경우 제거
trailing.comma.panel.add.when.multiline=여러 줄일 경우 추가
trailing.comma.panel.scope.arguments.list=인수 목록
trailing.comma.panel.scope.parameters.list=매개변수 목록
trailing.comma.panel.scope.tuple=튜플
trailing.comma.panel.scope.tuple.type=튜플 타입
trailing.comma.panel.scope.pattern.arguments.list=패턴 인수 목록
trailing.comma.panel.scope.type.parameters.list=타입 매개변수 목록
trailing.comma.panel.scope.import.selector=import 선택자

### org/jetbrains/plugins/scala/lang/formatting/settings/TypeAnnotationsPanelBase.form
#Use for
type.annotations.panel.use.for=사용 대상
type.annotations.panel.public.member=public 멤버
type.annotations.panel.protected.member=protected 멤버
type.annotations.panel.private.member=private 멤버
type.annotations.panel.local.definition=로컬 정의
type.annotations.panel.function.literal.parameter=함수 리터럴 매개변수
type.annotations.panel.underscore.parameter=밑줄 매개변수
#Enforce for
type.annotations.panel.enforce.for=강제 적용 대상
type.annotations.panel.implicit.definition=묵시적 정의
type.annotations.panel.unit.type=Unit 타입
type.annotations.panel.accidental.structural.type=예기치 않은 구조 타입*
type.annotations.panel.accidental.structural.type.tooltip=<html>추론된 구조 타입을 가진 값에 타입 어노테이션을 강제 적용합니다. 예시\:<br>\n\
<pre><code>\n\
val foo \= Runnable {\n\
  override def run()\: Unit \= ()\n\
  def helper()\: Unit \= ()\n\
} // 추론 타입인 Runnable { def helper()\: Unit }이 foo에 있습니다\n\
</code></pre></html>
#Except when
type.annotations.panel.except.when=다음의 경우 예외
type.annotations.panel.member.of.anonymous.class=익명 클래스 멤버
type.annotations.panel.member.of.private.class=비공개 클래스 멤버
type.annotations.panel.member.of=다음의 멤버\:
type.annotations.panel.annotated.with=다음 어노테이션 추가\:
type.annotations.panel.constant.final.val=상수(final val)
type.annotations.panel.type.is.stable=타입이 안정적입니다*
type.annotations.panel.type.is.stable.tooltip=<html><body>오른쪽이 다음인 경우\:<br> 리터럴\: <code>123</code>, <code>\"string\"</code> 등(<code>null</code> 제외)<br> Unit 표현식\: <code>()</code><br> 객체 생성\: <code>new Foo(...)</code>(구체화된 코드 제외\: <code>new Foo() {}</code>)<br> Factory 메서드 호출\: <code>Foo(...)</code>(컴패니언 객체에서 <code>apply(...)</code> 호출)<br> 빈 컬렉션\: <code>Seq.empty[Int]</code>, <code>Map.empty[Int, String]</code> 등<br> Java 열거형 상수\: <code>Enum.VALUE</code><br> 예외\: <code>throw Exception()</code> </body></html>
type.annotations.panel.type.matches=타입 일치\:
type.annotations.panel.in.test.sources=테스트 소스 내
type.annotations.panel.in.scala.dialect.sources=Scala 파생 언어 소스 내*
type.annotations.panel.in.scala.dialect.sources.tooltip=*.sbt, *.sc 등

### org/jetbrains/plugins/scala/lang/formatting/settings/TypeAnnotationsPanelBase.java
#Type Annotations panel
type.annotations.panel.title=타입 어노테이션
type.annotations.panel.classes=클래스
type.annotations.panel.annotations=어노테이션
type.annotations.panel.type.patterns=타입 패턴

### org/jetbrains/plugins/scala/lang/macros/expansion/MacroExpansionLineMarkerProvider.scala
expand.macro=매크로 확장

### org/jetbrains/plugins/scala/lang/parser/parsing/CommonUtils.scala
wrong.pattern=잘못된 패턴
right.brace.expected='}'가 필요합니다
bad.interpolated.string.injection=잘못된 보간된 문자열 삽입
wrong.string.literal=잘못된 문자열 리터럴
end.of.string.expected=문자열의 끝이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/CompilationUnit.scala
package.qualID.expected=패키지 정규화된 식별자가 필요합니다
semi.expected='';'' 또는 새 줄이 필요합니다
out.of.compilation.unit=컴파일 단위를 벗어났습니다

### org/jetbrains/plugins/scala/lang/parser/parsing/Packaging.scala
lbrace.expected='{'가 필요합니다
unreachable.error=예기치 않은 오류가 발견되었습니다

### org/jetbrains/plugins/scala/lang/parser/parsing/base/AccessQualifier.scala
rsqbracket.expected='']'' 가 필요합니다
identifier.expected=식별자가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/base/Extension.scala
parameter.expected=매개변수 필요
expected.at.least.one.extension.method=확장 메서드가 1개 이상 필요합니다
expected.new.line.after.colon=콜론 뒤에 새 줄이 필요합니다
extension.method.expected=확장 메서드가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportExpr.scala
identifier.or.opening.brace.expected=식별자 또는 여는 중괄호가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportSelector.scala
identifier.or.wild.sign.expected=식별자 또는 ''_''이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportSelectors.scala
rbrace.expected='}'가 필요합니다
import.selector.expected=import 선택자가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Annotation.scala
wrong.annotation.expression=잘못된 어노테이션 표현식

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/ArgumentExprs.scala
rparenthesis.expected='')''가 필요합니다
wrong.expression=잘못된 표현식

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Ascription.scala
annotation.or.type.expected=어노테이션 또는 타입이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Binding.scala
wrong.type=잘못된 타입

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Bindings.scala
wrong.binding=잘못된 매개변수

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/BlockStat.scala
wrong.declaration.in.block=블록에 선언이 포함될 수 없습니다
missing.statement.for.annotation=어노테이션에 대한 구문 누락

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Enumerator.scala
choose.expected=제너레이터 구문 내 ''<-''가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Expr1.scala
case.clauses.expected=case 절이 필요합니다
while.expected=''do'' 문 내 while 키워드가 필요합니다
enumerators.expected=''for'' 문 내 열거자가 필요합니다
condition.expected=부울 조건이 필요합니다
expected.then=''then''이 필요합니다
expected.do=''do''가 필요합니다
expected.do.or.yield=''do'' 또는 ''yield''가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/ExprInIndentationRegion.scala
line.is.indented.too.far.to.the.left=줄이 너무 왼쪽으로 들여쓰기되어 있습니다

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/NameValuePair.scala
assign.expected=''\=''가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Quoted.scala
type.expected=타입이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/ResultExpr.scala
fun.sign.expected=''\=>''가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/params/FunTypeParamClause.scala
wrong.parameter=잘못된 매개변수

### org/jetbrains/plugins/scala/lang/parser/parsing/params/ImplicitParamClause.scala
implicit.params.excepted=묵시적 매개변수 절은 최소 하나의 매개변수를 포함해야 합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/params/ParamClause.scala
using.parameter.clause.expected=''using'' 매개변수 절이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/params/ParamClauses.scala
param.clause.expected=매개변수 절이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/params/TypeParam.scala
variance.annotation.not.allowed=변동성 어노테이션은 여기에서 허용되지 않습니다
context.bounds.not.allowed=컨텍스트 바운드가 허용되지 않습니다
view.bounds.not.allowed=여기에서는 뷰 바운드가 허용되지 않습니다

### org/jetbrains/plugins/scala/lang/parser/parsing/params/TypesAsParamsOrParams.scala
expected.more.types=더 많은 타입이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/patterns/CaseClause.scala
pattern.expected=패턴이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/patterns/Guard.scala
wrong.postfix.expression=잘못된 접미사 표현식

### org/jetbrains/plugins/scala/lang/parser/parsing/patterns/Pattern3.scala
wrong.type.associativity=결합법칙이 잘못되었습니다. 모든 연산자가 동일한 결합법칙을 가져야 합니다
simple.pattern.expected=단순 패턴의 올바르지 않은 시작

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/FunDef.scala
wrong.constr.expression=잘못된 생성자 표현식
auxiliary.constructor.may.not.have.a.type.annotation=보조 생성자는 타입 어노테이션을 가질 수 없습니다
auxiliary.constructor.definition.expected=보조 생성자 정의가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/PatDef.scala
expression.expected=표현식이 필요합니다
expected.another.pattern=다른 패턴이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/ValDcl.scala
wrong.val.declaration=잘못된 값 선언

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/VarDcl.scala
wrong.var.declaration=잘못된 변수 선언

### org/jetbrains/plugins/scala/lang/parser/parsing/top/QualId.scala
wrong.qual.identifier=잘못된 정규화된 식별자

### org/jetbrains/plugins/scala/lang/parser/parsing/top/TmplDef.scala
wrong.case.modifier=케이스 제어자가 잘못되었습니다. 클래스 또는 객체로 사용하세요

### org/jetbrains/plugins/scala/lang/parser/parsing/top/params/ClassParam.scala
colon.expected=''\:''이 필요합니다
parameter.type.expected=매개변수 타입이 필요합니다
val.var.expected=val 또는 var 키워드가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/top/template/TemplateBody.scala
def.dcl.expected=정의 또는 선언이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/types/ExistentialClause.scala
existential.block.expected=존재 절이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/types/ExistentialDclSeq.scala
wrong.existential.declaration=잘못된 존재 선언입니다. 타입 또는 값 선언이어야 합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/types/InfixType.scala
compound.type.expected=복합 타입이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/types/MatchTypeSuffix.scala
match.type.cases.expected=match 타입 case 절이 필요합니다
expected.case.on.a.new.line=새 줄에 case가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/types/PolyFunOrTypeLambda.scala
type.lambda.expected=''\=>>''가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/types/SimpleType.scala
identifier.expected.comma.found=식별자가 필요하나 '',''가 발견되었습니다

### org/jetbrains/plugins/scala/lang/parser/parsing/types/StableId.scala
dot.expected=''.''가 필요합니다
dot.or.cq.expected=''.'' 또는 클래스 한정자가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/AttrValue.scala
xml.attribute.end.expected=XML 속성 값의 종료 구분자가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/Attribute.scala
xml.eq.expected=''\=''가 필요합니다
xml.attribute.value.expected=속성 값이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/CDSect.scala
xml.cdata.end.expected=XML CData의 종료가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/ETag.scala
xml.tag.end.expected=XML 태그의 종료가 필요합니다
xml.name.expected=XML 태그 이름이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/Element.scala
xml.end.tag.expected=XML 종료 태그(''</'' name '>')가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/PI.scala
xml.PI.end.expected=XML 처리 지침의 끝이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/ScalaExpr.scala
xml.scala.injection.end.expected=XML 내 Scala 삽입의 종료('}')가 필요합니다
xml.scala.expression.expected=XML의 삽입에 Scala 표현식이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/XmlComment.scala
xml.comment.end.expected=XML 주석의 종료(''-->'')가 필요합니다
xml.wrong.character=XML 주석 내 잘못된 문자열

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/pattern/ScalaPatterns.scala
xml.scala.patterns.expected=XML의 삽입에 Scala 패턴이 필요합니다

### org/jetbrains/plugins/scala/lang/psi/api/base/types/ScTypeElement.scala
recursive.type.of.type.element=타입 요소의 재귀 타입
cannot.desugarize.typename={0}을(를) 디슈가화할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/api/expr/ScBlock.scala
cannot.find.partialfunction.class=PartialFunction 클래스를 찾을 수 없습니다
cannot.find.throwable.class=Throwable 클래스를 찾을 수 없습니다
cannot.infer.type.without.expected.type=필요한 타입이 없는 타입을 추론할 수 없습니다
cannot.infer.type.without.function.expected.type=scala.FunctionN 또는 scala.PartialFunction의 필요한 타입이 없는 타입을 추론할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/api/expr/ScExpression.scala
no.type.inferred=표현식 ''{0}''의 타입을 추론할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/api/statements/ScTypeAliasDefinition.scala
no.alias.type=별칭 타입이 없습니다

### org/jetbrains/plugins/scala/lang/psi/compiled/SigFileViewProviderFactory.scala
file.type.scala.outlines=Scala 아웃라인
could.not.decompile.file.comment=//{0}을(를) 디컴파일할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/base/ScConstructorInvocationImpl.scala
can.t.resolve.type=타입을 해결할 수 없습니다
java.constructors.only.have.one.parameter.section=Java 생성자는 하나의 매개변수 섹션만 가집니다
has.no.reference=참조가 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/base/ScInterpolatedStringLiteralImpl.scala
cannot.find.method.of.stringcontext=StringContext의 메서드 {0}을(를) 찾을 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/base/literals/ScLiteralImplBase.scala
wrong.psi.for.literal.type="리터럴 타입을 얻는 잘못된 요소"

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScConstructorPatternImpl.scala
cannot.resolve.unknown.symbol=심볼을 해결할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScReferencePatternImpl.scala
cannot.define.expected.type=필요한 타입을 정의할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScSeqWildcardPatternImpl.scala
no.expected.type.for.wildcard.naming=와일드카드 이름 지정에 필요한 필요 타입이 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScTypedPatternImpl.scala
no.type.element.for.typed.pattern=타입 패턴에 대한 타입 요소가 없습니다
no.type.pattern=타입 패턴이 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScWildcardPatternImpl.scala
cannot.determine.expected.type=필요한 타입을 파악할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScDependentFunctionTypeElementImpl.scala
dependent.function.types.are.not.yet.supported=종속 함수 타입은 아직 지원되지 않습니다

### org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScSimpleTypeElementImpl.scala
cannot.find.template.for.this.reference=이 참조의 템플릿을 찾을 수 없습니다
cannot.find.enclosing.container=둘러싸는 컨테이너를 찾을 수 없습니다
cannot.resolve.ref=참조 {0}을(를) 해결할 수 없습니다
unknown.macro.in.type.position=타입 위치 내 알 수 없는 매크로
recursive.non.value.type.of.type.element=타입 요소의 값이 아닌 재귀 타입

### org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScTypeProjectionImpl.scala
cannot.resolve.reference=참조를 해결할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/expr/MethodInvocationImpl.scala
suitable.method.not.found=적합한 메서드를 찾을 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScForImpl.scala
cannot.create.expression=표현식을 생성할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScGenericCallImpl.scala
not.a.polymorphic.lambda=다형성 람다가 아닙니다.

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScIfImpl.scala
nothing.to.type=타입을 계산할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScNewTemplateDefinitionImpl.scala
empty.new.expression=빈 새로운 표현식

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScParenthesisedExprImpl.scala
no.expression.in.parentheses=소괄호 안에 표현식이 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScReferenceExpressionImpl.scala
no.declared.type.found=선언된 타입을 찾을 수 없습니다
case.class.has.no.primary.constructor=케이스 클래스에 기본 생성자가 없습니다
cannot.resolve.expression=표현식을 해결할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScSelfInvocationImpl.scala
not.enough.parameter.sections=매개변수 섹션이 충분하지 않습니다
cannot.shape.resolve.self.invocation=자체 호출을 해결할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScSuperReferenceImpl.scala
cannot.infer.type.of.super.expression=''super'' 표현식의 타입을 추론할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScThisReferenceImpl.scala
cannot.infer.type=타입을 추론할 수 없습니다
no.clazz.type.found=클래스 타입을 찾을 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScUnderscoreSectionImpl.scala
typed.statement.is.not.complete.for.underscore.section=타입이 지정된 구문이 밑줄 섹션에 대해 완전하지 않습니다
failed.to.found.corresponding.underscore.section=해당하는 밑줄 섹션을 찾을 수 없습니다
could.not.infer.type.of.underscore.section=밑줄 섹션 타입을 추론할 수 없습니다
no.type.inferred.for.unknown.expression=해당 표현식에 대해 추론된 타입이 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/expr/xml/ScXmlPatternImpl.scala
not.found.scala.xml.node=scala.xml.Node를 찾을 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/statements/ScFunctionImpl.scala
both.stub.and.name.identifier.node.are.null={0}의 스텁 및 이름 식별자 노드 모두 null입니다\n\
{1}
no.defined.return.type=정의된 반환 타입이 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/statements/ScValueDeclarationImpl.scala
no.type.element.found=''{0}''에서 타입 요소를 찾을 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/statements/ScVariableDefinitionImpl.scala
cannot.infer.type.without.an.expression=표현식 없이 타입을 추론할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/statements/params/ScParameterImpl.scala
wrong.stub.problem=잘못된 스텁 문제
wrong.type.element=잘못된 타입 요소 

### org/jetbrains/plugins/scala/lang/psi/impl/toplevel/typedef/DerivesUtil.scala
derives.type.has.no.type.parameters={0}은(는) 타입 매개변수가 없으므로 파생될 수 없습니다
derives.type.has.no.companion.object={0}은(는) 컴패니언 객체가 없으므로 파생될 수 없습니다
derives.cannot.be.unified={0}은(는) {1}의 타입 인수와 통합될 수 없습니다
derives.not.a.class.type={0}은(는) 클래스 타입이 아니므로 파생될 수 없습니다
derives.scala.class.expected=Scala class/trait가 필요합니다
derives.no.member.named.derived=파생된 값이 객체 {0}의 멤버가 아닙니다

### org/jetbrains/plugins/scala/lang/psi/impl/toplevel/typedef/ScTypeDefinitionImpl.scala
cannot.resolve.parent.class=상위 클래스를 해결할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/light/DummyLightTypeParam.scala
no.containing.file=포함하는 파일이 없습니다

### org/jetbrains/plugins/scala/lang/psi/types/Compatibility.scala
assignment.missing.right.side=대입 오른쪽이 누락되어 있습니다
cannot.handle.compatibility.for={0}에 대한 호환성을 처리할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/types/api/Variance.scala
variance.contravariant=반공변적
variance.covariant=공변적
variance.invariant=무공변적
variance.bivariant=이변적

### org/jetbrains/plugins/scala/lang/psi/types/result/package.scala
no.element.found=요소를 찾을 수 없습니다

### org/jetbrains/plugins/scala/lang/rearranger/RearrangerUtils.scala
#Rearranger panel
rearranger.panel.keep.scala.style.getters.and.setters.together=Scala 스타일의 getter 및 setter를 함께 유지
rearranger.panel.keep.java.style.getters.and.setters.together=Java 스타일의 getter 및 setter를 함께 유지
rearranger.panel.split.into.unarrangeable.blocks.by.expressions=표현식으로 인해 정렬할 수 없는 블록으로 분할
rearranger.panel.split.into.unarrangeable.blocks.by.implicits=묵시적 정의로 인해 정렬할 수 없는 블록으로 분할

### org/jetbrains/plugins/scala/lang/refactoring/ScalaProcessImportsRefactoringHelper.scala
processing.imports.modified.during.refactoring=리팩터링 중에 수정된 가져온 항목 처리 중

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ConflictsUtil.scala
by.name.parameters.cannot.be.used=이 메서드에는 Java 재정의자가 있으므로, 값 클래스의 이름에 의한 호출 매개변수를 사용할 수 없습니다.
method.is.overridden.by.class.parameter.of.class=메서드가 {0}의 클래스 매개변수에 의해 재정의되었습니다. 이를 함수 정의로 변환하는 것은 지원되지 않습니다.
updating.of.usages.of.generated.unapply=생성된 ''unapply'' 메서드의 사용 위치 업데이트는 지원되지 않습니다
method.is.overridden.in.a.composite.pattern.definition=메서드가 {0}의 복합 패턴 정의에서 재정의되었습니다. 이를 함수 정의로 변환하는 것은 지원되지 않습니다.
method.is.overridden.in.a.composite.variable.definition=메서드가 {0}의 복합 변수 정의에서 재정의되었습니다. 이를 함수 정의로 변환하는 것은 지원되지 않습니다.

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/DefaultValuesUsagePanel.scala
default.values=디폴트 값\:
add.to.definition=정의에 추가
modify.method.calls=메서드 호출 수정

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaChangeSignatureDialog.scala
change.signature.vararg.should.be.last.in.clause=Vararg 매개변수가 매개변수 절의 마지막에 와야 합니다
change.signature.parameters.same.name.{0}=매개변수의 이름이 동일합니다. {0}
change.signature.add.parameter.clause=매개변수 절 추가
change.signature.remove.parameter.clause=매개변수 절 제거
default.value.is.missing.default.arguments=디폴트 값이 없습니다. 디폴트 인수에 새로운 매개변숫값 대신 공백이 포함됩니다.
default.value.is.missing.method.calls=디폴트 값이 없습니다. 메서드 호출에 새로운 매개변숫값 대신 공백이 포함됩니다.
specify.result.type=결과 타입 지정
default.ta.settings=설정

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaChangeSignatureHandler.scala
error.wrong.caret.position.method.name=캐럿이 리팩터링할 메서드 이름에 있어야 합니다.
change.signature.not.supported.implicit.functions=시그니처 변경은 묵시적 함수에서 지원되지 않습니다
change.signature.not.supported.implicit.parameters=시그니처 변경은 묵시적 매개변수를 가진 함수에서 지원되지 않습니다
change.signature.not.supported.extractors=시그니처 변경은 추출기에서 지원되지 않습니다

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaParameterTableModelItem.scala
change.signature.specify.type.for.parameter=매개변수 ''{0}''의 타입 지정
parameter.could.not.be.repeated.and.by.name=매개변수가 반복되는 동시에 이름에 의한 호출일 수 없습니다
could.not.understand.type=타입 {0}을(를) 이해할 수 없습니다

### org/jetbrains/plugins/scala/lang/refactoring/extractMethod/ScalaExtractMethodDialog.java
extract.method.title=메서드 추출
default.ta.tooltip=타입 어노테이션 설정 구성

### org/jetbrains/plugins/scala/lang/refactoring/extractMethod/ScalaExtractMethodHandler.scala
cannot.extract.used.function.definition=리팩터링이 지원되지 않습니다. 선택 영역 내의 함수 정의가 선택한 조각 외부에서 사용됩니다
extract.method.cannot.find.possible.scope=추출한 메서드의 가능한 범위를 찾을 수 없음
extract.local.method={0} 내 지역 메서드 추출
extract.method.to.object.name=객체 {0}(으)로 메서드 추출
extract.method.to.class.name=클래스 {0}(으)로 메서드 추출
extract.method.to.trait.name=특성 {0}(으)로 메서드 추출
extract.method.to.package.name=패키지 {0}(으)로 메서드 추출
extract.method.to.anonymous.class=익명 클래스로 메서드 추출
try.block=try 블록
constructor=생성자
case.clause=case 절
if.block=if 블록
def.name=def {0}
extract.local.method.in.else.block=else 블록 내 지역 메서드 추출
val.name=val {0}
var.name=var {0}
for.statement=for 문
while.statement=while 문
do.statement=do 문
function.expression=함수 표현식
code.block=코드 블록
extract.file.method=파일 메서드 추출
unknown.extraction=알 수 없는 추출
choose.level.for.extract.method=메서드 추출의 수준 선택

### org/jetbrains/plugins/scala/lang/refactoring/extractMethod/duplicates/DuplicatesUtil.scala
process.duplicates=중복 처리

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ExtractSuperUtil.scala
cannot.find.package.with.name=다음 이름을 가진 패키지를 찾을 수 없습니다. {0}
cannot.find.directory.for.package=다음 패키지 디렉터리를 찾을 수 없습니다. {0}
class.already.exists.in.package=패키지 {1}에 이름이 {0}인 클래스가 이미 있습니다

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitAction.scala
extract.trait.action.text=특성 추출...
extract.trait.action.description=선택한 클래스에서 특성을 추출합니다

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitDialog.java
extract.trait.title=특성 추출
extract.trait.top.label.text=다음에서 특성 추출\:
extract.trait.name=특성 이름\:
extract.trait.package.label=새 특성용 패키지\:
members.to.extract=추출할 멤버
extract.abstracts=추상으로 추출

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitHandler.scala
private.member.cannot.be.used.in.extracted.member=비공개 멤버 {0}은(는) 추출된 멤버 {1}에서 사용될 수 없습니다
member.of.anonymous.class.cannot.be.used.in.extracted.member=익명 클래스의 멤버 {0}은(는) 추출된 멤버 {1}에서 사용될 수 없습니다
super.reference.used.in.extracted.member=추출된 멤버 {0}에 상위 항목에 대한 참조가 있지만, 추출된 특성에는 기본 클래스가 없습니다
type.parameters.for.self.type.not.supported=추출된 특성은 자기 타입으로 {0}을(를) 가지지만, 해당 타입 매개변수의 식별은 지원되지 않습니다

### org/jetbrains/plugins/scala/lang/refactoring/inline/ScalaInlineHandler.scala
cannot.inline.different.files=멤버가 다른 파일에 선언되어 있습니다. 인라인화가 지원되지 않습니다.
cannot.inline.used.outside.class=멤버가 포함하는 클래스의 외부에서 사용됩니다. 인라인화가 지원되지 않습니다.
cannot.inline.stable.reference=값이 안정된 참조에서 사용되어 인라인화될 수 없습니다
cannot.inline.never.used=변수가 한 번도 사용되지 않습니다.
cannot.inline.not.simple.pattern=단순 패턴 정의에만 인라인화가 지원됩니다
cannot.inline.recursive.function=인라인화는 재귀 함수에 지원되지 않습니다
cannot.inline.function.implicit.parameters=인라인화는 묵시적 매개변수를 가진 함수에 지원되지 않습니다
cannot.inline.function.multiple.clauses=인라인화는 다수의 매개변수 절을 가진 함수에 지원되지 않습니다
cannot.inline.function.varargs=인라인화는 vararg 매개변수를 가진 함수에 지원되지 않습니다
cannot.inline.implicit.element=인라인화는 묵시적 요소에 지원되지 않습니다
cannot.inline.special.function=인라인화는 특수 함수에 지원되지 않습니다
cannot.inline.generic.function=인라인화는 제네릭 함수에 지원되지 않습니다
cannot.inline.notsimple.typealias=단순 타입 별칭에만 인라인화가 지원됩니다
cannot.inline.value.functional.type=함수 타입을 가진 값의 인라인화는 지원되지 않습니다
cannot.inline.function.functional.parameters=함수 매개변수를 가진 함수의 인라인화는 지원되지 않습니다
cannot.inline.parameter=인라인화는 매개변수에 지원되지 않습니다
cannot.inline.not.method.call=정규 메서드 호출에만 인라인화가 지원됩니다

### org/jetbrains/plugins/scala/lang/refactoring/introduceField/ScalaIntroduceFieldDialog.java
introduce.field.title=필드 추출
field.occurrences={0}개 찾은 항목

### org/jetbrains/plugins/scala/lang/refactoring/introduceField/ScalaIntroduceFieldFromExpressionHandler.scala
cannot.refactor.not.expression=선택한 문자열을 표현식으로 추출할 수 없습니다
cannot.create.field.from.this.expression=이 표현식에서 필드를 생성할 수 없습니다
cannot.find.place.for.the.new.field=새 필드 위치를 찾을 수 없습니다
choose.class.for.introduce.field=필드 삽입용 클래스 선택

### org/jetbrains/plugins/scala/lang/refactoring/introduceParameter/ScalaIntroduceParameterDialog.scala
parameter.label.name=이름\:
parameter.label.type=타입\:
parameter.label.default.value=디폴트 값\:
replace.all.occurrences=모든 찾은 항목 바꾸기

### org/jetbrains/plugins/scala/lang/refactoring/introduceParameter/ScalaIntroduceParameterHandler.scala
cannot.refactor.no.function=매개변수 삽입을 위한 함수를 찾을 수 없습니다
introduce.parameter.title=매개변수 삽입
refactoring.is.not.supported.contains.return=리팩터링이 지원되지 않습니다. 선택 범위에 return 문이 있습니다
choose.function.for.refactoring={0}에 대한 함수 선택

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/IntroduceExpressions.scala
introduce.variable.title=값/변수 삽입

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/IntroduceTypeAlias.scala
cannot.refactor.not.valid.type=타입 요소가 선택되어야 합니다
cannot.refactor.scope.not.found=적합한 클래스 또는 패키지를 찾을 수 없습니다
choose.scope.for={0} 범위 선택
introduce.type.alias.title=타입 별칭 삽입

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaInplaceTypeAliasIntroducer.scala
command.introduce.type.alias=타입 별칭 삽입
press.hotkey.to.show.more.options=ctrl + alt + v를 눌러 더 많은 옵션을 가진 대화상자를 표시하세요

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaInplaceVariableIntroducer.scala
introduce.variable.declare.as.var=변수 [&V]
introduce.variable.specify.type.explicitly=타입 지정
introduce.variable.identifier.is.not.valid=식별자가 올바르지 않습니다

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaIntroduceTypeAliasDialog.java
replace.all.x.occurrences=모든 {0}개의 찾은 항목 바꾸기
1.occurrence=(1개 찾은 항목)
multi.occurrences=({0}개 찾은 항목)
replace.occurrences.available.from.companion.class=컴패니언 클래스 {0}에 있는 찾은 항목 바꾸기

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaIntroduceVariableHandler.scala
cannot.refactor.not.expression.nor.type=표현식 또는 타입 요소가 선택되어야 합니다
press.escape.to.remove.the.highlighting=ESC를 눌러 강조 표시를 제거하세요

### org/jetbrains/plugins/scala/lang/refactoring/memberPullUp/ScalaPullUpProcessor.scala
pull.up.members.from=다음의 멤버를 위로 이동
class.to.pull.up.members.to.class=멤버를 {0}(으)로 올릴 클래스

### org/jetbrains/plugins/scala/lang/refactoring/move/ScalaMoveClassesOrPackagesHandler.scala
move.to.inner.is.not.supported.title=리팩터링이 지원되지 않습니다
move.to.inner.is.not.supported=내부로의 클래스 이동은 Scala에서 지원되지 않습니다
move.with.companion=컴패니언과 함께 이동

### org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMemberHandler.scala
target.0.already.contains.definition.of.1=<b>{0}</b>이(가) 멤버 <b>{1}</b>의 정의를 이미 포함하고 있습니다

### org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMembersDialog.scala
move.members.source.title=객체에서 멤버 이동\:
move.members.target.title=객체로\:
move.members.object.name.or.qualified.name.expected=Scala 객체의 이름 또는 정규화된 이름이 필요합니다
move.members.cannot.find.object=해당 이름을 가진 객체를 찾을 수 없습니다

### org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMembersHandler.scala
move.members=멤버 이동
move.members.supported.only.stable.objects=이동 리팩터링은 안정적 객체 멤버에만 지원됩니다
move.members.not.supported.implicits=이동 리팩터링은 묵시적 정의에 지원되지 않습니다
move.members.not.supported.overridden=이동 리팩터링은 재정의된 정의에 지원되지 않습니다

### org/jetbrains/plugins/scala/lang/refactoring/rename/RenameScalaClassProcessor.scala
rename.companion.module=컴패니언 {0}의 이름 변경

### org/jetbrains/plugins/scala/lang/refactoring/rename/RenameScalaMethodProcessor.scala
rename.getters.and.setters.title=함수가 동일한 이름을 가진 getter 또는 setter를 포함합니다. 이 항목의 이름도 변경하시겠어요?

### org/jetbrains/plugins/scala/lang/refactoring/rename/RenameSuperMembersUtil.scala
rename.all.base.members=모든 기본 멤버의 이름 변경
rename.base.member=기본 멤버의 이름 변경
rename.only.current.member=현재 멤버만 이름 변경
rename.has.multiple.base.members={0}에 기본 멤버가 여러 개 있습니다
rename.only.in={0} {1}에서만 이름 변경
name.implements.member.of.qualname={0}이(가) {1}의 멤버를 구현합니다
name.overrides.member.of.qualname={0}이(가) {1}의 멤버를 재정의합니다

### org/jetbrains/plugins/scala/lang/refactoring/rename/inplace/ScalaInplaceRenameHandler.scala
rename.special.method.title=이 메서드의 이름을 변경할 수 없습니다
rename.special.method.rename.class=포함하는 {0}의 이름 변경
rename.cancel=취소
rename.aliased.title=import 별칭의 이름 변경은 지원되지 않습니다
rename.aliased.rename.actual=실제 요소의 이름 변경

### org/jetbrains/plugins/scala/lang/refactoring/rename/inplace/ScalaMemberInplaceRenamer.scala
rename=이름 변경
could.not.perform.inplace.rename=제자리에서 이름 변경을 수행할 수 없습니다.\n\
이름 변경할 요소\: {0} {1}\n\
대체됨\: {2}\n\
캐럿 주위\: {3}

### org/jetbrains/plugins/scala/lang/refactoring/ui/ScalaMemberInfoBase.scala
presentable.definition.unnamed=이름이 지정되지 않았습니다
presentable.type.unnamed=이름 없는 타입

### org/jetbrains/plugins/scala/lang/refactoring/util/ScalaRefactoringUtil.scala
only.for.scala=이는 Scala 파일에서만 작동합니다
cannot.refactor.constr.expression=선택한 블록이 생성자 표현식으로 표시되면 안 됩니다
cannot.refactor.under.generic.call=리팩터링은 제네릭 호출에서 지원되지 않습니다
cannot.refactor.arg.in.self.invocation.of.constructor=리팩터링은 생성자 본문의 자기 호출 인수에 지원되지 않습니다
cannot.refactor.named.arg=리팩터링은 명명된 인수에 지원되지 않습니다
cannot.refactor.literal.pattern=리팩터링은 리터럴 패턴에 지원되지 않습니다
cannot.refactor.class.parameter.top.level=리팩터링은 최상위 클래스의 매개변수에 지원되지 않습니다
cannot.refactor.interpolated.string.prefix=리팩터링은 보간된 문자열 접두사에 지원되지 않습니다
cannot.refactor.self.invocation=리팩터링은 보조 생성자의 생성자 호출에 지원되지 않습니다
refactoring.is.not.supported.in.guard=리팩터링은 가드에서 지원되지 않으며 코드 구조를 손상시킬 수 있습니다
file.is.not.writable=파일에 쓰기 권한이 없습니다
cannot.extract.empty.message=리팩터링 선택 범위가 잘못되었습니다. 완전한 표현식 또는 구문의 개수가 필요합니다.
cannot.extract.self.invocation=자기 호출을 추출할 수 없습니다.
cannot.extract.used.type.definition=리팩터링이 지원되지 않습니다. 선택 범위 내 타입 정의가 선택한 조각 외부에서 사용됩니다
choose.expression.for={0}에 대한 표현식 선택
choose.type.element.for={0}에 대한 타입 요소 선택

### org/jetbrains/plugins/scala/lang/refactoring/util/ScalaTypeValidator.scala
introduced.typeAlias.will.conflict.with.type.name=삽입한 타입 별칭이 타입 이름과 충돌합니다. {0}
introduced.typeAlias.will.conflict.with.class.name=삽입한 타입 별칭이 클래스 이름과 충돌합니다. {0}

### org/jetbrains/plugins/scala/lang/refactoring/util/ScalaVariableValidator.scala
introduced.variable.will.conflict.with.local=삽입된 변수가 지역 변수와 충돌합니다(또는 해당 요소에 의해 숨겨집니다). {0}
introduced.variable.will.conflict.with.parameter=삽입된 변수가 매개변수와 충돌합니다(또는 해당 요소에 의해 숨겨집니다). {0}
introduced.variable.will.conflict.with.field=삽입된 변수는 매개변수 없는 필드 또는 메서드와 충돌하거나 (필드 또는 메서드에 의해 숨겨질 수 있습니다.) {0}
introduced.variable.will.conflict.with.class.parameter=삽입된 변수가 클래스 매개변수와 충돌합니다(또는 해당 요소에 의해 숨겨집니다). {0}

### org/jetbrains/plugins/scala/lang/scaladoc/generate/ScaladocAction.scala
generate.scaladoc=Scaladoc 생성
generate.scaladoc.action.text=Scaladoc 생성
generate.scaladoc.action.description=Scaladoc 생성
scaladoc.noon=Scaladoc

### org/jetbrains/plugins/scala/lang/scaladoc/generate/ScaladocConsoleRunConfigurationForm.java
output.dir=출력 디렉터리
documentation.for.project={0} 문서

### org/jetbrains/plugins/scala/lang/scaladoc/parser/parsing/MyScaladocParsing.scala
scaladoc.parsing.open.syntax.element=구문 요소 열기
scaladoc.parsing.closing.link.tag.before.opening=열기 전 링크 태그 닫기
scaladoc.parsing.closing.code.tag.before.opening=열기 전 코드 태그 닫기
scaladoc.parsing.error.bad.token=오류\: 잘못된 토큰\: {0}
scaladoc.parsing.header.closed.by.opening.new.one=새 헤더가 열림에 따라 닫힌 헤더
scaladoc.parsing.wiki.syntax.element.closed.by.message={0}에 따라 닫힌 Wiki 구문 요소
scaladoc.parsing.wiki.syntax.closed.by.new.paragraph=새 단락
scaladoc.parsing.wiki.syntax.closed.by.tag=태그
scaladoc.parsing.wiki.syntax.closed.by.inner.code.tag=내부 코드 태그
scaladoc.parsing.cross.tags=크로스 태그
scaladoc.parsing.no.closing.element=닫는 요소가 없음
scaladoc.parsing.unclosed.code.tag=닫히지 않은 코드 태그
scaladoc.parsing.unexpected.end.of.tag.body=예기치 않은 태그 본문 끝
scaladoc.parsing.inline.tag=태그 인라인화
scaladoc.parsing.missing.tag.param=태그 매개변수 누락
scaladoc.parsing.unknown.tag=알 수 없는 태그\: {0}

### org/jetbrains/plugins/scala/lang/structureView/element/TypeAlias.scala
type.unnamed=타입의 이름이 지정되지 않음

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithBoldSurrounder.scala
bold.surrounder.template.description=굵게\: '''' ''''

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithItalicSurrounder.scala
italic.surrounder.template.description=기울임꼴\: '' ''

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithMonospaceSurrounder.scala
monospace.surrounder.template.description=고정폭\: '' ''

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithSubscriptSurrounder.scala
subscript.surrounder.template.description=아래 첨자\: ,, ,,

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithSuperscriptSurrounder.scala
superscript.surrounder.template.description=위 첨자\: ^ ^

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithUnderlinedSurrounder.scala
underline.surrounder.template.description=밑줄\: __ __

### org/jetbrains/plugins/scala/lang/transformation/DesugarCodeAction.scala
desugar.scala.code.in.scope=Scala 코드 디슈가({0})
scope.selection=선택 범위
scope.file=파일
desugar.scala.code.action.text=Scala 코드 디슈가...
desugar.scala.code.action.description=Scala 코드 디슈가(선택 범위/파일 전체)

### org/jetbrains/plugins/scala/lang/transformation/SelectionDialog.scala
column.enabled=활성화됨
column.transformation=변환
desugar.group.method.invocations=메서드 호출
desugar.expand.apply.call="apply" 호출 확장
desugar.expand.update.call="update" 호출 확장
desugar.expand.unary.call=단항 호출 확장
desugar.expand.property.setter.call=프로퍼티 setter 호출 확장
desugar.expand.assignment.call=대입 호출 확장
desugar.expand.dynamic.call=동적 호출 확장
desugar.canonize.infix.call=infix 호출 정규화
desugar.canonize.postfix.call=접미사 호출 정규화
desugar.canonize.arity.0.call=arity-0 호출 정규화
desugar.canonize.block.argument=빈 블록 인수 정규화
desugar.expand.auto.tupling=자동 튜플링 확장
desugar.expand.vararg.argument=vararg 인수 확장
desugar.inscribe.default.arguments=디폴트 인수 삽입
desugar.expand.to.equals.call="\=\="를 "equals" 호출로 확장
desugar.group.type.annotations=타입 어노테이션
desugar.value.definition=값 정의
desugar.variable.definition=변수 정의
desugar.method.definition=메서드 정의
desugar.function.parameter=함수 매개변수
desugar.underscore.parameter=밑줄 매개변수
desugar.reference.pattern=참조 패턴
desugar.type.parameters=타입 매개변수
desugar.group.types=타입
desugar.expand.function.type=함수 타입 확장
desugar.expand.tuple.type=튜플 타입 확장
desugar.expand.type.alias=타입 별칭 확장
desugar.expand.context.bound=컨텍스트 바운드 확장
desugar.expand.view.bound=뷰 바운드 확장
desugar.substitute.anyref=AnyRef 대체
desugar.group.implicits=묵시적
desugar.expand.implicit.conversion=묵시적 변환 확장
desugar.inscribe.implicit.parameters=묵시적 매개변수 삽입
desugar.group.functions=함수
desugar.expand.placeholder.syntax=자리표시자 구문 확장
desugar.expand.eta.expansion=eta 확장 확장
desugar.make.eta.expansion.explicit=eta 확장을 명시적으로 설정
desugar.expand.single.abstract.methods=단일 abstract 메서드 확장
desugar.expand.function.instantiation=함수 인스턴스화 확장
desugar.group.expressions=표현식
desugar.expand.for.comprehensions=for 내포 확장
desugar.expand.string.interpolation=문자열 보간 확장
desugar.expand.tuple.instantiation=튜플 인스턴스화 확장
desugar.group.declarations=선언
desugar.expand.procedure.syntax=프로시저 구문 확장
desugar.make.method.return.expressions.explicit=메서드 반환 표현식을 명시적으로 설정
desugar.add.explicit.override.modifier=명시적 "override" 제어자 추가
desugar.replace.underscore.section.with.default.value=밑줄 섹션을 디폴트 값으로 바꾸기
desugar.expand.property.declaration=프로퍼티 선언 확장
desugar.expand.property.definition=프로퍼티 정의 확장
desugar.convert.implicit.class.to.class.and.function=묵시적 클래스를 클래스 및 함수로 변환
desugar.group.references=참조
desugar.expand.wildcard.import=와일드카드 import 문 확장
desugar.fully.qualify.import.expression=import 표현식을 완전히 정규화
desugar.partially.qualify.simple.reference=단순 참조를 부분적으로 정규화
desugar.fully.qualify.reference=참조를 완전히 정규화
desugar.group.general=일반
desugar.append.semicolon=세미콜론 추가
desugar.inscribe.explicit.braces=명시적 중괄호 삽입
desugar.enforce.parentheses.in.constructor.invocation=생성자 호출 시 소괄호 강제 적용
desugar.convert.parentheses.to.braces.in.for.comprehensions=내포를 위해 소괄호를 중괄호로 변환
desugar.expand.macro=매크로 확장

### org/jetbrains/plugins/scala/overrideImplement/ScalaMemberChooser.scala
specify.return.type.explicitly=타입 지정 [&T]
add.override.modifier=''override'' 삽입 [&O]
copy.scaladoc=ScalaDoc 복사 [&S]

### org/jetbrains/plugins/scala/overrideImplement/ScalaOIUtil.scala
select.method.override=재정의할 멤버 선택
select.method.implement=구현할 멤버 선택
action.implement.method=메서드 구현
action.override.method=메서드 재정의

### org/jetbrains/plugins/scala/project/ScalaLibraryType.scala
library.type.scala.sdk=Scala SDK

### org/jetbrains/plugins/scala/project/Versions.scala
title.fetching.available.this.versions=사용 가능한 {0} 버전 페치 중

### org/jetbrains/plugins/scala/project/external/ScalaAbstractProjectDataService.scala
scala.project.data.service.scalaLibraryNotFound=모듈 ''{0}''의 Scala SDK를 구성할 수 없습니다(모듈 ''{0}''의 프로젝트 Scala 라이브러리 {1}을(를) 찾을 수 없습니다)

### org/jetbrains/plugins/scala/project/notification/SetupScalaSdkNotificationProvider.scala
sdk.notification.provider.setup.scala.sdk=Scala SDK 설치
sdk.notification.provider.no.scala.sdk.in.module=모듈에 Scala SDK가 없습니다

### org/jetbrains/plugins/scala/project/sdkdetect/ScalaSdkProvider.scala
sdk.scan.title=Scala SDK 검색 중\: {0}

### org/jetbrains/plugins/scala/project/sdkdetect/repository/BrewDetector.scala
brew.packages=Brew 패키지

### org/jetbrains/plugins/scala/project/sdkdetect/repository/CoursierDetector.scala
coursier.v1.cache=Coursier v1 캐시

### org/jetbrains/plugins/scala/project/sdkdetect/repository/IvyDetector.scala
ivy2.cache=Ivy2 캐시

### org/jetbrains/plugins/scala/project/sdkdetect/repository/MavenDetector.scala
maven.local.repo=Maven 로컬 저장소

### org/jetbrains/plugins/scala/project/sdkdetect/repository/ProjectLocalDetector.scala
local.project.libraries=로컬 프로젝트 라이브러리

### org/jetbrains/plugins/scala/project/sdkdetect/repository/SdkmanDetector.scala
sdkman=SDKMAN\!

### org/jetbrains/plugins/scala/project/sdkdetect/repository/SystemDetector.scala
system.wide.scala=시스템 전체 Scala

### org/jetbrains/plugins/scala/project/sdkdetect/repository/package.scala
unresolved.artifact=해결되지 않은 아티팩트\: {0}
ambiguous.artifact.resolved=모호한 아티팩트가 해결되었습니다. {0}
unknown.resolve.issues=알 수 없는 해결 이슈\: {0}
unknown.exception=알 수 없는 예외\: {0}

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerConfigurable.scala
displayname.scala.compiler=Scala 컴파일러

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerConfigurationPanel.form
#Scala compiler settings UI
incrementality.type=증분 타입 [&I]\:

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerProfilesPanel.scala
scala.compiler.profiles.panel.profile.name=프로파일 이름
scala.compiler.profiles.panel.move.to=다음으로 이동
scala.compiler.profiles.panel.create.new.profile=새 프로파일 생성
scala.compiler.profiles.panel.profile.should.not.be.empty=프로파일 이름은 공백일 수 없습니다
scala.compiler.profiles.panel.profile.already.exists=프로파일 {0}이(가) 이미 있습니다

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerSettingsPanel.form
unchecked.warnings=확인되지 않은 경고 [&U]
unchecked.warnings.tooltip=생성된 코드가 가정에 따라 달라지는 경우 추가 경고를 활성화하세요.
deprecation.warnings=지원 중단 경고 [&D]
deprecation.warnings.tooltip=지원 중단된 API의 사용 위치에 대한 경고 및 해당 위치를 전송합니다.
feature.dynamics=동적 [&D]
feature.existential.types=존재 타입 [&E]
explain.type.errors=타입 오류 설명 [&E]
explain.type.errors.tooltip=타입 오류를 자세히 설명합니다
feature.warnings=기능 경고 [&F]
feature.warnings.tooltip=언어 기능 경고를 전송합니다.
feature.higher.kinded.types=상위 타입 [&H]
feature.implicit.conversions=묵시적 변환 [&I]
feature.macros=매크로 [&M]
optimise.bytecode=바이트코드 최적화(신중히 사용*) [&O]
optimise.bytecode.tooltip=프로그램에 최적화를 적용하여 더 빠른 바이트코드를 생성하세요. 다양한 컴파일 문제가 발생할 수 있으니 신중히 사용하세요.
feature.postfix.notation=접미사 연산자 표기법 [&P]
feature.reflective.calls=리플렉티브 호출 [&R]
additional.compiler.options=추가 컴파일러 옵션 [&O]\:
compile.order=컴파일 순서 [&O]\:
compiler.plugins=컴파일러 플러그인
debugging.info.level=디버그 정보 수준 [&L]\:
feature.experimental.features=실험적 기능 [&X]
enable.continuations=연속 활성화 [&C]
enable.specialization=특수화 활성화 [&S]
enable.specialization.tooltip=@specialize 어노테이션 준수
enable.warnings=경고 활성화 [&W]
enable.warnings.tooltip=경고 생성
features=기능
options=옵션

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerSettingsPanel.java
compile.order.mixed=혼합
compile.order.java.then.scala=Java 다음에 Scala
compile.order.scala.then.java=Scala 다음에 Java
debug.info.level.none=없음
debug.info.level.source=소스 파일 속성
debug.info.level.source.and.line.number=소스 및 줄 번호 정보
debug.info.level.source.line.number.and.local.variable=소스, 줄 번호 및 지역 변수 정보
debug.info.level.complete.no.tail.call.optimization=전체(꼬리 호출 최적화 없음)

### org/jetbrains/plugins/scala/project/template/ScalaProjectTemplate.scala
idea.based.scala.project=ИСРA 기반 Scala 프로젝트
module.with.a.scala.sdk=Scala SDK를 포함하는 모듈

### org/jetbrains/plugins/scala/project/template/ScalaSDKStepLike.scala
package.prefix.label=패키지 접두사\:
package.prefix.example=예\: ''org.example.application''
package.prefix.help=패키지 접두사가 <code>org.example.application</code>인 경우, 소스 디렉터리 내 <code>PATH</code>는 <code>org/example/application/PATH</code>를 의미하므로, 명시적 <code>org</code>, <code>example</code>, <code>application</code> 하위 디렉터리를 생성할 필요가 없습니다.

### org/jetbrains/plugins/scala/project/template/ScalaVersionDownloadingDialog.scala
title.download=다운로드
title.error.downloading.scala.libraries=Scala 라이브러리 다운로드 중 오류 발생
no.versions.available.for.download=다운로드 가능한 버전이 없습니다
downloading.scala.version=Scala {0} 다운로드 중
error.downloading.scala.version=Scala {0} 다운로드 중 오류가 발생했습니다
invalid.scala.version.format=올바르지 않은 Scala 버전 형식\: {0}

### org/jetbrains/plugins/scala/project/template/SdkSelectionDialogWrapper.scala
sdk.create.select.files=새 Scala SDK용 JAR 선택
scala.sdk.selection.button.download=다운로드...
scala.sdk.selection.button.browse=찾아보기...
scala.sdk.component.name.compiler.classpath=컴파일러 클래스 경로
scala.sdk.component.name.library=라이브러리
scala.sdk.component.name.library.source=라이브러리 소스
scala.sdk.component.name.library.scaladoc=라이브러리 scaladoc
# {0} - component name
scala.sdk.descriptor.contains.duplicated.files=Scala SDK 설명자에 중복된 {0} 파일이 있습니다.

### org/jetbrains/plugins/scala/project/template/SdkTableModel.scala
sdk.table.model.location=위치
sdk.table.model.version=버전
sdk.table.model.sources=소스
sdk.table.model.docs=문서

### org/jetbrains/plugins/scala/project/template/sdk_browse/ScalaSdkFilesChooserDescriptor.scala
title.scala.sdk.files=Scala SDK 파일
choose.either.a.scala.sdk.directory.or.scala.jar.files=Scala SDK 디렉터리 또는 Scala jar 파일 중 하나를 선택하세요(허용\: 바이너리, 소스, 문서)

### org/jetbrains/plugins/scala/runner/ScalaApplicationConfigurationExtension.scala
no.program.arguments=프로그램 인수가 없습니다

### org/jetbrains/plugins/scala/runner/view/ScalaMainMethodParametersTable.scala
main.method.parameters.table.column.title.name=이름
main.method.parameters.table.column.title.type=타입
main.method.parameters.table.column.title.value=값

### org/jetbrains/plugins/scala/runner/view/ScalaProvideMainMethodParametersDialog.scala
provide.program.arguments=프로그램 인수 제공

### org/jetbrains/plugins/scala/settings/ScalaEditorSmartKeysConfigurable.scala
indent.pasted.lines.at.caret=캐럿 위치에 붙여넣은 줄 들여쓰기
insert.pair.multiline.quotes=다중 문자열에 따옴표를 쌍으로 삽입
wrap.single.expression.body='{' 입력 후 닫는 중괄호로 단일 표현식의 본문 래핑
delete.closing.brace='{'를 삭제하고 닫는 괄호 삭제
upgrade.to.interpolated=''${'' 입력 후 단순 문자열을 보간된 문자열로 업그레이드
insert.block.braces.automatically.based.on.indentation=중괄호를 자동으로 추가
insert.block.braces.automatically.based.on.indentation.tooltip=코드 편집 시 단일 줄 블록이 여러 줄 블록으로 바뀔 때 중괄호 추가
remove.block.braces.automatically.based.on.indentation=중괄호를 자동으로 제거
remove.block.braces.automatically.based.on.indentation.tooltip=코드 편집 시 여러 줄 블록이 단일 줄 블록으로 바뀔 때 중괄호 제거
control.curly.braces.based.on.line.indents=들여쓰기에 따라 중괄호 제어\:

### org/jetbrains/plugins/scala/settings/ScalaProjectSettings.java
scala.project.settings=Scala 프로젝트 설정

### org/jetbrains/plugins/scala/settings/ScalaProjectSettingsPanel.form
scala.project.settings.form.tabs.editor=에디터
scala.project.settings.form.tabs.project.view=프로젝트 뷰
scala.project.settings.form.tabs.performance=성능
scala.project.settings.form.tabs.worksheet=워크시트
scala.project.settings.form.tabs.base.packages=기본 패키지
scala.project.settings.form.base.package.inherit=소스 폴더의 패키지 접두사에서 상속
scala.project.settings.form.base.package.custom=사용자 지정 사용\:
scala.project.settings.form.tabs.misc=기타
scala.project.settings.form.tabs.updates=업데이트
scala.project.settings.form.tabs.extensions=확장
scala.project.settings.form.alias.export.semantics=Scala 및 Scala.Predef의 별칭\:
scala.project.settings.form.collection.type.highlighting.option=컬렉션 타입 강조 표시\:
scala.project.settings.form.sbt.index.ivy2.mode=로컬 ivy2 캐시 색인 생성 모드
scala.project.settings.form.sbt.index.ivy2.mode.hint=비활성화됨 - 색인 생성이 전혀 수행되지 않음\n\
메타데이터 - 라이브러리 이름 및 버전만 색인 생성. SBT 파일 종속성 완성에 사용됨\n\
클래스 - 캐시에 클래스 이름 색인 생성. ''SBT 종속성 추가'' 빠른 수정에 사용됨
scala.project.settings.form.scala.meta.settings.annot212=scala.meta 프로그램 실행
scala.project.settings.form.scala.meta.settings.annot212.tooltip=바이너리 호환성 때문에 2.12 모듈의 어노테이션이 매우 느린 문자열 기반의 직렬화 및 재분석을 사용해야 합니다. 이는 전반적인 성능에 심각한 영향을 미칠 수 있습니다.
scala.project.settings.form.scala.meta.settings.modeOptions.tooltip=활성화됨 - 타입 추론 중 모든 메타프로그램이 실행됩니다\n\
비활성화됨 - 타입 추론 중 메타프로그램을 건너뜁니다\n\
수동 - 수동으로 확장된 경우에만 메타프로그램이 실행됩니다
scala.project.settings.form.scala.meta.settings.trimBodies.caption=Trim 메서드 본문이 scala.meta에 의해 확장됩니다
scala.project.settings.form.scala.meta.settings.trimBodies.tooltip=생성된 메서드의 명시적 반환 타입에 의존합니다(본문이 ???로 대체됩니다). 메서드 본문 타입 검사를 건너뛰어 타입 추론 속도를 높입니다.
scala.project.settings.form.error.highlighting=오류 강조 표시
scala.project.settings.form.error.highlighting.use.compiler.ranges=Scala 컴파일러가 보고한 텍스트 범위 사용
scala.project.settings.form.highlighting=강조 표시
scala.project.settings.form.highlight.implicit.conversions=묵시적 변환 강조 표시
scala.project.settings.form.show.hints.if.no.implicit.arguments.found=묵시적 인수를 찾을 수 없는 경우 힌트 표시
scala.project.settings.form.show.hints.if.ambiguous.implicit.arguments.found=모호한 묵시적 인수가 발견되면 힌트 표시
scala.project.settings.form.highlight.arguments.to.by.name.parameters=이름에 의한 호출 매개변수의 인수 강조 표시
scala.project.settings.form.include.block.expressions=블록 표현식 포함
scala.project.settings.form.include.literals=리터럴 포함
scala.project.settings.form.custom.scalatest.keywords.highlighting=사용자 지정 scalaTest 키워드 강조 표시
scala.project.settings.form.autocomplete=자동 완성
scala.project.settings.form.ahead.of.time.completion=사전 코드 완성(매개변수 및 변수 이름)
scala.project.settings.form.use.scala.classes.priority.over.java=Java 클래스보다 Scala 클래스 우선 사용
scala.project.settings.form.code.conversion=코드 변환
scala.project.settings.form.convert.java.code.to.scala.on.copy.paste=복사 및 붙여넣기 시 Java 코드를 Scala로 변환
scala.project.settings.form.automatically.convert.to.scala.code.without.dialog=붙여넣기 시 대화상자를 표시 안 하고 Scala 코드로 자동 변환
scala.project.settings.form.add.override.keyword.to.method.implementation=메서드 구현에 override 키워드 추가
scala.project.settings.form.group.package.object.with.package=패키지 객체를 패키지와 그룹화 [&G]
scala.project.settings.form.highlight.nodes.with.errors=오류가 있는 노드 강조 표시 [&H]
scala.project.settings.form.implicit.parameters.search.depth=묵시적 매개변수 검색 깊이(아무것도 없는 경우 -1)\:
scala.project.settings.form.search.all.symbols=모든 심볼 검색(지역 심볼 포함)
scala.project.settings.form.disable.parsing.of.documentation.comments=문서 주석 분석 비활성화. 이렇게 하면 매우 큰 파일의 경우 에디터 성능이 향상됩니다. (SCL-2900)
scala.project.settings.form.disable.language.injection.in.scala.files=Scala 파일 내 언어 삽입 비활성화(삽입된 언어는 자동 팝업 코드 완성 기능으로 입력을 중지시킬 수 있습니다)
scala.project.settings.form.dont.cache.compound.types=복합 타입 캐시 안 함(GC에서 심한 멈춤 현상이 발생하는 경우 사용하세요)
scala.project.settings.form.treat.sc.files.as=.sc 파일을 다음으로 처리\:
scala.project.settings.form.output.cutoff.limit=출력 컷오프 제한\:
scala.project.settings.form.output.cutoff.limit.units=줄
scala.project.settings.form.delay.before.auto.run=자동 실행 전 지연\:
scala.project.settings.form.delay.before.auto.run.units=밀리초
scala.project.settings.form.run.worksheet.in.the.compiler.process=컴파일러 프로세스에서 워크시트 실행(일반 모드만 해당)
scala.project.settings.form.use.eclipse.compatibility.mode=''eclipse 호환성'' 모드 사용
scala.project.settings.form.treat.scala.scratch.files.as.worksheet.files=Scala 스크래치 파일을 워크시트 파일로 처리
scala.project.settings.form.collapse.long.output.by.default=기본적으로 긴 출력 접기
scala.project.settings.form.scalatest.default.super.class=ScalaTest 디폴트 상위 클래스\:
scala.project.settings.form.trailing.commas=후행 쉼표\:
scala.project.settings.form.plugin.update.channel=채널 업데이트\:
scala.project.settings.form.check.for.updates=지금 확인
scala.project.settings.form.info=언제든지 "안정화된 릴리스" 또는 "얼리 액세스 프로그램"을 선택하여 더 안정적인 빌드로 돌아갈 수 있습니다
support.back.references.in.shared.sources=공유된 소스에서 역참조 지원(실험적 기능) [&S]
support.back.references.in.shared.sources.tooltip=이 설정이 활성화되면 IntelliJ가 공유 소스 모듈에서<br>종속 모듈의 선언으로 참조를 처리할 수 있습니다  

### org/jetbrains/plugins/scala/settings/ScalaProjectSettingsPanel.java
scala.collection.highlighting.type.none=없음
scala.collection.highlighting.type.only.non.qualified=정규화되지 않은 항목만
scala.collection.highlighting.type.all=모두
scala.plugin.chanel.nightly=야간 빌드
scala.plugin.chanel.eap=얼리 액세스 프로그램
scala.plugin.chanel.release=안정화된 릴리스
scala.project.settings.form.alias.definition=정의
scala.project.settings.form.alias.export=내보내기
scala.project.settings.form.tabs.base.package=기본 패키지
scala.meta.mode.enabled=활성화됨
scala.meta.mode.disabled=비활성화됨
scala.meta.mode.manual=수동
ivy2.indexing.mode.disabled=비활성화됨
ivy2.indexing.mode.metadata=메타데이터
ivy2.indexing.mode.classes=클래스
trailing.commas.mode.enabled=활성화됨
trailing.commas.mode.disabled=비활성화됨
trailing.commas.mode.auto=자동
type.checker.built.in=기본 제공
type.checker.compiler=컴파일러
type.checker.help=<html><strong>기본 제공\: </strong> 더 많은 기능을 제공하며 반응이 더 빠르고 가볍습니다. 복잡한 코드에서는 거짓 오류가 발생할 수 있습니다.<br><br><strong>컴파일러\:</strong> 더 정확합니다. 그러나 더 느리고 더 많은 리소스를 소비하며 타입 비교, 빠른 수정, 검사 등의 기능을 지원하지 않습니다.<br><br>특정 코드 베이스에서 거짓 오류가 대량으로 발생하지 않는 한, 기본 제공 타입 검사기를 사용하는 것이 좋습니다.</html> 
use.compiler.ranges.help=<html><strong>오류 강조 표시가 컴파일러로 설정된 Scala 3 프로젝트에 적용됩니다.</strong><br><br>활성화 시 에디터 내의 코드를 강조 표시할 때 Scala 컴파일러가 보고한 텍스트 범위가 사용됩니다. 선택된 컴파일 오류에 대해 큰 텍스트 범위가 강조 표시될 수 있습니다.<br><br>비활성화 시 선택된 컴파일 오류에 대해 작은 텍스트 범위가 강조 표시됩니다.</html>
script.file.mode.always.worksheet=항상 워크시트
script.file.mode.ammonite.in.test.sources.otherwise.worksheet=테스트 소스에서는 Ammonite. 그 외의 경우 워크시트
script.file.mode.always.ammonite=항상 Ammonite
invalid.update.channel=잘못된 업데이트 채널
changes.in.scalatest.highlighting.will.be.processed...=ScalaTest 강조 표시에 적용된 변경 내용은 새로 강조 표시된 파일에서만 올바르게 처리됩니다. 사용 경험을 최적화하려면 Intellij ИСРA를 다시 시작하세요
base.package.help=<html>기본 패키지가 <code>org.example.application</code>인 경우, 패키지 <code>org.example.application.NAME</code>은<br><code>package org.example.application</code><br><code>package NAME</code>으로 정의되어야 합니다</html>

### org/jetbrains/plugins/scala/util/compile/ScalaCompileTask.scala
scala.compile.task.measure.start={0}...
scala.compile.task.measure.end={0} - {1}에 완료

### <unused>
default.notification.title=경고
