action.Swift.ExtractFunction.text=Извлечь функцию…
action.Swift.FormatFileWithSwiftFormat.text=Переформатовать код с помощью Swift-Format
action.Swift.Generate.DebugDescription.description=Сгенерировать debugDescription
action.Swift.Generate.DebugDescription.text=debugDescription…
action.Swift.Generate.Description.description=Сгенерировать description
action.Swift.Generate.Description.text=description…
action.Swift.Generate.EqualsHashValue.description=Сгенерировать equals и hash
action.Swift.Generate.EqualsHashValue.text=equals и hash
action.Swift.Generate.Init.description=Сгенерировать инициализатор
action.Swift.Generate.Init.text=Инициализатор
action.Swift.GenerateDocComment.text=Сгенерировать документирующий комментарий
action.Swift.IntroduceClosureVariable.text=Извлечь замыкание…
action.Swift.NewFile.description=Создать новый Swift файл или тип
action.Swift.NewFile.text=Swift файл/тип
action.Swift.ShowSwiftИСРTest.text=Запустить отчёт Swift ИСР
action.Swift.SwiftFormatCreateConfigFileAction.text=Создать конфигурационный файл Swift-Format
action.Swift.ToggleErrorHints.text=Показывать подсказки об ошибках
action.Swift.ToggleGlobalErrorHints.text=Показывать подсказки об ошибках Swift
action.Swift.ToggleGlobalTypeHints.text=Показывать подсказки типов Swift
action.Swift.ToggleTypeHints.text=Показывать подсказки типов
auto.import.command.name=Автоимпорт модулей
auto.import.completion.presentation.tail.from.0=\ ({0})
auto.import.settings.checkbox.sort=Сортировать import
auto.import.settings.import.symbol=Автоимпорт конкретных символов
auto.import.settings.import.symbol.help=При автоимпорте символов предпочитать импорт самого символа вместо импорта всего модуля, где он объявлен
auto.import.settings.optimize.non.module=Оптимизовать неmodule import
auto.import.settings.optimize.non.module.help=При оптимизации import заменять явный импорт функций, структур, классов и т.д. на импорт их родительского модуля
call.hierarchy.usage.in=Использование в ''{0}''
change.info.async.throws.label=async/throws\:
change.info.default.value.code.comment="Значение по умолчанию \= {0}"
change.info.default.value.label=Значение по умолчанию\:
change.info.dialog.invalid.function.name.0=Недопустимое имя функции\: ''{0}''
change.info.dialog.invalid.parameter.internal.name.0=Недопустимое внутреннее имя параметра\: ''{0}''
change.info.dialog.invalid.parameter.name.0=Недопустимое имя параметра\: ''{0}''
change.info.dialog.no.function.name.specified=Не указано имя функции
change.info.dialog.parameter.after.variadic.should.have.nonempty.name=Параметр после вариативного должен иметь непустое имя
change.info.dialog.rethrows.should.have.throwing.parameter=Функция с 'rethrows' должна иметь throwing параметр-функцию
change.info.internal.name.label=Внутреннее имя\:
change.info.name.label=Имя\:
change.info.optional.label=Опциональный\:
change.info.options.label=Опции
change.info.return.type.label=Тип возвращаемого значения\:
change.info.type.label=Тип\:
change.signature.0.1.will.no.longer.be.visible.from.overriding.0.in.2.3={0} ''{1}'' больше не будет видим из переопределяющего {0} в {2} ''{3}''
change.signature.0.1.with.2.visibility.wont.be.accessible.from.3.4={0} ''{1}'' с видимостью "{2}" не будет доступен из {3} ''{4}''
change.signature.0.can.throw.but.thrown.errors.are.not.handled=''{0}'' может выбрасывать исключения, но они не обрабатываются
change.signature.0.is.async.but.not.awaited=''{0}'' ожидает вызова, но не помечен как async
change.signature.dialog.title=Изменить сигнатуру
change.signature.initializer.will.conflict.with.0.in.1.2=Инициализатор будет конфликтовать с {0} в {1} ''{2}''
change.signature.processed.elements.header=Элементы для изменения сигнатуры
change.signature.subscript.will.conflict.with.0.in.1.2=Сабскрипт будет конфликтовать с {0} в {1} ''{2}''
change.signature.target.not.found=Курсор должен находиться на функции, инициализаторе или сабскрипте
change.signature.title=Изменить сигнатуру
code.style.blank.lines.around.class=Вокруг объявлений типов\:
code.style.blank.lines.around.field=Вокруг свойств\:
code.style.blank.lines.around.field.in.protocol=Вокруг свойств в протоколе\:
code.style.blank.lines.around.method=Вокруг методов/функций\:
code.style.blank.lines.around.method.in.protocol=Вокруг методов/функций в протоколе\:
code.style.blank.lines.before.method.body=Перед телом метода/функции\:
code.style.code.generation.doc.comment.style=Предпочитать блочные (/** */) комментарии строчным (///)
code.style.code.generation.doc.comment.tag.delimiter=Разделитель элементов списка\:
code.style.code.generation.prefer.explicit.return=Предпочитать явный return [&R]
code.style.code.generation.prefer.void=Предпочитать Void вместо () [&V]
code.style.code.generation.tab.title=Генерация кода
code.style.indent.directives.as.code=Следовать отступам кода
code.style.indent.directives.children=Отступ для дочерних элементов
code.style.indent.group.title.directives=Директивы
code.style.indent.method.chain=Отступ для цепочки методов\:
code.style.indent.multiline.string.or.regex=Отступ для многострочных строк или регулярных выражений
code.style.spaces.after.argument.colon=После двоеточия в вызове метода/функции
code.style.spaces.after.dictionary.literal.colon=После двоеточия в литерале словаря 'key\:value'
code.style.spaces.after.dictionary.type.colon=После двоеточия в типе словаря
code.style.spaces.after.operator.in.function.declarations=Оператор в объявлении функции
code.style.spaces.after.semicolon=После точки с запятой
code.style.spaces.after.superclass.colon=После двоеточия в выражении наследования типа
code.style.spaces.after.type.colon=После двоеточия в аннотации типа
code.style.spaces.around.range.operators=Операторы диапазона (..., ..<)
code.style.spaces.attribute.parameters=Параметры атрибута
code.style.spaces.attribute.parentheses=Скобки атрибута
code.style.spaces.before.argument.colon=Перед двоеточием в вызове метода/функции
code.style.spaces.before.class.lbrace=Левая фигурная скобка объявления типа
code.style.spaces.before.dictionary.literal.colon=Перед двоеточием в литерале словаря 'key\:value'
code.style.spaces.before.dictionary.type.colon=Перед двоеточием в типе словаря
code.style.spaces.before.method.call.parentheses=Скобки вызова метода/функции
code.style.spaces.before.method.lbrace=Левая фигурная скобка метода/функции
code.style.spaces.before.method.parentheses=Скобки объявления метода/функции
code.style.spaces.before.semicolon=Перед точкой с запятой
code.style.spaces.before.superclass.colon=Перед двоеточием в выражении наследования типа
code.style.spaces.before.type.colon=Перед двоеточием в аннотации типа
code.style.spaces.closure.arrow=Стрелка замыкания (->)
code.style.spaces.equality.operator=Оператор равенства '\=\='
code.style.spaces.group.title.colon=Вокруг двоеточия
code.style.spaces.group.title.in.ternary=В тернарном операторе
code.style.spaces.shift.operators=Операторы сдвига (<<, >>)
code.style.spaces.within.empty.method.call.parentheses=Пустые скобки вызова метода/функции
code.style.spaces.within.empty.method.parentheses=Пустые скобки объявления метода/функции
code.style.spaces.within.literal.brackets=Квадратные скобки в литералах массивов и словарей
code.style.spaces.within.method.call.parentheses=Скобки вызова метода/функции
code.style.spaces.within.method.parentheses=Скобки объявления метода/функции
code.style.spaces.within.string.interpolations=Интерполяция строк
code.style.wrapping.align.in.columns=Выравнивать в колонках
code.style.wrapping.align.when.multiline=Выравнивать при переносе
code.style.wrapping.array.literal=Литералы массивов и словарей
code.style.wrapping.array.new.line.after.left.bracket=Новая строка после '['
code.style.wrapping.array.right.bracket.on.new.line=']' на новой строке
code.style.wrapping.brace.placement.class.declaration=В объявлении типа
code.style.wrapping.classes.annotation=Атрибуты типов
code.style.wrapping.closure.signature.on.next.line=Параметры на новой строке при переносе
code.style.wrapping.fields.annotation=Атрибуты свойств
code.style.wrapping.group.title.closure=Замыкания
code.style.wrapping.group.title.condition.clauses=Условные выражения
code.style.wrapping.group.title.do.while=Выражение 'repeat … while'
code.style.wrapping.group.title.guard=Выражение 'guard'
code.style.wrapping.group.title.if=Выражение 'if'
code.style.wrapping.group.title.method.arguments=Аргументы вызова метода/функции
code.style.wrapping.group.title.method.parameters=Параметры объявления метода/функции
code.style.wrapping.group.title.superclass.list=Список базовых классов и реализуемых протоколов
code.style.wrapping.group.title.ternary=Тернарный оператор
code.style.wrapping.group.title.try=Выражение 'do'
code.style.wrapping.group.title.variable.groups=Группы переменных
code.style.wrapping.guard.else='else'
code.style.wrapping.guard.else.always=Всегда с новой строки
code.style.wrapping.guard.else.never=Никогда с новой строки
code.style.wrapping.guard.else.wrapped=С новой строки при переносе
code.style.wrapping.keep.control.statement.in.one.line=Управляющие конструкции на одной строке
code.style.wrapping.keep.simple.argument.blocks.in.one.line=Аргументы-замыкания на одной строке
code.style.wrapping.keep.simple.blocks.in.one.line=Блоки и (trailing) замыкания на одной строке
code.style.wrapping.keep.simple.methods.in.one.line=Методы и функции на одной строке
code.style.wrapping.local.variables.annotation=Атрибуты локальных переменных
code.style.wrapping.method.brace.placement=В методах и функциях
code.style.wrapping.method.chain.dot.on.new.line='.' на новой строке
code.style.wrapping.methods.annotation=Атрибуты методов
code.style.wrapping.parameters.annotation=Атрибуты параметров
code.style.wrapping.structures.in.one.line=Пустые объявления типов на одной строке
color.conditionally.not.compiled=Ключевые слова и директивы//Условно не скомпилированный код
color.settings.actor=Типы//Actor
color.settings.anonymous.closure.parameter=Идентификаторы//Анонимный параметр замыкания
color.settings.argument.label=Идентификаторы//Метка аргумента
color.settings.associated.type=Типы//Ассоциированный тип
color.settings.attribute.argument=Атрибуты//Аргумент атрибута
color.settings.attribute.name=Атрибуты//Имя атрибута
color.settings.class=Типы//Класс
color.settings.colon=Скобки и операторы//Двоеточие
color.settings.directive=Ключевые слова и директивы//Директива
color.settings.directive.condition=Ключевые слова и директивы//Условие директивы
color.settings.directive.flag=Ключевые слова и директивы//Флаг директивы
color.settings.enum.case.value=Идентификаторы//Значение case перечисления
color.settings.external.parameter.name=Идентификаторы//Внешнее имя параметра
color.settings.function.and.method.call=Функции//Вызов функции и метода
color.settings.function.and.method.declaration=Функции//Объявление функции и метода
color.settings.inline.closure.parameter=Идентификаторы//Параметр встроенного замыкания
color.settings.inline.hints.error.hint=Встроенные подсказки//Подсказка об ошибке
color.settings.inline.hints.type.hint=Встроенные подсказки//Подсказка типа
color.settings.keyword=Ключевые слова и директивы//Ключевое слово
color.settings.module.name=Типы//Имя модуля
color.settings.nested.function.call=Функции//Вызов вложенной функции
color.settings.nested.function.declaration=Функции//Объявление вложенной функции
color.settings.operator.sign=Скобки и операторы//Оператор
color.settings.property=Идентификаторы//Свойство
color.settings.protocol=Типы//Протокол
color.settings.self.and.super.keywords=Ключевые слова и директивы//'self' и 'super'
color.settings.struct.and.enum=Типы//Структура и перечисление
color.settings.tuple.label=Идентификаторы//Метка кортежа
color.settings.tuple.type.label=Идентификаторы//Метка типа кортежа
color.settings.type.alias=Типы//Псевдоним типа
color.settings.type.parameter=Типы//Параметр обобщения
color.settings.wildcard=Идентификаторы//Wildcard
command.name.extract.function=Извлечь функцию
context.declaration=Объявление
context.statement=Выражение
create.file.action=Создать Swift файл {0}
create.file.description=Создать новый Swift файл
create.file.dialog.title=Новый Swift файл
create.file.kind=Вид [&K]\:
create.file.kind.file=Файл
create.file.title=Swift файл
create.file.type.description=Создать новый Swift тип
create.file.type.dialog.title=Новый Swift тип
create.file.type.dialog.title.with.kind=Новый Swift {0}
create.file.type.title=Swift тип
create.from.usage.choose.target.type=Выберите целевой тип
create.from.usage.create.function.command=Создать функцию из использования
create.from.usage.create.init.command=Создать инициализатор из использования
create.from.usage.create.type.command=Создать новый Swift тип
create.from.usage.create.variable.command=Создать переменную из использования
create.from.usage.location.in=(в {0})
create.from.usage.location.new.file=Новый файл
create.from.usage.location.this.file=Этот файл
doc.comments.enable.markdown=Включите плагин Markdown для форматования документирующих комментариев
editor.appearance.error.hints=Показывать подсказки об ошибках Swift
editor.appearance.type.hints=Показывать подсказки типов Swift
error.cannot.perform.refactoring=Невозможно выполнить рефакторинг
error.no.expression.found=Выражение не найдено
extract.method.0.1.will.be.shadowed.by.2.1={0} ''{1}'' будет затенен {2} ''{1}''
extract.method.at.least.two.parameters.have.name.0=Как минимум два параметра имеют имя ''{0}''
extract.method.cannot.extract.mutable.value=Невозможно извлечь изменяемое значение
extract.method.error.cannot.determine.expr.type=Невозможно определить тип выбранного выражения
extract.method.error.cannot.determine.function.result.type=Невозможно определить тип результата функции
extract.method.error.cannot.determine.parameters.type=Невозможно определить типы параметров
extract.method.error.cannot.extract.expr.with.var.declarations=Невозможно извлечь выражение, содержащее объявления переменных
extract.method.error.cannot.extract.with.returns=Невозможно извлечь функцию с инструкциями return внутри фрагмента кода
extract.method.error.fragment.should.be.inside.code.block=Выбранный фрагмент должен находиться внутри блока кода
extract.method.error.multiple.exit.points=Выбранный фрагмент имеет несколько точек выхода
extract.method.error.result.builder.block=Невозможно извлечь функцию из замыкания result builder
extract.method.error.should.represent.expr.or.statements=Выбранный блок должен представлять набор выражений или инструкций
extract.method.function.0.will.conflict.with.1.2=Функция ''{0}'' будет конфликтовать с {1} {2}
extract.method.method.0.will.conflict.with.1.in.2.3=Метод ''{0}'' будет конфликтовать с {1} в {2} ''{3}''
extract.method.title.closure=Извлечь замыкание
extract.method.title.function=Извлечь функцию
extract.method.title.method=Извлечь метод
extract.method.variable.0.will.no.longer.be.accessible=Переменная ''{0}'' станет недоступной после рефакторинга
find.usages.base.member.warning.message.default.implementation.method={0} является реализацией по умолчанию для метода, объявленного в {1}\n\nИскать использования {3,choice,1\#метода|2\#методов} протокола?
find.usages.base.member.warning.message.default.implementation.property={0} является реализацией по умолчанию для свойства, объявленного в {1}\n\nИскать использования {3,choice,1\#свойства|2\#свойств} протокола?
find.usages.base.member.warning.message.default.implementation.subscript={0} является реализацией по умолчанию для сабскрипта, объявленного в {1}\n\nИскать использования {3,choice,1\#сабскрипта|2\#сабскриптов} протокола?
find.usages.base.member.warning.message.implements.method={0} реализует метод, объявленный в {1}\n\nИскать использования {3,choice,1\#метода|2\#методов} протокола?
find.usages.base.member.warning.message.implements.property={0} реализует свойство, объявленное в {1}\n\nИскать использования {3,choice,1\#свойства|2\#свойств} протокола?
find.usages.base.member.warning.message.implements.subscript={0} реализует сабскрипт, объявленный в {1}\n\nИскать использования {3,choice,1\#сабскрипта|2\#сабскриптов} протокола?
find.usages.base.member.warning.message.override.implemented.method={0} переопределяет метод, объявленный в {2}, и реализует метод, объявленный в {1}\n\nИскать использования {3,choice,1\#метода|2\#методов} базового класса и протокола?
find.usages.base.member.warning.message.override.implemented.property={0} переопределяет свойство, объявленное в {2}, и реализует свойство, объявленное в {1}\n\nИскать использования {3,choice,1\#свойства|2\#свойств} базового класса и протокола?
find.usages.base.member.warning.message.override.implemented.subscript={0} переопределяет сабскрипт, объявленный в {2}, и реализует сабскрипт, объявленный в {1}\n\nИскать использования {3,choice,1\#сабскрипта|2\#сабскриптов} базового класса и протокола?
find.usages.base.member.warning.message.override.method={0} переопределяет метод, объявленный в {2}\n\nИскать использования {3,choice,1\#метода|2\#методов} базового класса?
find.usages.base.member.warning.message.override.property={0} переопределяет свойство, объявленное в {2}\n\nИскать использования {3,choice,1\#свойства|2\#свойств} базового класса?
find.usages.base.member.warning.message.override.subscript={0} переопределяет сабскрипт, объявленный в {2}\n\nИскать использования {3,choice,1\#сабскрипта|2\#сабскриптов} базового класса?
find.usages.base.member.warning.title=Предупреждение
find.usages.option.search.in.not.compiled.code=Показывать потенциальные использования в условно не скомпилированном коде
generate.0.title=Сгенерировать {0}
generate.cannot.generate.0.for.1=Невозможно сгенерировать {0} для {1}
generate.description.multi.string.template=Многострочная строка
generate.description.single.string.template=Одиночная строка
generate.description.string.concatenation.template=Несколько строк с конкатенацией (+)
generate.equals.hash=equals и hash
generate.equals.hash.choose.in.0=Выберите свойства для включения в {0}
generate.if.statements.equals.template=Несколько if-выражений
generate.init.choose.properties=Выберите свойства для инициализации
generate.init.choose.super.init=Выберите инициализатор суперкласса
generate.init.init.already.exists=Инициализатор уже существует
generate.method.0.and.operator.function.1.are.already.defined=Метод ''{0}'' и функция-оператор ''{1}'' уже определены. Удалить их и продолжить?
generate.method.0.and.property.1.are.already.defined=Метод ''{0}'' и свойство ''{1}'' уже определены. Удалить их и продолжить?
generate.method.0.is.already.defined=Метод ''{0}'' уже определен. Удалить его и продолжить?
generate.method.0.property.1.and.operator.function.2.are.already.defined=Метод ''{0}'', свойство ''{1}'' и функция-оператор ''{2}'' уже определены. Удалить их и продолжить?
generate.operator.function.0.is.already.defined=Функция-оператор ''{0}'' уже определена. Удалить её и продолжить?
generate.preparing.generation.title=Подготовка к генерации...
generate.property.0.and.operator.function.1.are.already.defined=Свойство ''{0}'' и функция-оператор ''{1}'' уже определены. Удалить их и продолжить?
generate.property.0.is.already.defined=Свойство ''{0}'' уже определено. Удалить его и продолжить?
generate.single.expression.equals.template=Одиночное выражение
generate.template.title=Шаблон [&T]\:
got.it.no.refactoring.in.not.compiled.code.header=Рефакторинг недоступен
got.it.no.refactoring.in.not.compiled.code.message=Рефакторинг недоступен в условно не скомпилированном коде. Переключитесь на другой контекст разбора, чтобы включить окружающую ветвь директивы `\#if`.
got.it.search.not.compiled.code.header=Использования в условно не скомпилированном коде
got.it.search.not.compiled.code.message=Поиск использований в условно не скомпилированном коде можно включить в диалоге переименования. Чтобы показать диалог переименования, нажмите {0} еще раз.
goto.base.type=Базовый тип
goto.class.kind=Тип
goto.class.kinds.title=Типы
goto.super.action=Выбрать {0}
goto.super.class=Класс или протокол
goto.super.extension.of.0=Расширение {0}
goto.super.location={0} (в {1})
goto.super.menu.action=Перейти к супер {0} [_U]
goto.super.typealias=Псевдоним типа или ассоциированный тип
inheritance.relation.implements=Реализует {0}
inheritance.relation.is.implemented=Реализуется
inheritance.relation.is.overridden=Переопределяется
inheritance.relation.is.subclassed=Наследуется
inheritance.relation.overrides=Переопределяет {0}
inline.0.action.1=Встраивание {0} {1}
inline.0.command.1=Встроить {0} {1}
inline.all.invocations.and.keep.the.0=Встроить все вызовы и сохранить {0} [&A]
inline.all.invocations.and.remove.the.0=Встроить все вызовы и удалить {0} [&A]
inline.all.references.and.keep.the.0=Встроить все ссылки и сохранить {0} [&A]
inline.all.references.and.remove.the.0=Встроить все ссылки и удалить {0} [&A]
inline.all.typealias.and.keep.the.0=Встроить все использования и сохранить {0} [&A]
inline.all.typealias.and.remove.the.0=Встроить все использования и удалить {0} [&A]
inline.error.cannot.access.symbol.0=Невозможно получить доступ к символу {0}
inline.error.cannot.resolve.symbol=Невозможно разрешить символ
inline.error.function.definition.contains.no.body=Определение функции не содержит тела
inline.error.function.no.return.statement=В функции отсутствует оператор return
inline.error.implements.function.from.0=Встраиваемый метод реализует метод из {0}
inline.error.inline.function.has.conditionally.compiled.code=Функция может быть встроена некорректно, так как содержит условно компилируемый код
inline.error.inline.function.only.in.swift.code=Встраивание функций поддерживается только в коде Swift
inline.error.inline.recursive.function.only.on.invocations=Встраивание рекурсивных функций поддерживается только для вызовов
inline.error.inline.typealias.has.conditionally.compiled.code=Псевдоним типа может быть встроен некорректно, так как содержит условно компилируемый код
inline.error.inline.variable.has.conditionally.compiled.code=Переменная может быть встроена некорректно, так как содержит условно компилируемый код
inline.error.inline.variable.no.single.definition=Не найдено единственное определение для встраивания
inline.error.inlined.expression.should.be.part.of.statement=Встраиваемое выражение должно быть частью инструкции
inline.error.invalid.function.arguments=Недопустимые аргументы функции
inline.error.is.overridden.by.function.from.0=Встраиваемый метод переопределяется методом из {0}
inline.error.not.function.call=Не является вызовом функции
inline.error.overrides.associated.type.from.0=Встраиваемый псевдоним типа переопределяет ассоциированный тип из {0}
inline.error.overrides.function.from.0=Встраиваемый метод переопределяет метод из {0}
inline.error.unexpected.error=Неожиданная ошибка при встраивании
inline.function.description=Заменить вызов функции её телом
inline.function.label.kind.0.name.1=Встроить {0} {1}\:
inline.function.label.kind.0.name.1.2.occurrences=Встроить {2} вызова(ов) {0} {1}\:
inline.function.label.kind.0.name.1.occurence=Встроить вызов {0} {1}\:
inline.include.doc.comments=Встраивать doc-комментарии
inline.recursively=Встраивать рекурсивно
inline.this.invocation.only.and.keep.the.0=Встроить только этот вызов и сохранить {0}
inline.this.reference.only.and.keep.the.0=Встроить только эту ссылку и сохранить {0}
inline.this.typealias.only.and.keep.the.0=Встроить только это использование и сохранить {0}
inline.title.0=Встроить {0}
inline.typealias.label.kind.0.name.1=Встроить {0} {1}\:
inline.typealias.label.kind.0.name.1.2.occurrences=Встроить {2} использования(й) {0} {1}\:
inline.typealias.label.kind.0.name.1.occurence=Встроить использование {0} {1}\:
inline.variable.label.kind.0.name.1=Встроить {0} {1}\:
inline.variable.label.kind.0.name.1.2.occurrences=Встроить {2} ссылки(ок) на {0} {1}\:
inline.variable.label.kind.0.name.1.occurence=Встроить ссылку на {0} {1}\:
inspection.conditionally.not.compiled.code=Условно не скомпилированный код
inspection.missing.doc.comment.parameter.item=Несоответствие doc-комментария и сигнатуры функции
inspection.missing.doc.comment.parameter.item.error=Параметр {0} не описан в doc-комментарии
inspection.missing.doc.comment.parameter.item.fix=Обновить doc-комментарий
inspection.missing.localization=Отсутствует локализация
inspection.missing.localization.all.languages.only=Сообщать только о локализациях, отсутствующих во всех языках
inspection.redundant.attribute=Избыточный атрибут
inspection.redundant.attribute.error=''@{0}'' избыточен
inspection.redundant.attribute.fix=Удалить избыточный ''@{0}''
inspection.redundant.closure=Избыточное замыкание
inspection.redundant.closure.error=Избыточное создание замыкания
inspection.redundant.closure.fix=Встроить тело
inspection.redundant.nullable.function.type.error=''{0}'' всегда возвращает non-null тип
inspection.redundant.nullable.type=Избыточный nullable тип
inspection.redundant.nullable.type.error=''{0}'' всегда non-null
inspection.redundant.nullable.type.fix=Удалить избыточный '?'
inspection.redundant.return=Избыточный 'return'
inspection.redundant.return.error='return' избыточен
inspection.redundant.return.fix=Удалить избыточный 'return'
inspection.unnecessary.argument.list=Пустые скобки аргументов перед замыканием
inspection.unnecessary.argument.list.error=Скобки аргументов не нужны
inspection.unnecessary.argument.list.fix=Удалить ненужные скобки аргументов
inspection.unnecessary.parentheses=Ненужные скобки
inspection.unnecessary.parentheses.error=Скобки не нужны
inspection.unnecessary.parentheses.fix=Удалить ненужные скобки
inspection.unnecessary.self=Ненужный 'self'
inspection.unnecessary.self.error='self' не нужен
inspection.unnecessary.self.fix=Удалить ненужный 'self'
inspection.unnecessary.tuple.wrap=Ненужная обертка кортежа
inspection.unnecessary.tuple.wrap.error=Одноэлементный кортеж может быть заменен типом
inspection.unnecessary.tuple.wrap.fix=Заменить одноэлементный кортеж типом
intention.access.control.error.access=Невозможно получить доступ к {0}\: он {1} в {2}
intention.access.control.error.access.dynamic=Невозможно получить доступ к {0}\: динамический сабскрипт члена {1} в {2}
intention.access.control.error.override=Невозможно переопределить {0}\: он {1} в {2}
intention.access.control.fix=Сделать {0} {1} в {2}
intention.access.control.remove.setter=Удалить {1} из {0}
intention.add.catch.clause=Добавить 'catch'
intention.add.default.catch.clause=Добавить блок 'catch' по умолчанию
intention.add.digit.separators=Добавить разделители цифр
intention.add.explicit.qualifier=Добавить явный квалификатор
intention.add.explicit.type=Добавить явный тип
intention.add.try.to.expression=Добавить 'try' к выражению
intention.add.try.to.iteration=Добавить 'try' к итерации
intention.category.swift=Swift
intention.convert.to.binary=Преобразовать в двоичную систему
intention.convert.to.closure.argument=Преобразовать в аргумент-замыкание
intention.convert.to.decimal=Преобразовать в десятичную систему
intention.convert.to.hex=Преобразовать в шестнадцатеричную систему
intention.convert.to.multiline.string=Преобразовать в многострочный литерал
intention.convert.to.octal=Преобразовать в восьмеричную систему
intention.convert.to.string=Преобразовать в однострочный строковый литерал
intention.convert.to.trailing.closure=Преобразовать в замыкающее замыкание
intention.create.actor.0=Создать actor ''{0}''
intention.create.actor.0.in.new.file=Создать actor ''{0}'' в новом файле
intention.create.actor.0.nested.in.1=Создать вложенный actor ''{0}'' в ''{1}''
intention.create.class.0=Создать класс ''{0}''
intention.create.class.0.in.new.file=Создать класс ''{0}'' в новом файле
intention.create.class.0.nested.in.1=Создать вложенный класс ''{0}'' в ''{1}''
intention.create.enum.0=Создать перечисление ''{0}''
intention.create.enum.0.in.new.file=Создать перечисление ''{0}'' в новом файле
intention.create.enum.0.nested.in.1=Создать вложенное перечисление ''{0}'' в ''{1}''
intention.create.enum.case.0=Создать case перечисления ''{0}''
intention.create.global.function.0=Создать глобальную функцию ''{0}''
intention.create.global.variable.0=Создать глобальную переменную ''{0}''
intention.create.initializer=Создать инициализатор
intention.create.local.variable.0=Создать локальную переменную ''{0}''
intention.create.method.0=Создать метод ''{0}''
intention.create.method.0.in.extension=Создать метод расширения ''{0}''
intention.create.new.swift.declaration=Создать новое объявление Swift
intention.create.new.swift.type.in.a.new.file=Создать новый тип Swift в новом файле
intention.create.property.0=Создать свойство ''{0}''
intention.create.property.0.in.extension=Создать свойство расширения ''{0}''
intention.create.protocol.0=Создать протокол ''{0}''
intention.create.protocol.0.in.new.file=Создать протокол ''{0}'' в новом файле
intention.create.protocol.0.nested.in.1=Создать вложенный протокол ''{0}'' в ''{1}''
intention.create.struct.0=Создать структуру ''{0}''
intention.create.struct.0.in.new.file=Создать структуру ''{0}'' в новом файле
intention.create.struct.0.nested.in.1=Создать вложенную структуру ''{0}'' в ''{1}''
intention.create.type.0=Создать тип ''{0}''
intention.create.type.0.in.new.file=Создать тип ''{0}'' в новом файле
intention.create.type.0.nested.in.1=Создать вложенный тип ''{0}'' в ''{1}''
intention.create.type.method.0=Создать статический метод ''{0}''
intention.create.type.method.0.in.extension=Создать статический метод расширения ''{0}''
intention.create.type.property.0=Создать статическое свойство ''{0}''
intention.create.type.property.0.in.extension=Создать статическое свойство расширения ''{0}''
intention.decrease.string.escape.level=Понизить уровень экранирования строки
intention.demorgans.law=Закон де Моргана
intention.demorgans.law.format=Заменить ''{0}'' на ''{1}''
intention.extract.class.0.to.extension=Извлечь класс ''{0}'' в расширение
intention.extract.class.0.to.type.declaration=Извлечь класс ''{0}'' в объявление типа
intention.extract.conformance.to.extension.cannot.add.protocol.conformance.to.protocol=Расширение протокола не может соответствовать другим протоколам
intention.extract.conformance.to.extension.cannot.extract.class=Невозможно извлечь наследование класса ''{0}'' в расширение
intention.extract.conformance.to.extension.familyName=Извлечь соответствие в расширение
intention.extract.conformance.to.extension.type.cannot.be.local=Невозможно создать расширение в локальной области видимости
intention.extract.conformance.to.extension.type.must.be.fileprivate=Тип должен быть как минимум fileprivate
intention.extract.enum.0.to.extension=Вынести enum ''{0}'' в расширение
intention.extract.enum.0.to.type.declaration=Вынести enum ''{0}'' в объявление типа
intention.extract.from.extension.to.type.declaration.error.message.title=Вынести члены в исходное объявление типа
intention.extract.from.extension.to.type.declaration.familyName=Вынести члены в исходное объявление типа
intention.extract.from.extension.to.type.declaration.original.analysis.on.type.not.allowed=Исходное объявление типа вне области видимости
intention.extract.from.extension.to.type.declaration.original.type.not.found=Исходное объявление типа не найдено
intention.extract.function.0.to.extension=Вынести функцию ''{0}'' в расширение
intention.extract.function.0.to.type.declaration=Вынести функцию ''{0}'' в объявление типа
intention.extract.initializer.to.extension=Вынести инициализатор в расширение
intention.extract.initializer.to.type.declaration=Вынести инициализатор в объявление типа
intention.extract.member.to.extension.cannot.extract.from.protocol=Невозможно вынести из протокола
intention.extract.member.to.extension.type.cannot.be.local=Невозможно создать расширение в локальной области видимости
intention.extract.member.to.extension.type.must.be.fileprivate=Тип должен быть как минимум fileprivate
intention.extract.members.to.extension.error.message.title=Вынести члены в расширение
intention.extract.members.to.extension.familyName=Вынести члены в расширение
intention.extract.multiple.members.to.extension=Вынести члены в расширение
intention.extract.multiple.members.to.type.declaration=Вынести члены в объявление типа
intention.extract.property.0.to.extension=Вынести свойство ''{0}'' в расширение
intention.extract.property.0.to.type.declaration=Вынести свойство ''{0}'' в объявление типа
intention.extract.struct.0.to.extension=Вынести структуру ''{0}'' в расширение
intention.extract.struct.0.to.type.declaration=Вынести структуру ''{0}'' в объявление типа
intention.extract.subscript.to.extension=Вынести сабскрипт в расширение
intention.extract.subscript.to.type.declaration=Вынести сабскрипт в объявление типа
intention.extract.typealias.0.to.extension=Вынести typealias ''{0}'' в расширение
intention.extract.typealias.0.to.type.declaration=Вынести typealias ''{0}'' в объявление типа
intention.flip.binary.expression=Инвертировать бинарное выражение
intention.flip.binary.expression.format=Инвертировать ''{0}''
intention.flip.comparison=Инвертировать сравнение
intention.flip.comparison.format=Инвертировать ''{0}'' в ''{1}''
intention.generate.documentation.comment=Добавить документационный комментарий
intention.implement.equals=Реализовать отсутствующий equals
intention.implement.hash=Реализовать отсутствующий hash
intention.implement.members.error=Тип {0} не соответствует {1} {2}
intention.implement.members.implement.missing=Реализовать {0} отсутствующих {0, choice,1\#член|2\#членов}
intention.implement.missing.equals.hash=Реализовать отсутствующие equals и hash
intention.increase.string.escape.level=Повысить уровень экранирования строки
intention.invert.if.statement=Инвертировать оператор 'if'
intention.join.declaration.and.assignment=Объединить объявление и присваивание
intention.localize.string=Локализовать строку
intention.localize.string.title.case=Локализовать строку
intention.mark.the.enclosing.function.as.throws=Добавить 'throws' к сигнатуре функции
intention.merge.conditions=Объединить условия
intention.merge.else.if=Объединить 'else if'
intention.merge.nested.if=Объединить вложенные 'if'
intention.negate.comparison=Инвертировать сравнение
intention.negate.comparison.format=Инвертировать ''{0}'' в ''{1}''
intention.remove.digit.separators=Удалить разделители цифр
intention.remove.explicit.type=Удалить явный тип
intention.replace.guard.with.if=Заменить 'guard' на 'if'
intention.replace.if.with.guard=Заменить 'if' на 'guard'
intention.replace.rethrows.with.throws=Заменить 'rethrows' на 'throws'
intention.simplifyifelse.collapse.conditional.expression=Свернуть условное выражение
intention.simplifyifelse.collapse.guard=Свернуть 'guard'
intention.simplifyifelse.collapse.ifelse=Свернуть 'if else'
intention.simplifyifelse.familyName=Упростить if-else
intention.simplifyifelse.replace.guard.with.0=Заменить ''guard'' на ''{0}''
intention.simplifyifelse.replace.if.else.with.0=Заменить ''if else'' на ''{0}''
intention.simplifyifelse.simplify=Упростить
intention.simplifyifelse.simplify.guard=Упростить 'guard'
intention.simplifyifelse.simplify.if.else=Упростить 'if else'
intention.split.condition=Разделить на отдельные условия
intention.split.declaration.and.assignment=Разделить на объявление и присваивание
intention.split.else.if=Разделить 'else if'
intention.split.into.separate.declarations=Разделить на отдельные объявления
intention.split.nested.if=Разделить на вложенные 'if'
intention.suppress.call.error.with.try=Подавить ошибку с помощью 'try\!'
intention.surround.with.do.catch=Обернуть в 'do/catch'
intention.swift.module.info=Показать информацию о модуле
intention.switch.resolve.configuration.specified=Переключить на ''{0}'', сделав эту ветку действительной
intention.unresolved.reference.0.1=Импортовать {0} ''{1}''
intention.unwrap.with.guard.let=Развернуть с помощью 'guard let'
intention.unwrap.with.if.let=Развернуть с помощью 'if let'
intention.wrong.return.type.fix=Исправить возвращаемый тип функции
intention.wrong.return.type.fix.with.types=Сделать ''{0}'' возвращающим ''{1}''
introduce.variable.declare.with.var=Объявить с помощью var [&V]
introduce.variable.expression.will.be.ambiguous.without.explicit.type=Выражение будет неоднозначным<br/>без явного типа
introduce.variable.specify.type.explicitly=Указать тип явно [&T]
notification.group.plugin.errors=Сбой Swift Language Service
optimize.imports.rearranged.imports=Переупорядоченные импорты
optimize.imports.removed.0.added.1.imports=Удалено {0} {0,choice,0\#импортов|1\#импорт|1<импортов}, добавлено {1} {1,choice,0\#импортов|1\#импорт|1<импортов}
optimize.imports.removed.0.imports=Удалено {0} {0,choice,0\#импортов|1\#импорт|1<импортов}
override.implement.elements.to.implement.chooser.title=Выберите члены для реализации
override.implement.elements.to.override.chooser.title=Выберите члены для переопределения
override.implement.elements.to.override.implement.chooser.title=Выберите члены для переопределения/реализации
override.implement.implement.not.allowed=Реализация невозможна
override.implement.nothing.to.implement=Нечего реализовывать
override.implement.nothing.to.override=Нечего переопределять
override.implement.override.not.allowed=Переопределение невозможно
override.implement.progress=Обработка членов для переопределения/реализации...
override.implement.show.members.to.implement.title=Показать члены для реализации
override.implement.show.no.optional.members=Показать опциональные члены (нет опциональных)
override.implement.show.only.optional.members=Показать опциональные члены (только опциональные)
override.implement.show.optional.member=Показать 1 опциональный член [&O]
override.implement.show.optional.members=Показать {0} опциональных членов [&O]
refactor.0.overrides.associated.type.of.1={0} переопределяет ассоциированный тип {1}
refactor.0.overrides.declaration.in.1={0} переопределяет объявление в {1}
refactor.0.overrides.initializer.of.1={0} переопределяет инициализатор {1}
refactor.0.overrides.method.of.1={0} переопределяет метод {1}
refactor.0.overrides.property.of.1={0} переопределяет свойство {1}
refactor.0.overrides.subscript.of.1={0} переопределяет сабскрипт {1}
refactor.base.declaration=Рефакторинг базовых {0,choice,1\#объявления|2\#объявлений}
refactor.only.current.declaration=Рефакторинг только текущего объявления
refactoring.option.search.in.not.compiled.code=Применить к условно не скомпилированному коду
rename.containing.file.dialog.description=Переименовать содержащий файл в\:
rename.containing.file.dialog.title=Переименовать содержащий файл
rename.containing.file.entity.name=Include файл
rename.error.dynamic.called.values=Невозможно переименовать динамически вызываемые значения
rename.error.message.renaming.swift.member.elements.in.objective.c.code.is.not.supported=Переименование элементов Swift в коде Objective-C не поддерживается
rename.error.title=Swift - Переименование
rename.inheritor.entity.name=Наследник
rename.inheritors=Переименовать наследников
rename.inheritors.to=Переименовать наследников в\:
rename.init.is.not.supported=Переименование инициализаторов Swift не поддерживается
rename.related.dialog.description=Переименовать связанные объявления в\:
rename.related.dialog.title=Переименовать связанные объявления
rename.related.entity.name=Связанное объявление
rename.self.is.not.supported=Переименование self-параметра не поддерживается
rename.title=Переименование Swift
searching.for.implementations=Поиск реализаций...
searching.for.overriders=Поиск переопределений...
searching.for.subclasses=Поиск подклассов...
sourcekit.fix.it=Применить Fix-it
sourcekit.inspections=Проверки SourceKit
swift-format.dump.progress=Создание конфигурационного файла '.swift-format' по умолчанию
swift-format.format.progress=Форматование {0} с помощью Swift-Format
swift.name=Swift
syntax.error.call.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=Вызов может выбросить исключение, но выполняется в non-throwing autoclosure
syntax.error.call.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=Вызов может выбросить исключение, но не помечен 'try' и выполняется в non-throwing autoclosure
syntax.error.call.can.throw.in.default.argument=Вызов может выбросить исключение, но исключения нельзя выбрасывать из аргумента по умолчанию
syntax.error.call.can.throw.in.property.initializer=Вызов может выбросить исключение, но исключения нельзя выбрасывать из инициализатора свойства
syntax.error.call.can.throw.not.marked.with.try=Вызов может выбросить исключение, но не помечен 'try'
syntax.error.call.can.throw.not.marked.with.try.not.exhaustive=Вызов может выбросить исключение, но не помечен 'try', и окружающий catch не исчерпывающий
syntax.error.call.can.throw.not.marked.with.try.not.handled=Вызов может выбросить исключение, но не помечен 'try', и исключение не обработано
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.handled=Вызов может выбросить исключение, но исключение не обработано; функция, объявленная как 'rethrows', может выбрасывать исключения только когда выбрасывают её параметры
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=Вызов может выбросить исключение, но не помечен 'try', исключение не обработано; функция, объявленная как 'rethrows', может выбрасывать исключения только когда выбрасывают её параметры
syntax.error.duplicate.platform=Платформа ''{0}'' уже указана
syntax.error.error.is.not.handled=Исключение не обработано, так как окружающая функция не объявлена как 'throws'
syntax.error.error.is.not.handled.not.exhaustive=Исключение не обработано, так как окружающий catch не исчерпывающий
syntax.error.errors.are.not.handled=Исключения, выброшенные отсюда, не обработаны
syntax.error.errors.are.not.handled.not.exhaustive=Исключения, выброшенные отсюда, не обработаны, так как окружающий catch не исчерпывающий
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.file=Строка hashbang разрешена только в первой строке файла
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.main.file=Строка hashbang разрешена только в первой строке основного файла
syntax.error.hashbang.line.is.allowed.only.in.the.main.file=Строка hashbang разрешена только в основном файле
syntax.error.interpolation.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=Интерполяция может выбросить исключение, но выполняется в non-throwing autoclosure
syntax.error.interpolation.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=Интерполяция может выбросить исключение, но не помечена 'try' и выполняется в non-throwing autoclosure
syntax.error.interpolation.can.throw.in.default.argument=Интерполяция может выбросить исключение, но исключения нельзя выбрасывать из аргумента по умолчанию
syntax.error.interpolation.can.throw.in.property.initializer=Интерполяция может выбросить исключение, но исключения нельзя выбрасывать из инициализатора свойства
syntax.error.interpolation.can.throw.not.marked.with.try=Интерполяция может выбросить исключение, но не помечена 'try'
syntax.error.interpolation.can.throw.not.marked.with.try.not.exhaustive=Интерполяция может выбросить исключение, но не помечена 'try', и окружающий catch не исчерпывающий
syntax.error.interpolation.can.throw.not.marked.with.try.not.handled=Интерполяция может выбросить исключение, но не помечена 'try', и исключение не обработано
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.handled=Интерполяция может выбросить исключение, но исключение не обработано; функция, объявленная как 'rethrows', может выбрасывать исключения только когда выбрасывают её параметры
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=Интерполяция может выбросить исключение, но не помечена 'try', исключение не обработано; функция, объявленная как 'rethrows', может выбрасывать исключения только когда выбрасывают её параметры
syntax.error.iteration.can.throw.not.marked.with.try=Итерация может выбросить исключение, но не помечена 'try'
syntax.error.iteration.can.throw.not.marked.with.try.not.exhaustive=Итерация может выбросить исключение, но не помечена 'try', и окружающий catch не исчерпывающий
syntax.error.iteration.can.throw.not.marked.with.try.not.handled=Итерация может выбросить исключение, но не помечена 'try', и исключение не обработано
syntax.error.operator.can.throw.not.marked.with.try=Оператор может выбросить исключение, но выражение не помечено 'try'
syntax.error.property.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=Доступ к свойству может выбросить исключение, но выполняется в non-throwing autoclosure
syntax.error.property.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=Доступ к свойству может выбросить исключение, но не помечен 'try' и выполняется в non-throwing autoclosure
syntax.error.property.can.throw.in.default.argument=Доступ к свойству может выбросить исключение, но исключения нельзя выбрасывать из аргумента по умолчанию
syntax.error.property.can.throw.in.property.initializer=Доступ к свойству может выбросить исключение, но исключения нельзя выбрасывать из инициализатора свойства
syntax.error.property.can.throw.not.marked.with.try=Доступ к свойству может выбросить исключение, но не помечен 'try'
syntax.error.property.can.throw.not.marked.with.try.not.exhaustive=Доступ к свойству может выбросить исключение, но не помечен 'try', и окружающий catch не исчерпывающий
syntax.error.property.can.throw.not.marked.with.try.not.handled=Доступ к свойству может выбросить исключение, но не помечен 'try', и исключение не обработано
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.handled=Доступ к свойству может выбросить исключение, но исключение не обработано; функция, объявленная как 'rethrows', может выбрасывать исключения только когда выбрасывают её параметры
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=Доступ к свойству может выбросить исключение, но не помечен 'try', исключение не обработано; функция, объявленная как 'rethrows', может выбрасывать исключения только когда выбрасывают её параметры
syntax.error.rethrows.function.can.only.throw.parameter.call=Функция, объявленная как 'rethrows', может выбрасывать исключения только когда выбрасывают её параметры
syntax.error.rethrows.function.must.take.a.throwing.function.argument=Функция 'rethrows' должна принимать throwing функцию в качестве аргумента
syntax.error.rethrows.is.not.allowed.in.closures='rethrows' не разрешено в замыканиях
syntax.error.rethrows.is.not.allowed.in.function.type.elements=Только объявления функций могут быть помечены как 'rethrows'
syntax.error.rethrows.is.not.allowed.in.subscripts='rethrows' не разрешено в сабскриптах
syntax.error.subscript.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=Доступ к сабскрипту может выбросить исключение, но выполняется в non-throwing autoclosure
syntax.error.subscript.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=Доступ к сабскрипту может выбросить исключение, но не помечен 'try' и выполняется в non-throwing autoclosure
syntax.error.subscript.can.throw.in.default.argument=Доступ к сабскрипту может выбросить исключение, но исключения нельзя выбрасывать из аргумента по умолчанию
syntax.error.subscript.can.throw.in.property.initializer=Доступ к сабскрипту может выбросить исключение, но исключения нельзя выбрасывать из инициализатора свойства
syntax.error.subscript.can.throw.not.marked.with.try=Доступ к сабскрипту может выбросить исключение, но не помечен 'try'
syntax.error.subscript.can.throw.not.marked.with.try.not.exhaustive=Доступ к сабскрипту может выбросить исключение, но не помечен 'try', и окружающий catch не исчерпывающий
syntax.error.subscript.can.throw.not.marked.with.try.not.handled=Доступ к сабскрипту может выбросить исключение, но не помечен 'try', и исключение не обработано
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.handled=Доступ к сабскрипту может выбросить исключение, но исключение не обработано; функция, объявленная как 'rethrows', может выбрасывать исключения только когда выбрасывают её параметры
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=Доступ к сабскрипту может выбросить исключение, но не помечен 'try', исключение не обработано; функция, объявленная как 'rethrows', может выбрасывать исключения только когда выбрасывают её параметры
syntax.error.thrown.expression.type.0.does.not.conform.to.ErrorType=Тип выброшенного выражения ''{0}'' не соответствует ''{1}''
syntax.error.throws.is.not.allowed.in.subscripts='throws' не разрешено в сабскриптах
syntax.error.try.cannot.appear.to.the.right='try' не может появляться справа от оператора, не являющегося присваиванием
syntax.error.try.cannot.appear.to.the.right.fix=Переместить 'try' влево
syntax.error.typealias.without.assignment=В объявлении typealias отсутствует присваивание
syntax.error.unrecognized.platform.name.0=Неизвестное имя платформы ''{0}''
syntax.error.variable.declaration.with.multiple.variables.cannot.have.explicit.getters.setters=Объявление 'var' с несколькими переменными не может иметь явные геттеры/сеттеры
syntax.error.variable.declaration.with.multiple.variables.cannot.have.implicit.getter.clause=Объявление 'var' с несколькими переменными не может иметь неявное выражение геттера
syntax.error.variable.declaration.with.multiple.variables.cannot.have.willset.didset.clause=Объявление 'var' с несколькими переменными не может иметь выражения willSet/didSet
usage.type.argument.label=Метка аргумента
usage.type.conditionally.not.compiled=Потенциальное использование в условно не скомпилированном коде
usage.type.extension=Расширение
usage.type.function.declaration=Объявление функции
usage.type.key.path=Выражение ключевого пути
usage.type.operator.declaration=Объявление оператора
usage.type.precedence.group.declaration=Объявление группы приоритета
usage.type.raw.value=Raw value
usage.type.requirement=Использование в требовании
usage.type.type.alias=Псевдоним типа
usage.type.type.parameter=Параметр типа