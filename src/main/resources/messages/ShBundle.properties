0.is.true.use.false.instead='[ 0 ]' истинно. Используйте 'false'.
action.ShGenerateForLoop.description=Создает for-цикл
action.ShGenerateForLoop.text=For-цикл
action.ShGenerateUntilLoop.description=Создает until-цикл
action.ShGenerateUntilLoop.text=Until-цикл
action.ShGenerateWhileLoop.description=Создает while-цикл
action.ShGenerateWhileLoop.text=While-цикл
action.runShellFileAction.description=Запустить текущий shell-файл в терминале
action.runShellFileAction.text=Запустить файл
add.dev.null.to.prevent.ssh.from.swallowing.stdin=Добавьте '< /dev/null' чтобы предотвратить поглощение stdin через ssh.
aliases.can.t.use.positional.parameters.use.a.function=Алиасы не могут использовать позиционные параметры. Используйте функцию.
argument.mixes.string.and.array.use.or.separate.argument=Аргумент смешивает строку и массив. Используйте '*' или отдельный аргумент.
argument.to.implicit.n.is.always.true.due.to.literal.strings=Аргумент для неявного '-n' всегда истинен из-за литеральных строк.
arrays.don.t.work.as.operands.in.use.a.loop.or.concatenate.with.instead.of=Массивы не работают как операнды в '[ ]'. Используйте цикл (или конкатенируйте с '*' вместо '@').
arrays.implicitly.concatenate.in.use.a.loop.or.explicit.instead.of=Массивы неявно конкатенируются в `[[ ]]`. Используйте цикл (или явно '*' вместо '@').
ash.scripts.will.be.checked.as.dash.add.shellcheck.shell.dash.to.silence=Ash-скрипты будут проверяться как Dash. Добавьте '\# shellcheck shell\=dash' для подавления.
assigning.an.array.to.a.string.assign.as.array.or.use.instead.of.to.concatenate=Присваивание массива строке\! Присваивайте как массив или используйте '*' вместо '@' для конкатенации.
bash.does.not.support.multidimensional.arrays.use.1d.or.associative.arrays=Bash не поддерживает многомерные массивы. Используйте только одномерные или ассоциативные массивы.
bash.doesn.t.support.variables.in.brace.range.expansions=Bash не поддерживает переменные в диапазонах раскрытия фигурных скобок.
bin.sh.was.specified.so.is.not.supported.even.when.sh.is.actually.bash=Указан '\#\!/bin/sh', поэтому ____ не поддерживается, даже если sh на самом деле bash.
brace.expansion.doesn.t.happen.in.use.a.loop=Раскрытие фигурных скобок не происходит в `[[ ]]`. Используйте цикл.
brace.expansions.and.globs.are.literal.in.assignments.quote.it.or.use.an.array=Раскрытие фигурных скобок и глобы являются литералами в присваиваниях. Используйте кавычки или массив.
brace.expansions.don.t.work.as.operands.in.use.a.loop=Раскрытие фигурных скобок не работает как операнд в '[ ]'. Используйте цикл.
break.is.only.valid.in.loops=`break` допустим только в циклах.
can.only.exit.with.status.0.255.other.data.should.be.written.to.stdout.stderr=Можно выйти только со статусом 0-255. Другие данные должны быть записаны в stdout/stderr.
can.only.return.0.255.other.data.should.be.written.to.stdout=Можно вернуть только 0-255. Другие данные должны быть записаны в stdout.
can.t.match.globs.use.or.grep=`[ .. ]` не может сопоставлять глобы. Используйте `[[ .. ]]` или grep.
can.t.use.in.use.instead=Нельзя использовать `\=~` в `[ ]`. Используйте `[[..]]`.
can.t.use.sudo.with.builtins.like.cd.did.you.want.sudo.sh.c.instead=Нельзя использовать 'sudo' со встроенными командами вроде 'cd'. Используйте 'sudo sh -c'.
check.1008.this.shebang.was.unrecognized.shellcheck.only.supports.sh.bash.dash.ksh.add.a.shell.directive.to.specify=Этот shebang не распознан. ShellCheck поддерживает только sh/bash/dash/ksh. Добавьте директиву 'shell' для указания.
check.1009.the.mentioned.parser.error.was.in=Упомянутая ошибка парсера была в…
check.1010.use.semicolon.or.linefeed.before.done.or.quote.to.make.it.literal=Используйте точку с запятой или перевод строки перед 'done' (или кавычки для литерала).
check.1011.this.apostrophe.terminated.the.single.quoted.string=Этот апостроф завершил строку в одинарных кавычках\!
check.1012.is.just.literal.t.here.for.tab.use.printf.instead=`\t` здесь просто литерал `t`. Чтобы добавить табуляцию, используйте "$(printf '\t')".
check.1014.use.if.cmd.then.to.check.exit.code.or.if.cmd.to.check.output=Используйте 'if cmd; then ...' для проверки кода выхода или 'if [ "$(cmd)" \= .. ]' для проверки вывода.
check.1015.this.is.a.unicode.double.quote.delete.and.retype.it=Это Unicode-кавычка. Удалите и введите заново.
check.1016.this.is.a.unicode.single.quote.delete.and.retype.it=Это Unicode-апостроф. Удалите и введите заново.
check.1017.literal.carriage.return.run.script.through.tr.d=Литеральный возврат каретки. Запустите скрипт через `tr -d '\n'`.
check.1018.this.is.a.unicode.non.breaking.space.delete.it.and.retype.as.space=Это неразрывный пробел Unicode. Удалите его и введите обычный пробел.
check.1019.expected.this.to.be.an.argument.to.the.unary.condition=Ожидался аргумент для унарного условия.
check.1020.you.need.a.space.before.the.if.single.then.else=Добавьте пробел перед `]` или `]]`
check.1026.if.grouping.expressions.inside.use=При группировке выражений внутри [[..]] используйте ( .. ).
check.1028.in.you.have.to.escape.or.preferably.combine.expressions=В [..] нужно экранировать \\( \\) или лучше объединить выражения [..].
check.1029.in.you.shouldn.t.escape.or=В `[[..]]` не нужно экранировать `(` или `)`.
check.1035.you.need.a.space.here=Добавьте здесь пробел.
check.1036.is.invalid.here.did.you.forget.to.escape.it=`(` здесь недопустима. Возможно, вы забыли экранировать?
check.1037.braces.are.required.for.positionals.over.9.e.g.10=Для позиционных параметров больше 9 требуются фигурные скобки, например 10.
check.1038.shells.are.space.sensitive.use.cmd.not.cmd=Shell чувствителен к пробелам. Используйте '< <(cmd)', а не '<<(cmd)'.
check.1039.remove.indentation.before.end.token.or.use.and.indent.with.tabs=Удалите отступ перед закрывающим токеном (или используйте `<<-` и отступы табуляцией).
check.1040.when.using.you.can.only.indent.with.tabs=При использовании <<- отступы только табуляцией.
check.1041.found.eof.further.down.but.not.on.a.separate.line=Найден 'eof' ниже, но не на отдельной строке.
check.1042.found.eof.further.down.but.not.on.a.separate.line=Найден 'eof' ниже, но не на отдельной строке.
check.1044.couldn.t.find.end.token.eof.in.the.here.document=Не найден закрывающий токен `EOF' в here-документе.
check.1045.expected.then=Ожидалось 'then'.
check.1045.it.s.not.foo.bar.just.foo.bar=Лишняя точка с запятой в 'foo \\&; bar'. Должно быть 'foo \\& bar'.
check.1046.couldn.t.find.fi.for.this.if=Не найден 'fi' для этого 'if'.
check.1047.expected.fi.matching.previously.mentioned.if=Ожидался 'fi', соответствующий ранее упомянутому 'if'.
check.1048.can.t.have.empty.then.clauses.use.true.as.a.no.op=Не может быть пустых then-блоков (используйте 'true' как no-op).
check.1049.did.you.forget.the.then.for.this.if=Вы забыли указать 'then' для этого 'if'?
check.1051.semicolons.directly.after.then.are.not.allowed.just.remove.it=Точка с запятой сразу после 'then' недопустима.
check.1052.semicolons.directly.after.then.are.not.allowed.just.remove.it=Точка с запятой сразу после 'then' недопустима.
check.1053.semicolons.directly.after.else.are.not.allowed.just.remove.it=Точка с запятой сразу после 'else' недопустима.
check.1054.you.need.a.space.after.the=Добавьте пробел после '{'.
check.1058.expected.do=Ожидалось `do`.
check.1061.couldn.t.find.done.for.this.do=Не найден 'done' для этого 'do'.
check.1062.expected.done.matching.previously.mentioned.do=Ожидался 'done', соответствующий ранее упомянутому 'do'.
check.1064.expected.a.to.open.the.function.definition=Ожидалась '{' для открытия определения функции.
check.1065.trying.to.declare.parameters.don.t.use.and.refer.to.params.as.1.2=Не объявляйте параметры. Используйте () и обращайтесь к параметрам как $1, $2 и т.д.
check.1066.don.t.use.on.the.left.side.of.assignments=Не используйте '$' в левой части присваивания.
check.1068.don.t.put.spaces.around.the.in.assignments=Не ставьте пробелы вокруг '\=' в присваиваниях.
check.1069.you.need.a.space.before.the=Добавьте пробел перед '['.
check.1071.shellcheck.only.supports.sh.bash.dash.ksh.scripts.sorry=ShellCheck поддерживает только скрипты sh/bash/dash/ksh.
check.1072.unexpected=Неожиданное ..
check.1073.couldn.t.parse.this.thing.fix.to.allow.more.checks=Не удалось разобрать это. Исправьте для выполнения дополнительных проверок.
check.1075.use.elif.instead.of.else.if=Используйте 'elif' вместо 'else if'.
check.1077.for.command.expansion.the.tick.should.slant.left.vs=Для подстановки команд используйте обратный апостроф\: (` vs ´).
check.1078.did.you.forget.to.close.this.double.quoted.string=Вы забыли закрыть строку в двойных кавычках?
check.1079.this.is.actually.an.end.quote.but.due.to.next.char.it.looks.suspect=Это закрывающая кавычка, но из-за следующего символа она выглядит подозрительно.
check.1081.scripts.are.case.sensitive.use.if.not.if=Скрипты чувствительны к регистру. Используйте 'if', а не 'If'.
check.1082.this.file.has.a.utf.8.bom.remove.it.with.lc.ctype.c.sed.1s.yourscript=Этот файл содержит UTF-8 BOM. Удалите его командой\: LC_CTYPE\=C sed '1s/^...//' < yourscript
check.1083.this.is.literal.check.expression.missing.or.quote.it=Эта `{`/`}` литеральная. Проверьте, не пропущена ли `;` или возьмите выражение в кавычки.
check.1084.use.not.for.the.shebang=Shebang это '\#\!', а не '\!\#'.
check.1086.don.t.use.on.the.iterator.name.in.for.loops=Не используйте '$' в имени итератора в for-циклах.
check.1087.use.braces.when.expanding.arrays.e.g.array.idx.or.var.to.quiet=Используйте фигурные скобки при раскрытии массивов, например\: ${array[idx]} (или ${var}[.. для подавления).
check.1088.parsing.stopped.here.invalid.use.of.parentheses=Разбор остановлен здесь. Неверное использование скобок?
check.1089.parsing.stopped.here.is.this.keyword.correctly.matched.up=Разбор остановлен здесь. Правильно ли сопоставлено это ключевое слово?
check.1090.can.t.follow.non.constant.source.use.a.directive.to.specify.location=Невозможно проследить непостоянный источник. Используйте директиву для указания местоположения.
check.1091.not.following.error.message.here=Не следует\: (сообщение об ошибке)
check.1094.parsing.of.sourced.file.failed.ignoring.it=Не удалось разобрать подключаемый файл. Игнорируется.
check.1095.you.need.a.space.or.linefeed.between.the.function.name.and.body=Требуется пробел или перевод строки между именем функции и телом.
check.1097.unexpected.for.assignment.use.for.comparison.use=Неожиданное '\=\='. Для присваивания используйте '\='. Для сравнения поместите выражение '\=\=' в квадратные скобки.
check.1098.quote.escape.special.characters.when.using.eval.e.g.eval.a.b=Заключайте в кавычки или экранируйте специальные символы при использовании eval, например\: eval "a\=(b)".
check.1099.you.need.a.space.before.the=Добавьте пробел перед '\#'.
check.1100.this.is.a.unicode.dash.delete.and.retype.as.ascii.minus=Это Unicode-тире. Удалите и введите заново как ASCII-минус.
check.1101.delete.trailing.spaces.after.to.break.line.or.use.quotes.for.literal.space=Удалите пробелы после \\ для разрыва строки (или используйте кавычки для литерального пробела).
check.1102.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.command.substitution.add.a.space.after.it=Shell по-разному разрешает неоднозначность $(( или не разрешает вовсе. Если первый $( должен начинать подстановку команды, добавьте после него пробел.
check.1104.use.not.just.for.the.shebang=Shebang это '\#\!', а не '\!'.
check.1105.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.a.subshell.add.a.space.after.it=Shell по-разному разрешает неоднозначность (( или не разрешает вовсе. Если первая ( должна начинать подоболочку, добавьте после нее пробел.
check.1107.this.directive.is.unknown.it.will.be.ignored=Эта директива неизвестна. Она будет проигнорирована.
check.1108.you.need.a.space.before.and.after.the=Добавьте пробел до и после '\='.
check.1109.this.is.an.unquoted.html.entity.replace.with.corresponding.character=Это HTML-сущность без кавычек. Замените соответствующим символом.
check.1110.this.is.a.unicode.quote.delete.and.retype.it.or.quote.to.make.literal=Это Unicode-кавычка. Удалите и введите заново (или используйте кавычки для создания литерала).
check.1111.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.singlequote.for.literal=Это Unicode-кавычка. Удалите и введите заново (или используйте одинарные кавычки для создания литерала).
check.1112.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.doublequote.for.literal=Это Unicode-кавычка. Удалите и введите заново (или используйте двойные кавычки для создания литерала).
check.1113.use.not.just.for.the.sheban=Shebang это '\#\!', а не '\#'.
check.1114.remove.leading.spaces.before.the.shebang=Удалите начальные пробелы перед shebang.
check.1115.remove.spaces.between.and.in.the.shebang=Удалите пробелы между '\#' и '\!' в shebang.
check.1116.missing.on.a.expression.or.use.for.arrays=Отсутствует '$' в выражении '$((..))'. Если это массив, используйте '( ('.
check.1117.backslash.is.literal.in.prefer.explicit.escaping.n=Обратный слеш является литералом в "\n". Предпочтительно явное экранирование\: "\\n".
check.1118.delete.whitespace.after.the.here.doc.end.token=Удалите пробел после завершающего токена here document.
check.1119.add.a.linefeed.between.end.token.and.terminating=Добавьте перевод строки между завершающим токеном и закрывающей ')'
check.1120.no.comments.allowed.after.here.doc.token.comment.the.next.line.instead=Комментарии после токена here document не допускаются. Вместо этого прокомментируйте следующую строку.
check.1121.add.terminators.and.other.syntax.on.the.line.with.the.not.here=Добавляйте терминаторы ;/\\& (и другой синтаксис) в строке с '<<', а не здесь.
check.1122.nothing.allowed.after.end.token.to.continue.a.command.put.it.on.the.line.with.the=После завершающего токена ничего не допускается. Для продолжения команды поместите её в строку с `<<`.
check.1123.shellcheck.directives.are.only.valid.in.front.of.complete.compound.commands.like.if.not.e.g.individual.elif.branches=Директивы ShellCheck действительны только перед полными составными командами, такими как `if`, а не отдельными ветками `elif`.
check.1124.shellcheck.directives.are.only.valid.in.front.of.complete.commands.like.case.statements.not.individual.case.branches=Директивы ShellCheck действительны только перед полными командами, такими как 'case', а не отдельными ветками case.
check.1126.place.shellcheck.directives.before.commands.not.after=Размещайте директивы ShellCheck перед командами, а не после.
check.1127.was.this.intended.as.a.comment.use.in.sh=Если это комментарий, используйте `\#`.
check.1128.the.shebang.must.be.on.the.first.line.delete.blanks.and.move.comments=Shebang должен быть на первой строке. Удалите пустые строки и переместите комментарии.
check.1129.you.need.a.space.before.the=Добавьте пробел перед '\!'.
check.1130.you.need.a.space.before.the=Добавьте пробел перед '\:'.
check.1131.use.elif.to.start.another.branch=Используйте `elif` для начала новой ветки.
check.exit.code.directly.with.e.g.if.mycmd.not.indirectly.with=Проверяйте код выхода напрямую через 'if mycmd;', а не косвенно через '$'?.
check1000.is.not.used.specially.and.should.therefore.be.escaped=$ должен быть экранирован.
check1001.this.o.will.be.a.regular.o.in.this.context=В данном контексте \\o будет обычным 'o'.
check1003.want.to.escape.a.single.quote.echo.this.is.how.it.s.done=Хотите экранировать одинарную кавычку? Используйте echo 'This is how it'\\''s done'.
check1004.this.backslash.linefeed.is.literal.break.outside.single.quotes.if.you.just.want.to.break.the.line=Этот обратный слеш и перевод строки являются литералами. Если нужно разбить строку, делайте это вне одинарных кавычек.
check1007.remove.space.after.if.trying.to.assign.a.value.or.for.empty.string.use.var=Уберите пробел после '\=' для присваивания значения (или для пустой строки используйте var\='' ... ).
consider.adding.a.default.case.even.if.it.just.exits.with.error=Рассмотрите добавление случая по умолчанию '*)', даже если он просто завершается с ошибкой.
consider.using.cmd1.cmd2.file.instead.of.individual.redirects=Рассмотрите использование '{ cmd1; cmd2; } >> file' вместо отдельных перенаправлений.
consider.using.grep.c.instead.of.grep.wc=Рассмотрите использование 'grep -c' вместо 'grep|wc'.
d.only.applies.to.the.first.expansion.of.this.glob.use.a.loop.to.check.any.all='-d' применяется только к первому раскрытию этого glob. Используйте цикл для проверки любого/всех.
decimals.are.not.supported.either.use.integers.only.or.use.bc.or.awk.to.compare=Десятичные числа не поддерживаются. Используйте только целые числа или 'bc' или 'awk' для сравнения.
declare.and.assign.separately.to.avoid.masking.return.values=Объявляйте и присваивайте отдельно, чтобы избежать маскировки возвращаемых значений.
did.you.mean.ifs=Возможно, вы имели в виду IFS\=$'\t' ?
display.name.shell.check=ShellCheck
doesn.t.support.decimals.use.bc.or.awk='(( ))' не поддерживает десятичные числа. Используйте 'bc' или 'awk'.
don.t.quote.rhs.of.it.ll.match.literally.rather.than.as.a.regex=Не заключайте в кавычки правую часть \=~, она будет сопоставляться буквально, а не как регулярное выражение.
don.t.use.around.ranges.in.tr.it.replaces.literal.square.brackets=Не используйте '[]' вокруг диапазонов в 'tr', это заменяет литеральные квадратные скобки.
don.t.use.ls.grep.use.a.glob.or.a.for.loop.with.a.condition.to.allow.non.alphanumeric.filenames=Не используйте 'ls | grep'. Используйте glob или цикл for с условием для поддержки неалфавитно-цифровых имён файлов.
don.t.use.variables.in.the.printf.format.string.use.printf.s.foo=Не используйте переменные в строке формата printf. Вместо этого используйте следующий синтаксис\: printf "..%s.." "$foo".
double.quote.array.expansions.to.avoid.re.splitting.elements=Заключайте раскрытия массивов в двойные кавычки, чтобы избежать повторного разделения элементов.
double.quote.to.prevent.globbing.and.word.splitting=Используйте двойные кавычки для предотвращения глоббинга и разделения слов.
e.doesn.t.work.with.globs.use.a.for.loop='-e' не работает с glob-выражениями. Используйте цикл for.
echo.doesn.t.read.from.stdin.are.you.sure.you.should.be.piping.to.it='echo' не читает из stdin. Перенаправление в него не рекомендуется.
echo.won.t.expand.escape.sequences.consider.printf='echo' не раскрывает escape-последовательности. Рассмотрите использование 'printf'.
egrep.is.non.standard.and.deprecated.use.grep.e.instead=egrep нестандартен и устарел. Используйте grep -E.
elements.in.associative.arrays.need.index.e.g.array.index.value=Элементы в ассоциативных массивах требуют индекса, например\: array\=( [index]\=value ).
ensure.the.shebang.uses.the.absolute.path.to.the.interpreter=Убедитесь, что shebang указывает абсолютный путь к интерпретатору.
eq.is.for.integer.comparisons.use.instead='-eq' для сравнения целых чисел. Используйте '\=' вместо этого.
error.message.can.t.find.info.in.your.path=Не удаётся найти информацию в вашей переменной $PATH.
error.message.cannot.determine.shell.script.parent.directory=Невозможно определить родительскую директорию shell скрипта
exec.does.not.automatically.invoke.a.shell.use.exec.sh.c.for.that='-exec' не вызывает shell автоматически. Используйте '-exec sh -c'.
expanding.an.array.without.an.index.only.gives.the.first.element=Раскрытие массива без индекса даёт только первый элемент.
expr.is.antiquated.consider.rewriting.this.using.or='expr' устарел. Рассмотрите переписывание с использованием '$((..))', '${}' или '\\[\\[ \\]\\]'.
expressions.don.t.expand.in.single.quotes.use.double.quotes.for.that=Выражения не раскрываются в одинарных кавычках, используйте для этого двойные кавычки.
false.is.true.remove.the.brackets='[ false ]' является истинным. Удалите скобки.
fgrep.is.non.standard.and.deprecated.use.grep.f.instead=fgrep нестандартен и устарел. Используйте grep -F.
filetype.sh.shell.script.description=Shell скрипт
find.usages.type.function=функция
flip.leading.and.if.this.should.be.a.quoted.substitution=Поменяйте местами начальные '$' и '"', если это должна быть цитированная подстановка.
foo.appears.unused.verify.it.or.export.it='foo' кажется неиспользуемым. Проверьте его или экспортуйте.
foo.references.arguments.but.none.are.ever.passed='foo' ссылается на аргументы, но они никогда не передаются.
for.loops.over.find.output.are.fragile.use.find.exec.or.a.while.read.loop=Циклы for по выводу find ненадёжны. Используйте 'find -exec' или цикл while read.
function.keyword.is.non.standard.delete.it=Ключевое слово 'function' нестандартно. Удалите его.
getopts.specified.n.but.it.s.not.handled.by.this.case='getopts' указал '-n', но это не обрабатывается этим 'case'.
globs.are.ignored.in.except.right.of.use.a.loop=Glob-выражения игнорируются в `[[ ]]`, кроме правой части '\=' и '\!\='. Используйте цикл.
globs.don.t.work.as.operands.in.use.a.loop=Glob-выражения не работают как операнды в '[ ]'. Используйте цикл.
grep.uses.regex.but.this.looks.like.a.glob=Grep использует регулярные выражения, но это похоже на glob.
i.do.mind.path.placeholder=Я возражаю
if.you.wanted.to.assign.the.output.of.the.pipeline.use.a.b.c=Если вы хотели присвоить вывод конвейера, используйте 'a\=$(b | c)'.
in.dash.something.is.not.supported=Эта функция не поддерживается в dash.
in.functions.use.return.instead.of.break=В функциях используйте 'return' вместо 'break'.
in.posix.sh.something.is.undefined=В POSIX sh это не определено.
in.use.instead.of.a=В '[\\[..]]' используйте '\\&\\&' вместо '-a'.
in.use.instead.of.o=В '[\\[..]]' используйте '||' вместо '-o'.
increase.precision.by.replacing.a.b.c.with.a.c.b=Увеличьте точность, заменив 'a/b\\*c' на 'a\\*c/b'.
injecting.filenames.is.fragile.and.insecure.use.parameters=Внедрение имён файлов ненадёжно и небезопасно. Используйте параметры.
instead.of.1.use.true=Вместо '[ 1 ]' используйте 'true'.
instead.of.a.b.use.a.b=Вместо '[ a || b ]' используйте '[ a ] || [ b ]'.
instead.of.a.b.use.a.b2=Вместо '[ a \\&\\& b ]' используйте '[ a ] \\&\\& [ b ]'.
instead.of.let.expr.prefer.expr=Вместо `let expr` предпочтительнее использовать `(( expr ))`.
instead.of.true.just.use.true=Вместо '[ true ]' используйте 'true'.
intention.shell.script=Shell скрипт
invalid.flags.are.not.handled.add.a.case=Недопустимые флаги не обрабатываются. Добавьте случай `*)`.
is.a.subshell.did.you.mean.a.test.expression='(..)' это подоболочка. Возможно, вы имели в виду '[ .. ]', выражение проверки?
is.for.regex.but.this.looks.like.a.glob.use.instead='\=~' для регулярных выражений, но это похоже на glob. Используйте '\=' вместо этого.
is.for.string.comparisons.use.gt.instead='>' для сравнения строк. Используйте '-gt' вместо этого.
is.not.a.valid.operator.use.a.b.instead='>\=' не является допустимым оператором. Используйте '\! a < b' вместо этого.
is.unnecessary.on.arithmetic.variables='$' и '${}' не нужны для арифметических переменных.
iterating.over.ls.output.is.fragile.use.globs=Итерация по выводу ls ненадёжна. Используйте glob-выражения.
line.marker.run.0=Запустить {0}
literal.tilde.in.path.works.poorly.across.programs=Литеральная тильда в PATH плохо работает между программами.
local.is.only.valid.in.functions='local' действителен только в функциях.
make.sure.all.escape.sequences.are.enclosed.in.to.prevent.line.wrapping.issues=Убедитесь, что все escape-последовательности заключены в `\\[..\\]` для предотвращения проблем с переносом строк
missing.or.terminating.exec.you.can.t.use.and.has.to.be.a.separate.quoted.argument=Отсутствует ';' или '+' завершающий '-exec'. Не используйте |/||/\\&\\&, и используйте кавычки для ';'.
modification.of.var.is.local.to.subshell.caused.by.pipeline=Изменение 'var' локально (для подоболочки, созданной конвейером).
n.doesn.t.work.with.unquoted.arguments.quote.or.use=`-n` не работает с неэкранированными аргументами. Используйте кавычки или ``[[ ]]``.
named.class.needs.outer.e.g.digit=Именованный класс требует внешних '[]', например\: [[\:digit\:]\\]
note.that.a.b.c.is.not.if.then.else.c.may.run.when.a.is.true=Обратите внимание, что 'A \\&\\& B || C' не является 'if-then-else'. C может выполниться, когда A истинно.
note.that.unescaped.this.expands.on.the.client.side=Если не экранировано, это раскрывается на стороне клиента.
note.that.unlike.globs.o.here.matches.ooo.but.not.oscar=Обратите внимание, что в отличие от glob, 'o*' здесь соответствует 'ooo', но не 'oscar'
notification.group.shell.script=Доступны инструменты для shell-скриптов
numbers.with.leading.0.are.considered.octal=Числа с ведущим 0 считаются восьмеричными.
numerical.eq.does.not.dereference.in.expand.or.use.string.operator=Числовой '-eq' не разыменовывает в [..]. Раскройте или используйте строковый оператор.
on.most.os.shebangs.can.only.specify.a.single.parameter=В большинстве ОС shebang может указывать только один параметр.
only.one.integer.0.255.can.be.returned.use.stdout.for.other.data=Может быть возвращено только одно целое число 0-255. Используйте stdout для других данных.
path.is.the.shell.search.path.use.another.name=PATH - это путь поиска shell. Используйте другое имя.
piping.to.rm.a.command.that.doesn.t.read.stdin.wrong.command.or.missing.xargs=Передача по конвейеру в 'rm', команду, которая не читает stdin. Неверная команда или отсутствует xargs?
possible.misspelling.myvariable.may.not.be.assigned.but.my.variable.is=Возможная опечатка\: MYVARIABLE может быть не присвоена, но MY_VARIABLE присвоена.
prefer.explicit.n.to.check.for.output.or.run.command.without.to.check.for.success=Предпочтительнее явный '-n' для проверки вывода. Запускайте команду без '[' и '[[' для проверки успешности.
prefer.explicit.n.to.check.non.empty.string.or.use.ne.to.check.boolean.integer=Предпочтительнее явный '-n' для проверки непустых строк. Используйте '\=' или '-ne' для проверки булевых значений и целых чисел.
prefer.mapfile.or.read.a.to.split.command.output.or.quote.to.avoid.splitting=Предпочтительнее 'mapfile' или 'read -a' для разделения вывода команды (или кавычки для предотвращения разделения).
prefer.p.q.as.p.a.q.is.not.well.defined=Предпочтительнее '[ p ] \\&\\& [ q ]', так как '[ p -a q ]' плохо определен.
quote.arguments.to.unset.so.they.re.not.glob.expanded=Заключите аргументы в кавычки, чтобы игнорировать glob-синтаксис.
quote.eof.to.make.here.document.expansions.happen.on.the.server.side.rather.than.on.the.client=Добавьте кавычки вокруг 'EOF', чтобы раскрытие here-документа происходило на стороне сервера, а не клиента.
quote.expansions.in.this.for.loop.glob.to.prevent.wordsplitting.e.g.dir.txt=Заключите раскрытия в этом glob-выражении цикла for в кавычки для предотвращения разделения слов, например\: "$dir"/*.txt
quote.parameters.to.tr.to.prevent.glob.expansion=Заключите параметры 'tr' в кавычки для предотвращения glob-раскрытия.
quote.the.grep.pattern.so.the.shell.won.t.interpret.it=Заключите шаблон grep в кавычки, чтобы shell не интерпретировал его.
quote.the.parameter.to.name.so.the.shell.won.t.interpret.it=Заключите параметр для '-name' в кавычки, чтобы shell не интерпретировал его.
quote.the.rhs.of.in.to.prevent.glob.matching=Заключите 'rhs of \=' в '[[ ]]' в кавычки для предотвращения glob-сопоставления.
quote.this.invalid.brace.expansion.since.it.should.be.passed.literally.to.eval=Заключите это неверное раскрытие скобок в кавычки, так как оно должно быть передано в eval буквально.
quote.this.to.prevent.word.splitting=Заключите это в кавычки для предотвращения разделения слов.
quote.to.prevent.word.splitting.or.split.robustly.with.mapfile.or.read.a=Заключите в кавычки для предотвращения разделения слов или разделяйте надежно с помощью 'mapfile' или 'read -a'.
quotes.backslashes.in.this.variable.will.not.be.respected=Кавычки и обратные слеши в этой переменной не будут учитываться.
quotes.backslashes.will.be.treated.literally.use.an.array=Кавычки и обратные слеши будут обработаны буквально. Используйте массив.
ranges.can.only.match.single.chars.mentioned.due.to.duplicates=Диапазоны могут соответствовать только одиночным символам (упомянуто из-за дубликатов).
read.without.r.will.mangle.backslashes='read' без '-r' исказит обратные слеши.
redirecting.to.echo.a.command.that.doesn.t.read.stdin.bad.quoting.or.missing.xargs=Перенаправление в 'echo', команду, которая не читает stdin. Неправильные кавычки или отсутствует xargs?
redirecting.to.from.command.name.instead.of.file.did.you.want.pipes.xargs.or.quote.to.ignore=Перенаправление в/из имени команды вместо файла. Используйте конвейеры или xargs (или кавычки для игнорирования).
redirection.applies.to.the.find.command.itself.rewrite.to.work.per.action.or.move.to.end=Перенаправление применяется к самой команде 'find'. Перепишите для работы с каждым действием (или переместите в конец).
remove.backticks.to.avoid.executing.output=Удалите обратные кавычки, чтобы избежать выполнения вывода.
remove.exec.if.script.should.continue.after.this.command=Удалите "exec ", если скрипт должен продолжить выполнение после этой команды.
remove.for.numeric.index.or.escape.it.for.string=Удалите '$' и '${}' для числового индекса или экранируйте для строки.
remove.or.use.expr.to.avoid.executing.output=Удалите '$' или используйте '_\=$((expr))', чтобы избежать выполнения вывода.
remove.superfluous.around.condition=Удалите лишние `(..)` вокруг условия.
remove.superfluous.around.test.command=Удалите лишние `(..)` вокруг команды test.
remove.surrounding.to.avoid.executing.output=Удалите окружающие '$()', чтобы избежать выполнения вывода.
sc2001.see.if.you.can.use.variable.search.replace.instead=SC2001\: Проверьте, можно ли использовать ${variable//search/replace}.
sc2009.consider.using.pgrep.instead.of.grepping.ps.output=SC2009 Рассмотрите использование pgrep вместо grep для вывода ps.
sc2094.make.sure.not.to.read.and.write.the.same.file.in.the.same.pipeline=SC2094 Убедитесь, что не читаете и не записываете один и тот же файл в одном конвейере.
sc2106.this.only.exits.the.subshell.caused.by.the.pipeline=SC2106\: Это завершает только subshell, созданный конвейером.
sh.code.style.binary.ops.like.and.may.start.a.line=Разрешить перенос строки после бинарных операторов
sh.code.style.choose.path=Выберите путь к Shfmt\:
sh.code.style.download.link=Скачать форматтер shfmt
sh.code.style.keep.column.alignment.padding=Сохранять выравнивание столбцов
sh.code.style.minify.program.to.reduce.its.size=Минифицировать программу для уменьшения размера
sh.code.style.redirect.operators.will.be.followed.by.a.space=Добавлять пробел после операторов перенаправления
sh.code.style.switch.cases.will.be.indented=Делать отступы для операторов case
sh.code.style.unix.line.separator=Использовать разделители строк Unix (\\n)
sh.color.backquotes=Обратные кавычки
sh.color.braces.curly.brackets=Скобки//фигурные скобки
sh.color.braces.parentheses=Скобки//круглые скобки
sh.color.braces.square.brackets=Скобки//квадратные скобки
sh.color.commands.generic.command=Команды//общая команда
sh.color.commands.subshell.command=Команды//команда subshell
sh.color.conditional.operators=Условные операторы
sh.color.function.declaration=Объявление функции
sh.color.here.documents=Here-документы
sh.color.here.documents.end=Конец here-документа
sh.color.here.documents.start=Начало here-документа
sh.color.keyword=Ключевое слово
sh.color.line.comment=Однострочный комментарий
sh.color.number=Число
sh.color.raw.string=Сырая строка
sh.color.redirection=Перенаправление
sh.color.shebang.comment=Комментарий shebang
sh.color.string=Строка
sh.color.variables.composed.variable=Переменные//составная переменная
sh.color.variables.variable.declaration=Переменные//объявление переменной
sh.color.variables.variable.usage=Переменные//использование переменной
sh.disable.inspection.text=Отключить проверку {0}
sh.download=Скачать
sh.explain.command.to.explain=Команда для объяснения
sh.explain.inspection.text=Объяснить shell
sh.explain.message.nothing.to.explain=Нечего объяснять
sh.explain.title.nothing.to.explain=Нечего объяснять
sh.fmt.cannot.download=Не удаётся скачать форматтер shfmt. Установите его вручную.
sh.fmt.cannot.update=Не удаётся обновить форматтер shfmt. Выполнен откат к предыдущей версии.
sh.fmt.formatter=Форматтер Shfmt
sh.fmt.indent.label=Отступ
sh.fmt.install.question=Хотите установить форматтер shell-скриптов?
sh.fmt.missing.formatter=отсутствует форматтер
sh.fmt.success.install=Форматтер shell-скриптов успешно установлен
sh.fmt.success.update=Форматтер shell-скриптов успешно обновлен
sh.fmt.update.question=Хотите обновить форматтер shell-скриптов с "{0}" до "{1}"?
sh.install=Установить
sh.invalid.path=Неверный путь.
sh.label.choose.interpreter=Выбрать интерпретатор
sh.label.choose.script.working.directory=Выбрать рабочую директорию скрипта
sh.label.choose.shell.script=Выбрать Shell-скрипт
sh.label.download.shfmt.formatter=Скачать форматтер shfmt
sh.livetemplate.description.array.add=Добавить новый элемент в конец массива
sh.livetemplate.description.array.all=Все элементы массива
sh.livetemplate.description.array.at.index=Элементы по индексу
sh.livetemplate.description.array.create=Создать массив
sh.livetemplate.description.array.delete=Удалить массив
sh.livetemplate.description.array.delete.at=Удалить из массива
sh.livetemplate.description.array.iteration=Перебрать массив
sh.livetemplate.description.array.length=Длина массива
sh.livetemplate.description.array.set.element=Установка элемента массива по индексу
sh.livetemplate.description.case=Оператор case
sh.livetemplate.description.cmd=Подстановка команды
sh.livetemplate.description.cmd.success.check=Проверка успешности команды
sh.livetemplate.description.command.exists=Команда существует
sh.livetemplate.description.curl=HTTP запрос
sh.livetemplate.description.directory.exists=Директория существует
sh.livetemplate.description.elif=Выражение elif
sh.livetemplate.description.file.equals=Файлы равны
sh.livetemplate.description.file.executable=Файл исполняемый
sh.livetemplate.description.file.exists=Файл существует
sh.livetemplate.description.file.newer=Файл новее
sh.livetemplate.description.file.not.empty=Файл не пуст
sh.livetemplate.description.file.older=Файл старше
sh.livetemplate.description.file.readable=Файл доступен для чтения
sh.livetemplate.description.file.writable=Файл доступен для записи
sh.livetemplate.description.find=Найти файл или директорию
sh.livetemplate.description.for=Цикл for по индексу
sh.livetemplate.description.fori=Цикл for по списку
sh.livetemplate.description.function=Определить функцию
sh.livetemplate.description.git.branch.create=Создать ветку
sh.livetemplate.description.git.commit=Закоммитить изменения
sh.livetemplate.description.git.push=Отправить ветку в remote
sh.livetemplate.description.heredoc=Многострочная строка
sh.livetemplate.description.if=Оператор if
sh.livetemplate.description.mkdir=Создать директорию
sh.livetemplate.description.number.equal=Числа равны
sh.livetemplate.description.number.greater=Число больше чем
sh.livetemplate.description.number.greater.or.equal=Число больше или равно
sh.livetemplate.description.number.less=Число меньше чем
sh.livetemplate.description.number.less.or.equal=Число меньше или равно
sh.livetemplate.description.number.not.equal=Числа не равны
sh.livetemplate.description.path.exists=Путь существует
sh.livetemplate.description.rm=Удалить файл или директорию
sh.livetemplate.description.select=Выражение select
sh.livetemplate.description.string.equal=Строки равны
sh.livetemplate.description.string.is.empty=Строка пуста
sh.livetemplate.description.string.not.empty=Строка не пуста
sh.livetemplate.description.string.not.equal=Строки не равны
sh.livetemplate.description.system.info.linux=Информация о системе Linux
sh.livetemplate.description.system.info.mac=Информация о системе Mac OS
sh.livetemplate.description.system.kernel.info=Информация о ядре
sh.livetemplate.description.tar.compress=tar сжатие
sh.livetemplate.description.tar.decompress=tar распаковка
sh.livetemplate.description.until=Цикл until по условию
sh.livetemplate.description.while=Цикл while по условию
sh.livetemplate.description.xargs=Выполнить команды из стандартного ввода
sh.markdown.runner.title=Запустить в терминале
sh.no.thanks=Нет
sh.parser.expected.similar.close.bracket=Ожидается похожая закрывающая скобка
sh.path.label=Путь\:
sh.rename.all.occurrences=Переименовать все вхождения
sh.rename.occurence=Переименовать {0}
sh.run.configuration.description.0.configuration=Конфигурация {0}
sh.run.environment.variables=Переменные окружения\:
sh.run.execute=Выполнить\:
sh.run.execute.script.file=Файл скрипта
sh.run.execute.script.text=Текст скрипта
sh.run.execute.script.text.title=Текст скрипта\:
sh.run.execute.terminal=Выполнить в терминале
sh.run.interpreter=Интерпретатор
sh.run.interpreter.not.found=Интерпретатор не найден
sh.run.interpreter.options=Параметры интерпретатора\:
sh.run.interpreter.path=Путь к интерпретатору\:
sh.run.interpreter.should.be.executable=Интерпретатор должен быть исполняемым файлом
sh.run.script.not.found=Shell скрипт не найден
sh.run.script.options=Параметры скрипта\:
sh.run.script.path=Путь к скрипту\:
sh.run.working.dir=Рабочая директория\:
sh.run.working.dir.not.found=Рабочая директория не найдена
sh.shell.script=Shell скрипт
sh.shellcheck.cannot.download=Не удалось скачать shellcheck. Установите его вручную.
sh.shellcheck.cannot.update=Не удалось обновить shellcheck. Выполнен откат к предыдущей версии.
sh.shellcheck.download.label.text=Скачать shellcheck
sh.shellcheck.install.question=Установить shellcheck для проверки ваших shell скриптов?
sh.shellcheck.missing=\ отсутствует shellcheck
sh.shellcheck.path.label=Выберите путь к Shellcheck\:
sh.shellcheck.success.install=Shellcheck успешно установлен
sh.shellcheck.success.update=Shellcheck успешно обновлен
sh.shellcheck.update.question=Обновить shellcheck с версии "{0}" до версии "{1}"?
sh.skip.version=Пропустить эту версию
sh.suppress.inspection=Подавить {0}
sh.unnamed.element.presentable.name=<без имени>
sh.update=Обновить
shell.functions.can.t.be.passed.to.external.commands=Shell функции нельзя передавать внешним командам.
sigkill.sigstop.can.not.be.trapped=SIGKILL и SIGSTOP нельзя перехватить.
since.you.double.quoted.this.it.will.not.word.split.and.the.loop.will.only.run.once=Поскольку вы заключили это в двойные кавычки, разбиение на слова не произойдет, и цикл выполнится только один раз.
some.finds.don.t.have.a.default.path.specify.explicitly=Некоторые find не имеют пути по умолчанию. Явно укажите '.'.
sudo.doesn.t.affect.redirects.use.sudo.tee.file=`sudo` не влияет на перенаправления. Используйте `..| sudo tee file`
tempfile.is.deprecated.use.mktemp.instead=tempfile устарел. Используйте mktemp.
the.arguments.to.this.comparison.can.never.be.equal.make.sure.your.syntax.is.correct=Аргументы этого сравнения никогда не могут быть равны. Проверьте правильность синтаксиса.
the.dot.command.does.not.support.arguments.in.sh.dash.set.them.as.variables=Команда dot не поддерживает аргументы в sh/dash. Установите их как переменные.
the.exit.status.can.only.be.one.integer.0.255.use.stdout.for.other.data=Статус выхода может быть только целым числом 0-255. Используйте stdout для других данных.
the.here.is.literal.to.assign.by.index.use.index.value.with.no.spaces.to.keep.as.literal.quote.it=Символ '\=' здесь является литералом. Для присваивания по индексу используйте ( [index]\=значение ) без пробелов. Чтобы сохранить как литерал, используйте кавычки.
the.surrounding.quotes.actually.unquote.this.remove.or.escape.them=Окружающие кавычки фактически снимают кавычки. Удалите или экранируйте их.
this.action.ignores.everything.before.the.o.use.to.group=Это действие игнорирует всё перед '-o'. Используйте \\( \\) для группировки.
this.array.element.has.no.value.remove.spaces.after.or.use.for.empty.string=Этот элемент массива не имеет значения. Удалите пробелы после '\=' или используйте "" для пустой строки.
this.assignment.is.only.seen.by.the.forked.process=Это присваивание видно только в порожденном процессе.
this.case.is.not.specified.by.getopts=Этот case не указан в 'getopts'.
this.cp.has.no.destination.check.the.arguments=У этой команды 'cp' нет места назначения. Проверьте аргументы.
this.default.assignment.may.cause.dos.due.to.globbing.quote.it=Это присваивание по умолчанию может вызвать DoS из-за глоббинга. Заключите его в кавычки.
this.does.not.export.foo.remove.for.that.or.use.var.to.quiet=Это не экспортует 'FOO'. Удалите '$' и '${}' или используйте '${var?}' для подавления.
this.does.not.read.foo.remove.for.that.or.use.var.to.quiet=Это не читает 'foo'. Удалите '$' и '${}' или используйте '${var?}' для подавления.
this.expands.when.defined.not.when.used.consider.escaping=Раскрывается при определении, а не при использовании. Рассмотрите экранирование.
this.expansion.will.not.see.the.mentioned.assignment=Это раскрытие не увидит упомянутое присваивание.
this.expression.is.constant.did.you.forget.a.somewhere=Это выражение константно. Возможно, вы забыли `$` где-то?
this.expression.is.constant.did.you.forget.the.on.a.variable=Это выражение константно. Возможно, вы забыли `$` для переменной?
this.flag.is.used.as.a.command.name.bad.line.break.or.missing=Этот флаг используется как имя команды. Неправильный перенос строки или отсутствует `[ .. ]`?
this.format.string.has.2.variables.but.is.passed.1.arguments=В этой строке форматования 2 переменных, но передается 1 аргумент.
this.function.is.only.defined.later.move.the.definition.up=Эта функция определена только позже. Переместите определение выше.
this.is.a.file.redirection.was.it.supposed.to.be.a.comparison.or.fd.operation=Это перенаправление файла. Должно ли это быть сравнением или операцией с дескриптором?
this.is.a.glob.used.as.a.command.name.was.it.supposed.to.be.in.array.or.is.it.missing.quoting=Это глоб, используемый как имя команды. Должен ли он быть в '${..}' или массиве? Если нет, используйте кавычки.
this.is.a.literal.string.to.run.as.a.command.use.instead.of=Это литеральная строка. Для выполнения как команды используйте '$(..)' вместо '..' .
this.is.interpreted.as.a.shell.file.redirection.not.a.comparison=Это интерпретируется как перенаправление файла shell, а не как сравнение.
this.ln.has.no.destination.check.the.arguments.or.specify.explicitly=У этой команды 'ln' нет назначения. Проверьте аргументы или явно укажите '.'.
this.loop.will.only.ever.run.once.for.a.constant.value.did.you.perhaps.mean.to.loop.over.dir.var.or.cmd=Этот цикл выполнится только один раз для константного значения. Возможно, вы хотели выполнить цикл по 'dir/*', '$var' или '$(cmd)'?
this.mv.has.no.destination.check.the.arguments=У этой команды 'mv' нет назначения. Проверьте аргументы.
this.nested.loop.overrides.the.index.variable.of.its.parent=Этот вложенный цикл переопределяет индексную переменную родительского цикла.
this.parent.loop.has.its.index.variable.overridden=Индексная переменная родительского цикла переопределена.
this.pattern.always.overrides.a.later.one=Этот шаблон всегда переопределяет последующий.
this.pattern.never.matches.because.of.a.previous.pattern=Этот шаблон никогда не совпадет из-за предыдущего шаблона.
this.pattern.will.never.match.the.case.statement.s.word.double.check.them=Этот шаблон никогда не совпадет со словом оператора case.
this.printf.format.string.has.no.variables.other.arguments.are.ignored=В этой строке форматования printf нет переменных. Другие аргументы игнорируются.
this.redirection.doesn.t.have.a.command.move.to.its.command.or.use.true.as.no.op=У этого перенаправления нет команды. Переместите к команде (или используйте 'true' как no-op).
this.shebang.specifies.a.directory.ensure.the.interpreter.is.a.file=Этот shebang указывает на директорию. Убедитесь, что интерпретатор является файлом.
this.terminates.the.command.escape.it.or.add.space.after.to.silence=Этот `\\&` прерывает команду. Экранируйте его или добавьте пробел после `\\&` для подавления.
this.will.expand.once.before.find.runs.not.per.file.found=Это раскроется один раз перед запуском find, а не для каждого найденного файла.
this.word.is.constant.did.you.forget.the.on.a.variable=Это слово является константой. Возможно, вы забыли символ '$' для переменной?
this.word.is.outside.of.quotes.did.you.intend.to.nest.single.quotes.instead=Это слово находится вне кавычек. Возможно, вы хотели 'вложить '"'одинарные кавычки'"'?
tilde.does.not.expand.in.quotes.use.home=Тильда не раскрывается в кавычках. Используйте $HOME.
time.is.undefined.for.compound.commands.time.sh.c.instead='time' не определен для составных команд. Используйте 'time sh -c'.
time.is.undefined.for.pipelines.time.single.stage.or.bash.c.instead='time' не определен для пайплайнов. Используйте `time` для одного этапа или `time bash -c`.
tips.depend.on.target.shell.and.yours.is.unknown.add.a.shebang=Подсказки зависят от целевого shell. Добавьте shebang.
to.assign.a.variable.use.just.var.value.no.set=Для присвоения переменной используйте 'var\=value', а не 'set ..'.
to.assign.the.output.of.a.command.use.var.cmd=Для присвоения вывода команды используйте 'var\=$(cmd)'.
to.expand.via.indirection.use.name.foo.n.echo.name=Для косвенного раскрытия используйте name\="foo$n"; echo "${\!name}".
to.read.lines.rather.than.words.pipe.redirect.to.a.while.read.loop=Для чтения строк вместо слов перенаправьте вывод через пайп в цикл 'while read'.
to.redirect.stdout.stderr.2.1.must.be.last.or.use.cmd.file.2.1.to.clarify=Для перенаправления stdout+stderr, '2>\\&1' должен быть последним (или используйте '{ cmd > file; } 2>\\&1' для ясности).
to.run.commands.as.another.user.use.su.c.or.sudo=Для запуска команд от имени другого пользователя используйте 'su -c' или 'sudo'.
tr.replaces.sets.of.chars.not.words.mentioned.due.to.duplicates='tr' заменяет наборы символов, а не слова (упомянуто из-за дубликатов).
trapping.signals.by.number.is.not.well.defined.prefer.signal.names=Перехват сигналов по номеру плохо определен. Предпочтительнее использовать имена сигналов.
unexpected.start.of.line.if.breaking.lines.should.be.at.the.end.of.the.previous.one=Неожиданное начало новой строки. При разрыве строк |/||/\\&\\& должны быть в конце предыдущей.
unknown.binary.operator=Неизвестный бинарный оператор.
unknown.unaryoperator=Неизвестный унарный оператор.
use.a.subshell.to.avoid.having.to.cd.back=Используйте ( subshell ) чтобы избежать необходимости возврата cd.
use.array.item.to.append.items.to.an.array=Используйте 'array+\=("item")' для добавления элементов в массив.
use.cd.exit.in.case.cd.fails=Используйте cd ... || exit на случай неудачи cd.
use.false.instead.of.empty.conditionals=Используйте 'false' вместо пустых условий '[' и '[['.
use.find.instead.of.ls.to.better.handle.non.alphanumeric.filenames=Используйте `find` вместо `ls` для лучшей обработки неалфавитно-цифровых имен файлов.
use.foo.if.function.s.1.should.mean.script.s.1=Используйте 'foo "$@"', если аргумент '$1' функции должен означать аргумент '$1' скрипта.
use.for.arithmetics.e.g.i.i.2=Используйте `$((..))` для арифметики, например\: i\=$((i + 2))
use.glob.or.glob.so.names.with.dashes.won.t.become.options=Используйте './\\*glob*' или '-- \\*glob*', чтобы имена с дефисами не стали опциями.
use.grep.q.instead.of.comparing.output.with.n=Используйте 'grep -q' вместо сравнения вывода с '[ -n .. ]'.
use.instead.of.deprecated=Используйте '$((..))' вместо устаревшего '$[..]'.
use.instead.of.to.avoid.subshell.overhead=Используйте `{ ..; }` вместо `(..)` для избежания накладных расходов subshell.
use.lower.to.support.accents.and.foreign.alphabets=Используйте '[\:lower\:]' для поддержки диакритических знаков и иностранных алфавитов.
use.n.instead.of.z=Используйте `[ -n .. ]` вместо `\! [ -z .. ]`.
use.n.instead.of.z2=Используйте `-n` вместо `\! -z`.
use.notation.instead.of.legacy.backticked=Используйте нотацию '$(...)' вместо устаревших обратных кавычек `` `...` ``.
use.or.quote.arguments.to.v.to.avoid.glob.expansion=Используйте `[[ ]]` или заключите аргументы опции '-v' в кавычки для избежания раскрытия глобов.
use.own.script.or.sh.c.to.run.this.from.su=Используйте собственный скрипт или sh -c '..' для запуска из su.
use.print0.0.or.find.exec.to.allow.for.non.alphanumeric.filenames=Используйте '-print0', '-0' или 'find -exec +' для поддержки неалфавитно-цифровых имен файлов.
use.single.quotes.otherwise.this.expands.now.rather.than.when.signalled=Используйте одинарные кавычки для раскрытия только при сигнале, а не сразу.
use.spaces.not.commas.to.separate.array.elements=Используйте пробелы, а не запятые, для разделения элементов массива.
use.upper.to.support.accents.and.foreign.alphabets=Используйте '[\:upper\:]' для поддержки диакритических знаков и иностранных алфавитов.
use.var.command.to.assign.output.or.quote.to.assign.string=Используйте 'var\=$(command)' для присвоения вывода (или кавычки для присвоения строки).
use.var.to.ensure.this.never.expands.to=Используйте "${var\:?}" чтобы гарантировать, что это никогда не раскроется в /* .
use.with.quotes.to.prevent.whitespace.problems=Используйте "$@" (с кавычками) для предотвращения проблем с пробелами.
useless.cat.consider.cmd.file.or.cmd.file.instead=Лишний 'cat'. Рассмотрите использование 'cmd < file | ..' или 'cmd file | ..' вместо этого.
useless.echo.instead.of.cmd.echo.foo.just.use.cmd.foo=Лишний echo? Вместо 'cmd $(echo foo)' используйте 'cmd foo'.
useless.echo.instead.of.echo.cmd.just.use.cmd=Лишний `echo`? Вместо `echo $(cmd)` используйте `cmd`.
var.is.referenced.but.not.assigned='var' используется, но не присвоена.
var.was.modified.in.a.subshell.that.change.might.be.lost='var' был изменен в subshell. Это изменение может быть потеряно.
variable.was.used.as.an.array.but.is.now.assigned.a.string=Переменная использовалась как массив, но теперь ей присваивается строка.
warning.deletes.a.system.directory=Внимание\: удаляет системную директорию.
when.used.with.p.m.only.applies.to.the.deepest.directory=При использовании с '-p', '-m' применяется только к самой глубокой директории.
which.is.non.standard.use.builtin.command.v.instead='which' нестандартен. Используйте встроенную команду 'command -v'.
word.is.on.the.form.a.b.c.b.indicated.did.you.mean.abc.or.a.b.c=\ Слово имеет форму "A"B"C" (указано B). Возможно, вы имели в виду "ABC" или "A\\"B\\"C"?
you.can.t.have.between.this.redirection.and.the.command.it.should.apply.to=Нельзя использовать '|' между этим перенаправлением и командой, к которой оно применяется.
you.need.spaces.around.the.comparison.operator=Необходимы пробелы вокруг оператора сравнения.
you.probably.wanted.here=Используйте '\\&\\&'.