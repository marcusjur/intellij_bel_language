GuiceClassAnnotator.popup.title=Выберите выражение для навигации
GuiceClassAnnotator.popup.tooltip.text=Перейти к выражению привязки Guice
ImplicitSubclassInspection.display.forMethod.annotated=Методы с @Transactional не могут быть private
binding.annotation.without.inject.display.name=Аннотация привязки без @Inject
binding.annotation.without.inject.problem.descriptor=Аннотация привязки без объявленного @Inject \#ref \#loc
class.provided=Предоставленный класс\:
conflicting.annotations.display.name=Конфликт аннотаций Guice
conflicting.annotations.problem.descriptor=Аннотация \#ref конфликтует с другими объявленными аннотациями \#loc
delete.binding=Удалить привязку
group.GuiceActionGroup.description=Компоненты Google Guice
group.GuiceActionGroup.text=Google Guice
group.guice.inspections.name=Guice
guice.intentions=Guice
gutter.choose.injected.point=Выберите точку внедрения
gutter.navigate.to.injection.point=Перейти к точке внедрения
interception.annotation.without.runtime.retention.display.name=Аннотация перехвата без сохранения во время выполнения
interception.annotation.without.runtime.retention.problem.descriptor=Аннотация \#ref не имеет сохранения во время выполнения \#loc
invalid.implemented.by.display.name=Недействительная аннотация @ImplementedBy
invalid.implemented.by.problem.descriptor=Класс \#ref не реализует аннотированный класс \#loc
invalid.provided.by.display.name=Недействительная аннотация @ProvidedBy
invalid.provided.by.problem.descriptor=Класс \#ref не предоставляет аннотированный класс \#loc
invalid.request.parameters.display.name=Неверный тип параметров для @RequestParameters
invalid.request.parameters.problem.descriptor=Переменная или параметр, помеченные как \#ref, должны иметь тип Map<String, String[]> \#loc
make.injection.mandatory=Сделать аннотацию обязательной
make.injection.optional=Сделать аннотацию опциональной
move.binding.scope.to.class.family.name=Переместить область видимости привязки в класс
move.binding.scope.to.class.text=Переместить область видимости привязки в класс
move.binding.to.class.family.name=Переместить привязку в класс
move.binding.to.class.text=Переместить привязку в класс
move.provider.binding.to.class.family.name=Переместить привязку провайдера в класс
move.provider.binding.to.class.text=Переместить привязку провайдера в класс
multiple.binding.annotations.display.name=Несколько аннотаций привязки для переменной
multiple.binding.annotations.problem.descriptor=Переменная \#ref имеет несколько аннотаций привязки \#loc
multiple.injected.constructors.for.class.display.name=Класс имеет несколько конструкторов с @Inject
multiple.injected.constructors.for.class.problem.descriptor=Класс \#ref имеет несколько конструкторов с @Inject \#loc
new.guice.binding.annotation.action.name=Создать аннотацию привязки Guice
new.guice.binding.annotation.error=Не удалось создать аннотацию привязки Guice
new.guice.binding.annotation.name=Создать аннотацию привязки Guice\: {0}.{1}
new.guice.method.interceptor.action.name=Создать перехватчик метода Guice
new.guice.method.interceptor.error=Не удалось создать перехватчик метода Guice
new.guice.method.interceptor.name=Создать перехватчик метода Guice\: {0}.{1}
new.guice.module.action.name=Создать модуль Guice
new.guice.module.error=Не удалось создать модуль Guice
new.guice.module.name=Создать модуль Guice\: {0}.{1}
new.guice.provider=Новый провайдер Guice
new.guice.provider.action.name=Создать провайдер Guice
new.guice.provider.error=Не удалось создать провайдер Guice
new.guice.provider.name=Создать провайдер Guice\: {0}.{1}
new.guice.scope.annotation.action.name=Создать аннотацию области видимости Guice
new.guice.scope.annotation.error=Не удалось создать аннотацию области видимости Guice
pointless.binding.display.name=Бесполезная привязка
pointless.binding.problem.descriptor=Привязка не нужна и может быть удалена \#loc
provider.class.name=Имя класса провайдера\:
redundant.scope.binding.display.name=Избыточная привязка области видимости
redundant.scope.binding.problem.descriptor=Избыточная привязка с областью видимости \#ref \#loc
redundant.to.binding.display.name=Избыточная привязка
redundant.to.binding.problem.descriptor=Избыточная привязка к классу \#ref \#loc
redundant.to.provider.binding.display.name=Избыточная привязка провайдера
redundant.to.provider.binding.problem.descriptor=Избыточная привязка к классу \#ref \#loc
select.provided.class=Выберите класс для предоставления
session.scoped.injects.request.scoped.display.name=Компонент @SessionScoped внедряет компонент @RequestScoped
session.scoped.injects.request.scoped.problem.descriptor=@Inject класса @RequestScoped \#ref происходит из класса @SessionScoped \#loc
singleton.injects.scoped.display.name=Компонент @Singleton внедряет компонент с областью видимости
singleton.injects.scoped.problem.descriptor=@Inject класса с областью видимости \#ref происходит из класса @Singleton \#loc
toggle.injection.required.family.name=Переключить внедрение
toggle.required=Переключить 'optional'
uninstantiable.binding.display.name=Невозможно создать экземпляр привязки
uninstantiable.binding.problem.descriptor=Невозможно создать экземпляр класса \#ref, поэтому он не может быть привязан \#loc
uninstantiable.implemented.by.class.display.name=Невозможно создать экземпляр класса @ImplementedBy
uninstantiable.implemented.by.class.problem.descriptor=Невозможно создать экземпляр класса \#ref, поэтому он не может быть @ImplementedBy \#loc
uninstantiable.provided.by.class.display.name=Невозможно создать экземпляр класса @ProvidedBy
uninstantiable.provided.by.class.problem.descriptor=Невозможно создать экземпляр класса \#ref, поэтому он не может быть @ProvidedBy \#loc
unnecessary.static.injection.display.name=Ненужное статическое внедрение
unnecessary.static.injection.problem.descriptor=Класс \#ref не имеет статических членов с @Inject \#loc