action.AddToISuite.text=Добавить в набор шаблонов JUnit
action.excludeFromSuite.text=Исключить из набора
action.text.test.category=Тесты {0}
action.text.test.tags=Тесты {0}
action.text.test.unknown.target=Неизвестно
cannot.browse.test.inheritors.dialog.title=Невозможно просмотреть наследников TestCase
category.interface.dialog.title=Интерфейс категории
category.is.not.specified.error.message=Категория не указана
category.label=Категория
change.list.label=Список изменений
class.isnt.inheritor.of.testcase.error.message={0} не является наследником TestCase
class.not.test.error.message=Класс ''{0}'' не является тестом
combobox.changelists.all=Все
configuration.not.specified.message=Не указан тип конфигурации теста\: {0}
create.setup.dialog.message=Метод setUp уже существует, но не аннотирован как {0}. Добавить аннотацию?
create.setup.dialog.title=Создать метод setUp
default.junit.config.empty.category=Недействительно
default.junit.config.name.all.in.module=Все в {0}
default.junit.config.name.all.in.package.in.module={0} в {1}
default.junit.config.name.category=@Category({0})
default.junit.config.name.tags=Теги ({0})
default.junit.config.name.temp.suite=Временный набор
default.junit.config.name.whole.project=Весь проект
default.junit.configuration.name=<без имени>
dialog.message.failed.to.resolve.maven.id=Не удалось разрешить {0}
dialog.message.no.unique.id.specified.exception=Не указан уникальный ID
dialog.title.preparing.test=Подготовка теста
directory.0.is.not.found.error.message=Каталог ''{0}'' не найден
directory.is.not.specified.error.message=Каталог не указан
directory.label=Каталог
directory.not.found.error.message=Каталог ''{0}'' не найден
expected.exception.never.thrown.display.name=Ожидаемое исключение никогда не выбрасывается в теле тестового метода
expected.exception.never.thrown.problem.descriptor=Ожидаемое <code>\#ref</code> никогда не выбрасывается в теле ''{0}()'' \#loc
fix.data.provider.create.method.fix.name=Создать метод-поставщик данных '@Parameters public static Iterable<Object> parameters()'
fix.data.provider.multiple.methods.problem=В классе <code>\#ref</code> присутствует несколько методов-поставщиков данных с @Parameters
fix.data.provider.signature.family.name=Исправить сигнатуру метода-поставщика данных
fix.data.provider.signature.fix.name=Изменить сигнатуру метода на ''{0}''
fix.data.provider.signature.incorrect.problem=Метод-поставщик данных <code>\#ref()</code> имеет неверную сигнатуру
fix.data.provider.signature.missing.method.problem=В параметризованном тестовом классе <code>\#ref</code> отсутствует метод-поставщик данных с аннотацией '@Parameters'
fork.mode.label=Режим форка [&F]\:
fork.mode.name=Режим форка
inspection.parameterized.parameters.static.collection.display.name=Параметризованный тестовый класс без метода-поставщика данных
junit.config.with.parameter.0=\ с параметром "{0}"
junit.configuration.across.module.dependencies.radio=По зависимостям модулей
junit.configuration.class.label=Класс\:
junit.configuration.description=Конфигурация теста JUnit
junit.configuration.display.name=JUnit
junit.configuration.fork.mode.class=Класс
junit.configuration.fork.mode.method=Метод
junit.configuration.fork.mode.none=Нет
junit.configuration.fork.mode.repeat=Повтор
junit.configuration.in.single.module.radio=В одном модуле
junit.configuration.in.whole.project.radio=Во всем проекте
junit.configuration.kind.all.in.directory=Все в каталоге
junit.configuration.kind.all.in.package=Все в пакете
junit.configuration.kind.by.pattern=Шаблон
junit.configuration.kind.by.tags=Теги
junit.configuration.kind.by.unique.id=UniqueId
junit.configuration.kind.category=Категория
junit.configuration.kind.class=Класс
junit.configuration.kind.method=Метод
junit.configuration.method.label=Метод\:
junit.configuration.package.label=Пакет\:
junit.configuration.repeat.mode.n.times=N раз
junit.configuration.repeat.mode.once=Один раз
junit.configuration.repeat.mode.until.failure=До ошибки
junit.configuration.repeat.mode.until.stopped=До остановки
junit.configuration.repeat.mode.until.success=До успеха
junit.configuration.search.for.tests.label=Поиск тестов\:
junit.entry.point.suggest.package.private.visibility.junit5=Предлагать уровень видимости package-private для тестов junit 5
junit.inspections.group.name=JUnit
junit.not.found.in.module.error.message=JUnit не найден в модуле ''{0}''
junit3.style.test.method.in.junit4.class.display.name=Тестовый метод в старом стиле JUnit в классе JUnit 4
junit3.style.test.method.in.junit4.class.problem.descriptor=Тестовый метод в старом стиле <code>\#ref()</code> в классе JUnit 4 \#loc
junit5.migration.description=При переносе аннотаций тестов JUnit 4 на новые jupiter-аннотации может появиться красный код\! Assertions не будут перенесены. Для автоматической миграции только тех тестов, которые могут быть полностью преобразованы, см. инспекцию 'Java | JUnit issues | JUnit 4 test can be JUnit 5'.
jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()' может быть заменен на 'assertSame()'
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>\#ref()</code> может быть заменен на 'assertSame()' \#loc
jvm.inspections.junit.assertequals.on.array.display.name='assertEquals()' вызван для массива
jvm.inspections.junit.assertequals.on.array.problem.descriptor=<code>\#ref()</code> вызван для массива \#loc
jvm.inspections.junit.ignored.test.class.problem.descriptor=Тестовый класс ''{0}'' игнорируется/отключен {1, choice, 1\#|2\#без причины} \#loc
jvm.inspections.junit.ignored.test.display.name=JUnit тест с аннотацией '@Ignore'/'@Disabled'
jvm.inspections.junit.ignored.test.ignore.reason.option=Сообщать только об аннотациях без причины
jvm.inspections.junit.ignored.test.method.problem.descriptor=Тестовый метод ''{0}()'' игнорируется/отключен {1, choice, 1\#|2\#без причины} \#loc
jvm.inspections.junit.malformed.annotated.double.descriptor={0, choice, 0\#Поле|1\#Метод} <code>\#ref</code> с аннотацией ''@{1}'' должен быть {2} и {3}
jvm.inspections.junit.malformed.annotated.double.typed.descriptor={0, choice, 0\#Поле|1\#Метод} <code>\#ref</code> с аннотацией ''@{1}'' должен быть {2}, {3} и иметь тип ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=Метод <code>\#ref</code> с аннотацией ''@{0}'' должен быть {1}, {2} и не должен объявлять параметры ''{3}'' и ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=Метод <code>\#ref</code> с аннотацией ''@{0}'' должен быть {1}, {2} и не должен объявлять параметр ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=Метод <code>\#ref</code> с аннотацией ''@{0}'' должен быть {1}, {2}, иметь тип ''{3}'' и не должен объявлять параметры {4} и ''{5}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=Метод <code>\#ref</code> с аннотацией ''@{0}'' должен быть {1}, {2}, иметь тип ''{3}'' и не должен объявлять параметр ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=Метод <code>\#ref</code> с аннотацией ''@{0}'' не должен объявлять параметры {1} и ''{2}''
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=Метод <code>\#ref</code> с аннотацией ''@{0}'' не должен объявлять параметр ''{1}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=Метод <code>\#ref</code> с аннотацией ''@{0}'' должен быть {1} и не должен объявлять параметры ''{2}'' и ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=Метод <code>\#ref</code> с аннотацией ''@{0}'' должен быть {1} и не должен объявлять параметр ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=Метод <code>\#ref</code> с аннотацией ''@{0}'' должен быть {1}, иметь тип ''{2}'' и не должен объявлять параметры {3} и ''{4}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=Метод <code>\#ref</code> с аннотацией ''@{0}'' должен быть {1}, иметь тип ''{2}'' и не должен объявлять параметр ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=Метод <code>\#ref</code> с аннотацией ''@{0}'' должен иметь тип ''{1}'' и не должен объявлять параметры {2} и ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=Метод <code>\#ref</code> с аннотацией ''@{0}'' должен иметь тип ''{1}'' и не должен объявлять параметр ''{2}''
jvm.inspections.junit.malformed.annotated.single.descriptor={0, choice, 0\#Поле|1\#Метод} <code>\#ref</code> с аннотацией ''@{1}'' должен быть {2}
jvm.inspections.junit.malformed.annotated.single.typed.descriptor={0, choice, 0\#Поле|1\#Метод} <code>\#ref</code> с аннотацией ''@{1}'' должен быть {2} и иметь тип ''{3}''
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=Метод <code>\#ref</code> с аннотацией ''@{0}'' не должен быть suspend-функцией
jvm.inspections.junit.malformed.annotated.typed.descriptor={0, choice, 0\#Поле|1\#Метод} <code>\#ref</code> с аннотацией ''@{1}'' должен иметь тип ''{2}''
jvm.inspections.junit.malformed.declaration.name=Некорректное объявление JUnit
jvm.inspections.junit.malformed.extension.class.level.descriptor={0} должен быть зарегистрирован на уровне класса
jvm.inspections.junit.malformed.fix.class.signature=Исправить сигнатуру класса
jvm.inspections.junit.malformed.fix.class.signature.descriptor=Исправить сигнатуру класса ''{0}''
jvm.inspections.junit.malformed.fix.class.signature.multi=Исправить сигнатуры классов
jvm.inspections.junit.malformed.fix.field.signature=Исправить сигнатуру поля
jvm.inspections.junit.malformed.fix.field.signature.descriptor=Исправить сигнатуру поля ''{0}''
jvm.inspections.junit.malformed.fix.method.signature=Исправить сигнатуру метода
jvm.inspections.junit.malformed.fix.method.signature.descriptor=Исправить сигнатуру метода ''{0}''
jvm.inspections.junit.malformed.missing.nested.annotation.descriptor=Тесты во вложенном классе не будут выполнены
jvm.inspections.junit.malformed.no.arg.descriptor=Метод <code>\#ref</code> должен быть {0}, {1}{2, choice, 0\# и не иметь параметров|1\#, не иметь параметров и иметь тип void}
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=Игнорировать тестовый параметр, если он аннотирован\:
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=Дублирующееся имя константы 'enum'
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' не может предоставить аргумент методу, так как метод имеет неподдерживаемый параметр типа ''{1}''
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=Должен быть предоставлен ровно один тип входных данных
jvm.inspections.junit.malformed.param.file.source.descriptor=Не удаётся разрешить источник файла\: ''{0}''
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=Не найдено неявное преобразование из ''{0}'' в ''{1}''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=Метод-источник ''{0}'' не должен иметь параметров
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=Метод-источник ''{0}'' должен иметь один из следующих типов возвращаемого значения\: ''Stream<?>'', ''Iterator<?>'', ''Iterable<?>'' или ''Object[]''
jvm.inspections.junit.malformed.param.method.source.static.descriptor=Метод-источник ''{0}'' должен быть static
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=Не удаётся разрешить целевой источник метода\: ''{0}''
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=''@{0}'' может предоставить только один параметр
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=Источники не предоставлены, набор тестов будет пустым
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=Не определен источник значений
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=Не удаётся разрешить ссылку на константу 'enum'
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=Множественные параметры должны быть обернуты в 'Arguments'
jvm.inspections.junit.malformed.repetition.number.descriptor=Количество повторений должно быть больше нуля
jvm.inspections.junit.malformed.source.without.params.descriptor=''@{0}'' не может предоставить аргумент методу, так как метод не имеет параметров
jvm.inspections.junit.malformed.suspend.function.descriptor=Метод <code>\#ref</code> не должен быть suspend-функцией
jvm.inspections.junit.malformed.test.combination.descriptor=Подозрительная комбинация {0} и ''@{1}''
jvm.inspections.junit.mixed.annotations.junit.descriptor=Метод <code>\#ref()</code> с аннотацией ''@{0}'' внутри класса, наследующего JUnit {1} TestCase \#loc
jvm.inspections.junit.mixed.annotations.name=Использование API JUnit разных версий в одном TestCase
jvm.inspections.junit3.super.teardown.display.name=JUnit 3 'super.tearDown()' не вызывается из блока 'finally'
jvm.inspections.junit3.super.teardown.problem.descriptor=<code>\#ref()</code> не вызывается из блока 'finally' \#loc
jvm.inspections.junit4.converter.display.name=Тест JUnit 3 может быть преобразован в JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=<code>\#ref</code> может быть преобразован в тестовый случай JUnit4
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=Вызов метода {0} не будет компилироваться после преобразования {1} в JUnit 4
jvm.inspections.junit4.converter.quickfix.conflict.name=У метода {0} возникнет конфликт имен с его super методом
jvm.inspections.junit4.converter.quickfix.conflict.semantics=Вызов метода {0} может изменить семантику при преобразовании {1} в JUnit 4
jvm.inspections.junit4.converter.quickfix.conflict.suite=Миграция метода suite для {0} имеет побочные эффекты, которые будут удалены
jvm.inspections.junit4.converter.quickfix.name=Преобразовать в тестовый случай JUnit 4
jvm.inspections.junit4.inherited.runwith.display.name=Аннотация '@RunWith' уже существует в родительском классе
jvm.inspections.junit4.inherited.runwith.problem.descriptor=Аннотация '@RunWith' уже существует в классе {0}
jvm.inspections.junit5.assertions.converter.display.name=Устаревшие утверждения JUnit 5
jvm.inspections.junit5.assertions.converter.familyName=Заменить на совместимый с JUnit 5 вызов
jvm.inspections.junit5.assertions.converter.problem.descriptor=Вызов <code>\#ref()</code> из ''{0}'' следует заменить вызовом метода из ''{1}'' \#loc
jvm.inspections.junit5.assertions.converter.quickfix=Заменить на вызов метода ''{0}''
jvm.inspections.junit5.converter.display.name=Тест JUnit 4 может быть преобразован в JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=\#ref может быть тестом JUnit 5
jvm.inspections.junit5.converter.quickfix=Мигрировать на JUnit 5
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=Класс {0} не может быть преобразован в JUnit 5 из-за несовместимых наследников\: {1}
jvm.inspections.junit5.converter.quickfix.presentation.text=Преобразовать утверждения
jvm.inspections.migrate.assert.to.matcher.description=Выражение утверждения <code>\#ref</code> может быть заменено вызовом ''{0}'' \#loc
jvm.inspections.migrate.assert.to.matcher.option=Статически импортовать методы matcher'а
jvm.inspections.migrate.assertion.name=Утверждение JUnit может быть вызовом 'assertThat()'
jvm.inspections.unconstructable.test.case.junit3.descriptor=Тестовый класс <code>\#ref</code> не может быть создан, так как у него нет 'public' конструктора без параметров или с одним параметром 'String' \#loc
jvm.inspections.unconstructable.test.case.junit4.descriptor=Тестовый класс <code>\#ref</code> не может быть создан, так как он должен иметь ровно один 'public' конструктор без параметров \#loc
jvm.inspections.unconstructable.test.case.not.public.descriptor=Тестовый класс <code>\#ref</code> не может быть создан, так как он не 'public' \#loc
method.name.not.specified.error.message=Имя метода не указано
module.does.not.exists=Модуль ''{0}'' не существует в проекте ''{1}''
module.to.choose.classpath.not.specified.error.message=Не указан модуль для выбора classpath
multiple.exceptions.declared.on.test.method.display.name=Несколько исключений объявлено в тестовом методе
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>\#ref</code> может быть заменено на 'throws Exception' \#loc
no.module.selected.error.message=Модуль не выбран
no.pattern.error.message=Шаблон не выбран
no.test.class.specified.error.text=Тестовый класс не указан
package.does.not.exist.error.message=Пакет ''{0}'' не существует
pattern.label=Шаблон
progress.title.download.additional.dependencies=Загрузка дополнительных зависимостей…
repeat.count.label=Количество повторов [&R]\:
repeat.label=Повторить [&R]\:
repeat.name=Повторить
running.tests.disabled.during.index.update.error.message=Запуск тестов отключен во время обновления индекса
search.scope.module=В одном модуле
search.scope.module.deps=По зависимостям модуля
search.scope.name=Поиск тестов
search.scope.project=Во всем проекте
tag.expression.label=Выражение тега
tag.name.0.must.be.syntactically.valid.warning=Имя тега [{0}] должно быть синтаксически корректным
tags.are.not.specified.error.message=Теги не указаны
test.class.hint=Полное имя класса, содержащего тесты
test.discovery.by.all.changes.combo.item=Все
test.group=Тесты
test.kind.hint=Тип ресурса для поиска тестов
test.method.doesnt.exist.error.message=Тестовый метод ''{0}'' не существует
test.method.hint=Полное имя тестового метода
test.package.hint=Имя пакета, содержащего тесты
test.pattern.hint=Регулярное выражение для сопоставления имен классов, содержащих тесты
uniqueid.label=UniqueId
unused.declaration.junit.test.entry.point=Тестовые случаи JUnit
usage.of.obsolete.assert.display.name=Использование устаревшего метода 'junit.framework.Assert'
use.of.obsolete.assert.problem.descriptor=Вызов <code>\#ref()</code> из ''{0}'' следует заменить вызовом метода из ''org.junit.Assert'' \#loc
use.of.obsolete.assert.quickfix=Заменить на вызов метода 'org.junit.Assert'