ACT.CMD.use.import=Использовать импортованный модуль
ACT.from.some.module.import=Импортовать из…
ACT.qualify.with.module=Уточнить импортованным модулем
ANN.assign.to.none=Присваивание None
ANN.assignment.expression.as.a.target=Выражение присваивания не может использоваться здесь в качестве цели
ANN.assignment.expression.in.an.iterable=Выражение присваивания не может использоваться в итерируемом объекте включения
ANN.assignment.expressions.within.a.comprehension.cannot.be.used.in.a.class.body=Выражения присваивания внутри включения не могут использоваться в теле класса
ANN.assignment.to.keyword=Присваивание ключевому слову
ANN.await.outside.async.function='await' вне асинхронной функции
ANN.break.outside.loop='break' вне цикла
ANN.can.t.use.starred.expression.here=Невозможно использовать выражение со звездочкой здесь
ANN.cannot.assign.to.debug=Невозможно присвоить значение __debug__
ANN.cant.assign.to.await.expr=Невозможно присвоить значение выражению await
ANN.cant.assign.to.call=Невозможно присвоить значение вызову функции
ANN.cant.assign.to.comprh=Невозможно присвоить значение списковому включению
ANN.cant.assign.to.dict.comprh=Невозможно присвоить значение словарному включению
ANN.cant.assign.to.generator=Невозможно присвоить значение выражению генератора
ANN.cant.assign.to.lambda=Невозможно присвоить значение lambda
ANN.cant.assign.to.literal=Невозможно присвоить значение литералу
ANN.cant.assign.to.operator=Невозможно присвоить значение оператору
ANN.cant.assign.to.parens=Невозможно присвоить значение ()
ANN.cant.assign.to.set.comprh=Невозможно присвоить значение множественному включению
ANN.cant.aug.assign.starred.assignment.target.must.be.in.list.or.tuple=Цель присваивания со звездочкой должна находиться в списке или кортеже
ANN.cant.aug.assign.to.comprh=Невозможно выполнить расширенное присваивание списковому включению
ANN.cant.aug.assign.to.dict.comprh=Невозможно выполнить расширенное присваивание словарному включению
ANN.cant.aug.assign.to.generator=Невозможно выполнить расширенное присваивание выражению генератора
ANN.cant.aug.assign.to.list.or.comprh=Невозможно выполнить расширенное присваивание списочному литералу или списковому включению
ANN.cant.aug.assign.to.set.comprh=Невозможно выполнить расширенное присваивание множественному включению
ANN.cant.aug.assign.to.tuple.or.generator=Невозможно выполнить расширенное присваивание кортежному литералу или выражению генератора
ANN.cant.delete.call=Невозможно удалить вызов функции
ANN.cant.delete.literal=Невозможно удалить литерал
ANN.continue.break.or.return.in.star.except='break', 'continue' и 'return' не могут появляться в блоке except*
ANN.continue.outside.loop='continue' вне цикла
ANN.default.except.must.be.last=default 'except\:' должен быть последним
ANN.deleting.none=Удаление None
ANN.duplicate.param.name=повторяющееся имя параметра
ANN.exception.group.in.star.except=ExceptionGroup не может использоваться в except*
ANN.fstrings.illegal.conversion.character=Недопустимый символ преобразования ''{0}''\: должен быть одним из ''s'', ''r'', ''a''
ANN.fstrings.missing.conversion.character=Ожидается символ преобразования\: должен быть одним из 's', 'r', 'a'
ANN.fstrings.single.right.brace.not.allowed.inside.fstrings=Одиночная '}' не допускается внутри f-строк
ANN.generator.expression.must.be.parenthesized.if.not.sole.argument=Выражение генератора должно быть заключено в скобки, если это не единственный аргумент
ANN.ignore.errors.like.this=Игнорировать подобные ошибки
ANN.illegal.target.for.variable.annotation=Недопустимая цель для аннотации переменной
ANN.missing.closing.quote=Отсутствует закрывающая кавычка [{0}]
ANN.missing.closing.triple.quotes=Отсутствуют закрывающие тройные кавычки
ANN.multiple.args=множественные параметры * не допускаются
ANN.multiple.kwargs=множественные параметры ** не допускаются
ANN.multiple.slash=множественные параметры / не допускаются
ANN.name.used.both.as.global.and.param=Имя ''{0}'' используется одновременно как параметр и как глобальная переменная
ANN.named.parameters.after.star=именованные параметры должны следовать после одиночного *
ANN.named.parameters.before.slash=именованные параметры должны предшествовать одиночному /
ANN.no.exception.to.reraise=Нет исключения для повторного возбуждения
ANN.non.default.param.after.default=параметр без значения по умолчанию следует после параметра со значением по умолчанию
ANN.non.empty.return.inside.asynchronous.generator=непустой 'return' внутри асинхронного генератора
ANN.patterns.attribute.name.is.repeated=Имя атрибута ''{0}'' повторяется
ANN.patterns.double.star.pattern.cannot.be.used.outside.mapping.patterns=Шаблон с двумя звездочками не может использоваться вне шаблонов отображения
ANN.patterns.invalid.complex.number.literal=Недопустимый литерал комплексного числа
ANN.patterns.key.pattern.can.only.be.value.or.literal.pattern=Шаблон ключа может быть только шаблоном значения или литеральным шаблоном
ANN.patterns.name.already.bound=Имя ''{0}'' уже связано
ANN.patterns.pattern.does.not.bind.names=Шаблон не связывает {0,choice,1\#имя|2\#имена} {1}
ANN.patterns.pattern.makes.remaining.alternatives.unreachable=Шаблон делает оставшиеся альтернативы недостижимыми
ANN.patterns.pattern.makes.remaining.case.clauses.unreachable=Шаблон делает оставшиеся case-предложения недостижимыми
ANN.patterns.repeated.star.pattern=Повторяющийся шаблон со звездочкой
ANN.patterns.single.star.pattern.cannot.be.used.outside.sequence.patterns=Шаблон с одной звездочкой не может использоваться вне последовательных шаблонов
ANN.python.does.not.support.yield.from.inside.async.functions=Python не поддерживает 'yield from' внутри асинхронных функций
ANN.regular.param.after.keyword=обычный параметр после параметра **
ANN.regular.param.after.vararg=обычный параметр после параметра *
ANN.return.outside.of.function='return' вне функции
ANN.slash.param.after.keyword=параметр / должен предшествовать параметру **
ANN.slash.param.after.vararg=параметр / должен предшествовать параметру *
ANN.star.import.at.top.only='import *' разрешен только на уровне модуля
ANN.starred.param.after.kwparam=параметр * после параметра **
ANN.try.except.can.not.have.except.and.star.except=Оператор try не может содержать одновременно except и except*
ANN.tuple.py3=распаковка кортежных параметров не поддерживается в Python 3
ANN.unparenthesized.assignment.expression.statement=Выражения присваивания без скобок запрещены на верхнем уровне выражения-инструкции
ANN.unparenthesized.assignment.expression.value=Выражения присваивания без скобок запрещены на верхнем уровне правой части инструкции присваивания
ANN.variable.annotation.cannot.be.combined.with.tuple.unpacking=Аннотация переменной не может быть объединена с распаковкой кортежа
ANN.variable.annotation.cannot.be.used.in.assignment.with.multiple.targets=Аннотация переменной не может использоваться в присваивании с несколькими целями
ANN.yield.outside.of.function='yield' вне функции
INSP.GROUP.python=Python
INSP.NAME.abstract.class=Класс должен реализовать все абстрактные методы
INSP.NAME.argument.equal.default=Аргумент функции равен значению параметра по умолчанию
INSP.NAME.assignment.to.loop.or.with.parameter=Присваивания параметру цикла 'for' или оператора 'with'
INSP.NAME.attribute.outside.init=Атрибут экземпляра определен вне `__init__`
INSP.NAME.augment.assignment=Присваивание может быть заменено расширенным присваиванием
INSP.NAME.bad.except.clauses.order=Неправильный порядок предложений 'except'
INSP.NAME.byte.literal=Байтовый литерал содержит не-ASCII символ
INSP.NAME.calling.non.callable=Попытка вызвать необъект
INSP.NAME.chained.comparisons=Слишком сложные цепочки сравнений
INSP.NAME.check.can.be.simplified=Избыточная проверка логической переменной
INSP.NAME.class.has.no.init=Класс не имеет метода `__init__`
INSP.NAME.class.var.variables=Неверное использование переменных ClassVar
INSP.NAME.classic.class.usage=Использование классического стиля классов
INSP.NAME.comparison.with.none=Использование операторов равенства для сравнения с None
INSP.NAME.compatibility=Код несовместим с определёнными версиями Python
INSP.NAME.coroutine.is.not.awaited=Корутина ''{0}'' не ожидается
INSP.NAME.dataclass.definition.and.usages=Неверное определение и использование классов данных
INSP.NAME.decorator.outside.class=Декоратор, специфичный для класса, используется вне класса
INSP.NAME.default.argument=Аргумент по умолчанию является изменяемым
INSP.NAME.deprecated.function.class.or.module=Устаревшая функция, класс или модуль
INSP.NAME.dict.creation=Создание словаря может быть переписано с помощью литерала словаря
INSP.NAME.docstring.types=Тип в docstring не соответствует выведенному типу
INSP.NAME.dunder.slots=Некорректное использование классов с определениями '__slots__'
INSP.NAME.duplicate.keys=Словарь содержит дублирующиеся ключи
INSP.NAME.exception.not.inherit=Исключения не наследуются от стандартного класса 'Exception'
INSP.NAME.final.classes.methods.and.variables=Некорректное использование final классов, методов и переменных
INSP.NAME.first.arg.assign=Первый аргумент метода переназначен
INSP.NAME.from.future.import=Неправильное положение from __future__ import
INSP.NAME.global.undefined=Глобальная переменная не определена на уровне модуля
INSP.NAME.inconsistent.indentation=Непоследовательные отступы
INSP.NAME.incorrect.call.arguments=Некорректные аргументы вызова
INSP.NAME.incorrect.docstring=Некорректный docstring
INSP.NAME.init.return=Метод __init__, возвращающий значение
INSP.NAME.invalid.interpreter=Недействительный интерпретатор
INSP.NAME.invalid.usages.of.override.decorator=Некорректное использование декоратора @override
INSP.NAME.list.creation=Неоптимальное объявление списка
INSP.NAME.mandatory.encoding=Не указано кодование для файла
INSP.NAME.method.may.be.static=Метод не объявлен как static
INSP.NAME.method.over=Сигнатура метода не соответствует сигнатуре переопределяемого метода
INSP.NAME.missing.or.empty.docstring=Отсутствующий или пустой docstring
INSP.NAME.missing.super.constructor=Пропущен вызов '__init__' суперкласса
INSP.NAME.missing.type.hints=Отсутствуют подсказки типов для определения функции
INSP.NAME.nested.decorators=Проблемная вложенность декораторов
INSP.NAME.new.init.signature=Несовместимые сигнатуры __new__ и __init__
INSP.NAME.new.style.generics.type.param.syntax=Некорректное использование параметров типа и псевдонимов типа нового стиля
INSP.NAME.non.ascii=Файл содержит не-ASCII символы
INSP.NAME.none.function.assignment=Присваивание вызовов функций, которые ничего не возвращают
INSP.NAME.oldstyle.class=Класс старого стиля содержит функции класса нового стиля
INSP.NAME.overloads.in.regular.python.files=Перегрузки в обычных Python файлах
INSP.NAME.pep8.naming=Нарушение соглашения об именовании PEP 8
INSP.NAME.problematic.first.parameter=Некорректный первый параметр
INSP.NAME.property.access=Некорректный доступ к свойствам
INSP.NAME.property.definition=Некорректное определение свойства
INSP.NAME.protected.member=Доступ к защищенному члену класса или модуля
INSP.NAME.protocol.definition.and.usages=Некорректные определения и использования протоколов
INSP.NAME.pytest-parametrized=Некорректные аргументы в @pytest.mark.parametrize
INSP.NAME.pytest.unpassed.fixture=Фикстура не запрошена тестовыми функциями
INSP.NAME.redeclaration=Повторно объявленные имена без использования
INSP.NAME.redundant.parentheses=Избыточные скобки
INSP.NAME.relative.import=Подозрительные относительные импорты
INSP.NAME.requirements=Неудовлетворенные требования к пакетам
INSP.NAME.set.function.to.literal=Вызов функции может быть заменен литералом множества
INSP.NAME.shadowing.builtins=Затенение встроенных имен
INSP.NAME.single.quoted.docstring=Docstring в одинарных кавычках
INSP.NAME.statement.effect=Выражение не имеет эффекта
INSP.NAME.str.format=Ошибки в операциях форматования строк
INSP.NAME.too.broad.exception.clauses=Неясные блоки исключений
INSP.NAME.trailing.semicolon=Запрещенная завершающая точка с запятой в выражении
INSP.NAME.tuple.assignment.balance=Некорректный баланс присваивания кортежа
INSP.NAME.tuple.item.assignment=Присваивание элементу кортежа запрещено
INSP.NAME.type.checker=Некорректный тип
INSP.NAME.type.hints=Некорректные определения и использования подсказок типов
INSP.NAME.typed.dict=Некорректное определение и использование TypedDict
INSP.NAME.unbound=Несвязанные локальные переменные
INSP.NAME.unnecessary.backslash=Ненужный обратный слеш
INSP.NAME.unreachable.code=Недостижимый код
INSP.NAME.unresolved.refs=Неразрешённые ссылки
INSP.NAME.unused=Неиспользуемые локальные символы
INSP.NAME.wrong.super.arguments=Неверные аргументы при вызове super
INSP.abstract.class.add.to.superclasses=Добавить ''{0}'' в суперклассы
INSP.abstract.class.class.must.implement.all.abstract.methods=Класс {0} должен реализовать все абстрактные методы
INSP.abstract.class.set.as.metaclass=Установить ''{0}'' как метакласс
INSP.argument.equals.to.default=Аргумент равен значению параметра по умолчанию
INSP.arguments.not.declared.but.provided.by.decorator=Следующие аргументы не объявлены, но предоставлены декоратором\: {0}
INSP.assignment.can.be.replaced.with.augmented.assignment=Присваивание может быть заменено составным присваиванием
INSP.assignment.to.loop.or.with.parameter=Переменная ''{0}'' уже объявлена в цикле ''for'' или операторе ''with'' выше
INSP.async.call=Отсутствует синтаксис `await` в вызовах корутин
INSP.attribute.outside.init=Атрибут экземпляра {0} определен вне __init__
INSP.auto.to.manual.field.numbering=Невозможно переключиться с автоматической нумерации полей на ручную спецификацию
INSP.bad.except.exception.class.already.caught=Класс исключения ''{0}'' уже был перехвачен
INSP.bad.except.superclass.of.exception.class.already.caught=''{0}'', суперкласс класса исключения ''{1}'', уже был перехвачен
INSP.byte.literal.contains.illegal.characters=Байтовый литерал содержит символы > 255
INSP.cant.return.value.from.init=Невозможно вернуть значение из __init__
INSP.chained.comparisons.ignore.statements.with.constant.in.the.middle=Игнорировать выражения с константой в середине
INSP.class.has.no.init=У класса нет метода __init__
INSP.class.is.not.subtype.of.class=''{0}'' не является экземпляром или подклассом ''{1}''
INSP.class.object.is.not.callable=Объект ''{0}'' не является вызываемым
INSP.class.var.can.be.used.only.in.class.body='ClassVar' может использоваться только для присваиваний в теле класса
INSP.class.var.can.not.be.assigned.to.instance=Невозможно присвоить классовую переменную ''{0}'' через экземпляр
INSP.class.var.can.not.be.used.in.annotation.for.function.return.value='ClassVar' нельзя использовать в аннотации для возвращаемого значения функции
INSP.class.var.can.not.be.used.in.annotations.for.function.parameters='ClassVar' нельзя использовать в аннотациях для параметров функции
INSP.class.var.can.not.be.used.in.function.body='ClassVar' нельзя использовать в аннотациях для локальных переменных
INSP.class.var.can.not.include.type.variables=Параметр 'ClassVar' не может включать переменные типа
INSP.class.var.can.not.override.class.variable=Невозможно переопределить классовую переменную ''{0}'' (ранее объявленную в базовом классе ''{1}'') переменной экземпляра
INSP.class.var.can.not.override.instance.variable=Невозможно переопределить переменную экземпляра ''{0}'' (ранее объявленную в базовом классе ''{1}'') классовой переменной
INSP.classic.class.usage.old.style.class=Класс старого стиля
INSP.classic.class.usage.old.style.class.ancestors=Класс старого стиля, так как все классы, от которых он наследуется, являются классами старого стиля
INSP.comparison.with.none.performed.with.equality.operators=Сравнение с None выполнено с помощью операторов равенства
INSP.compatibility.basestring.type.not.available.in.py3=тип basestring недоступен в Python 3
INSP.compatibility.check.for.compatibility.with.python.versions=Проверить совместимость с версиями Python\:
INSP.compatibility.feature.allow.async.and.await.as.names=разрешить использование 'async' и 'await' в качестве имен
INSP.compatibility.feature.allow.backslashes.in.f-strings=разрешить обратные слеши внутри частей выражений f-строк
INSP.compatibility.feature.allow.deep.expression.nesting.in.f-strings=разрешить вложение выражений в спецификаторах формата на такую глубину
INSP.compatibility.feature.allow.duplicate.kwargs=разрешить дублирующиеся **выражения
INSP.compatibility.feature.allow.duplicate.positional.varargs=разрешить дублирующиеся *выражения
INSP.compatibility.feature.allow.keyword.arguments.after.kwargs=разрешить именованные аргументы после **выражения
INSP.compatibility.feature.allow.new.lines.in.f-strings=разрешить новые строки в частях выражений не-тройных f-строк
INSP.compatibility.feature.allow.positional.arguments.after.expression=разрешить позиционные аргументы после *выражения
INSP.compatibility.feature.allow.quote.reuse.in.f-strings=разрешить вложение строковых литералов с одинаковым типом кавычек внутри f-строк
INSP.compatibility.feature.allow.to.mix.bytes.and.non.bytes.literals=разрешить смешивание байтовых и небайтовых литералов
INSP.compatibility.feature.allow.trailing.comma.after.kwargs=разрешает завершающую запятую после **выражения
INSP.compatibility.feature.allow.trailing.comma.after.positional.vararg=разрешает завершающую запятую после *выражения
INSP.compatibility.feature.have.method=имеет метод {0}
INSP.compatibility.feature.have.module=имеет модуль {0}
INSP.compatibility.feature.have.module.builtin=имеет модуль __builtin__
INSP.compatibility.feature.have.module.builtins=имеет модуль builtins
INSP.compatibility.feature.have.nonlocal.keyword=имеет ключевое слово nonlocal
INSP.compatibility.feature.have.type.long=имеет тип long. Используйте int вместо этого.
INSP.compatibility.feature.line.comments.in.f-strings=разрешает комментарии внутри выражений в f-строках
INSP.compatibility.feature.support.arbitrary.expressions.as.decorator=поддерживает произвольные выражения в качестве декоратора
INSP.compatibility.feature.support.assignment.expressions=поддерживает выражения присваивания
INSP.compatibility.feature.support.backquotes=поддерживает обратные кавычки, используйте repr() вместо этого
INSP.compatibility.feature.support.continue.inside.finally.clause=поддерживает 'continue' внутри блока 'finally'
INSP.compatibility.feature.support.diamond.operator=поддерживает <>, используйте \!\= вместо этого
INSP.compatibility.feature.support.ellipsis.outside.slices=поддерживает '...' вне срезов последовательностей
INSP.compatibility.feature.support.long.integer.literal.suffix=поддерживает суффикс ''{0}''
INSP.compatibility.feature.support.match.statements=поддерживает операторы match
INSP.compatibility.feature.support.matrix.multiplication.operators=поддерживает операторы матричного умножения
INSP.compatibility.feature.support.old.style.octal.literals=поддерживает этот синтаксис. Для восьмеричных литералов требуется префикс '0o'
INSP.compatibility.feature.support.parenthesized.context.expressions=поддерживает контекстные выражения в скобках
INSP.compatibility.feature.support.positional.only.parameters=поддерживает параметры только по позиции
INSP.compatibility.feature.support.print.statement=поддерживает этот синтаксис. Оператор print заменен функцией print()
INSP.compatibility.feature.support.raise.with.no.arguments.outside.except.block=поддерживает этот синтаксис. Raise без аргументов можно использовать только в блоке except
INSP.compatibility.feature.support.starred.except.part=поддерживает часть except*
INSP.compatibility.feature.support.starred.expressions.as.assignment.targets=поддерживает starred-выражения как цели присваивания
INSP.compatibility.feature.support.starred.expressions.in.dicts=поддерживает starred-выражения в словарях
INSP.compatibility.feature.support.starred.expressions.in.subscriptions=поддерживает starred-выражения в подписках
INSP.compatibility.feature.support.starred.expressions.in.tuples.lists.and.sets=поддерживает starred-выражения в кортежах, списках и множествах
INSP.compatibility.feature.support.starred.expressions.in.type.annotations=поддерживает starred-выражения в аннотациях типов
INSP.compatibility.feature.support.string.literal.prefix=поддерживает префикс ''{0}''
INSP.compatibility.feature.support.super.without.arguments=поддерживает этот синтаксис. super() должен иметь аргументы в Python 2
INSP.compatibility.feature.support.this.syntax=поддерживает этот синтаксис
INSP.compatibility.feature.support.this.syntax.in.list.comprehensions=поддерживает этот синтаксис в списковых включениях
INSP.compatibility.feature.support.type.alias.statements=поддерживает выражения псевдонимов типов
INSP.compatibility.feature.support.underscores.in.numeric.literals=поддерживает подчеркивания в числовых литералах
INSP.compatibility.feature.support.unpacking.without.parentheses.in.return.statements=поддерживает распаковку без скобок в операторах return
INSP.compatibility.feature.support.unpacking.without.parentheses.in.yield.statements=поддерживает распаковку без скобок в операторах yield
INSP.compatibility.feature.support.variable.annotations=поддерживает аннотации переменных
INSP.compatibility.feature.support.yield.from=поддерживает этот синтаксис. Делегирование подгенератору доступно с Python 3.3; используйте явную итерацию по подгенератору.
INSP.compatibility.inspection.unsupported.feature.prefix=Python {0,choice,1\#версия|2\#версии} {1} {0,choice,1\#не|2\#не} {2}
INSP.compatibility.keyword.argument.repeated=Повторяющийся именованный аргумент
INSP.compatibility.new.union.syntax.not.available.in.earlier.version=позволяет записывать объединенные типы как X | Y
INSP.compatibility.old.dict.methods.not.available.in.py3=Методы dict.iterkeys(), dict.iteritems() и dict.itervalues() недоступны в Python 3
INSP.compatibility.positional.argument.after.keyword.argument=Позиционный аргумент после именованного аргумента
INSP.compatibility.positional.argument.after.kwargs=Позиционный аргумент после **выражения
INSP.compatibility.pre35.versions.do.not.allow.return.with.argument.inside.generator=Версии Python < 3.3 не позволяют использовать 'return' с аргументом внутри генератора.
INSP.compatibility.support.equality.signs.in.fstrings=поддерживает знаки равенства в f-строках
INSP.compatibility.this.syntax.available.only.since.py3=Этот синтаксис доступен только начиная с Python 3
INSP.dataclasses.argument.ignored.if.class.already.defines.method=''{0}'' игнорируется, если класс уже определяет метод ''{1}''
INSP.dataclasses.attribute.default.set.using.method=Значение по умолчанию установлено с помощью ''{0}''
INSP.dataclasses.attribute.lacks.type.annotation=Атрибут ''{0}'' не имеет аннотации типа
INSP.dataclasses.attribute.useless.until.post.init.declared=Атрибут ''{0}'' бесполезен, пока не объявлен ''__post_init__''
INSP.dataclasses.attrs.post.init.should.not.take.any.parameters.except.self='__attrs_post_init__' не должен принимать никаких параметров, кроме 'self'
INSP.dataclasses.attrs.post.init.would.not.be.called.until.init.parameter.set.to.true='__attrs_post_init__' не будет вызван, пока параметр 'init' не установлен в True
INSP.dataclasses.cannot.specify.both.default.and.default.factory=Нельзя указывать одновременно 'default' и 'default_factory'
INSP.dataclasses.cannot.specify.both.default.and.factory=Нельзя указывать одновременно 'default' и 'factory'
INSP.dataclasses.eq.must.be.true.if.order.true='eq' должен быть true, если 'order' равен true
INSP.dataclasses.field.cannot.have.default.factory=Поле не может иметь фабрику по умолчанию
INSP.dataclasses.frozen.attribute.should.be.false.if.class.defines.setattr.or.delattr='frozen' должен быть False, если класс определяет '__setattr__' или '__delattr__'
INSP.dataclasses.frozen.dataclasses.can.not.inherit.non.frozen.one=Замороженные dataclass не могут наследовать незамороженные и наоборот
INSP.dataclasses.hash.ignored.if.class.already.defines.cmp.or.order.or.frozen.parameters='__hash__' игнорируется, если класс уже определяет параметры 'cmp/order' и 'frozen'
INSP.dataclasses.method.is.ignored.if.class.already.defines.parameter=''{0}'' игнорируется, если класс уже определяет параметр ''{1}''
INSP.dataclasses.method.should.be.called.on.attrs.instances=Метод ''{0}'' должен вызываться на экземплярах attrs
INSP.dataclasses.method.should.be.called.on.attrs.types=Метод ''{0}'' должен вызываться на типах attrs
INSP.dataclasses.method.should.be.called.on.dataclass.instances=Метод ''{0}'' должен вызываться на экземплярах dataclass
INSP.dataclasses.method.should.be.called.on.dataclass.instances.or.types=Метод ''{0}'' должен вызываться на экземплярах или типах dataclass
INSP.dataclasses.method.should.take.only.n.parameter=''{0}'' должен принимать только {1} {1,choice,1\#параметр|2\#параметра|3\#параметров}
INSP.dataclasses.mutable.attribute.default.not.allowed.use.default.factory=Изменяемое значение по умолчанию ''{0}'' не допускается. Используйте ''default_factory''
INSP.dataclasses.object.attribute.read.only=Атрибут ''{1}'' объекта ''{0}'' доступен только для чтения
INSP.dataclasses.object.could.have.no.attribute.because.it.declared.as.init.only=Объект ''{0}'' не может иметь атрибут ''{1}'', так как он объявлен как init-only
INSP.dataclasses.operator.not.supported.between.instances.of.class=''{0}'' не поддерживается между экземплярами ''{1}''
INSP.dataclasses.operator.not.supported.between.instances.of.classes=''{0}'' не поддерживается между экземплярами ''{1}'' и ''{2}''
INSP.dataclasses.order.argument.should.be.false.if.class.defines.one.of.order.methods='order' должен быть False, если класс определяет один из методов упорядочивания
INSP.dataclasses.post.init.should.take.all.init.only.variables.in.same.order.they.defined='__post_init__' должен принимать все init-only переменные в том же порядке, в котором они определены
INSP.dataclasses.post.init.should.take.all.init.only.variables.including.inherited.in.same.order.they.defined='__post_init__' должен принимать все init-only переменные (включая унаследованные) в том же порядке, в котором они определены
INSP.dataclasses.post.init.would.not.be.called.until.init.parameter.set.to.true='__post_init__' не будет вызван, пока параметр 'init' не установлен в True
INSP.dataclasses.unsafe.hash.attribute.should.be.false.if.class.defines.hash='unsafe_hash' должен быть False, если класс определяет '__hash__'
INSP.decorator.receives.unexpected.builtin=Этот декоратор не получит ожидаемый callable; встроенный декоратор возвращает специальный объект
INSP.decorators.method.only.decorator.on.method.outside.class=Декоратор {0} на методе вне класса
INSP.default.arguments.default.argument.value.mutable=Значение аргумента по умолчанию является изменяемым
INSP.deleter.should.not.return=Deleter не должен возвращать значение
INSP.deleter.signature.advice=Сигнатура deleter должна быть (self)
INSP.deprecation.abc.decorator.deprecated.use.alternative=''{0}'' устарел с Python 3.3. Используйте ''{1}'' с ''{2}'' вместо этого
INSP.dict.creation.this.dictionary.creation.could.be.rewritten.as.dictionary.literal=Это создание словаря можно переписать как литерал словаря
INSP.doc.param.should.be.str=Параметр doc должен быть строкой
INSP.docstring.types.change.type=Изменить тип {0} с {1} на {2}
INSP.docstring.types.dynamically.inferred.type.does.not.match.specified.type=Динамически выведенный тип ''{0}'' не соответствует указанному типу ''{1}''
INSP.docstring.types.fix.docstring=Исправить docstring
INSP.dunder.slots.class.object.attribute.read.only=Атрибут ''{1}'' объекта ''{0}'' доступен только для чтения
INSP.dunder.slots.name.in.slots.conflicts.with.class.variable=''{0}'' в __slots__ конфликтует с переменной класса
INSP.duplicate.keys.dictionary.contains.duplicate.keys=Словарь содержит повторяющиеся ключи ''{0}''
INSP.empty.docstring=Пустой docstring
INSP.exception.inheritance.exception.does.not.inherit.from.base.exception.class=Исключение не наследуется от базового класса 'Exception'
INSP.expected.dict.got.type=Ожидался словарь, получен {0}
INSP.expected.iterable.got.type=Ожидался итерируемый объект, получен {0}
INSP.expression.can.be.simplified=Выражение можно упростить
INSP.expression.is.not.callable=Выражение не является вызываемым
INSP.final.already.declared.name.could.not.be.redefined.as.final=Уже объявленное имя не может быть переопределено как 'Final'
INSP.final.either.instance.attribute.or.class.attribute.could.be.type.hinted.as.final=Атрибут экземпляра или класса может иметь подсказку типа 'Final'
INSP.final.final.attribute.could.not.be.overridden=''{0}'' является ''Final'' и не может быть переопределен
INSP.final.final.attribute.should.be.declared.in.class.body.or.init='Final' атрибут должен быть объявлен в теле класса или '__init__'
INSP.final.final.class.could.not.contain.abstract.methods='Final' класс не может содержать абстрактные методы
INSP.final.final.could.not.be.mixed.with.abstract.decorators='Final' нельзя смешивать с абстрактными декораторами
INSP.final.final.could.not.be.used.in.annotation.for.function.return.value='Final' нельзя использовать в аннотации возвращаемого значения функции
INSP.final.final.could.not.be.used.in.annotations.for.function.parameters='Final' нельзя использовать в аннотациях параметров функции
INSP.final.final.could.not.be.used.inside.loop='Final' нельзя использовать внутри цикла
INSP.final.final.could.only.be.used.as.outermost.type='Final' может использоваться только как самый внешний тип
INSP.final.final.name.should.be.initialized.with.value='Final' имя должно быть инициализовано значением
INSP.final.final.should.be.placed.on.first.overload='@final' должен быть размещен на первой перегрузке
INSP.final.final.should.be.placed.on.implementation='@final' должен быть размещен в реализации
INSP.final.final.target.could.not.be.reassigned=''{0}'' является ''Final'' и не может быть переназначен
INSP.final.if.assigned.value.omitted.there.should.be.explicit.type.argument.to.final=Если присваиваемое значение опущено, должен быть явный аргумент типа для 'Final'
INSP.final.method.marked.as.final.should.not.be.overridden=''{0}'' помечен как ''@final'' и не должен быть переопределен
INSP.final.no.need.to.mark.method.in.final.class.as.final=Нет необходимости помечать метод в 'Final' классе как '@final'
INSP.final.non.method.function.could.not.be.marked.as.final=Функция, не являющаяся методом, не может быть помечена как '@final'
INSP.final.super.classes.are.marked.as.final.and.should.not.be.subclassed={0} {1,choice,1\#помечен|2\#помечены} как ''@final'' и не должен наследоваться
INSP.first.arg.assign.method.parameter.reassigned=Параметр метода ''{0}'' переназначен
INSP.first.param.must.not.be.tuple=Первый параметр нестатического метода не должен быть кортежем
INSP.format.requires.mapping=Формат требует отображения
INSP.format.requires.no.mapping=Формат не требует отображения
INSP.from.future.import.from.future.imports.must.occur.at.beginning.file=Импорты from __future__ должны находиться в начале файла
INSP.func.property.name.mismatch=Имена функции и декоратора не совпадают; аксессор свойства не создан
INSP.function.lacks.positional.argument=Функции ''{0}'' не хватает позиционного аргумента
INSP.getter.return.smth=Геттер должен что-то возвращать или генерировать
INSP.getter.signature.advice=Сигнатура геттера должна быть (self)
INSP.global.variable.undefined=Глобальная переменная ''{0}'' не определена на уровне модуля
INSP.incompatible.options=Параметры формата в блоке "{0}" несовместимы
INSP.inconsistent.indentation.mix.tabs.spaces=Непоследовательные отступы\: смешение табуляции и пробелов
INSP.inconsistent.indentation.previous.line.used.spaces.this.line.uses.tabs=Непоследовательные отступы\: предыдущая строка использует пробелы, эта строка использует табуляцию
INSP.inconsistent.indentation.previous.line.used.tabs.this.line.uses.spaces=Непоследовательные отступы\: предыдущая строка использует табуляцию, эта строка использует пробелы
INSP.incorrect.arguments=Неверные аргумент(ы)
INSP.init.incompatible.to.new=Сигнатура несовместима с __new__
INSP.interpreter.configure.python.interpreter=Настроить интерпретатор Python
INSP.interpreter.interpreter.settings=Настройки интерпретатора
INSP.interpreter.invalid.python.interpreter.selected.for.module=Выбран неверный интерпретатор Python для модуля
INSP.interpreter.invalid.python.interpreter.selected.for.project=Выбран неверный интерпретатор Python для проекта
INSP.interpreter.no.python.interpreter.configured.for.module=Не настроен интерпретатор Python для модуля
INSP.interpreter.no.python.interpreter.configured.for.project=Не настроен интерпретатор Python для проекта
INSP.interpreter.pipenv.interpreter.associated.with.another.module=Интерпретатор Pipenv связан с другим модулем\: ''{0}''
INSP.interpreter.pipenv.interpreter.associated.with.another.project=Интерпретатор Pipenv связан с другим проектом\: ''{0}''
INSP.interpreter.pipenv.interpreter.not.associated.with.any.module=Интерпретатор Pipenv не связан ни с одним модулем
INSP.interpreter.pipenv.interpreter.not.associated.with.any.project=Интерпретатор Pipenv не связан ни с одним проектом
INSP.interpreter.python.has.reached.its.end.life.and.is.no.longer.supported.in.python.plugin=Python {0} достиг конца срока поддержки и больше не поддерживается в плагине Python
INSP.interpreter.python.has.reached.its.end.of.life.and.is.no.longer.supported.in.pycharm=Python {0} достиг конца срока поддержки и больше не поддерживается в PyCharm
INSP.interpreter.use.interpreter=Использовать {0}
INSP.interpreter.use.suggested.interpreter=Использовать предложенный интерпретатор
INSP.list.creation.this.list.creation.could.be.rewritten.as.list.literal=Многошаговая инициализация списка может быть заменена литералом списка
INSP.mandatory.encoding.checkbox.enable.in.python.3=Включить в Python 3+
INSP.mandatory.encoding.label.encoding.comment.format=Формат комментария кодования\:
INSP.mandatory.encoding.label.select.default.encoding=Выберите кодование по умолчанию\:
INSP.mandatory.encoding.no.encoding.specified.for.file=Не указано кодование для файла
INSP.manual.to.auto.field.numbering=Невозможно переключиться с ручной спецификации полей на автоматическую нумерацию
INSP.message.single.quoted.docstring=Для docstring следует использовать строки с тройными двойными кавычками.
INSP.method.may.be.static=Метод <code>\#ref</code> может быть 'static'
INSP.method.parameters.metaclass.method.first.argument.name=Имя первого аргумента метода метакласса
INSP.missing.parameter.in.docstring=Отсутствует параметр {0} в docstring
INSP.missing.super.constructor.message=Пропущен вызов __init__ суперкласса
INSP.missing.type.hints.add.type.hints=Добавить подсказки типов
INSP.missing.type.hints.add.type.hints.for=Добавить подсказки типов для ''{0}''
INSP.missing.type.hints.checkbox.only.when.types.are.known=Только когда типы известны (собраны во время выполнения или выведены)
INSP.missing.type.hints.type.hinting.missing.for.function.definition=Отсутствуют подсказки типов для определения функции
INSP.must.have.first.parameter=Метод должен иметь первый параметр, обычно называемый ''{0}''
INSP.named.tuple=Неверное определение 'typing.NamedTuple'
INSP.new.incompatible.to.init=Сигнатура несовместима с __init__
INSP.new.style.generics.are.not.allowed.inside.type.param.bounds=Обобщенные типы не разрешены внутри ограничений и границ параметров типа
INSP.new.style.generics.assignment.expressions.not.allowed=Выражения присваивания не разрешены внутри объявлений классов, функций и псевдонимов типов, имеющих список параметров типа
INSP.new.style.generics.classes.with.type.param.list.should.not.extend.generic=Классы с явным списком параметров типа не должны расширять 'Generic'
INSP.new.style.generics.extending.protocol.does.not.need.parameterization=Расширение 'Protocol' не требует параметризации в классах со списком параметров типа
INSP.new.style.generics.mixing.old.style.and.new.style.type.vars.not.allowed=Смешивание традиционных и новых переменных типа не разрешено
INSP.new.style.generics.old.style.type.vars.not.allowed.in.new.style.type.aliases=Традиционные TypeVar не разрешены внутри объявлений псевдонимов типов нового стиля
INSP.no.docstring=Отсутствует docstring
INSP.no.format.specifier.char=Отсутствует символ спецификатора формата
INSP.non.ascii.char.non.ascii.character.in.file.but.no.encoding.declared=Не-ASCII символ ''{0}'' в файле, но кодование не объявлена
INSP.none.function.assignment=Функция ''{0}'' ничего не возвращает
INSP.oldstyle.class.getattribute=Класс старого стиля содержит определение __getattribute__
INSP.oldstyle.class.slots=Класс старого стиля содержит определение __slots__
INSP.oldstyle.class.super=Класс старого стиля содержит вызов метода super
INSP.overloads.series.overload.decorated.functions.should.always.be.followed.by.implementation=За серией функций с декоратором @overload всегда должна следовать реализация без декоратора @overload
INSP.overloads.series.overload.decorated.methods.should.always.be.followed.by.implementation=За серией методов с декоратором @overload всегда должна следовать реализация без декоратора @overload
INSP.overloads.this.function.overload.signature.not.compatible.with.implementation=Сигнатура этой функции с декоратором @overload несовместима с реализацией
INSP.overloads.this.method.overload.signature.not.compatible.with.implementation=Сигнатура этого метода с декоратором @overload несовместима с реализацией
INSP.override.missing.super.method=Отсутствует super метод для переопределения
INSP.package.requirements.add.import=Добавить импорт
INSP.package.requirements.administrator.privileges.required=Требуются права администратора
INSP.package.requirements.administrator.privileges.required.button.configure=Настроить
INSP.package.requirements.administrator.privileges.required.button.install.anyway=Установить всё равно
INSP.package.requirements.administrator.privileges.required.description=Для установки пакетов в ''{0}'' требуются права администратора.\n\nНастройте виртуальное окружение для проекта в качестве интерпретатора проекта,\nчтобы избежать установки пакетов в защищенную область файловой системы.
INSP.package.requirements.requirement.has.been.ignored=''{0}'' был проигнорирован
INSP.package.requirements.requirements.file.empty=Файл requirements пуст
INSP.package.requirements.requirements.have.been.ignored=Требования были проигнорированы
INSP.pandas.series.values.replace.with.tolist=Рекомендуется метод Series.to_list()
INSP.parameter(s).unfilled=Параметр(ы) не заполнены
INSP.parameter.unfilled=Параметр ''{0}'' не заполнен
INSP.pep8.coding.style.violation=Нарушение стиля кодования PEP 8
INSP.pep8.ignore.base.class=Игнорировать базовый класс
INSP.pep8.ignore.method.names.for.descendants.of.class=Игнорировать имена методов для потомков класса
INSP.pep8.naming.argument.name.should.be.lowercase=Имя аргумента должно быть в нижнем регистре
INSP.pep8.naming.camelcase.variable.imported.as.constant=Переменная в CamelCase импортована как константа
INSP.pep8.naming.camelcase.variable.imported.as.lowercase=Переменная в CamelCase импортована как нижний регистр
INSP.pep8.naming.class.names.should.use.capwords.convention=Имена классов должны использовать соглашение CapWords
INSP.pep8.naming.column.name.excluded.base.classes=Исключенные базовые классы\:
INSP.pep8.naming.column.name.ignored.errors=Игнорируемые ошибки\:
INSP.pep8.naming.constant.variable.imported.as.non.constant=Константа импортована как не константа
INSP.pep8.naming.function.name.should.be.lowercase=Имя функции должно быть в нижнем регистре
INSP.pep8.naming.lowercase.variable.imported.as.non.lowercase=Переменная в нижнем регистре импортована не в нижнем регистре
INSP.pep8.naming.variable.in.function.should.be.lowercase=Переменная в функции должна быть в нижнем регистре
INSP.possible.callees=Возможные вызываемые объекты
INSP.probably.mistyped.self=Возможно, вы имели в виду 'self'?
INSP.property.cannot.be.deleted=Свойство ''{0}'' не может быть удалено
INSP.property.cannot.be.read=Свойство ''{0}'' не может быть прочитано
INSP.property.cannot.be.set=Свойство ''{0}'' не может быть установлено
INSP.protected.member.access.to.protected.member.of.class=Доступ к защищенному члену {0} класса
INSP.protected.member.access.to.protected.member.of.module=Доступ к защищенному члену {0} модуля
INSP.protected.member.ignore.annotations=Игнорировать аннотации
INSP.protected.member.ignore.test.functions=Игнорировать тестовые функции
INSP.protected.member.name.not.declared.in.all=''{0}'' не объявлен в __all__
INSP.protocol.all.bases.protocol.must.be.protocols=Все базовые классы протокола должны быть протоколами
INSP.protocol.element.type.incompatible.with.protocol=Тип ''{0}'' несовместим с ''{1}''
INSP.protocol.newtype.cannot.be.used.with.protocol.classes=NewType нельзя использовать с классами протоколов
INSP.protocol.only.runtime.checkable.protocols.can.be.used.with.instance.class.checks=Только протоколы с @runtime_checkable могут использоваться с проверками экземпляров и классов
INSP.python.suppressor.suppress.for.class=Подавить для класса
INSP.python.suppressor.suppress.for.function=Подавить для функции
INSP.python.suppressor.suppress.for.statement=Подавить для выражения
INSP.redeclared.name=Повторно объявлено ''{0}'', определённое выше без использования
INSP.redundant.parens.ignore.argument.of.operator=Игнорировать аргумент оператора %
INSP.redundant.parens.ignore.empty.lists.of.base.classes=Игнорировать пустые списки базовых классов
INSP.redundant.parens.ignore.tuples=Игнорировать кортежи
INSP.relative.import.relative.import.outside.package=Относительный импорт вне пакета
INSP.requirements.ignore.packages.label=Игнорируемые пакеты\:
INSP.requirements.package.containing.module.not.listed.in.project.requirements=Пакет, содержащий модуль ''{0}'', не указан в требованиях проекта
INSP.requirements.package.requirements.not.satisfied=Требования к пакету {0} {1,choice,1\#не удовлетворено|2\#не удовлетворены}
INSP.setter.should.not.return=Сеттер не должен возвращать значение
INSP.setter.signature.advice=Сигнатура сеттера должна быть (self, value)
INSP.shadowing.builtins.ignore.built.ins.label=Игнорируемые встроенные объекты\:
INSP.shadowing.builtins.shadows.built.in.name=Скрывает встроенное имя ''{0}''
INSP.shadowing.names=Скрытие имен из внешних областей видимости
INSP.shadows.name.from.outer.scope=Скрывает имя ''{0}'' из внешней области видимости
INSP.signature.mismatch=Сигнатура метода ''{0}'' не соответствует сигнатуре базового метода в классе ''{1}''
INSP.simplify.boolean.check.ignore.comparison.to.zero=Игнорировать сравнение с нулем
INSP.simplify.chained.comparison=Упростить цепочку сравнений
INSP.statement.effect.statement.having.no.effect.can.be.replaced.with.function.call=Выражение, похоже, не имеет эффекта и может быть заменено вызовом функции
INSP.statement.effect.statement.seems.to.have.no.effect=Выражение, похоже, не имеет эффекта
INSP.str.format.can.not.use.star.in.formats.when.using.mapping=Нельзя использовать '*' в форматах при использовании отображения
INSP.str.format.key.has.no.argument=Ключ ''{0}'' не имеет соответствующего аргумента
INSP.str.format.unexpected.argument.type=Неожиданный тип {0}
INSP.str.format.unsupported.format.character.b=Неподдерживаемый символ форматования 'b'
INSP.strange.arg.want.callable=Странный аргумент; ожидается вызываемый объект
INSP.stub.packages=Анонсирование заглушек пакетов
INSP.stub.packages.compatibility=Несовместимые заглушки пакетов
INSP.stub.packages.compatibility.ignore=Игнорировать совместимость ''{0}''
INSP.stub.packages.compatibility.ignored.packages.label=Игнорируемые заглушки пакетов\:
INSP.stub.packages.compatibility.incompatible.packages.message=''{0}{1}{2}'' несовместим с ''{3}{4}{5}''. Ожидаемая версия ''{6}''\: [{7}]
INSP.symbol.is.not.callable=''{0}'' не является вызываемым
INSP.too.broad.exception.clause=Слишком широкий блок исключений
INSP.too.few.args.for.fmt.string=Слишком мало аргументов для строки форматования
INSP.too.few.keys=Слишком мало ключей отображения
INSP.too.many.args.for.fmt.string=Слишком много аргументов для строки форматования
INSP.trailing.semicolon=Лишняя точка с запятой в выражении
INSP.try.except.import.error=''{0}'' в блоке try с ''except ImportError'' также должно быть определено в блоке except
INSP.tuple.assignment.balance.need.more.values.to.unpack=Требуется больше значений для распаковки
INSP.tuple.assignment.balance.only.one.starred.expression.allowed.in.assignment=В присваивании разрешено только одно выражение со звездочкой
INSP.tuple.assignment.balance.too.many.values.to.unpack=Слишком много значений для распаковки
INSP.tuples.never.assign.items=Кортежи не поддерживают присваивание элементов
INSP.type.checker.expected.matched.type.got.type.instead=Ожидался тип ''{0}'' (соответствующий обобщенному типу ''{1}''), получен ''{2}''
INSP.type.checker.expected.to.return.type.got.no.return=Ожидается возврат ''{0}'', но ничего не возвращается
INSP.type.checker.expected.type.from.dunder.set.got.type.instead=Ожидался тип ''{0}'' (из ''__set__''), получен ''{1}''
INSP.type.checker.expected.type.got.type.instead=Ожидался тип ''{0}'', получен ''{1}''
INSP.type.checker.expected.types.prefix=Возможные типы\:
INSP.type.checker.init.should.return.none=__init__ должен возвращать None
INSP.type.checker.only.concrete.class.can.be.used.where.matched.protocol.expected=Только конкретный класс может использоваться там, где ожидается протокол ''{0}'' (соответствующий обобщенному типу ''{1}'')
INSP.type.checker.only.concrete.class.can.be.used.where.protocol.expected=Только конкретный класс может использоваться там, где ожидается протокол ''{0}''
INSP.type.checker.type.does.not.have.expected.attribute=Тип ''{0}'' не имеет ожидаемых {1,choice,1\#атрибута|2\#атрибутов} {2}
INSP.type.checker.typed.dict.extra.key=Лишний ключ ''{0}'' для TypedDict ''{1}''
INSP.type.checker.typed.dict.missing.keys=В TypedDict ''{0}'' отсутствуют {1,choice,1\#ключ|2\#ключи}\: {2}
INSP.type.checker.unexpected.argument.from.paramspec=Неожиданный аргумент (из ParamSpec ''{0}'')
INSP.type.checker.unexpected.types.prefix=Неожиданные типы\:
INSP.type.checker.unfilled.parameter.for.paramspec=Параметр ''{0}'' не заполнен (из ParamSpec ''{1}'')
INSP.type.checker.unfilled.vararg=Параметр ''{0}'' не заполнен, ожидается ''{1}''
INSP.type.hints.annotated.must.be.called.with.at.least.two.arguments='Annotated' должен вызываться как минимум с двумя аргументами
INSP.type.hints.argument.to.paramspec.must.be.string.equal.to.variable.name=Аргумент 'ParamSpec()' должен быть строкой, равной имени переменной, которой он присваивается
INSP.type.hints.argument.to.typevar.must.be.string.equal.to.variable.name=Аргумент 'TypeVar()' должен быть строкой, равной имени переменной, которой он присваивается
INSP.type.hints.argument.to.typevar.tuple.must.be.string.equal.to.variable.name=Аргумент 'TypeVarTuple()' должен быть строкой, равной имени переменной, которой он присваивается
INSP.type.hints.bivariant.type.variables.are.not.supported=Бивариантные типовые переменные не поддерживаются
INSP.type.hints.builtin.cannot.be.parameterized.directly=Встроенный тип ''{0}'' нельзя параметризовать напрямую
INSP.type.hints.cannot.inherit.from.generic.multiple.times=Нельзя наследоваться от 'Generic[...]' несколько раз
INSP.type.hints.cannot.inherit.from.plain.generic=Нельзя наследоваться от простого 'Generic'
INSP.type.hints.generics.should.be.specified.through.square.brackets=Обобщения должны указываться через квадратные скобки
INSP.type.hints.illegal.callable.format='Callable' должен использоваться как 'Callable[[arg, ...], result]'
INSP.type.hints.illegal.first.parameter=Первый параметр 'Callable' должен быть выражением параметра
INSP.type.hints.illegal.literal.parameter='Literal' может быть параметризован литералами int, байтовыми и юникод строками, bool, значениями Enum, None, другими литеральными типами или псевдонимами типов для других литеральных типов
INSP.type.hints.invalid.type.self=Недопустимый тип 'self'
INSP.type.hints.literal.must.have.at.least.one.parameter='Literal' должен иметь хотя бы один параметр
INSP.type.hints.non.default.type.vars.cannot.follow.defaults=TypeVar без значений по умолчанию не могут следовать за TypeVar со значениями по умолчанию
INSP.type.hints.non.self.attribute.could.not.be.type.hinted=Атрибут не-self не может иметь подсказку типа
INSP.type.hints.parameterized.generics.cannot.be.used.with.instance.class.checks=Параметризованные обобщения нельзя использовать с проверками экземпляров и классов
INSP.type.hints.parameters.to.generic.must.all.be.type.variables=Параметры 'Generic[...]' должны быть типовыми переменными
INSP.type.hints.parameters.to.generic.must.all.be.unique=Параметры 'Generic[...]' должны быть уникальными
INSP.type.hints.parameters.to.generic.types.cannot.contain.more.than.one.unpacking=Параметры обобщенного типа не могут содержать более одной распаковки
INSP.type.hints.parameters.to.generic.types.must.be.types=Параметры обобщенных типов должны быть типами
INSP.type.hints.paramspec.expects.string.literal.as.first.argument='ParamSpec()' ожидает строковый литерал в качестве первого аргумента
INSP.type.hints.self.use.for.cls.parameter.with.self.annotation=Нельзя использовать 'Self', если параметр 'cls' не аннотирован как 'Self'
INSP.type.hints.self.use.for.self.parameter.with.self.annotation=Нельзя использовать 'Self', если параметр 'self' не аннотирован как 'Self'
INSP.type.hints.self.use.in.staticmethod=Нельзя использовать 'Self' в staticmethod
INSP.type.hints.self.use.outside.class=Нельзя использовать 'Self' вне класса
INSP.type.hints.single.typevar.constraint.not.allowed=Одиночное ограничение не допускается
INSP.type.hints.some.type.variables.are.not.listed.in.generic=Некоторые переменные типа ({0}) не перечислены в ''Generic[{1}]''
INSP.type.hints.type.alias.cannot.be.parameterized='TypeAlias' не может быть параметризован
INSP.type.hints.type.alias.must.be.immediately.initialized=Псевдоним типа должен быть инициализован немедленно
INSP.type.hints.type.alias.must.be.top.level.declaration=Псевдоним типа должен быть объявлением верхнего уровня
INSP.type.hints.type.alias.must.be.used.as.standalone.type.hint='TypeAlias' должен использоваться как отдельная подсказка типа
INSP.type.hints.type.cannot.be.used.with.instance.class.checks=''{0}'' не может использоваться с проверками экземпляров и классов
INSP.type.hints.type.comment.cannot.be.matched.with.unpacked.variables=Комментарий типа не может быть сопоставлен с распакованными переменными
INSP.type.hints.type.self.not.supertype.its.class=Тип self ''{0}'' не является супертипом его класса ''{1}''
INSP.type.hints.type.signature.has.too.few.arguments=Сигнатура типа имеет слишком мало аргументов
INSP.type.hints.type.signature.has.too.many.arguments=Сигнатура типа имеет слишком много аргументов
INSP.type.hints.type.specified.both.in.type.comment.and.annotation=Типы указаны как в комментарии типа, так и в аннотации
INSP.type.hints.type.var.tuple.must.always.be.unpacked=TypeVarTuple всегда должен быть распакован
INSP.type.hints.type.variables.cannot.be.used.with.instance.class.checks=Переменные типа не могут использоваться с проверками экземпляров и классов
INSP.type.hints.type.variables.must.not.be.redefined=Переменные типа не должны переопределяться
INSP.type.hints.typeIs.does.not.match=Возвращаемый тип TypeIs ''{0}'' не соответствует типу первого параметра ''{1}''
INSP.type.hints.typeIs.has.zero.arguments=Пользовательские функции TypeGuard или TypeIs должны иметь хотя бы один параметр
INSP.type.hints.typevar.constraints.cannot.be.combined.with.bound=Ограничения не могут комбинироваться с bound\=…
INSP.type.hints.typevar.constraints.cannot.be.parametrized.by.type.variables=Ограничения не могут быть параметризованы переменными типа
INSP.type.hints.typevar.expects.string.literal.as.first.argument='TypeVar()' ожидает строковый литерал в качестве первого аргумента
INSP.type.hints.typevar.expression.must.be.always.directly.assigned.to.variable=Выражение 'TypeVar()' всегда должно присваиваться непосредственно переменной
INSP.type.hints.typevar.tuple.expects.string.literal.as.first.argument='TypeVarTuple()' ожидает строковый литерал в качестве первого аргумента
INSP.type.hints.typing.self.cannot.be.parameterized='Self' не может быть параметризован
INSP.typeddict.cannot.add.non.string.key.to.typeddict=Невозможно добавить нестроковый ключ в TypedDict "{0}"
INSP.typeddict.cannot.be.required.and.not.required.at.the.same.time=Ключ не может быть одновременно обязательным и необязательным
INSP.typeddict.cannot.overwrite.typeddict.field=Невозможно перезаписать поле TypedDict
INSP.typeddict.cannot.overwrite.typeddict.field.while.merging=Невозможно перезаписать поле TypedDict ''{0}'' при слиянии
INSP.typeddict.first.argument.has.to.match.variable.name=Первый аргумент должен совпадать с именем переменной
INSP.typeddict.invalid.statement.in.typeddict.definition.expected.field.name.field.type=Недопустимое выражение в определении TypedDict; ожидается 'field_name\: field_type'
INSP.typeddict.key.cannot.be.deleted=Ключ ''{0}'' TypedDict ''{1}'' не может быть удален
INSP.typeddict.key.should.be.string=Ключ должен быть строкой
INSP.typeddict.qualifiers.cannot.be.used.outside.typeddict.definition=''{0}'' может использоваться только в определении TypedDict
INSP.typeddict.required.notrequired.must.have.exactly.one.type.argument=''{0}'' должен иметь ровно один аргумент типа
INSP.typeddict.right.hand.side.values.are.not.supported.in.typeddict=Значения правой части не поддерживаются в TypedDict
INSP.typeddict.specifying.metaclass.not.allowed.in.typeddict=Указание метакласса не разрешено в TypedDict
INSP.typeddict.this.operation.might.break.typeddict.consistency=Эта операция может нарушить целостность TypedDict
INSP.typeddict.total.value.must.be.true.or.false=Значение 'total' должно быть True или False
INSP.typeddict.typeddict.cannot.have.key=TypedDict "{0}" не может иметь ключ ''{1}''
INSP.typeddict.typeddict.cannot.inherit.from.non.typeddict.base.class=TypedDict не может наследоваться от базового класса, не являющегося TypedDict
INSP.typeddict.typeddict.field.is.readonly=Ключ TypedDict "{0}" является ReadOnly
INSP.typeddict.typeddict.has.no.key=TypedDict "{0}" не имеет ключа ''{1}''
INSP.typeddict.typeddict.has.no.keys=TypedDict "{0}" не имеет ключей ({1})
INSP.typeddict.typeddict.key.must.be.string.literal.expected.one=Ключ TypedDict должен быть строковым литералом; ожидается один из ({0})
INSP.typeddict.value.must.be.type=Значение должно быть типом
INSP.unbound.function.too.large=Функция ''{0}'' слишком большая для анализа
INSP.unbound.local.variable=Локальная переменная ''{0}'' может быть использована до присваивания
INSP.unbound.name.undefined=Имя ''{0}'' может быть не определено
INSP.unbound.nonlocal.variable=Нелокальная переменная ''{0}'' должна быть связана в области видимости внешней функции
INSP.unexpected.arg=Неожиданный аргумент
INSP.unexpected.arg(s)=Неожиданные аргументы
INSP.unexpected.parameter.in.docstring=Неожиданный параметр {0} в docstring
INSP.unnecessary.backslash.unnecessary.backslash.in.expression=Лишний обратный слеш в выражении
INSP.unreachable.code=Этот код недостижим
INSP.unresolved.refs.cannot.find.reference.in.type=Не удаётся найти ссылку ''{0}'' в ''{1}''
INSP.unresolved.refs.class.does.not.define.operator=Класс ''{0}'' не определяет ''{1}'', поэтому оператор ''{2}'' не может использоваться с его экземплярами
INSP.unresolved.refs.class.object.has.no.attribute=Объект ''{0}'' не имеет атрибута ''{1}''
INSP.unresolved.refs.ignore.references.label=Игнорируемые ссылки\:
INSP.unresolved.refs.import.resolves.to.its.containing.file=Импорт разрешается в содержащий его файл
INSP.unresolved.refs.module.not.found=Модуль ''{0}'' не найден
INSP.unresolved.refs.unresolved.attribute.for.class=Неразрешённая ссылка на атрибут ''{0}'' для класса ''{1}''
INSP.unresolved.refs.unresolved.reference=Неразрешённая ссылка ''{0}''
INSP.unsupported.format.character=Неподдерживаемый символ форматования ''{0}''
INSP.unused.import.statement=Неиспользуемый оператор import <code>\#ref</code>
INSP.unused.locals.ignore.lambda.parameters=Игнорировать параметры lambda
INSP.unused.locals.ignore.range.iteration.variables=Игнорировать переменные итерации диапазона
INSP.unused.locals.ignore.variables.starting.with=Игнорировать переменные, начинающиеся с '_'
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=Игнорировать переменные, используемые в распаковке кортежей
INSP.unused.locals.local.class.isnot.used=Локальный класс ''{0}'' не используется
INSP.unused.locals.local.function.isnot.used=Локальная функция ''{0}'' не используется
INSP.unused.locals.local.variable.isnot.used=Значение локальной переменной ''{0}'' не используется
INSP.unused.locals.parameter.isnot.used=Значение параметра ''{0}'' не используется
INSP.unused.locals.replace.with.wildcard=Заменить на _
INSP.use.fixture.without.declaration.in.test.function=Фикстура ''{0}'' не запрошена тестовыми функциями или маркером '@pytest.mark.usefixtures'
INSP.usually.named=Обычно первый параметр таких методов называется ''{0}''
INSP.usually.named.self=Обычно первый параметр метода называется 'self'
INTN.NAME.add.type.hint.for.variable=Добавить подсказку типа для переменной
INTN.NAME.add.type.hints.for.function=Добавить подсказки типов для функции
INTN.NAME.convert.collection.literal=Преобразовать коллекцию в {0}
INTN.NAME.convert.import.qualify=Преобразовать 'from module import' в 'import module'
INTN.NAME.convert.import.unqualify=Преобразовать 'import module' в 'from module import'
INTN.NAME.convert.type.comment.to.variable.annotation=Преобразовать комментарий типа в аннотацию переменной
INTN.NAME.demorgan.law=Закон де Моргана
INTN.NAME.flip.comparison=Поменять операнды сравнения местами
INTN.NAME.hide.type.annotations=Скрыть аннотации типов
INTN.NAME.insert.docstring.stub=Вставить заглушку docstring
INTN.NAME.join.if=Объединить операторы 'if'
INTN.NAME.negate.comparison=Инвертировать сравнение
INTN.NAME.specify.type.in.annotation=Указать тип для ссылки через аннотацию
INTN.NAME.specify.type.in.docstring=Указать тип для ссылки в docstring
INTN.NAME.split.if=Разделить оператор 'if'
INTN.NAME.toggle.import.alias=Переключить использование псевдонимов импорта
INTN.add.import.alias=Добавить псевдоним
INTN.add.import.alias.dialog.message=Псевдоним для ''{0}''\:
INTN.add.import.alias.title=Добавить псевдоним
INTN.add.import.alias.to.name=Добавить псевдоним для ''{0}''
INTN.add.parameters.to.docstring=Добавить параметры в docstring
INTN.add.qualifier=Добавить квалификатор ''{0}''
INTN.add.type.hint.for.variable=Добавить подсказку типа для переменной ''{0}''
INTN.add.type.hint.for.variable.PEP484.incompatible.type=Тип ''{0}'' не может быть выражен встроенно в формате PEP 484
INTN.add.type.hints.for.function=Добавить подсказки типов для функции ''{0}''
INTN.category.python=Python
INTN.convert.absolute.to.relative=Преобразовать абсолютный импорт в относительный
INTN.convert.builtin.import=Преобразовать импорт встроенного модуля в поддерживаемую форму
INTN.convert.collection.literal=Преобразовать {0} в {1}
INTN.convert.dict.constructor.to.dict.literal=Преобразовать конструктор dict в литерал dict
INTN.convert.dict.literal.to.dict.constructor=Преобразовать литерал dict в конструктор dict
INTN.convert.except.to=Преобразовать 'except exceptClass, Target' в 'except exceptClass as Target'
INTN.convert.lambda.to.function=Преобразовать lambda в функцию
INTN.convert.method.to.property=Преобразовать метод в свойство
INTN.convert.relative.to.absolute=Преобразовать относительный импорт в абсолютный
INTN.convert.static.method.to.function=Преобразовать статический метод в функцию
INTN.convert.to.from.import=Преобразовать в ''from {0} import {1}''
INTN.convert.to.fstring.literal=Преобразовать в f-строку
INTN.convert.to.plain.import=Преобразовать в ''import {0}''
INTN.convert.type.comment.to.variable.annotation=Преобразовать в аннотацию переменной
INTN.convert.variadic.param=Преобразовать вариативные параметры в обычные
INTN.flip.comparison=Инвертировать ''{0}''
INTN.flip.comparison.to.operator=Заменить ''{0}'' на ''{1}''
INTN.format.operator.to.method=Преобразовать оператор форматования в вызов метода 'str.format'
INTN.hide.type.annotations=Скрыть аннотации типов
INTN.insert.assertion=Вставить проверку типа
INTN.insert.docstring.stub=Вставить заглушку документации
INTN.invert.if.condition=Инвертировать условие 'if'
INTN.join.if=Объединить два оператора 'if'
INTN.multiple.usages.of.import.found=Найдено несколько использований импорта
INTN.negate.comparison=Заменить ''{0}'' на ''{1}''
INTN.quoted.string=Преобразовать строки с одинарными кавычками в двойные и наоборот
INTN.quoted.string.double.to.single=Преобразовать строку с двойными кавычками в строку с одинарными
INTN.quoted.string.single.to.double=Преобразовать строку с одинарными кавычками в строку с двойными
INTN.remove.import.alias=Удалить псевдоним ''{0}''
INTN.remove.qualifier=Удалить квалификатор ''{0}''
INTN.remove.qualifier.from.all.usages=Удалить квалификатор из всех использований
INTN.remove.qualifier.from.this.name=Удалить квалификатор из этого имени
INTN.replace.backquote.expression=Заменить выражение с обратными кавычками
INTN.replace.list.comprehensions=Преобразовать списковое включение в поддерживаемую форму
INTN.replace.list.comprehensions.with.for=Преобразовать списковое включение в цикл 'for'
INTN.replace.noteq.operator=Заменить оператор неравенства
INTN.replace.octal.numeric.literal=Преобразовать восьмеричный литерал в поддерживаемую форму
INTN.replace.plus.with.format.operator=Заменить + на оператор форматования строк
INTN.replace.plus.with.str.format=Заменить + на вызов метода str.format
INTN.replace.raise.statement=Преобразовать оператор raise в поддерживаемую форму
INTN.replace.with.method=Заменить на вызов метода str.format
INTN.specify.return.type.in.annotation=Указать возвращаемый тип с помощью аннотации
INTN.specify.return.type.in.docstring=Указать возвращаемый тип в docstring
INTN.specify.type.in.annotation=Указать тип для ссылки с помощью аннотации
INTN.specify.type.in.docstring=Указать тип для ссылки в docstring
INTN.split.if=Разделить на 2 оператора 'if'
INTN.string.concatenation.to.format=Заменить конкатенацию строк на 'str.format'
INTN.transform.into.if.else.statement=Преобразовать условные выражения в операторы 'if/else'
INTN.triple.quoted.string=Преобразовать строку с тройными кавычками в строку с одинарными
INTN.yield.from=Преобразовать явные итерации с 'yield' в выражения 'yield from'
QDOC.accessor.kind=Тип аксессора\:
QDOC.assigned.to=Присвоено\:
QDOC.attributes=Атрибуты\:
QDOC.built.in.description=встроенное описание
QDOC.class=класс
QDOC.class.attribute=Атрибут класса {0} из {1}
QDOC.copied.from=Скопировано из\:
QDOC.directory.name=Каталог "{0}"
QDOC.file.name=Файл "{0}"
QDOC.inferred.type.name=Выведенный тип\: {0}
QDOC.instance.attribute=Атрибут экземпляра {0} из {1}
QDOC.keyword.args=Именованные аргументы\:
QDOC.module.name=Модуль {0}
QDOC.module.path.unknown=(Путь к модулю неизвестен)
QDOC.not.defined.in.parentheses=(не определено)
QDOC.package.name=Пакет {0}
QDOC.parameter.name=Параметр "{0}"
QDOC.parameter.name.of.link=Параметр {0} из {1}
QDOC.parameter.of.function.name=Параметр "{0}" функции "{1}"
QDOC.parameter.of.method.name=Параметр "{0}" метода "{1}"
QDOC.params=Параметры\:
QDOC.property.getter=геттер свойства
QDOC.property.name.of.link=Свойство {0} из {1}
QDOC.python.3.sdk.needed.to.render.docstrings=Для отображения docstrings необходим настроенный локальный Python 3 SDK.
QDOC.raises=Вызывает\:
QDOC.returns=Возвращает\:
QDOC.type.alias.statement.name.of.link=Выражение псевдонима типа {0} из {1}
QDOC.type.parameter.kind=вид\:
QDOC.type.parameter.name=Параметр типа {0}
QDOC.type.parameter.name.of.link=Параметр типа {0} из {1}
QDOC.variable.name=Переменная "{0}"
QFIX.NAME.add.exception.base=Добавить базовый класс Exception
QFIX.NAME.add.field.to.class=Добавить поле в класс
QFIX.NAME.add.method.to.class=Добавить метод в класс
QFIX.NAME.add.specifier=Добавить символ спецификатора формата
QFIX.NAME.auto.import=Импортовать
QFIX.NAME.convert.builtin=Преобразовать импорт встроенного модуля
QFIX.NAME.create.function.in.module=Создать функцию в модуле
QFIX.NAME.docstring=Исправить docstring
QFIX.NAME.ignore.errors.like.this=Игнорировать подобные ошибки
QFIX.NAME.ignore.requirements=Игнорировать {0,choice,1\#требование|2\#требования}
QFIX.NAME.ignore.shadowed.built.in.name=Игнорировать затененное встроенное имя
QFIX.NAME.install.and.import.package=Установить и импортовать пакет ''{0}''
QFIX.NAME.install.requirements=Установить {0,choice,1\#требование|2\#требования}
QFIX.NAME.local.auto.import=Импортовать локально
QFIX.NAME.make.function=Создать функцию из метода
QFIX.NAME.make.function.return.type=Сделать возвращаемый тип функции выведенным
QFIX.NAME.make.list=Заменить кортеж на список
QFIX.NAME.make.static=Сделать метод статическим
QFIX.NAME.move.except.up=Переместить блок except вверх
QFIX.NAME.remove.argument=Удалить аргумент
QFIX.NAME.remove.assignment=Удалить присваивание
QFIX.NAME.remove.assignment.target=Удалить цель присваивания
QFIX.NAME.remove.call=Удалить вызов
QFIX.NAME.remove.dict.key=Удалить этот ключ
QFIX.NAME.remove.exception.target=Удалить цель исключения
QFIX.NAME.remove.parameter=Удалить параметр
QFIX.NAME.remove.statement=Удалить оператор
QFIX.NAME.remove.string.prefix=Удалить префикс
QFIX.NAME.remove.underscores.in.numeric=Удалить подчеркивания в числовых литералах
QFIX.NAME.remove.with.target=Удалить цель 'with'
QFIX.NAME.rename.argument=Переименовать аргумент
QFIX.NAME.rename.parameter=Переименовать параметр
QFIX.NAME.replace.with.true.or.false=Заменить на True или False
QFIX.NAME.simplify.boolean.expression=Упростить логическое выражение
QFIX.NAME.unpack.type.var.tuple=Распаковать TypeVarTuple
QFIX.NAME.unresolved.reference.add.param=Создать параметр для ссылки
QFIX.NAME.unresolved.reference.create.function=Создать функцию ''{0}''
QFIX.NAME.update.parameters=Обновить параметры
QFIX.action.failed=Действие не выполнено
QFIX.add.encoding=Добавить объявление кодования
QFIX.add.field.to.class=Добавить поле ''{0}'' в класс {1}
QFIX.add.field.to.class.popup.content.added.init=Добавлен __init__ в класс <code>{0}</code><br/>для размещения нового поля <code>{1}</code>
QFIX.add.fixture.to.test.function.parameters.list=Добавить фикстуру в параметры тестовой функции
QFIX.add.from.future.import.annotations=Добавить 'from __future__ import annotations'
QFIX.add.global=Добавить глобальное объявление
QFIX.add.imported.packages.to.requirements=Добавить импортованные пакеты в requirements…
QFIX.add.method.to.class=Добавить метод {0}() в класс {1}
QFIX.add.parameter.self=Добавить параметр ''{0}''
QFIX.add.property=Добавить свойство для поля
QFIX.add.qualifier=Добавить квалификатор
QFIX.add.super=Добавить вызов суперкласса
QFIX.augment.assignment=Заменить присваивание на расширенное присваивание
QFIX.auto.import.import.name=Импортовать ''{0}''
QFIX.auto.import.import.this.name=Импортовать это имя
QFIX.chained.comparison=Упростить цепочку сравнений
QFIX.change.base.class=Изменить базовый класс
QFIX.classic.class.transform=Наследовать от object
QFIX.convert.indents=Преобразовать отступы
QFIX.convert.indents.to.spaces=Преобразовать отступы в пробелы
QFIX.convert.indents.to.tabs=Преобразовать отступы в табуляцию
QFIX.convert.single.quoted.docstring=Преобразовать docstring в строку с тройными двойными кавычками
QFIX.convert.to.new.style=Преобразовать в класс нового стиля
QFIX.coroutine.is.not.awaited=Корутина не ожидается
QFIX.create.class=Создать класс
QFIX.create.class.0=Создать класс ''{0}''
QFIX.create.class.in.module=Создать класс ''{0}'' в модуле {1}
QFIX.create.function.in.module=Создать функцию {0}() в модуле {1}
QFIX.create.property=Создать свойство
QFIX.default.argument=Заменить изменяемый аргумент по умолчанию
QFIX.dict.creation=Заменить создание словаря
QFIX.docstring.add.parameter=Добавить параметр docstring ''{0}''
QFIX.docstring.insert.stub=Вставить docstring
QFIX.docstring.remove.parameter=Удалить параметр docstring ''{0}''
QFIX.failed.to.add.field=<br/>Не удалось добавить поле\!<br/><br/>
QFIX.failed.to.add.function=<br/>Не удалось добавить функцию\!<br/><br/>
QFIX.failed.to.add.method=<br/>Не удалось добавить метод\!<br/><br/>
QFIX.ignore.shadowed.built.in.name=Игнорировать затененное встроенное имя "{0}"
QFIX.install.and.import.package=Установить и импортовать пакет
QFIX.introduce.variable=Создать переменную для оператора
QFIX.list.creation=Заменить на литерал списка
QFIX.local.auto.import.import.locally=Локально {0}
QFIX.make.function.return.type=Сделать возвращаемый тип ''{0}'' равным ''{1}''
QFIX.make.public=Сделать публичным
QFIX.move.attribute=Переместить атрибут в метод __init__
QFIX.move.from.future.import=Переместить 'from __future__ import' в правильное место
QFIX.optimize.imports=Оптимизовать импорты
QFIX.pandas.series.values.replace.with.tolist=Заменить list(Series.values) на Series.to_list()
QFIX.redundant.parentheses=Удалить лишние скобки
QFIX.remove.annotation=Удалить аннотацию
QFIX.remove.argument.equal.default=Удалить аргументы, равные значениям по умолчанию
QFIX.remove.decorator=Удалить декоратор
QFIX.remove.function.annotations=Удалить аннотации функции
QFIX.remove.generic.parameters=Удалить обобщенные параметры
QFIX.remove.square.brackets=Удалить квадратные скобки
QFIX.remove.string.prefix=Удалить ведущий {0}
QFIX.remove.trailing.semicolon=Удалить завершающую точку с запятой
QFIX.remove.trailing.suffix=Удалить завершающий суффикс
QFIX.remove.type.comment=Удалить комментарий типа
QFIX.remove.unnecessary.backslash=Удалить ненужный обратный слеш в выражении
QFIX.rename.parameter=Переименовать в ''{0}''
QFIX.rename.unresolved.reference=Переименовать ссылку
QFIX.replace.equality=Заменить сравнение
QFIX.replace.function.set.with.literal=Заменить вызов функции на литерал множества
QFIX.replace.star.by.unpack=Заменить на typing_extensions.Unpack
QFIX.replace.with.old.union.style=Заменить на Union старого стиля
QFIX.replace.with.square.brackets=Заменить на квадратные скобки
QFIX.replace.with.target.name=Заменить на целевое имя
QFIX.replace.with.true.or.false=Заменить на {0}
QFIX.replace.with.type.name=Заменить на имя типа
QFIX.replace.with.typing.alias=Заменить на псевдоним типа
QFIX.simplify.boolean.expression=Заменить логическое выражение на ''{0}''
QFIX.statement.effect=Заменить на вызов функции
QFIX.surround.with.square.brackets=Обернуть в квадратные скобки
QFIX.unresolved.reference=Заменить ''{0}'' на ''{1}.{0}''
QFIX.unresolved.reference.add.param=Создать параметр ''{0}''
QFIX.unresolved.reference.create.function=Создать функцию
QFIX.use.property=Использовать свойство для поля
custom.type.mimic.name=Динамический класс на основе {0}
debugger.cleaning.signature.cache=Очистка кэша динамически собранных типов
element.presentation.location.string.in.class=({0} в {1})
element.presentation.location.string.in.class.stub=({0} в заглушке {1})
element.presentation.location.string.module=({0})
element.presentation.location.string.module.stub=({0} заглушка)
filetype.python.docstring.description=Python docstring
filetype.python.function.type.annotation.description=Аннотация типа функции Python PEP-484
filetype.python.type.hint.description=Подсказка типа Python PEP-484
find.usages.class=класс
find.usages.function=функция
find.usages.imported.module.alias=псевдоним импортованного модуля
find.usages.keyword.argument=именованный аргумент
find.usages.method=метод
find.usages.parameter=параметр
find.usages.unnamed=<без имени>
find.usages.variable=переменная
ignore.overridden.functions=Игнорировать переопределённые функции
python.docstring.format=Формат docstring\:
python.docstring.select.type=Выберите тип Docstring
python.find.usages=Найти использования
python.find.usages.base.method.question=Метод {0} переопределяет метод класса {1}.\nНайти использования базового метода?
python.find.usages.untyped.probable.usage=Нетипизованное (вероятное) использование
python.find.usages.usage.in.import.statement=Использование в операторе import
python.find.usages.usage.in.isinstance=Использование в isinstance()
python.find.usages.usage.in.superclass.list=Использование в списке суперклассов
python.find.usages.usage.in.type.hint=Использование в подсказке типа
refactoring.extract.method=Извлечь метод
refactoring.extract.method.error.bad.selection=Невозможно выполнить рефакторинг "Извлечь метод" с выбранными элементами
refactoring.extract.method.error.class.level=Невозможно выполнить рефакторинг на уровне класса
refactoring.extract.method.error.empty.fragment=Невозможно выполнить рефакторинг из пустого фрагмента кода
refactoring.extract.method.error.interrupted.execution.flow=Невозможно выполнить рефакторинг при прерванном потоке выполнения
refactoring.extract.method.error.local.variable.modifications=Невозможно выполнить рефакторинг из выражения с модификациями локальных переменных внутри фрагмента кода.
refactoring.extract.method.error.local.variable.modifications.and.returns=Невозможно выполнить рефакторинг из выражения с модификациями локальных переменных и инструкциями return внутри фрагмента кода
refactoring.extract.method.error.name.clash=Имя метода конфликтует с существующим именем
refactoring.extract.method.error.returns=Невозможно извлечь метод с инструкциями return внутри фрагмента кода
refactoring.extract.method.error.star.import=Невозможно выполнить рефакторинг с импортом со звездочкой внутри блока кода
refactoring.extract.method.error.yield=Невозможно выполнить рефакторинг с оператором 'yield' внутри блока кода
refactoring.inline.all.border.title=Встраивание
refactoring.inline.all.keep.declaration=Встроить все вызовы и сохранить объявление
refactoring.inline.all.remove.declaration=Встроить все вызовы и удалить объявление
refactoring.inline.can.not.multiline.string.to.f.string=Невозможно встроить многострочную строку в f-строку
refactoring.inline.can.not.string.to.nested.f.string=Невозможно встроить строку во вложенную f-строку
refactoring.inline.can.not.string.with.backslashes.or.quotes.to.f.string=Невозможно встроить строку с обратными слешами и кавычками в f-строку
refactoring.inline.function=Встроить функцию {0}
refactoring.inline.function.async=Невозможно встроить асинхронные функции
refactoring.inline.function.builtin=Невозможно встроить встроенные функции
refactoring.inline.function.command.name=Встраивание {0}
refactoring.inline.function.constructor=Невозможно встроить вызовы конструктора
refactoring.inline.function.decorator=Невозможно встроить функции с декораторами
refactoring.inline.function.function.to.inline=Функция для встраивания
refactoring.inline.function.generator=Невозможно встроить генераторы
refactoring.inline.function.global=Невозможно встроить функции с глобальными переменными
refactoring.inline.function.interrupts.flow=Невозможно встроить функции, прерывающие поток управления
refactoring.inline.function.invocations.to.be.inlined=Вызовы для встраивания в {0} файлах
refactoring.inline.function.is.decorator=Функция {0} используется как декоратор и не может быть встроена. Определение функции не будет удалено
refactoring.inline.function.is.overridden=Невозможно встроить переопределённые методы
refactoring.inline.function.is.reference=Функция {0} используется как ссылка и не может быть встроена. Определение функции не будет удалено
refactoring.inline.function.nested=Невозможно встроить функции с другим объявлением функции
refactoring.inline.function.nonlocal=Невозможно встроить функции с нелокальными переменными
refactoring.inline.function.overrides.method=Невозможно встроить методы, переопределяющие другие методы
refactoring.inline.function.self.referrent=Невозможно встроить функции, ссылающиеся на себя
refactoring.inline.function.skeleton.only=Невозможно встроить функцию из бинарного модуля
refactoring.inline.function.special.method=Невозможно встроить специальные методы
refactoring.inline.function.star=Невозможно встроить функции с аргументами *
refactoring.inline.function.title=Встроить функцию
refactoring.inline.function.uses.unpacking=Функция {0} использует распаковку аргументов и не может быть встроена. Определение функции не будет удалено
refactoring.inline.label.function=Функция {0}
refactoring.inline.label.method=Метод {0}
refactoring.inline.local.multiassignment=Определение находится в множественном присваивании
refactoring.inline.method=Встроить метод {0}
refactoring.inline.this.only=Встроить только этот вызов и сохранить объявление
refactoring.introduce.constant.cannot.extract.selected.expression=Выбранное выражение нельзя извлечь в константу
refactoring.introduce.constant.dialog.title=Извлечь константу
refactoring.introduce.constant.scope.error=Имя уже объявлено в этой области видимости
refactoring.introduce.name.error=Некорректное имя
refactoring.introduce.selection.error=Невозможно выполнить рефакторинг с выбранными элементами
refactoring.introduce.variable.dialog.title=Извлечь переменную
refactoring.introduce.variable.scope.error=Имя конфликтует с существующей переменной или параметром
refactoring.move.module.members.error.cannot.place.elements.into.nonpython.file=Невозможно поместить элементы в не-Python файл
refactoring.name.label.text={0} имеет {1} вхождени{2, choice, 0\#й|1\#е}
refactoring.progress.title.updating.existing.usages=Обновление существующих использований…
type.param.list.annotator.two.or.more.types.required=Требуется два или более типов
type.param.list.annotator.type.parameter.already.defined=Параметр типа с именем ''{0}'' уже определен в этом списке параметров типа
type.param.list.annotator.type.var.tuple.and.param.spec.can.not.have.bounds=ParamSpec и TypeVarTuple не могут иметь ограничений и верхних границ
unresolved.docstring.param.reference=Функция ''{0}'' не имеет параметра ''{1}''
unresolved.import.reference=Модуль ''{0}'' не найден