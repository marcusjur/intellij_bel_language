ACT.CMD.use.import=Выкарыстоўвайце імпартаваны модуль
ACT.from.some.module.import=Імпарт з...
ACT.qualify.with.module=Дапрацаваць з дапамогай імпартаванага модуля
ANN.assign.to.none=Прызначэнне Няма
ANN.assignment.expression.as.a.target=Выраз прысваення не можа быць выкарыстаны ў якасці мэты тут
ANN.assignment.expression.in.an.iterable=Выраз прысваення не можа быць выкарыстаны ў аб'екце, які можа паўтарацца
ANN.assignment.expressions.within.a.comprehension.cannot.be.used.in.a.class.body=Выразы прысваення ўнутры ўключэння нельга выкарыстоўваць у целе класа
ANN.assignment.to.keyword=Прызначэнне ключавых слоў
ANN.await.outside.async.function='чакаць' па-за асінхроннай функцыяй
ANN.break.outside.loop='разрыў' па-за цыклам
ANN.can.t.use.starred.expression.here=Тут нельга выкарыстоўваць выраз з зорачкай
ANN.cannot.assign.to.debug=Немагчыма прысвоіць значэнне __debug__
ANN.cant.assign.to.await.expr=Немагчыма прысвоіць значэнне выразу чакання
ANN.cant.assign.to.call=Немагчыма прысвоіць значэнне выкліку функцыі
ANN.cant.assign.to.comprh=Немагчыма прысвоіць значэнне ўключэнню ў спіс
ANN.cant.assign.to.dict.comprh=Немагчыма прысвоіць значэнне ўключэнню слоўніка
ANN.cant.assign.to.generator=Немагчыма прысвоіць значэнне выразу генератара
ANN.cant.assign.to.lambda=Немагчыма прысвоіць значэнне лямбда
ANN.cant.assign.to.literal=Немагчыма прысвоіць значэнне літаралу
ANN.cant.assign.to.operator=Немагчыма прысвоіць значэнне аператару
ANN.cant.assign.to.parens=Немагчыма прысвоіць значэнне ()
ANN.cant.assign.to.set.comprh=Немагчыма прысвоіць значэнне множнаму ўключэнню
ANN.cant.aug.assign.starred.assignment.target.must.be.in.list.or.tuple=Мэта прысваення з зорачкай павінна знаходзіцца ў спісе або картэжы
ANN.cant.aug.assign.to.comprh=Немагчыма выканаць пашыранае прызначэнне для ўключэння ў спіс
ANN.cant.aug.assign.to.dict.comprh=Немагчыма выканаць пашыранае прызначэнне для ўключэння ў слоўнік
ANN.cant.aug.assign.to.generator=Немагчыма выканаць пашыранае прызначэнне выразу генератара
ANN.cant.aug.assign.to.list.or.comprh=Немагчыма выканаць пашыранае прызначэнне літаралу спісу або ўбудове спісу
ANN.cant.aug.assign.to.set.comprh=Немагчыма выканаць пашыранае прызначэнне множнага ўключэння
ANN.cant.aug.assign.to.tuple.or.generator=Немагчыма выканаць пашыранае прызначэнне літэралу картэжа або выразу генератара
ANN.cant.delete.call=Немагчыма выдаліць выклік функцыі
ANN.cant.delete.literal=Немагчыма выдаліць літар
ANN.continue.break.or.return.in.star.except='break', 'continue' і 'return' не могуць з'явіцца ў блоку exception*
ANN.continue.outside.loop=«працягнуць» па-за цыклам
ANN.default.except.must.be.last=па змаўчанні 'except\:' павінен быць апошнім
ANN.deleting.none=Выдаленне нічога
ANN.duplicate.param.name=паўтаральнае імя параметра
ANN.exception.group.in.star.except=ExceptionGroup нельга выкарыстоўваць у акрамя*
ANN.fstrings.illegal.conversion.character=Няправільны сімвал пераўтварэння ''{0}''\: павінен быць адным з ''s'', ''r'', ''a''
ANN.fstrings.missing.conversion.character=Чаканы сімвал пераўтварэння\: павінен быць адным з '', 'r', 'a'
ANN.fstrings.single.right.brace.not.allowed.inside.fstrings=Адзін '}' не дазваляецца ўнутры f-радкоў
ANN.generator.expression.must.be.parenthesized.if.not.sole.argument=Выраз генератара павінен быць заключаны ў дужкі, калі гэта не адзіны аргумент
ANN.ignore.errors.like.this=Ігнаруйце такія памылкі
ANN.illegal.target.for.variable.annotation=Няправільная мэта для анатацыі зменнай
ANN.missing.closing.quote=Адсутнічае завяршальная цытата [{0}]
ANN.missing.closing.triple.quotes=Закрывальныя патройныя двукоссі адсутнічаюць
ANN.multiple.args=некалькі параметраў * не дапускаецца
ANN.multiple.kwargs=некалькі параметраў ** не дапускаюцца
ANN.multiple.slash=некалькі параметраў / не дапускаецца
ANN.name.used.both.as.global.and.param=Імя ''{0}'' выкарыстоўваецца і як параметр, і як глабальная зменная
ANN.named.parameters.after.star=названыя параметры павінны ісці пасля аднаго *
ANN.named.parameters.before.slash=найменныя параметры павінны папярэднічаць аднаму /
ANN.no.exception.to.reraise=Не выключэнне і для паўторнага ўзбуджэння
ANN.non.default.param.after.default=параметр без значэння па змаўчанні ідзе пасля параметра са значэннем па змаўчанні
ANN.non.empty.return.inside.asynchronous.generator=непусты "вяртанне" ўнутры асінхроннага генератара
ANN.patterns.attribute.name.is.repeated=Назва атрыбута ''{0}'' паўтараецца
ANN.patterns.double.star.pattern.cannot.be.used.outside.mapping.patterns=Шаблон з дзвюма зоркамі нельга выкарыстоўваць па-за шаблонамі адлюстравання
ANN.patterns.invalid.complex.number.literal=Няправільны літэр камплекснага ліку
ANN.patterns.key.pattern.can.only.be.value.or.literal.pattern=Ключавым шаблонам можа быць толькі шаблон значэння або літаральны шаблон
ANN.patterns.name.already.bound=Імя «{0}» ужо звязана
ANN.patterns.pattern.does.not.bind.names=Шаблон не связывает {0,choice,1\#имя|2\#имена} {1}
ANN.patterns.pattern.makes.remaining.alternatives.unreachable=Шаблон робіць астатнія альтэрнатывы недасягальнымі
ANN.patterns.pattern.makes.remaining.case.clauses.unreachable=Шаблон робіць астатнія склоны недасяжнымі
ANN.patterns.repeated.star.pattern=Паўтаральны ўзор з зоркай
ANN.patterns.single.star.pattern.cannot.be.used.outside.sequence.patterns=Шаблон адной зоркі не можа выкарыстоўвацца па-за паслядоўнымі шаблонамі
ANN.python.does.not.support.yield.from.inside.async.functions=Python не падтрымлівае «yield from» у асінхронных функцыях
ANN.regular.param.after.keyword=звычайны параметр пасля параметра **
ANN.regular.param.after.vararg=звычайны параметр пасля параметра *
ANN.return.outside.of.function="вярнуць" па-за функцыяй
ANN.slash.param.after.keyword=Параметр / павінен папярэднічаць параметру **
ANN.slash.param.after.vararg=Параметр / павінен папярэднічаць параметру *
ANN.star.import.at.top.only='імпарт *' дазволены толькі на ўзроўні модуля
ANN.starred.param.after.kwparam=параметр * пасля параметра **
ANN.try.except.can.not.have.except.and.star.except=Аператар try не можа змяшчаць адначасова акрамя і акрамя *
ANN.tuple.py3=распакаванне параметраў картэжа не падтрымліваецца ў Python 3
ANN.unparenthesized.assignment.expression.statement=Выразы прысваення без дужак забароненыя на верхнім узроўні выразу аператара
ANN.unparenthesized.assignment.expression.value=Выразы прысваення без дужак забароненыя на верхнім узроўні правага боку аператара прысвойвання
ANN.variable.annotation.cannot.be.combined.with.tuple.unpacking=Анатацыю зменнай нельга спалучаць з распакаваннем картэжа
ANN.variable.annotation.cannot.be.used.in.assignment.with.multiple.targets=Анатацыя зменнай не можа быць выкарыстана ў шматмэтавым прызначэнні
ANN.yield.outside.of.function='yield' знаходзіцца па-за функцыяй
INSP.GROUP.python=Python
INSP.NAME.abstract.class=Клас павінен рэалізаваць усе абстрактныя метады
INSP.NAME.argument.equal.default=Аргумент функцыі роўны значэнню параметра па змаўчанні
INSP.NAME.assignment.to.loop.or.with.parameter=Прызначэнне параметру цыкла "for" або "with".
INSP.NAME.attribute.outside.init=Атрыбут асобніка, вызначаны па-за `__init__`
INSP.NAME.augment.assignment=Заданне можна замяніць пашыраным заданнем
INSP.NAME.bad.except.clauses.order=Няправільны парадак сказаў «за выключэннем».
INSP.NAME.byte.literal=Літарал байта змяшчае сімвалы, якія не з'яўляюцца ASCII
INSP.NAME.calling.non.callable=Спроба выклікаць неаб'ект
INSP.NAME.chained.comparisons=Занадта складаныя ланцужкі параўнанняў
INSP.NAME.check.can.be.simplified=Праверка залішняй лагічнай зменнай
INSP.NAME.class.has.no.init=Клас не мае метаду `__init__`
INSP.NAME.class.var.variables=Няправільнае выкарыстанне ClassVars
INSP.NAME.classic.class.usage=Выкарыстанне класічнага стылю
INSP.NAME.comparison.with.none=Выкарыстанне аператараў роўнасці для параўнання з None
INSP.NAME.compatibility=Код несумяшчальны з пэўнымі версіямі Python
INSP.NAME.coroutine.is.not.awaited=Карэспандэнцыя ''{0}'' не чакаецца
INSP.NAME.dataclass.definition.and.usages=Няправільнае вызначэнне і выкарыстанне класаў даных
INSP.NAME.decorator.outside.class=Спецыфічны для класа дэкаратар выкарыстоўваецца па-за класам
INSP.NAME.default.argument=Аргумент па змаўчанні зменлівы
INSP.NAME.deprecated.function.class.or.module=Састарэлая функцыя, клас або модуль
INSP.NAME.dict.creation=Стварэнне слоўніка можа быць перапісана з дапамогай слоўнікавага літарала
INSP.NAME.docstring.types=Тып у радку дакументацыі не адпавядае меркаванаму тыпу
INSP.NAME.dunder.slots=Няправільнае выкарыстанне класаў з азначэннямі '__slots__'
INSP.NAME.duplicate.keys=Слоўнік змяшчае дублікаты ключоў
INSP.NAME.exception.not.inherit=Выключэнні не ўспадкоўваюцца ад стандартнага класа Exception
INSP.NAME.final.classes.methods.and.variables=Няправільнае выкарыстанне канчатковых класаў, метадаў і зменных
INSP.NAME.first.arg.assign=Першы аргумент метаду перапрызначаны
INSP.NAME.from.future.import=Няправільная пазіцыя з __будучага__ імпарту
INSP.NAME.global.undefined=Глабальная зменная не вызначана на ўзроўні модуля
INSP.NAME.inconsistent.indentation=Непаслядоўны водступ
INSP.NAME.incorrect.call.arguments=Няправільныя аргументы выкліку
INSP.NAME.incorrect.docstring=Няправільны радок дакументацыі
INSP.NAME.init.return=Метад __init__ вяртае значэнне
INSP.NAME.invalid.interpreter=Няправільны інтэрпрэтатар
INSP.NAME.invalid.usages.of.override.decorator=Няправільнае выкарыстанне дэкаратара @override
INSP.NAME.list.creation=Аб'ява неаптымальнага спісу
INSP.NAME.mandatory.encoding=Кадыроўка файла не ўказана
INSP.NAME.method.may.be.static=Метад не заяўлены як статычны
INSP.NAME.method.over=Подпіс метаду не супадае з подпісам перавызначанага метаду
INSP.NAME.missing.or.empty.docstring=Адсутнічае або пусты радок дакументацыі
INSP.NAME.missing.super.constructor=Прапушчаны выклік '__init__' суперкласа
INSP.NAME.missing.type.hints=Адсутнічаюць падказкі тыпу для вызначэння функцыі
INSP.NAME.nested.decorators=Праблемная ўкладзенасць дэкаратараў
INSP.NAME.new.init.signature=Несумяшчальныя подпісы __new__ і __init__
INSP.NAME.new.style.generics.type.param.syntax=Няправільнае выкарыстанне параметраў тыпу і новых псеўданімаў тыпу стылю
INSP.NAME.non.ascii=Файл змяшчае сімвалы, якія не з'яўляюцца ASCII
INSP.NAME.none.function.assignment=Прызначэнне выклікаў функцый, якія нічога не вяртаюць
INSP.NAME.oldstyle.class=Стары клас стылю змяшчае функцыі новага класа стылю
INSP.NAME.overloads.in.regular.python.files=Перагрузкі ў звычайных файлах Python
INSP.NAME.pep8.naming=Парушэнне правілаў наймення PEP 8
INSP.NAME.problematic.first.parameter=Няправільны першы параметр
INSP.NAME.property.access=Няправільны доступ да ўласцівасцей
INSP.NAME.property.definition=Няправільнае вызначэнне ўласцівасці
INSP.NAME.protected.member=Доступ да абароненага члена класа або модуля
INSP.NAME.protocol.definition.and.usages=Няправільныя азначэнні і выкарыстанне пратаколаў
INSP.NAME.pytest-parametrized=Няправільныя аргументы ў @pytest.mark.parametrize
INSP.NAME.pytest.unpassed.fixture=Прыстасаванне не запытваецца тэставымі функцыямі
INSP.NAME.redeclaration=Пераабвешчаныя імёны без выкарыстання
INSP.NAME.redundant.parentheses=Лішнія дужкі
INSP.NAME.relative.import=Падазроны адносны імпарт
INSP.NAME.requirements=Невыкананыя патрабаванні да пакета
INSP.NAME.set.function.to.literal=Выклік функцыі можа быць заменены літэралам набору
INSP.NAME.shadowing.builtins=Зацяненне ўбудаваных імёнаў
INSP.NAME.single.quoted.docstring=Радок дакументацыі ў адзінарных двукоссях
INSP.NAME.statement.effect=Выраз не дзейнічае
INSP.NAME.str.format=Памылкі ў аперацыях фарматавання радка
INSP.NAME.too.broad.exception.clauses=Невыразныя блокі выключэнняў
INSP.NAME.trailing.semicolon=Недапушчальная кропка з коскі ў выразе
INSP.NAME.tuple.assignment.balance=Няправільны баланс прысваення картэжа
INSP.NAME.tuple.item.assignment=Прызначэнне элементу картэжа забаронена
INSP.NAME.type.checker=Няправільны тып
INSP.NAME.type.hints=Няправільныя вызначэнні і выкарыстанне падказак тыпу
INSP.NAME.typed.dict=Няправільнае вызначэнне і выкарыстанне TypedDict
INSP.NAME.unbound=Непрывязаныя лакальныя зменныя
INSP.NAME.unnecessary.backslash=Непатрэбны зваротны слэш
INSP.NAME.unreachable.code=Недаступны код
INSP.NAME.unresolved.refs=Нявырашаныя спасылкі
INSP.NAME.unused=Нявыкарыстаная мясцовая сімволіка
INSP.NAME.wrong.super.arguments=Няправільныя аргументы пры выкліку супер
INSP.abstract.class.add.to.superclasses=Дадаць ''{0}'' да суперкласаў
INSP.abstract.class.class.must.implement.all.abstract.methods=Клас {0} павінен рэалізаваць усе абстрактныя метады
INSP.abstract.class.set.as.metaclass=Усталяваць ''{0}'' як метаклас
INSP.argument.equals.to.default=Аргумент роўны значэнню параметра па змаўчанні
INSP.arguments.not.declared.but.provided.by.decorator=Наступныя аргументы не дэкларуюцца, але прадастаўляюцца дэкаратарам: {0}
INSP.assignment.can.be.replaced.with.augmented.assignment=Заданне можна замяніць састаўным
INSP.assignment.to.loop.or.with.parameter=Пераменная «{0}» ужо аб'яўлена ў цыкле «for» або «with» вышэй
INSP.async.call=У выкліках супраграмы адсутнічае сінтаксіс `await`
INSP.attribute.outside.init=Атрыбут асобніка {0} вызначаны па-за __init__
INSP.auto.to.manual.field.numbering=Немагчыма пераключыцца з аўтаматычнай нумарацыі палёў на ручную спецыфікацыю
INSP.bad.except.exception.class.already.caught=Клас выключэння ''{0}'' ужо быў перахоплены
INSP.bad.except.superclass.of.exception.class.already.caught=''{0}'', суперклас класа выключэнняў ''{1}'', ужо быў перахоплены
INSP.byte.literal.contains.illegal.characters=Літарал байтаў змяшчае сімвалы > 255
INSP.cant.return.value.from.init=Немагчыма вярнуць значэнне з __init__
INSP.chained.comparisons.ignore.statements.with.constant.in.the.middle=Не звяртайце ўвагі на выразы з канстантай пасярэдзіне
INSP.class.has.no.init=Клас не мае метаду __init__
INSP.class.is.not.subtype.of.class=''{0}'' не з'яўляецца асобнікам або падкласам ''{1}''
INSP.class.object.is.not.callable=Аб'ект ''{0}'' нельга выклікаць
INSP.class.var.can.be.used.only.in.class.body='ClassVar' можна выкарыстоўваць толькі для прызначэнняў у целе класа
INSP.class.var.can.not.be.assigned.to.instance=Немагчыма прызначыць зменную класа ''{0}'' праз асобнік
INSP.class.var.can.not.be.used.in.annotation.for.function.return.value="ClassVar" не можа выкарыстоўвацца ў анатацыі для значэння, якое вяртаецца функцыяй
INSP.class.var.can.not.be.used.in.annotations.for.function.parameters="ClassVar" нельга выкарыстоўваць у анатацыях для параметраў функцыі
INSP.class.var.can.not.be.used.in.function.body='ClassVar' нельга выкарыстоўваць у анатацыях для лакальных зменных
INSP.class.var.can.not.include.type.variables=Параметр 'ClassVar' не можа ўключаць зменныя тыпу
INSP.class.var.can.not.override.class.variable=Немагчыма перавызначыць зменную класа ''{0}'' (раней заяўленую ў базавым класе ''{1}'') на зменную асобніка
INSP.class.var.can.not.override.instance.variable=Немагчыма перавызначыць зменную асобніка ''{0}'' (раней заяўленую ў базавым класе ''{1}'') зменнай класа
INSP.classic.class.usage.old.style.class=Клас у старым стылі
INSP.classic.class.usage.old.style.class.ancestors=Клас старога стылю, бо ўсе класы, ад якіх ён успадкоўваецца, з'яўляюцца класамі старога стылю
INSP.comparison.with.none.performed.with.equality.operators=Параўнанне з None робіцца з дапамогай аператараў роўнасці
INSP.compatibility.basestring.type.not.available.in.py3=тып basestring недаступны ў Python 3
INSP.compatibility.check.for.compatibility.with.python.versions=Праверце сумяшчальнасць з версіямі Python:
INSP.compatibility.feature.allow.async.and.await.as.names=дазваляюць выкарыстоўваць «асінхронныя» і «чакаць» у якасці імёнаў
INSP.compatibility.feature.allow.backslashes.in.f-strings=дазваляць зваротныя касыя рысы ўнутры частак f-радковых выразаў
INSP.compatibility.feature.allow.deep.expression.nesting.in.f-strings=дазваляюць укладваць выразы ў спецыфікатары фармату да такой глыбіні
INSP.compatibility.feature.allow.duplicate.kwargs=дазволіць дублікаты **выразаў
INSP.compatibility.feature.allow.duplicate.positional.varargs=дазволіць паўтаральныя *выразы
INSP.compatibility.feature.allow.keyword.arguments.after.kwargs=дазваляць названыя аргументы пасля **выразу
INSP.compatibility.feature.allow.new.lines.in.f-strings=дазваляць новыя радкі ў частках выразаў, якія не з'яўляюцца трайнымі f-радкамі
INSP.compatibility.feature.allow.positional.arguments.after.expression=дазваляць пазіцыйныя аргументы пасля *выразу
INSP.compatibility.feature.allow.quote.reuse.in.f-strings=дазваляюць укладваць радковыя літэралы з аднолькавым тыпам двукоссяў у f-радкі
INSP.compatibility.feature.allow.to.mix.bytes.and.non.bytes.literals=дазваляюць змешваць байтавыя і небайтавыя літаралы
INSP.compatibility.feature.allow.trailing.comma.after.kwargs=дазваляе коску пасля выразу **
INSP.compatibility.feature.allow.trailing.comma.after.positional.vararg=дазваляе ставіць коску пасля *выразу
INSP.compatibility.feature.have.method=мае метад {0}
INSP.compatibility.feature.have.module=мае модуль {0}
INSP.compatibility.feature.have.module.builtin=мае __ўбудаваны__ модуль
INSP.compatibility.feature.have.module.builtins=мае ўбудаваны модуль
INSP.compatibility.feature.have.nonlocal.keyword=мае ключавое слова nonlocal
INSP.compatibility.feature.have.type.long=мае тып long. Замест гэтага выкарыстоўвайце int.
INSP.compatibility.feature.line.comments.in.f-strings=дазваляе каментарыі ўнутры выразаў у f-радках
INSP.compatibility.feature.support.arbitrary.expressions.as.decorator=падтрымлівае адвольныя выразы ў якасці дэкаратара
INSP.compatibility.feature.support.assignment.expressions=падтрымлівае выразы прысваення
INSP.compatibility.feature.support.backquotes=падтрымлівае зваротныя двукоссі, замест гэтага выкарыстоўвайце repr().
INSP.compatibility.feature.support.continue.inside.finally.clause=падтрымлівае "працягнуць" у блоку "нарэшце".
INSP.compatibility.feature.support.diamond.operator=падтрымлівае <>, замест гэтага выкарыстоўвайце \!\=
INSP.compatibility.feature.support.ellipsis.outside.slices=падтрымлівае "..." знешнія зрэзы паслядоўнасці
INSP.compatibility.feature.support.long.integer.literal.suffix=падтрымлівае суфікс ''{0}''
INSP.compatibility.feature.support.match.statements=падтрымлівае аператары супастаўлення
INSP.compatibility.feature.support.matrix.multiplication.operators=падтрымлівае аператары матрычнага множання
INSP.compatibility.feature.support.old.style.octal.literals=падтрымлівае гэты сінтаксіс. Васьмярковыя літэралы патрабуюць прэфікса "0o".
INSP.compatibility.feature.support.parenthesized.context.expressions=падтрымлівае кантэкстныя выразы ў дужках
INSP.compatibility.feature.support.positional.only.parameters=падтрымлівае параметры толькі па пазіцыі
INSP.compatibility.feature.support.print.statement=падтрымлівае гэты сінтаксіс. Аператар print быў заменены функцыяй print().
INSP.compatibility.feature.support.raise.with.no.arguments.outside.except.block=падтрымлівае гэты сінтаксіс. Павышэнне без аргументаў можа выкарыстоўвацца толькі ў блоку выключэнняў
INSP.compatibility.feature.support.starred.except.part=падтрымлівае частку акрамя*
INSP.compatibility.feature.support.starred.expressions.as.assignment.targets=падтрымлівае пазначаныя зорачкай выразы як мэты прысваення
INSP.compatibility.feature.support.starred.expressions.in.dicts=падтрымлівае пазначаныя зорачкай выразы ў слоўніках
INSP.compatibility.feature.support.starred.expressions.in.subscriptions=падтрымлівае пазначаныя выразы ў падпісках
INSP.compatibility.feature.support.starred.expressions.in.tuples.lists.and.sets=падтрымлівае пазначаныя выразы ў картэжах, спісах і наборах
INSP.compatibility.feature.support.starred.expressions.in.type.annotations=падтрымлівае пазначаныя зорачкай выразы ў анатацыях тыпу
INSP.compatibility.feature.support.string.literal.prefix=падтрымлівае прэфікс ''{0}''
INSP.compatibility.feature.support.super.without.arguments=падтрымлівае гэты сінтаксіс. super() павінен мець аргументы ў Python 2
INSP.compatibility.feature.support.this.syntax=падтрымлівае гэты сінтаксіс
INSP.compatibility.feature.support.this.syntax.in.list.comprehensions=падтрымлівае гэты сінтаксіс у спісе ўключэнняў
INSP.compatibility.feature.support.type.alias.statements=падтрымлівае выразы псеўданімаў тыпу
INSP.compatibility.feature.support.underscores.in.numeric.literals=падтрымлівае падкрэсліванне ў лікавых літэралах
INSP.compatibility.feature.support.unpacking.without.parentheses.in.return.statements=падтрымлівае распакаванне без круглых дужак у аператарах вяртання
INSP.compatibility.feature.support.unpacking.without.parentheses.in.yield.statements=падтрымлівае распакаванне без дужак у заявах yield
INSP.compatibility.feature.support.variable.annotations=падтрымлівае зменныя анатацыі
INSP.compatibility.feature.support.yield.from=падтрымлівае гэты сінтаксіс. Дэлегаванне падгенератару даступна з Python 3.3; выкарыстоўваць відавочную ітэрацыю над падгенератарам.
INSP.compatibility.inspection.unsupported.feature.prefix=Python {0,choice,1\#версия|2\#версии} {1} {0,choice,1\#не|2\#не} {2}
INSP.compatibility.keyword.argument.repeated=Паўтаральны найменны аргумент
INSP.compatibility.new.union.syntax.not.available.in.earlier.version=дазваляе пісаць аб'яднаныя тыпы як X | Я
INSP.compatibility.old.dict.methods.not.available.in.py3=Метады dict.iterkeys(), dict.iteritems() і dict.itervalues() недаступныя ў Python 3
INSP.compatibility.positional.argument.after.keyword.argument=Пазіцыйны аргумент пасля названага аргумента
INSP.compatibility.positional.argument.after.kwargs=Пазіцыйны аргумент пасля выразу **
INSP.compatibility.pre35.versions.do.not.allow.return.with.argument.inside.generator=Версіі Python < 3.3 не дазваляюць выкарыстоўваць 'return' з аргументам у генератары.
INSP.compatibility.support.equality.signs.in.fstrings=падтрымлівае знакі роўнасці ў f-радках
INSP.compatibility.this.syntax.available.only.since.py3=Гэты сінтаксіс даступны толькі з Python 3
INSP.dataclasses.argument.ignored.if.class.already.defines.method=''{0}'' ігнаруецца, калі клас ужо вызначае метад ''{1}''
INSP.dataclasses.attribute.default.set.using.method=Па змаўчанні ўстаноўлена ''{0}''
INSP.dataclasses.attribute.lacks.type.annotation=Атрыбут ''{0}'' не мае анатацыі тыпу
INSP.dataclasses.attribute.useless.until.post.init.declared=Атрыбут ''{0}'' бескарысны, калі не аб'яўлены ''__post_init__''
INSP.dataclasses.attrs.post.init.should.not.take.any.parameters.except.self='__attrs_post_init__' не павінен прымаць ніякіх параметраў, акрамя 'self'
INSP.dataclasses.attrs.post.init.would.not.be.called.until.init.parameter.set.to.true='__attrs_post_init__' не будзе выклікаць, калі для 'init' не ўстаноўлена значэнне True
INSP.dataclasses.cannot.specify.both.default.and.default.factory=Вы не можаце ўказаць адначасова "default" і "default_factory"
INSP.dataclasses.cannot.specify.both.default.and.factory=Вы не можаце адначасова ўказаць "па змаўчанні" і "завод"
INSP.dataclasses.eq.must.be.true.if.order.true='eq' павінна быць ісцінай, калі 'order' ісціна
INSP.dataclasses.field.cannot.have.default.factory=Поле не можа мець завод па змаўчанні
INSP.dataclasses.frozen.attribute.should.be.false.if.class.defines.setattr.or.delattr=«замарожаны» павінен быць False, калі клас вызначае «__setattr__» або «__delattr__»
INSP.dataclasses.frozen.dataclasses.can.not.inherit.non.frozen.one=Замарожаныя класы даных не могуць успадкоўваць незамарожаныя, і наадварот
INSP.dataclasses.hash.ignored.if.class.already.defines.cmp.or.order.or.frozen.parameters='__hash__' ігнаруецца, калі клас ужо вызначае параметры 'cmp/order' і 'frozen'
INSP.dataclasses.method.is.ignored.if.class.already.defines.parameter=''{0}'' ігнаруецца, калі клас ужо вызначае ''{1}''
INSP.dataclasses.method.should.be.called.on.attrs.instances=Метад ''{0}'' павінен быць выкліканы ў асобніках attr
INSP.dataclasses.method.should.be.called.on.attrs.types=Метад ''{0}'' павінен быць выкліканы для тыпаў attr
INSP.dataclasses.method.should.be.called.on.dataclass.instances=Метад ''{0}'' павінен быць выкліканы ў асобніках класа дадзеных
INSP.dataclasses.method.should.be.called.on.dataclass.instances.or.types=Метад ''{0}'' павінен быць выкліканы ў асобніках або тыпах класа даных
INSP.dataclasses.method.should.take.only.n.parameter=''{0}'' должен принимать только {1} {1,choice,1\#параметр|2\#параметра|3\#параметров}
INSP.dataclasses.mutable.attribute.default.not.allowed.use.default.factory=Зменлівае значэнне па змаўчанні ''{0}'' не дазваляецца. Выкарыстоўвайце ''default_factory''
INSP.dataclasses.object.attribute.read.only=Атрыбут ''{1}'' аб'екта ''{0}'' даступны толькі для чытання
INSP.dataclasses.object.could.have.no.attribute.because.it.declared.as.init.only=Аб'ект ''{0}'' не можа мець атрыбут ''{1}'', таму што ён аб'яўлены як толькі для ініцыялізацыі
INSP.dataclasses.operator.not.supported.between.instances.of.class=''{0}'' не падтрымліваецца паміж асобнікамі ''{1}''
INSP.dataclasses.operator.not.supported.between.instances.of.classes=''{0}'' не падтрымліваецца паміж асобнікамі ''{1}'' і ''{2}''
INSP.dataclasses.order.argument.should.be.false.if.class.defines.one.of.order.methods='order' павінен быць False, калі клас вызначае адзін з метадаў упарадкавання
INSP.dataclasses.post.init.should.take.all.init.only.variables.in.same.order.they.defined='__post_init__' павінен прымаць усе зменныя толькі для ініцыялізацыі ў тым жа парадку, у якім яны вызначаны
INSP.dataclasses.post.init.should.take.all.init.only.variables.including.inherited.in.same.order.they.defined='__post_init__' павінен прымаць усе зменныя толькі для ініцыялізацыі (у тым ліку атрыманыя ў спадчыну) у тым жа парадку, у якім яны вызначаны
INSP.dataclasses.post.init.would.not.be.called.until.init.parameter.set.to.true='__post_init__' не будзе выклікаць, калі для 'init' не ўстаноўлена значэнне True
INSP.dataclasses.unsafe.hash.attribute.should.be.false.if.class.defines.hash='unsafe_hash' павінен быць False, калі клас вызначае '__hash__'
INSP.decorator.receives.unexpected.builtin=Гэты дэкаратар не атрымае чаканага выкліку; убудаваны дэкаратар вяртае спецыяльны аб'ект
INSP.decorators.method.only.decorator.on.method.outside.class=Дэкаратар {0} для метаду па-за класам
INSP.default.arguments.default.argument.value.mutable=Значэнне аргумента па змаўчанні зменлівае
INSP.deleter.should.not.return=Праграма выдалення не павінна вяртаць значэнне
INSP.deleter.signature.advice=Подпіс выдаляльніка павінен быць (сам)
INSP.deprecation.abc.decorator.deprecated.use.alternative=''{0}'' састарэла з Python 3.3. Замест гэтага выкарыстоўвайце ''{1}'' з ''{2}''
INSP.dict.creation.this.dictionary.creation.could.be.rewritten.as.dictionary.literal=Гэта стварэнне слоўніка можа быць перапісана як слоўнікавы літарал
INSP.doc.param.should.be.str=Параметр doc павінен быць радком
INSP.docstring.types.change.type=Змяніце тып {0} з {1} на {2}
INSP.docstring.types.dynamically.inferred.type.does.not.match.specified.type=Дынамічна выведзены тып ''{0}'' не адпавядае вызначанаму тыпу ''{1}''
INSP.docstring.types.fix.docstring=Выправіць радок дакумента
INSP.dunder.slots.class.object.attribute.read.only=Атрыбут ''{1}'' аб'екта ''{0}'' даступны толькі для чытання
INSP.dunder.slots.name.in.slots.conflicts.with.class.variable=«{0}» у __слотах__ канфліктуе са зменнай класа
INSP.duplicate.keys.dictionary.contains.duplicate.keys=Слоўнік змяшчае дублікаты ключоў ''{0}''
INSP.empty.docstring=Пусты радок дакументацыі
INSP.exception.inheritance.exception.does.not.inherit.from.base.exception.class=Выключэнне не ўспадкоўваецца ад базавага класа "Exception"
INSP.expected.dict.got.type=Чакаецца слоўнік, атрыманы {0}
INSP.expected.iterable.got.type=Чакаецца ітэраваны аб'ект, атрыманы {0}
INSP.expression.can.be.simplified=Выраз можна спрасціць
INSP.expression.is.not.callable=Выраз не выклікаецца
INSP.final.already.declared.name.could.not.be.redefined.as.final=Ужо заяўленае імя не можа быць перавызначана як "Канчатковае"
INSP.final.either.instance.attribute.or.class.attribute.could.be.type.hinted.as.final=Атрыбут асобніка або класа можа мець падказку тыпу "Final"
INSP.final.final.attribute.could.not.be.overridden=«{0}» з'яўляецца «канчатковым» і не можа быць перавызначаны
INSP.final.final.attribute.should.be.declared.in.class.body.or.init=Атрыбут «Final» павінен быць аб'яўлены ў целе класа або «__init__»
INSP.final.final.class.could.not.contain.abstract.methods=Клас «Final» не можа ўтрымліваць абстрактныя метады
INSP.final.final.could.not.be.mixed.with.abstract.decorators="Final" нельга змешваць з абстрактнымі дэкаратарамі
INSP.final.final.could.not.be.used.in.annotation.for.function.return.value="Final" нельга выкарыстоўваць у анатацыі значэння, якое вяртаецца функцыяй
INSP.final.final.could.not.be.used.in.annotations.for.function.parameters=«Final» нельга выкарыстоўваць у анатацыях параметраў функцыі
INSP.final.final.could.not.be.used.inside.loop="Final" нельга выкарыстоўваць у цыкле
INSP.final.final.could.only.be.used.as.outermost.type="Final" можна выкарыстоўваць толькі як крайні тып
INSP.final.final.name.should.be.initialized.with.value="Канчатковае" імя павінна быць ініцыялізавана значэннем
INSP.final.final.should.be.placed.on.first.overload='@final' павінен быць размешчаны на першай перагрузцы
INSP.final.final.should.be.placed.on.implementation='@final' павінен быць змешчаны ў рэалізацыі
INSP.final.final.target.could.not.be.reassigned=''{0}'' з'яўляецца ''Канчатковым'' і не можа быць перапрызначаны
INSP.final.if.assigned.value.omitted.there.should.be.explicit.type.argument.to.final=Калі прысвоенае значэнне апушчана, павінен быць відавочны аргумент тыпу для "Final"
INSP.final.method.marked.as.final.should.not.be.overridden=''{0}'' пазначаны як ''@final'' і не павінен быць перавызначаны
INSP.final.no.need.to.mark.method.in.final.class.as.final=Няма неабходнасці пазначаць метад у класе "Final" як "@final"
INSP.final.non.method.function.could.not.be.marked.as.final=Функцыя, якая не з'яўляецца метадам, не можа быць пазначана як "@final"
INSP.final.super.classes.are.marked.as.final.and.should.not.be.subclassed={0} {1,choice,1\#помечен|2\#помечены} как ''@final'' и не должен наследоваться
INSP.first.arg.assign.method.parameter.reassigned=Параметр метаду ''{0}'' быў перапрызначаны
INSP.first.param.must.not.be.tuple=Першы параметр нестатычнага метаду не павінен быць картэжам
INSP.format.requires.mapping=Фармат патрабуе адлюстравання
INSP.format.requires.no.mapping=Фармат не патрабуе адлюстравання
INSP.from.future.import.from.future.imports.must.occur.at.beginning.file=Імпарт з __future__ павінен быць у пачатку файла
INSP.func.property.name.mismatch=Назвы функцыі і дэкаратара не супадаюць; сродак доступу да ўласцівасці не створана
INSP.function.lacks.positional.argument=У функцыі ''{0}'' адсутнічае пазіцыйны аргумент
INSP.getter.return.smth=Геттер павінен нешта вяртаць або ствараць
INSP.getter.signature.advice=Подпіс атрымальніка павінен быць (сам)
INSP.global.variable.undefined=Глабальная зменная ''{0}'' не вызначана на ўзроўні модуля
INSP.incompatible.options=Параметры фармату ў блоку "{0}" несумяшчальныя
INSP.inconsistent.indentation.mix.tabs.spaces=Непаслядоўны водступ\: змешванне табуляцыі і прабелаў
INSP.inconsistent.indentation.previous.line.used.spaces.this.line.uses.tabs=Неадпаведны водступ: папярэдні радок выкарыстоўвае прабелы, гэты радок выкарыстоўвае табуляцыю
INSP.inconsistent.indentation.previous.line.used.tabs.this.line.uses.spaces=Неадпаведныя водступы: папярэдні радок выкарыстоўвае табуляцыю, гэты радок выкарыстоўвае прабелы
INSP.incorrect.arguments=Няправільны аргумент(ы)
INSP.init.incompatible.to.new=Подпіс несумяшчальны з __new__
INSP.interpreter.configure.python.interpreter=Наладзіць інтэрпрэтатар Python
INSP.interpreter.interpreter.settings=Налады інтэрпрэтатара
INSP.interpreter.invalid.python.interpreter.selected.for.module=Для модуля выбраны няправільны інтэрпрэтатар Python
INSP.interpreter.invalid.python.interpreter.selected.for.project=Для праекта абраны няправільны інтэрпрэтатар Python
INSP.interpreter.no.python.interpreter.configured.for.module=Інтэрпрэтатар Python для модуля не наладжаны
INSP.interpreter.no.python.interpreter.configured.for.project=Інтэрпрэтатар Python для праекта не наладжаны
INSP.interpreter.pipenv.interpreter.associated.with.another.module=Інтэрпрэтатар Pipenv звязаны з іншым модулем\: ''{0}''
INSP.interpreter.pipenv.interpreter.associated.with.another.project=Інтэрпрэтатар Pipenv звязаны з іншым праектам\: ''{0}''
INSP.interpreter.pipenv.interpreter.not.associated.with.any.module=Інтэрпрэтатар Pipenv не звязаны ні з адным модулем
INSP.interpreter.pipenv.interpreter.not.associated.with.any.project=Інтэрпрэтатар Pipenv не звязаны ні з адным праектам
INSP.interpreter.python.has.reached.its.end.life.and.is.no.longer.supported.in.python.plugin=Падтрымка Python {0} скончылася і больш не падтрымліваецца ў плагіне Python
INSP.interpreter.python.has.reached.its.end.of.life.and.is.no.longer.supported.in.pycharm=Падтрымка Python {0} скончылася і больш не падтрымліваецца ў PyCharm
INSP.interpreter.use.interpreter=Выкарыстоўвайце {0}
INSP.interpreter.use.suggested.interpreter=Выкарыстоўвайце прапанаваны інтэрпрэтатар
INSP.list.creation.this.list.creation.could.be.rewritten.as.list.literal=Шматэтапную ініцыялізацыю спіса можна замяніць літэралам спісу
INSP.mandatory.encoding.checkbox.enable.in.python.3=Уключыць у Python 3+
INSP.mandatory.encoding.label.encoding.comment.format=Фармат каментара кадавання\:
INSP.mandatory.encoding.label.select.default.encoding=Выберыце кадоўку па змаўчанні\:
INSP.mandatory.encoding.no.encoding.specified.for.file=Кадыроўка файла не ўказана
INSP.manual.to.auto.field.numbering=Немагчыма пераключыцца з ручной спецыфікацыі палёў на аўтаматычную нумарацыю
INSP.message.single.quoted.docstring=Для docstring трэба выкарыстоўваць радкі з патройнымі двукоссямі.
INSP.method.may.be.static=Метад <code>\#ref</code> можа быць «статычным»
INSP.method.parameters.metaclass.method.first.argument.name=Імя першага аргументу метаду метакласса
INSP.missing.parameter.in.docstring=У радку дакумента адсутнічае параметр {0}
INSP.missing.super.constructor.message=Прапушчаны выклік __init__ суперкласса
INSP.missing.type.hints.add.type.hints=Дадайце падказкі па тыпу
INSP.missing.type.hints.add.type.hints.for=Дадаць падказкі тыпу для ''{0}''
INSP.missing.type.hints.checkbox.only.when.types.are.known=Толькі калі тыпы вядомыя (сабраныя падчас выканання або выведзеныя)
INSP.missing.type.hints.type.hinting.missing.for.function.definition=Адсутнічаюць падказкі тыпу для вызначэння функцыі
INSP.must.have.first.parameter=Метад павінен мець першы параметр, які звычайна называецца ''{0}''
INSP.named.tuple=Няправільнае вызначэнне "typing.NamedTuple"
INSP.new.incompatible.to.init=Подпіс несумяшчальны з __init__
INSP.new.style.generics.are.not.allowed.inside.type.param.bounds=Універсальныя тыпы не дапускаюцца ў межах абмежаванняў і межаў параметраў тыпу
INSP.new.style.generics.assignment.expressions.not.allowed=Выразы прысваення не дапускаюцца ў аб'явах класаў, функцый і псеўданімаў тыпаў, якія маюць спіс параметраў тыпу
INSP.new.style.generics.classes.with.type.param.list.should.not.extend.generic=Класы з відавочным спісам параметраў тыпу не павінны пашыраць "Generic"
INSP.new.style.generics.extending.protocol.does.not.need.parameterization=Пашырэнне "Пратакол" не патрабуе параметрызацыі ў класах са спісам параметраў тыпу
INSP.new.style.generics.mixing.old.style.and.new.style.type.vars.not.allowed=Змешванне традыцыйных і новых зменных тыпу не дапускаецца
INSP.new.style.generics.old.style.type.vars.not.allowed.in.new.style.type.aliases=Традыцыйныя TypeVars не дапускаюцца ў новых аб'явах псеўданімаў тыпаў стыляў
INSP.no.docstring=Адсутнічае радок дакументацыі
INSP.no.format.specifier.char=Адсутнічае сімвал спецыфікатара фармату
INSP.non.ascii.char.non.ascii.character.in.file.but.no.encoding.declared=Не-ASCII сімвал ''{0}'' у файле, але кадзіроўка не аб'яўлена
INSP.none.function.assignment=Функцыя ''{0}'' нічога не вяртае
INSP.oldstyle.class.getattribute=Клас старога стылю змяшчае азначэнне __getattribute__
INSP.oldstyle.class.slots=Клас старога стылю змяшчае вызначэнне __slots__
INSP.oldstyle.class.super=Клас старога стылю змяшчае выклік метаду super
INSP.overloads.series.overload.decorated.functions.should.always.be.followed.by.implementation=Серыя функцый з дэкаратарам @overload заўсёды павінна суправаджацца рэалізацыяй без дэкаратара @overload
INSP.overloads.series.overload.decorated.methods.should.always.be.followed.by.implementation=Серыя метадаў з дэкаратарам @overload заўсёды павінна суправаджацца рэалізацыяй без дэкаратара @overload
INSP.overloads.this.function.overload.signature.not.compatible.with.implementation=Подпіс гэтай функцыі з дэкаратарам @overload не адпавядае рэалізацыі
INSP.overloads.this.method.overload.signature.not.compatible.with.implementation=Подпіс гэтага метаду з дэкаратарам @overload не адпавядае рэалізацыі
INSP.override.missing.super.method=Адсутнічае суперметад для перавызначэння
INSP.package.requirements.add.import=Дадаць імпарт
INSP.package.requirements.administrator.privileges.required=Патрабуюцца правы адміністратара
INSP.package.requirements.administrator.privileges.required.button.configure=Наладзіць
INSP.package.requirements.administrator.privileges.required.button.install.anyway=Ўсталяваць у любым выпадку
INSP.package.requirements.administrator.privileges.required.description=Усталяванне пакетаў у ''{0}'' патрабуе правоў адміністратара.\n\nНаладзьце віртуальнае асяроддзе для праекта ў якасці інтэрпрэтатара праекта,\nкаб пазбегнуць усталявання пакетаў у абароненую вобласць файлавай сістэмы.
INSP.package.requirements.requirement.has.been.ignored=''{0}'' быў праігнараваны
INSP.package.requirements.requirements.file.empty=Файл патрабаванняў пусты
INSP.package.requirements.requirements.have.been.ignored=Патрабаванні былі праігнараваныя
INSP.pandas.series.values.replace.with.tolist=Рэкамендаваны метад Series.to_list()
INSP.parameter(s).unfilled=Параметры не запоўнены
INSP.parameter.unfilled=Параметр ''{0}'' пусты
INSP.pep8.coding.style.violation=Парушэнне стылю кадавання PEP 8
INSP.pep8.ignore.base.class=Ігнараваць базавы клас
INSP.pep8.ignore.method.names.for.descendants.of.class=Ігнараваць назвы метадаў для класаў-нашчадкаў
INSP.pep8.naming.argument.name.should.be.lowercase=Назва аргумента павінна быць з малой літары
INSP.pep8.naming.camelcase.variable.imported.as.constant=Пераменная CamelCase імпартавана як канстанта
INSP.pep8.naming.camelcase.variable.imported.as.lowercase=Пераменная ў CamelCase імпартавана ў ніжнім рэгістры
INSP.pep8.naming.class.names.should.use.capwords.convention=Імёны класаў павінны выкарыстоўваць CapWords
INSP.pep8.naming.column.name.excluded.base.classes=Выключаныя базавыя класы\:
INSP.pep8.naming.column.name.ignored.errors=Праігнараваныя памылкі\:
INSP.pep8.naming.constant.variable.imported.as.non.constant=Канстанта імпартавана як неканстанта
INSP.pep8.naming.function.name.should.be.lowercase=Імя функцыі павінна быць у малым рэгістры
INSP.pep8.naming.lowercase.variable.imported.as.non.lowercase=Імпартаваная зменная ў ніжнім рэгістры не ў малым рэгістры
INSP.pep8.naming.variable.in.function.should.be.lowercase=Зменная ў функцыі павінна быць у ніжнім рэгістры
INSP.possible.callees=Магчымыя выклікі
INSP.probably.mistyped.self=Магчыма, вы мелі на ўвазе «я»?
INSP.property.cannot.be.deleted=Уласцівасць «{0}» не можа быць выдалена
INSP.property.cannot.be.read=Уласцівасць ''{0}'' немагчыма прачытаць
INSP.property.cannot.be.set=Немагчыма ўсталяваць уласцівасць ''{0}''
INSP.protected.member.access.to.protected.member.of.class=Доступ да абароненага ўдзельніка {0} класа
INSP.protected.member.access.to.protected.member.of.module=Доступ да абароненага члена {0} модуля
INSP.protected.member.ignore.annotations=Ігнараваць анатацыі
INSP.protected.member.ignore.test.functions=Ігнараваць тэставыя функцыі
INSP.protected.member.name.not.declared.in.all=''{0}'' не аб'яўлены ў __all__
INSP.protocol.all.bases.protocol.must.be.protocols=Усе базавыя класы пратаколаў павінны быць пратаколамі
INSP.protocol.element.type.incompatible.with.protocol=Тып ''{0}'' несумяшчальны з ''{1}''
INSP.protocol.newtype.cannot.be.used.with.protocol.classes=NewType нельга выкарыстоўваць з класамі пратаколаў
INSP.protocol.only.runtime.checkable.protocols.can.be.used.with.instance.class.checks=Толькі пратаколы з @runtime_checkable можна выкарыстоўваць для праверкі асобнікаў і класаў
INSP.python.suppressor.suppress.for.class=Здушыць для класа
INSP.python.suppressor.suppress.for.function=Здушыць для функцыі
INSP.python.suppressor.suppress.for.statement=Здушыць для выразнасці
INSP.redeclared.name=Паўторна абвешчаны ''{0}'', вызначаны вышэй, без выкарыстання
INSP.redundant.parens.ignore.argument.of.operator=Ігнараваць аргумент аператара %
INSP.redundant.parens.ignore.empty.lists.of.base.classes=Ігнараваць пустыя спісы базавых класаў
INSP.redundant.parens.ignore.tuples=Ігнараваць картэжы
INSP.relative.import.relative.import.outside.package=Адносны імпарт па-за пакетам
INSP.requirements.ignore.packages.label=Ігнаруемыя пакеты\:
INSP.requirements.package.containing.module.not.listed.in.project.requirements=Пакет, які змяшчае модуль ''{0}'', не пазначаны ў патрабаваннях да праекта
INSP.requirements.package.requirements.not.satisfied=Требования к пакету {0} {1,choice,1\#не удовлетворено|2\#не удовлетворены}
INSP.setter.should.not.return=Усталёўшчык не павінен вяртаць значэнне
INSP.setter.signature.advice=Подпіс установшчыка павінен быць (я, значэнне)
INSP.shadowing.builtins.ignore.built.ins.label=Ігнаруюцца ўбудаваныя аб'екты\:
INSP.shadowing.builtins.shadows.built.in.name=Хавае ўбудаваную назву ''{0}''
INSP.shadowing.names=Схаванне імёнаў ад знешніх абласцей
INSP.shadows.name.from.outer.scope=Хавае імя ''{0}'' ад знешняй вобласці
INSP.signature.mismatch=Подпіс метаду ''{0}'' не супадае з подпісам базавага метаду ў класе ''{1}''
INSP.simplify.boolean.check.ignore.comparison.to.zero=Ігнараваць параўнанне з нулем
INSP.simplify.chained.comparison=Спрасціце ланцужок параўнанняў
INSP.statement.effect.statement.having.no.effect.can.be.replaced.with.function.call=Здаецца, выраз не мае ніякага эфекту і можа быць заменены выклікам функцыі
INSP.statement.effect.statement.seems.to.have.no.effect=Здаецца, выраз не мае ніякага эфекту
INSP.str.format.can.not.use.star.in.formats.when.using.mapping=Вы не можаце выкарыстоўваць «*» у фарматах пры выкарыстанні адлюстравання
INSP.str.format.key.has.no.argument=Ключ ''{0}'' не мае адпаведнага аргумента
INSP.str.format.unexpected.argument.type=Нечаканы тып {0}
INSP.str.format.unsupported.format.character.b=Непадтрымоўваны сімвал фармату "b"
INSP.strange.arg.want.callable=Дзіўны аргумент; чаканы выклік
INSP.stub.packages=Аб'яву заглушак пакетаў
INSP.stub.packages.compatibility=Несумяшчальныя заглушкі пакетаў
INSP.stub.packages.compatibility.ignore=Ігнараваць сумяшчальнасць ''{0}''
INSP.stub.packages.compatibility.ignored.packages.label=Праігнараваныя заглушкі пакетаў\:
INSP.stub.packages.compatibility.incompatible.packages.message=«{0}{1}{2}» несумяшчальны з «{3}{4}{5}». Чаканая версія ''{6}''\: [{7}]
INSP.symbol.is.not.callable=''{0}'' нельга выклікаць
INSP.too.broad.exception.clause=Блок выключэнняў занадта шырокі
INSP.too.few.args.for.fmt.string=Занадта мала аргументаў для радка фармату
INSP.too.few.keys=Занадта мала клавіш дысплея
INSP.too.many.args.for.fmt.string=Зашмат аргументаў для радка фармату
INSP.trailing.semicolon=Лішняя кропка з коскі ў выразе
INSP.try.except.import.error=«{0}» у блоку try з «except ImportError» таксама павінен быць вызначаны ў блоку Except
INSP.tuple.assignment.balance.need.more.values.to.unpack=Патрабуецца больш значэнняў для распакавання
INSP.tuple.assignment.balance.only.one.starred.expression.allowed.in.assignment=У заданні дазваляецца толькі адзін выраз са зорачкай
INSP.tuple.assignment.balance.too.many.values.to.unpack=Занадта шмат значэнняў для распакавання
INSP.tuples.never.assign.items=Картэжы не падтрымліваюць прызначэнне элементаў
INSP.type.checker.expected.matched.type.got.type.instead=Чакаецца тып ''{0}'' (адпаведны агульнаму тыпу ''{1}''), атрыманы ''{2}''
INSP.type.checker.expected.to.return.type.got.no.return=Чакаецца вяртанне ''{0}'', але нічога не вяртаецца
INSP.type.checker.expected.type.from.dunder.set.got.type.instead=Чакаецца тып ''{0}'' (ад ''__set__''), атрыманы ''{1}''
INSP.type.checker.expected.type.got.type.instead=Чаканы тып ''{0}'', атрыманы ''{1}''
INSP.type.checker.expected.types.prefix=Магчымыя тыпы\:
INSP.type.checker.init.should.return.none=__init__ павінен вяртаць None
INSP.type.checker.only.concrete.class.can.be.used.where.matched.protocol.expected=Толькі канкрэтны клас можа выкарыстоўвацца там, дзе чакаецца пратакол ''{0}'' (адпаведны агульнаму тыпу ''{1}'')
INSP.type.checker.only.concrete.class.can.be.used.where.protocol.expected=Толькі канкрэтны клас можа выкарыстоўвацца там, дзе чакаецца пратакол ''{0}''
INSP.type.checker.type.does.not.have.expected.attribute=Тип ''{0}'' не имеет ожидаемых {1,choice,1\#атрибута|2\#атрибутов} {2}
INSP.type.checker.typed.dict.extra.key=Дадатковы ключ ''{0}'' для TypedDict ''{1}''
INSP.type.checker.typed.dict.missing.keys=В TypedDict ''{0}'' отсутствуют {1,choice,1\#ключ|2\#ключи}\: {2}
INSP.type.checker.unexpected.argument.from.paramspec=Нечаканы аргумент (з ParamSpec ''{0}'')
INSP.type.checker.unexpected.types.prefix=Нечаканыя тыпы\:
INSP.type.checker.unfilled.parameter.for.paramspec=Параметр ''{0}'' пусты (з ParamSpec ''{1}'')
INSP.type.checker.unfilled.vararg=Параметр ''{0}'' пусты, чакаецца ''{1}''
INSP.type.hints.annotated.must.be.called.with.at.least.two.arguments='Anotated' павінен быць выкліканы як мінімум з двума аргументамі
INSP.type.hints.argument.to.paramspec.must.be.string.equal.to.variable.name=Аргумент "ParamSpec()" павінен быць радком, роўным імені зменнай, якой ён прызначаны
INSP.type.hints.argument.to.typevar.must.be.string.equal.to.variable.name=Аргумент "TypeVar()" павінен быць радком, роўным імені зменнай, якой ён прызначаны
INSP.type.hints.argument.to.typevar.tuple.must.be.string.equal.to.variable.name=Аргумент "TypeVarTuple()" павінен быць радком, роўным імені зменнай, якой ён прызначаны
INSP.type.hints.bivariant.type.variables.are.not.supported=Зменныя двухварыянтнага тыпу не падтрымліваюцца
INSP.type.hints.builtin.cannot.be.parameterized.directly=Убудаваны тып ''{0}'' не можа быць параметраваны непасрэдна
INSP.type.hints.cannot.inherit.from.generic.multiple.times=Вы не можаце атрымаць спадчыну ад 'Generic[...]' некалькі разоў
INSP.type.hints.cannot.inherit.from.plain.generic=Вы не можаце атрымаць у спадчыну ад простага "Generic"
INSP.type.hints.generics.should.be.specified.through.square.brackets=Абагульненні неабходна ўказваць у квадратных дужках
INSP.type.hints.illegal.callable.format="Callable" трэба выкарыстоўваць як "Callable[[arg, ...], вынік]"
INSP.type.hints.illegal.first.parameter=Першы параметр "Callable" павінен быць выразам параметра
INSP.type.hints.illegal.literal.parameter=«Літэрал» можа быць параметрізаваны літэраламі int, радкамі байтаў і юнікодаў, лагічным, значэннямі Enum, None, іншымі тыпамі літэралаў або псеўданімамі для іншых тыпаў літэралаў
INSP.type.hints.invalid.type.self=Няправільны тып "я"
INSP.type.hints.literal.must.have.at.least.one.parameter=Літарал павінен мець хаця б адзін параметр
INSP.type.hints.non.default.type.vars.cannot.follow.defaults=TypeVars без значэнняў па змаўчанні не могуць ісці за TypeVars са значэннямі па змаўчанні
INSP.type.hints.non.self.attribute.could.not.be.type.hinted=Атрыбут, які не з'яўляецца ўласным, не можа мець падказку тыпу
INSP.type.hints.parameterized.generics.cannot.be.used.with.instance.class.checks=Параметраваныя генерыкі нельга выкарыстоўваць з праверкай асобнікаў і класаў
INSP.type.hints.parameters.to.generic.must.all.be.type.variables=Параметры 'Generic[...]' павінны быць агульнымі зменнымі
INSP.type.hints.parameters.to.generic.must.all.be.unique=Параметры 'Generic[...]' павінны быць унікальнымі
INSP.type.hints.parameters.to.generic.types.cannot.contain.more.than.one.unpacking=Параметры агульнага тыпу не могуць змяшчаць больш за адно распакаванне
INSP.type.hints.parameters.to.generic.types.must.be.types=Параметры агульнага тыпу павінны быць тыпамі
INSP.type.hints.paramspec.expects.string.literal.as.first.argument='ParamSpec()' чакае радковы літэрал у якасці першага аргумента
INSP.type.hints.self.use.for.cls.parameter.with.self.annotation=Немагчыма выкарыстоўваць "Self", калі параметр "cls" не пазначаны як "Self"
INSP.type.hints.self.use.for.self.parameter.with.self.annotation=Немагчыма выкарыстоўваць "Self", калі параметр "self" не пазначаны як "Self"
INSP.type.hints.self.use.in.staticmethod=Немагчыма выкарыстоўваць "Self" у статычным метадзе
INSP.type.hints.self.use.outside.class=Вы не можаце выкарыстоўваць "Я" па-за класам
INSP.type.hints.single.typevar.constraint.not.allowed=Аднаразовае абмежаванне недапушчальна
INSP.type.hints.some.type.variables.are.not.listed.in.generic=Некаторыя зменныя тыпу ({0}) не пералічаны ў ''Generic[{1}]''
INSP.type.hints.type.alias.cannot.be.parameterized="TypeAlias" не можа быць параметраваны
INSP.type.hints.type.alias.must.be.immediately.initialized=Псеўданім тыпу павінен быць ініцыялізаваны неадкладна
INSP.type.hints.type.alias.must.be.top.level.declaration=Псеўданім тыпу павінен быць дэкларацыяй верхняга ўзроўню
INSP.type.hints.type.alias.must.be.used.as.standalone.type.hint=«TypeAlias» трэба выкарыстоўваць як асобную падказку тыпу
INSP.type.hints.type.cannot.be.used.with.instance.class.checks=«{0}» нельга выкарыстоўваць з праверкай асобнікаў і класаў
INSP.type.hints.type.comment.cannot.be.matched.with.unpacked.variables=Каментарый тыпу не можа быць адлюстраваны ў зменных без скрынкі
INSP.type.hints.type.self.not.supertype.its.class=Тып self ''{0}'' не з'яўляецца супертыпам свайго класа ''{1}''
INSP.type.hints.type.signature.has.too.few.arguments=Подпіс тыпу мае занадта мала аргументаў
INSP.type.hints.type.signature.has.too.many.arguments=Подпіс тыпу мае занадта шмат аргументаў
INSP.type.hints.type.specified.both.in.type.comment.and.annotation=Тыпы ўказваюцца як у каментарыі тыпу, так і ў анатацыі
INSP.type.hints.type.var.tuple.must.always.be.unpacked=TypeVarTuple заўсёды павінен быць распакаваны
INSP.type.hints.type.variables.cannot.be.used.with.instance.class.checks=Зменныя тыпу нельга выкарыстоўваць для праверкі асобнікаў і класаў
INSP.type.hints.type.variables.must.not.be.redefined=Зменныя тыпу не павінны быць перавызначаны
INSP.type.hints.typeIs.does.not.match=Вярнуты тып TypeI ''{0}'' не супадае з тыпам першага параметра ''{1}''
INSP.type.hints.typeIs.has.zero.arguments=Карыстальніцкія функцыі TypeGuard або TypeI павінны мець хаця б адзін параметр
INSP.type.hints.typevar.constraints.cannot.be.combined.with.bound=Абмежаванні нельга спалучаць з прывязанымі\=…
INSP.type.hints.typevar.constraints.cannot.be.parametrized.by.type.variables=Абмежаванні не могуць быць параметрызаваны зменнымі тыпу
INSP.type.hints.typevar.expects.string.literal.as.first.argument='TypeVar()' чакае радковы літэрал у якасці першага аргумента
INSP.type.hints.typevar.expression.must.be.always.directly.assigned.to.variable=Выраз 'TypeVar()' заўсёды павінен прысвойвацца непасрэдна зменнай
INSP.type.hints.typevar.tuple.expects.string.literal.as.first.argument='TypeVarTuple()' чакае радковы літэрал у якасці першага аргумента
INSP.type.hints.typing.self.cannot.be.parameterized=Немагчыма наладзіць параметр "Сам".
INSP.typeddict.cannot.add.non.string.key.to.typeddict=Немагчыма дадаць нерадковы ключ у TypedDict "{0}"
INSP.typeddict.cannot.be.required.and.not.required.at.the.same.time=Ключ не можа быць абавязковым і неабавязковым
INSP.typeddict.cannot.overwrite.typeddict.field=Немагчыма перазапісаць поле TypedDict
INSP.typeddict.cannot.overwrite.typeddict.field.while.merging=Немагчыма перазапісаць поле TypedDict ''{0}'' пры аб'яднанні
INSP.typeddict.first.argument.has.to.match.variable.name=Першы аргумент павінен адпавядаць імені зменнай
INSP.typeddict.invalid.statement.in.typeddict.definition.expected.field.name.field.type=Няправільны выраз у вызначэнні TypedDict; чакаецца 'назва_поля\:тып_поля'
INSP.typeddict.key.cannot.be.deleted=Ключ «{0}» TypedDict «{1}» не можа быць выдалены
INSP.typeddict.key.should.be.string=Ключ павінен быць радком
INSP.typeddict.qualifiers.cannot.be.used.outside.typeddict.definition=''{0}'' можна выкарыстоўваць толькі ў вызначэнні TypedDict
INSP.typeddict.required.notrequired.must.have.exactly.one.type.argument=''{0}'' павінен мець роўна адзін аргумент тыпу
INSP.typeddict.right.hand.side.values.are.not.supported.in.typeddict=Значэнні справа не падтрымліваюцца ў TypedDict
INSP.typeddict.specifying.metaclass.not.allowed.in.typeddict=Вызначэнне метакласса не дазваляецца ў TypedDict
INSP.typeddict.this.operation.might.break.typeddict.consistency=Гэтая аперацыя можа парушыць цэласнасць TypedDict
INSP.typeddict.total.value.must.be.true.or.false=Значэнне 'total' павінна быць True або False
INSP.typeddict.typeddict.cannot.have.key=TypedDict "{0}" не можа мець ключ ''{1}''
INSP.typeddict.typeddict.cannot.inherit.from.non.typeddict.base.class=TypedDict не можа быць успадкаваны ад базавага класа, які не з'яўляецца TypedDict
INSP.typeddict.typeddict.field.is.readonly=Ключ TypedDict "{0}" прызначаны толькі для чытання
INSP.typeddict.typeddict.has.no.key=TypedDict "{0}" не мае ключа ''{1}''
INSP.typeddict.typeddict.has.no.keys=TypedDict "{0}" не мае ключоў ({1})
INSP.typeddict.typeddict.key.must.be.string.literal.expected.one=Ключ TypedDict павінен быць радковым літаралам; чакаецца адзін з ({0})
INSP.typeddict.value.must.be.type=Значэнне павінна быць тыпам
INSP.unbound.function.too.large=Функцыя ''{0}'' занадта вялікая для аналізу
INSP.unbound.local.variable=Лакальная зменная ''{0}'' можа быць выкарыстана перад прызначэннем
INSP.unbound.name.undefined=Назва «{0}» можа быць не вызначана
INSP.unbound.nonlocal.variable=Нелакальная зменная ''{0}'' павінна быць звязана ў вобласці знешняй функцыі
INSP.unexpected.arg=Нечаканы аргумент
INSP.unexpected.arg(s)=Нечаканыя аргументы
INSP.unexpected.parameter.in.docstring=Нечаканы параметр {0} у радку дакумента
INSP.unnecessary.backslash.unnecessary.backslash.in.expression=Лішні зваротны слэш у выразе
INSP.unreachable.code=Гэты код недасяжны
INSP.unresolved.refs.cannot.find.reference.in.type=Немагчыма знайсці спасылку ''{0}'' у ''{1}''
INSP.unresolved.refs.class.does.not.define.operator=Клас ''{0}'' не вызначае ''{1}'', таму аператар ''{2}'' не можа быць выкарыстаны з яго асобнікамі
INSP.unresolved.refs.class.object.has.no.attribute=Аб'ект ''{0}'' не мае атрыбута ''{1}''
INSP.unresolved.refs.ignore.references.label=Ігнаруемыя спасылкі\:
INSP.unresolved.refs.import.resolves.to.its.containing.file=Імпарт дазволены ў файл, які яго змяшчае
INSP.unresolved.refs.module.not.found=Модуль «{0}» не знойдзены
INSP.unresolved.refs.unresolved.attribute.for.class=Нявырашаная спасылка на атрыбут ''{0}'' для класа ''{1}''
INSP.unresolved.refs.unresolved.reference=Нявырашаная спасылка ''{0}''
INSP.unsupported.format.character=Непадтрымоўваны сімвал фармату ''{0}''
INSP.unused.import.statement=Нявыкарыстаны аператар імпарту <code>\#ref</code>
INSP.unused.locals.ignore.lambda.parameters=Ігнараваць лямбда-параметры
INSP.unused.locals.ignore.range.iteration.variables=Ігнараваць зменныя ітэрацыі дыяпазону
INSP.unused.locals.ignore.variables.starting.with=Ігнараваць зменныя, якія пачынаюцца з '_'
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=Ігнараваць зменныя, якія выкарыстоўваюцца пры распакаванні картэжа
INSP.unused.locals.local.class.isnot.used=Лакальны клас ''{0}'' не выкарыстоўваецца
INSP.unused.locals.local.function.isnot.used=Лакальная функцыя ''{0}'' не выкарыстоўваецца
INSP.unused.locals.local.variable.isnot.used=Значэнне лакальнай зменнай ''{0}'' не выкарыстоўваецца
INSP.unused.locals.parameter.isnot.used=Значэнне параметра ''{0}'' не выкарыстоўваецца
INSP.unused.locals.replace.with.wildcard=Замяніць на _
INSP.use.fixture.without.declaration.in.test.function=Прыстасаванне «{0}» не было запытана тэставымі функцыямі або маркерам «@pytest.mark.usefixtures»
INSP.usually.named=Звычайна першы параметр такіх метадаў называецца ''{0}''
INSP.usually.named.self=Звычайна першы параметр метаду называецца "я"
INTN.NAME.add.type.hint.for.variable=Дадаць падказку тыпу да зменнай
INTN.NAME.add.type.hints.for.function=Дадайце падказкі тыпу для функцыі
INTN.NAME.convert.collection.literal=Пераўтварыць калекцыю ў {0}
INTN.NAME.convert.import.qualify=Пераўтварыць «з імпарту модуля» ў «імпарт модуля»
INTN.NAME.convert.import.unqualify=Пераўтварыць «імпартаваць модуль» у «з імпарту модуля»
INTN.NAME.convert.type.comment.to.variable.annotation=Пераўтварэнне каментара тыпу ў анатацыю зменнай
INTN.NAME.demorgan.law=Закон дэ Моргана
INTN.NAME.flip.comparison=Памяняць месцамі аперанды параўнання
INTN.NAME.hide.type.annotations=Схаваць анатацыі тыпу
INTN.NAME.insert.docstring.stub=Уставіць заглушку радка дакумента
INTN.NAME.join.if=Аб'яднайце выказванні "калі".
INTN.NAME.negate.comparison=Інверснае параўнанне
INTN.NAME.specify.type.in.annotation=Вызначце тып спасылкі праз анатацыю
INTN.NAME.specify.type.in.docstring=Укажыце тып спасылкі ў радку дакументацыі
INTN.NAME.split.if=Раздзяліць аператар "калі".
INTN.NAME.toggle.import.alias=Пераключыць выкарыстанне псеўданімаў імпарту
INTN.add.import.alias=Дадайце псеўданім
INTN.add.import.alias.dialog.message=Псеўданім для ''{0}''\:
INTN.add.import.alias.title=Дадайце псеўданім
INTN.add.import.alias.to.name=Дадаць псеўданім для ''{0}''
INTN.add.parameters.to.docstring=Дадайце параметры ў радок дакументацыі
INTN.add.qualifier=Дадаць кваліфікатар ''{0}''
INTN.add.type.hint.for.variable=Дадаць падказку тыпу для зменнай ''{0}''
INTN.add.type.hint.for.variable.PEP484.incompatible.type=Тып ''{0}'' не можа быць убудаваны ў фармат PEP 484
INTN.add.type.hints.for.function=Дадаць падказкі тыпу для функцыі ''{0}''
INTN.category.python=Python
INTN.convert.absolute.to.relative=Пераўтварыце абсалютны імпарт у адносны
INTN.convert.builtin.import=Пераўтварыце імпарт убудаванага модуля ў форму, якая падтрымліваецца
INTN.convert.collection.literal=Пераўтварыць {0} у {1}
INTN.convert.dict.constructor.to.dict.literal=Пераўтварыць канструктар dict у літаральны dict
INTN.convert.dict.literal.to.dict.constructor=Пераўтварыць літарал dict у канструктар dict
INTN.convert.except.to=Пераўтварыць «except osimClass, Target» у «except acceptClass as Target»
INTN.convert.lambda.to.function=Пераўтварэнне лямбда ў функцыю
INTN.convert.method.to.property=Пераўтварыць метад ва ўласцівасць
INTN.convert.relative.to.absolute=Пераўтварэнне адноснага імпарту ў абсалютны
INTN.convert.static.method.to.function=Пераўтварэнне статычнага метаду ў функцыянальны
INTN.convert.to.from.import=Пераўтварыць у ''з {0} імпартаваць {1}''
INTN.convert.to.fstring.literal=Пераўтварыць у f-радок
INTN.convert.to.plain.import=Пераўтварыць у ''імпартаваць {0}''
INTN.convert.type.comment.to.variable.annotation=Пераўтварыць у зменную анатацыю
INTN.convert.variadic.param=Пераўтварыце зменныя параметры ў звычайныя
INTN.flip.comparison=Інвертаваць ''{0}''
INTN.flip.comparison.to.operator=Замяніць ''{0}'' на ''{1}''
INTN.format.operator.to.method=Пераўтварыце фармат у выклік метаду "str.format"
INTN.hide.type.annotations=Схаваць анатацыі тыпу
INTN.insert.assertion=Праверка тыпу ўстаўкі
INTN.insert.docstring.stub=Уставіць заглушку дакументацыі
INTN.invert.if.condition=Інверсія ўмовы "калі".
INTN.join.if=Аб'яднайце два выказванні "калі".
INTN.multiple.usages.of.import.found=Знойдзена некалькі варыянтаў выкарыстання імпарту
INTN.negate.comparison=Замяніць ''{0}'' на ''{1}''
INTN.quoted.string=Пераўтварэнне радкоў з адзінарнымі двукоссямі ў падвойныя і наадварот
INTN.quoted.string.double.to.single=Пераўтварэнне радка з падвойнымі двукоссямі ў радок з адзінарнымі двукоссямі
INTN.quoted.string.single.to.double=Пераўтварэнне радка з адзінарнымі двукоссямі ў радок з падвойнымі двукоссямі
INTN.remove.import.alias=Выдаліць псеўданім ''{0}''
INTN.remove.qualifier=Выдаліць кваліфікатар ''{0}''
INTN.remove.qualifier.from.all.usages=Выдаліць кваліфікатар з усіх варыянтаў выкарыстання
INTN.remove.qualifier.from.this.name=Выдаліце ​​кваліфікатар з гэтай назвы
INTN.replace.backquote.expression=Замяніце выраз зваротнымі двукоссямі
INTN.replace.list.comprehensions=Пераўтварыце ўключэнне ў спіс у форму, якая падтрымліваецца
INTN.replace.list.comprehensions.with.for=Пераўтварыце ўкладанне спісу ў цыкл "for".
INTN.replace.noteq.operator=Замяніць аператар няроўнасці
INTN.replace.octal.numeric.literal=Пераўтварэнне васьмярковага літарала ў форму, якая падтрымліваецца
INTN.replace.plus.with.format.operator=Заменіце + аператарам фарматавання радка
INTN.replace.plus.with.str.format=Заменіце + на выклік метаду str.format
INTN.replace.raise.statement=Пераўтварыце заяву аб павышэнні ў форму, якая падтрымліваецца
INTN.replace.with.method=Заменіце выклікам метаду str.format
INTN.specify.return.type.in.annotation=Укажыце тып вяртання з дапамогай анатацыі
INTN.specify.return.type.in.docstring=Укажыце тып вяртання ў радку дакументацыі
INTN.specify.type.in.annotation=Вызначце тып спасылкі з дапамогай анатацыі
INTN.specify.type.in.docstring=Укажыце тып спасылкі ў радку дакументацыі
INTN.split.if=Разбіце на 2 аператары "калі".
INTN.string.concatenation.to.format=Замяніць аб'яднанне радкоў на "str.format"
INTN.transform.into.if.else.statement=Пераўтварыце ўмоўныя выразы ў аператары «if/else».
INTN.triple.quoted.string=Пераўтварэнне радка з патройнымі двукоссямі ў радок з адзінарнымі двукоссямі
INTN.yield.from=Пераўтварыце відавочныя ітэрацыі з выразамі 'yield' у 'yield from'
QDOC.accessor.kind=Тып доступу:
QDOC.assigned.to=Прызначана\:
QDOC.attributes=Атрыбуты\:
QDOC.built.in.description=убудаванае апісанне
QDOC.class=Клас
QDOC.class.attribute=Атрыбут класа {0} ад {1}
QDOC.copied.from=Скапіравана з\:
QDOC.directory.name=Каталог "{0}"
QDOC.file.name=Файл "{0}"
QDOC.inferred.type.name=Вылучаны тып\: {0}
QDOC.instance.attribute=Атрыбут асобніка {0} з {1}
QDOC.keyword.args=Найменныя аргументы\:
QDOC.module.name=Модуль {0}
QDOC.module.path.unknown=(Шлях да модуля невядомы)
QDOC.not.defined.in.parentheses=(не вызначана)
QDOC.package.name=Пакет {0}
QDOC.parameter.name=Параметр "{0}"
QDOC.parameter.name.of.link=Параметр {0} ад {1}
QDOC.parameter.of.function.name=Параметр "{0}" функцыі "{1}"
QDOC.parameter.of.method.name=Параметр "{0}" метаду "{1}"
QDOC.params=Параметры\:
QDOC.property.getter=здабывальнік уласнасці
QDOC.property.name.of.link=Уласцівасць {0} ад {1}
QDOC.python.3.sdk.needed.to.render.docstrings=Для адлюстравання радкоў дакументацыі неабходна наладзіць лакальны Python 3 SDK.
QDOC.raises=Званкі\:
QDOC.returns=Вяртае\:
QDOC.type.alias.statement.name.of.link=Выраз псеўданіма, напрыклад {0} з {1}
QDOC.type.parameter.kind=прагляд\:
QDOC.type.parameter.name=Тып параметра {0}
QDOC.type.parameter.name.of.link=Параметр тыпу {0} з {1}
QDOC.variable.name=Пераменная "{0}"
QFIX.NAME.add.exception.base=Дадаць базавы клас Exception
QFIX.NAME.add.field.to.class=Дадаць поле ў клас
QFIX.NAME.add.method.to.class=Дадайце метад у клас
QFIX.NAME.add.specifier=Дадаць сімвал спецыфікатара фармату
QFIX.NAME.auto.import=Імпарт
QFIX.NAME.convert.builtin=Пераўтварэнне імпарту ўбудаванага модуля
QFIX.NAME.create.function.in.module=Стварыце функцыю ў модулі
QFIX.NAME.docstring=Выправіць радок дакумента
QFIX.NAME.ignore.errors.like.this=Ігнаруйце такія памылкі
QFIX.NAME.ignore.requirements=Игнорировать {0,choice,1\#требование|2\#требования}
QFIX.NAME.ignore.shadowed.built.in.name=Ігнараваць зацененае ўбудаванае імя
QFIX.NAME.install.and.import.package=Усталяваць і імпартаваць пакет ''{0}''
QFIX.NAME.install.requirements=Установить {0,choice,1\#требование|2\#требования}
QFIX.NAME.local.auto.import=Імпартаваць лакальна
QFIX.NAME.make.function=Стварыць функцыю з метаду
QFIX.NAME.make.function.return.type=Зрабіце выведзены тып вяртання функцыі
QFIX.NAME.make.list=Замяніць картэж спісам
QFIX.NAME.make.static=Зрабіце метад статычным
QFIX.NAME.move.except.up=Рухайцеся, акрамя блакіроўкі
QFIX.NAME.remove.argument=Выдаліць аргумент
QFIX.NAME.remove.assignment=Выдаліць прызначэнне
QFIX.NAME.remove.assignment.target=Выдаліць мэту прысваення
QFIX.NAME.remove.call=Выдаліць выклік
QFIX.NAME.remove.dict.key=Выдаліць гэты ключ
QFIX.NAME.remove.exception.target=Выдаліць мэта выключэння
QFIX.NAME.remove.parameter=Выдаліць параметр
QFIX.NAME.remove.statement=Выдаліць аператара
QFIX.NAME.remove.string.prefix=Выдаліць прэфікс
QFIX.NAME.remove.underscores.in.numeric=Выдаліць падкрэсліванне ў лікавых літэралах
QFIX.NAME.remove.with.target=Выдаліць мэта "з"
QFIX.NAME.rename.argument=Перайменаваць аргумент
QFIX.NAME.rename.parameter=Перайменаваць параметр
QFIX.NAME.replace.with.true.or.false=Замяніць на True або False
QFIX.NAME.simplify.boolean.expression=Спрасціце лагічны выраз
QFIX.NAME.unpack.type.var.tuple=Распакуйце TypeVarTuple
QFIX.NAME.unresolved.reference.add.param=Стварыце параметр для спасылкі
QFIX.NAME.unresolved.reference.create.function=Стварыць функцыю ''{0}''
QFIX.NAME.update.parameters=Абнавіць налады
QFIX.action.failed=Дзеянне не завершана
QFIX.add.encoding=Дадайце дэкларацыю кадавання
QFIX.add.field.to.class=Дадаць поле ''{0}'' да класа {1}
QFIX.add.field.to.class.popup.content.added.init=Дададзены __init__ у клас <code>{0}</code><br/>, каб змясціць новае поле <code>{1}</code>
QFIX.add.fixture.to.test.function.parameters.list=Дадайце прыстасаванне для праверкі параметраў функцыі
QFIX.add.from.future.import.annotations=Дадаць «з __будучага__ анатацый імпарту»
QFIX.add.global=Дадаць глабальнае аб'яву
QFIX.add.imported.packages.to.requirements=Дадаць імпартаваныя пакеты ў патрабаванні...
QFIX.add.method.to.class=Дадаць метад {0}() у клас {1}
QFIX.add.parameter.self=Дадаць параметр ''{0}''
QFIX.add.property=Дадайце ўласцівасць для поля
QFIX.add.qualifier=Дадаць кваліфікатар
QFIX.add.super=Дадаць выклік суперкласса
QFIX.augment.assignment=Замяніць прызначэнне пашыраным прызначэннем
QFIX.auto.import.import.name=Імпарт ''{0}''
QFIX.auto.import.import.this.name=Імпартаваць гэтае імя
QFIX.chained.comparison=Спрасціце ланцужок параўнанняў
QFIX.change.base.class=Змяніць базавы клас
QFIX.classic.class.transform=Успадкаваць ад аб'екта
QFIX.convert.indents=Пераўтварыць пракладку
QFIX.convert.indents.to.spaces=Пераўтварэнне водступаў у прабелы
QFIX.convert.indents.to.tabs=Пераўтварэнне водступаў у табуляцыі
QFIX.convert.single.quoted.docstring=Пераўтварэнне радка дакумента ў радок з патройнымі падвойнымі двукоссямі
QFIX.convert.to.new.style=Пераўтварыць у клас новага стылю
QFIX.coroutine.is.not.awaited=Не чакаецца супраграма
QFIX.create.class=Стварыце клас
QFIX.create.class.0=Стварыць клас ''{0}''
QFIX.create.class.in.module=Стварыць клас ''{0}'' у модулі {1}
QFIX.create.function.in.module=Стварыце функцыю {0}() у модулі {1}
QFIX.create.property=Стварыце ўласнасць
QFIX.default.argument=Замяніць зменлівы аргумент па змаўчанні
QFIX.dict.creation=Замяніць стварэнне слоўніка
QFIX.docstring.add.parameter=Дадаць радок дакументацыі параметра ''{0}''
QFIX.docstring.insert.stub=Устаўце радок дакументацыі
QFIX.docstring.remove.parameter=Выдаліць радок дакументацыі параметра ''{0}''
QFIX.failed.to.add.field=<br/>Не атрымалася дадаць поле\!<br/><br/>
QFIX.failed.to.add.function=<br/>Не атрымалася дадаць функцыю\!<br/><br/>
QFIX.failed.to.add.method=<br/>Не атрымалася дадаць метад\!<br/><br/>
QFIX.ignore.shadowed.built.in.name=Ігнараваць зацененае ўбудаванае імя "{0}"
QFIX.install.and.import.package=Усталяваць і імпартаваць пакет
QFIX.introduce.variable=Стварыце зменную для аператара
QFIX.list.creation=Замяніць літаральным спісам
QFIX.local.auto.import.import.locally=Мясцовы {0}
QFIX.make.function.return.type=Зрабіце тып вяртання ''{0}'' роўным ''{1}''
QFIX.make.public=Зрабіце гэта публічным
QFIX.move.attribute=Перамясціць атрыбут у метад __init__
QFIX.move.from.future.import=Перамясціць 'from __future__ import' у патрэбнае месца
QFIX.optimize.imports=Аптымізацыя імпарту
QFIX.pandas.series.values.replace.with.tolist=Замяніць list(Series.values) на Series.to_list()
QFIX.redundant.parentheses=Выдаліць лішнія дужкі
QFIX.remove.annotation=Выдаліць анатацыю
QFIX.remove.argument.equal.default=Выдаліць аргументы, роўныя значэнням па змаўчанні
QFIX.remove.decorator=Выдаліць дэкаратар
QFIX.remove.function.annotations=Выдаліць функцыянальныя анатацыі
QFIX.remove.generic.parameters=Выдаліць агульныя параметры
QFIX.remove.square.brackets=Зняць квадратныя дужкі
QFIX.remove.string.prefix=Выдаліць майстар {0}
QFIX.remove.trailing.semicolon=Выдаліце ​​кропку з коскі
QFIX.remove.trailing.suffix=Выдаліць канчатковы суфікс
QFIX.remove.type.comment=Выдаліць тып каментарыя
QFIX.remove.unnecessary.backslash=Выдаліце ​​непатрэбную зваротную касую рысу ў выразе
QFIX.rename.parameter=Перайменаваць у ''{0}''
QFIX.rename.unresolved.reference=Перайменаваць спасылку
QFIX.replace.equality=Замяніце параўнанне
QFIX.replace.function.set.with.literal=Заменіце выклік функцыі зададзеным літэралам
QFIX.replace.star.by.unpack=Замяніць на typing_extensions. Распакаваць
QFIX.replace.with.old.union.style=Замяніць на стары саюз
QFIX.replace.with.square.brackets=Замяніць квадратнымі дужкамі
QFIX.replace.with.target.name=Замяніць мэтавым імем
QFIX.replace.with.true.or.false=Замяніць на {0}
QFIX.replace.with.type.name=Замяніць імем тыпу
QFIX.replace.with.typing.alias=Замяніць псеўданімам тыпу
QFIX.simplify.boolean.expression=Заменіце лагічны выраз на ''{0}''
QFIX.statement.effect=Замяніць выклікам функцыі
QFIX.surround.with.square.brackets=Заключыць у квадратныя дужкі
QFIX.unresolved.reference=Замяніць ''{0}'' на ''{1}.{0}''
QFIX.unresolved.reference.add.param=Стварыць параметр ''{0}''
QFIX.unresolved.reference.create.function=Стварыце функцыю
QFIX.use.property=Выкарыстоўвайце ўласцівасць для поля
custom.type.mimic.name=Дынамічны клас на аснове {0}
debugger.cleaning.signature.cache=Ачыстка кэша дынамічна зборных тыпаў
element.presentation.location.string.in.class=({0} да {1})
element.presentation.location.string.in.class.stub=({0} у заглушцы {1})
element.presentation.location.string.module=({0})
element.presentation.location.string.module.stub=({0} заглушка)
filetype.python.docstring.description=Python docstring
filetype.python.function.type.annotation.description=Анатацыя тыпу функцыі Python PEP-484
filetype.python.type.hint.description=Падказка тыпу Python PEP-484
find.usages.class=Клас
find.usages.function=функцыя
find.usages.imported.module.alias=псеўданім імпартаванага модуля
find.usages.keyword.argument=названы аргумент
find.usages.method=метад
find.usages.parameter=параметр
find.usages.unnamed=<без імя>
find.usages.variable=зменная
ignore.overridden.functions=Ігнараваць перавызначаныя функцыі
python.docstring.format=радок дакумента \ фармат:
python.docstring.select.type=Выберыце тып Docstring
python.find.usages=Знайдзіце прымяненне
python.find.usages.base.method.question=Метад {0} перавызначае метад класа {1}.\nЗнайсці прымяненне базавага метаду?
python.find.usages.untyped.probable.usage=Нетыпізаванае (верагоднае) выкарыстанне
python.find.usages.usage.in.import.statement=Выкарыстоўвайце ў аператары імпарту
python.find.usages.usage.in.isinstance=Выкарыстанне ў isinstance()
python.find.usages.usage.in.superclass.list=Выкарыстоўвайце ў спісе суперкласаў
python.find.usages.usage.in.type.hint=Выкарыстоўвайце ў падказцы тыпу
refactoring.extract.method=Метад экстракта
refactoring.extract.method.error.bad.selection=Немагчыма рэарганізаваць «Метад вылучэння» з выбранымі элементамі
refactoring.extract.method.error.class.level=Немагчыма рэарганізаваць на ўзроўні класа
refactoring.extract.method.error.empty.fragment=Немагчыма правесці рэфактаринг з пустога фрагмента кода
refactoring.extract.method.error.interrupted.execution.flow=Немагчыма рэарганізаваць, пакуль паток перапынены
refactoring.extract.method.error.local.variable.modifications=Немагчыма рэарганізаваць выраз з мадыфікацыямі лакальных зменных у фрагменце кода.
refactoring.extract.method.error.local.variable.modifications.and.returns=Немагчыма выканаць рэарганізацыю з выразу з мадыфікацыямі лакальных зменных і аператараў вяртання ўнутры фрагмента кода
refactoring.extract.method.error.name.clash=Назва метаду канфліктуе з існуючай назвай
refactoring.extract.method.error.returns=Немагчыма атрымаць метад з аператарамі вяртання ўнутры фрагмента кода
refactoring.extract.method.error.star.import=Немагчыма рэарганізаваць з імпартам са зорачкай у блоку кода
refactoring.extract.method.error.yield=Немагчыма выканаць рэфактаринг з аператарам 'yield' у блоку кода
refactoring.inline.all.border.title=Убудаванне
refactoring.inline.all.keep.declaration=Убудаваць усе выклікі і захаваць аб'явы
refactoring.inline.all.remove.declaration=Уставіць усе выклікі і выдаліць рэкламу
refactoring.inline.can.not.multiline.string.to.f.string=Немагчыма ўбудаваць шматрадковы радок у f-радок
refactoring.inline.can.not.string.to.nested.f.string=Немагчыма ўбудаваць радок ва ўкладзены f-радок
refactoring.inline.can.not.string.with.backslashes.or.quotes.to.f.string=Немагчыма ўбудаваць радок са зваротнай касой рысай і двукоссямі ў f-радок
refactoring.inline.function=Функцыя ўбудавання {0}
refactoring.inline.function.async=Немагчыма ўбудаваць асінхронныя функцыі
refactoring.inline.function.builtin=Немагчыма ўбудаваць уласныя функцыі
refactoring.inline.function.command.name=Убудаванне {0}
refactoring.inline.function.constructor=Немагчыма выклікаць убудаваны канструктар
refactoring.inline.function.decorator=Немагчыма ўбудаваць функцыі з дэкаратарамі
refactoring.inline.function.function.to.inline=Функцыя ўбудавання
refactoring.inline.function.generator=Немагчыма ўбудаваць генератары
refactoring.inline.function.global=Немагчыма ўбудаваць функцыі з глабальнымі зменнымі
refactoring.inline.function.interrupts.flow=Немагчыма ўбудаваць функцыі, якія перарываюць паток кіравання
refactoring.inline.function.invocations.to.be.inlined=Выклікі для ўбудавання ў файлы {0}
refactoring.inline.function.is.decorator=Функцыя {0} выкарыстоўваецца ў якасці дэкаратара і не можа быць убудавана. Вызначэнне функцыі не будзе выдалена
refactoring.inline.function.is.overridden=Немагчыма ўбудаваць перавызначаныя метады
refactoring.inline.function.is.reference=Функцыя {0} выкарыстоўваецца ў якасці спасылкі і не можа быць убудавана. Вызначэнне функцыі не будзе выдалена
refactoring.inline.function.nested=Немагчыма ўбудаваць функцыі з іншым аб'явай функцыі
refactoring.inline.function.nonlocal=Немагчыма ўбудаваць функцыі з нелакальнымі зменнымі
refactoring.inline.function.overrides.method=Немагчыма ўбудаваць метады, якія перавызначаюць іншыя метады
refactoring.inline.function.self.referrent=Немагчыма ўбудаваць функцыі, якія спасылаюцца на саміх сябе
refactoring.inline.function.skeleton.only=Немагчыма ўбудаваць функцыю з бінарнага модуля
refactoring.inline.function.special.method=Немагчыма ўбудаваць карыстальніцкія метады
refactoring.inline.function.star=Немагчыма ўбудаваць функцыі з аргументамі *
refactoring.inline.function.title=Функцыя ўбудавання
refactoring.inline.function.uses.unpacking=Функцыя {0} выкарыстоўвае распакаванне аргументаў і не можа быць убудавана. Вызначэнне функцыі не будзе выдалена
refactoring.inline.label.function=функцыя {0}
refactoring.inline.label.method=Метад {0}
refactoring.inline.local.multiassignment=Вызначэнне ў множным прызначэнні
refactoring.inline.method=Метад убудавання {0}
refactoring.inline.this.only=Устаўце толькі гэты званок і захавайце аб'яву
refactoring.introduce.constant.cannot.extract.selected.expression=Выбраны выраз не можа быць выняты ў канстанту
refactoring.introduce.constant.dialog.title=Выняць канстанту
refactoring.introduce.constant.scope.error=Імя ўжо заяўлена ў гэтай вобласці
refactoring.introduce.name.error=Няправільнае імя
refactoring.introduce.selection.error=Немагчыма рэарганізаваць выбраныя элементы
refactoring.introduce.variable.dialog.title=Атрымаць зменную
refactoring.introduce.variable.scope.error=Імя канфліктуе з існуючай зменнай або параметрам
refactoring.move.module.members.error.cannot.place.elements.into.nonpython.file=Немагчыма змясціць элементы ў файл не Python
refactoring.name.label.text={0} имеет {1} вхождени{2, choice, 0\#й|1\#е}
refactoring.progress.title.updating.existing.usages=Абнаўленне існуючых варыянтаў выкарыстання...
type.param.list.annotator.two.or.more.types.required=Патрабуецца два або больш тыпаў
type.param.list.annotator.type.parameter.already.defined=Параметр тыпу пад назвай ''{0}'' ужо вызначаны ў гэтым спісе параметраў тыпу
type.param.list.annotator.type.var.tuple.and.param.spec.can.not.have.bounds=ParamSpec і TypeVarTuple не могуць мець абмежаванняў або верхніх межаў
unresolved.docstring.param.reference=Функцыя ''{0}'' не мае параметра ''{1}''
unresolved.import.reference=Модуль «{0}» не знойдзены