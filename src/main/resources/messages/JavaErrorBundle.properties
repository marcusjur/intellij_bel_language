abstract.cannot.be.instantiated=''{0}'' является абстрактным; невозможно создать экземпляр
abstract.method.0.cannot.be.accessed.directly.method.reference.context=Нельзя напрямую обратиться к абстрактному методу ''{0}''
abstract.method.in.non.abstract.class=Абстрактный метод в неабстрактном классе
abstract.methods.cannot.have.a.body=Абстрактные методы не могут иметь тело
actual.type.argument.contradict.inferred.type=Фактический аргумент типа и выведенный тип противоречат друг другу
ambiguous.method.call=Неоднозначный вызов метода\: подходят и ''{0}'', и ''{1}''
ambiguous.method.call.no.match=Не удаётся разрешить метод ''{0}'' в ''{1}''
ambiguous.method.html.tooltip=<html><body><table border\=0><tr><td colspan\={0}>Неоднозначный вызов метода. Подходят</td></tr><tr>{1}<td>в <b>{2}</b>\\&nbsp;и</td></tr><tr>{3}<td>в <b>{4}</b></td></tr></table></body></html>
ambiguous.reference=Ссылка на ''{0}'' неоднозначна, подходят и ''{1}'', и ''{2}''
an.enclosing.instance.of.type.not.in.scope.method.reference.context=Охватывающий экземпляр типа {0} не находится в области видимости
annotation.annotation.type.expected=Ожидается тип аннотации
annotation.cannot.be.local=Локальные аннотации не разрешены
annotation.container.abstract=Аннотация-контейнер ''{0}'' не имеет значения по умолчанию для ''{1}''
annotation.container.bad.type=Недопустимая аннотация-контейнер ''{0}''\: метод ''value'' должен иметь тип ''{1}''
annotation.container.low.retention=Аннотация-контейнер ''{0}'' имеет более короткое время жизни (''{1}''), чем содержащаяся аннотация
annotation.container.missed.annotation=Аннотация-контейнер ''{0}'' не имеет обязательной аннотации @{1}
annotation.container.no.value=Недопустимая аннотация-контейнер ''{0}''\: не объявлен метод ''value''
annotation.container.not.applicable=Аннотация-контейнер ''@{0}'' не применима к {1}
annotation.container.wide.target=Цель аннотации-контейнера ''{0}'' не является подмножеством цели этой аннотации
annotation.container.wrong.place=Аннотация-контейнер ''{0}'' не должна присутствовать одновременно с содержащимся в ней элементом
annotation.cyclic.element.type=Циклический тип элемента аннотации
annotation.duplicate.annotation=Дублирующаяся аннотация
annotation.duplicate.attribute=Дублирующийся атрибут ''{0}''
annotation.duplicate.explained=Дублирующаяся аннотация. {0}
annotation.illegal.array.initializer=Недопустимый инициализатор для ''{0}''
annotation.interface.is.not.used=@interface ''{0}'' никогда не используется
annotation.interface.members.may.not.have.parameters=Члены @interface не могут иметь параметры
annotation.invalid.annotation.member.type=Недопустимый тип ''{0}'' для члена аннотации
annotation.may.not.have.extends.list=@interface не может иметь список extends
annotation.may.not.have.type.parameters=@interface не может иметь параметры типа
annotation.members.may.not.have.throws.list=Методы @interface не могут иметь список throws
annotation.missing.attribute=Отсутствует обязательный {0}
annotation.missing.method=Не удаётся найти метод ''{0}''
annotation.non.class.literal.attribute.value=Значение атрибута должно быть литералом класса
annotation.non.constant.attribute.value=Значение атрибута должно быть константой
annotation.non.enum.constant.attribute.value=Значение атрибута должно быть константой перечисления
annotation.non.repeatable=Объявление ''{0}'' не имеет действительной аннотации java.lang.annotation.Repeatable
annotation.not.allowed.class=Литерал класса не может быть аннотирован
annotation.not.allowed.here=Аннотации здесь не разрешены
annotation.not.allowed.in.permit.list=Аннотации не разрешены в списке 'permits'
annotation.not.allowed.ref=Аннотация не применима к данному типу ссылки
annotation.not.allowed.static=Статический член, определяющий тип, не может быть аннотирован
annotation.not.allowed.var=Тип 'var' не может быть аннотирован
annotation.not.allowed.void=Тип 'void' не может быть аннотирован
annotation.not.applicable=''@{0}'' не применим к {1}
annotation.on.static.member.qualifying.type.family.name=Переместить аннотацию типа
annotation.type.permits=Для типа аннотации не разрешена секция permits
annotation.unknown.method=Не удаётся разрешить метод ''{0}''
anonymous.class.implements.interface.cannot.have.qualifier=Анонимный класс реализует интерфейс; new не может иметь квалификатор
anonymous.class.implements.interface.cannot.have.type.arguments=Анонимный класс реализует интерфейс; не может иметь аргументы типа
anonymous.classes.must.not.extend.sealed.classes=Анонимные классы не должны расширять sealed классы
array.creation.with.type.arguments=Нельзя создать массив с аргументами типа
array.initializer.not.allowed=Инициализатор массива здесь не разрешен
array.type.expected=Ожидается тип массива; найдено\: ''{0}''
assert.identifier.warn=Использование 'assert' в качестве идентификатора не поддерживается начиная с Java 1.4
assignment.to.final.variable=Невозможно присвоить значение final переменной ''{0}''
auto.closeable.resource=автоматически закрываемый ресурс
bad.qualifier.in.super.method.reference.extended=Неверный квалификатор типа в вызове super по умолчанию\: избыточный интерфейс {0} расширен {1}
bad.qualifier.in.super.method.reference.overridden=Неверный квалификатор типа в вызове super по умолчанию\: метод {0} переопределен в {1}
bad.type.in.switch.expression=Неверный тип в switch-выражении\: {0} не может быть преобразован в {1}
binary.numbers.must.contain.at.least.one.hexadecimal.digit=Двоичные числа должны содержать хотя бы одну двоичную цифру
binary.operator.not.applicable=Оператор ''{0}'' не может быть применен к ''{1}'', ''{2}''
break.outside.switch.expr=Break вне switch-выражения не разрешен
break.outside.switch.or.loop=Break вне switch или цикла
call.to.super.is.not.allowed.in.enum.constructor=Вызов super не разрешен в конструкторе enum
cannot.access.member.on.type=Невозможно получить доступ к члену, так как ''{0}'' имеет примитивный тип {1}
cannot.be.referenced.from.static.context=''{0}'' не может быть использован в статическом контексте
cannot.call.method.on.type=Невозможно вызвать метод, так как ''{0}'' имеет примитивный тип {1}
cannot.create.array.with.empty.diamond=Нельзя создать массив с '<>'
cannot.find.class=Не удаётся найти класс {0}
cannot.infer.functional.interface.type=Не удаётся вывести тип функционального интерфейса
cannot.resolve.constructor=Не удаётся разрешить конструктор ''{0}''
cannot.resolve.method=Не удаётся разрешить метод ''{0}''
cannot.resolve.package=Не удаётся разрешить пакет {0}
cannot.resolve.symbol=Не удаётся разрешить символ ''{0}''
cannot.select.dot.class.from.type.variable=Невозможно получить доступ к объекту класса параметра типа
cannot.select.from.a.type.parameter=Невозможно выбрать из параметра типа
cannot.select.from.parameterized.type=Невозможно получить доступ к объекту класса параметризованного типа
case.statement.outside.switch=Оператор case вне switch
catch.without.try='catch' без 'try'
clash.methods.message=''{0}'' конфликтует с ''{1}''
clash.methods.message.show.classes=''{0}'' в ''{2}'' конфликтует с ''{1}'' в ''{3}''
class.already.imported=''{0}'' уже определен в этой единице компиляции
class.cannot.be.inherited.with.different.arguments={0} не может быть унаследован с другими аргументами\: {1}
class.cannot.extend.multiple.classes=Класс не может расширять несколько классов
class.cannot.inherit.from.its.type.parameter=Класс не может наследоваться от своего параметра типа
class.clashes.with.package=Класс ''{0}'' конфликтует с пакетом того же имени
class.expected=Здесь ожидается имя класса
class.in.default.package=Класс ''{0}'' находится в пакете по умолчанию
class.is.already.defined.in.single.static.import=Класс ''{0}'' уже определен в единичном статическом импорте
class.is.ambiguous.in.single.static.import=Класс ''{0}'' неоднозначен в единичном статическом импорте
class.is.not.used=Класс ''{0}'' никогда не используется
class.must.be.abstract=Класс ''{0}'' должен быть объявлен как abstract или реализовать абстрактный метод ''{1}'' в ''{2}''
class.must.implement.method=Класс ''{0}'' должен реализовать абстрактный метод ''{1}'' в ''{2}''
class.name.expected=Ожидается имя класса
class.not.allowed.to.extend.sealed.class.from.another.module=Класс не может расширять sealed класс из другого модуля
class.not.allowed.to.extend.sealed.class.from.another.package=Класс не может расширять sealed класс из другого пакета
classes.extends.prohibited.super=Классы не могут напрямую расширять ''{0}''
compact.constructor.in.regular.class=Ожидается список параметров
constant.expression.required=Требуется константное выражение
constructor.call.must.be.first.statement=Вызов ''{0}'' должен быть первым оператором в теле конструктора
constructor.call.must.be.top.level.statement=Вызов ''{0}'' должен быть верхнеуровневым оператором в теле конструктора
constructor.call.only.allowed.in.constructor=Вызов ''{0}'' разрешен только в теле конструктора
constructor.is.not.used=Конструктор ''{0}'' никогда не используется
continue.outside.loop=Continue вне цикла
continue.outside.switch.expr=Continue вне охватывающего switch-выражения
create.class.action.this.not.valid.java.qualified.name=Это не является допустимым полным именем Java
cyclic.inheritance=Циклическое наследование с участием ''{0}''
declaration.not.allowed=Объявление здесь не допускается
declaration.or.variable.expected=Ожидается объявление, final или effectively final переменная
deconstruction.pattern.requires.record=Шаблон деконструкции может применяться только к record, ''{0}'' не является record
deconstruction.pattern.type.contain.annotation=Аннотации не допускаются в типах шаблона деконструкции
default.label.must.not.contains.case.keyword=Метка для default должна использовать только ключевое слово 'default', без 'case'
default.label.not.allowed.here=Метка default здесь не допускается\: 'default' может использоваться только как отдельная метка case или в паре с 'null'
default.method.overrides.object.member=Метод по умолчанию ''{0}'' переопределяет член ''java.lang.Object''
deprecated.default.constructor=Конструктор по умолчанию в ''{0}'' помечен как устаревший
deprecated.since.symbol=''{0}'' помечен как устаревший начиная с версии {1}
deprecated.symbol=''{0}'' помечен как устаревший
diamond.operator.not.allowed.here=Diamond-оператор здесь не разрешен
different.case.kinds.in.switch=В switch используются разные виды case
direct.abstract.method.access=Абстрактный метод ''{0}'' не может быть вызван напрямую
dot.expected.after.super.or.this=Ожидается '.'
duplicate.class=Дублирующийся класс\: ''{0}''
duplicate.class.in.other.file=Дублирующийся класс найден в файле ''{0}''
duplicate.default.switch.label=Дублирующаяся метка default
duplicate.label=Метка ''{0}'' уже используется
duplicate.method=''{0}'' уже определен в ''{1}''
duplicate.reference.in.list=Дублирующаяся ссылка на ''{0}'' в списке ''{1}''
duplicate.switch.label=Дублирующаяся метка ''{0}''
duplicate.unconditional.pattern.label=Дублирующийся безусловный шаблон
else.without.if='else' без 'if'
empty.character.literal=Пустой символьный литерал
enum.constant.must.implement.method=Константа enum ''{0}'' должна реализовать абстрактный метод ''{1}'' в ''{2}''
enum.identifier.warn=Использование 'enum' в качестве идентификатора не поддерживается начиная с Java 1.5
enum.is.not.used=Enum ''{0}'' никогда не используется
enum.types.cannot.be.instantiated=Типы enum не могут быть созданы
error.cannot.infer.pattern.type=Не удаётся вывести тип шаблона\: {0}
error.cannot.resolve.class=Не удаётся разрешить класс ''{0}''
error.cannot.resolve.class.or.package=Не удаётся разрешить класс или пакет ''{0}''
error.extra.semicolons.between.import.statements.not.allowed=Дополнительные точки с запятой между операторами import не допускаются
error.guard.allowed.after.patterns.only=Guard допускается только после шаблонов
error.implicit.class.contains.no.main.method=Неявно объявленный класс не содержит метод 'main'
error.implicit.class.has.invalid.file.name=Имя файла неявно объявленного класса не является допустимым идентификатором
error.initializers.are.not.allowed.in.implicit.classes=Инициализаторы не разрешены в неявно объявленных классах
error.interface.member.clashes=Член @interface конфликтует с ''{0}'' в {1}
error.package.statement.not.allowed.for.implicit.class=Оператор package не разрешен для неявно объявленного класса
exception.already.caught=Исключение ''{0}'' уже было перехвачено
exception.already.caught.warn=Недостижимая секция\: {1, choice, 0\#исключение|2\#исключения} ''{0}'' {1, choice, 0\#уже было|2\#уже были} перехвачено
exception.is.never.thrown=Исключение ''{0}'' никогда не выбрасывается в методе
exception.must.be.disjoint=Типы в multi-catch должны быть непересекающимися\: ''{0}'' является подклассом ''{1}''
exception.never.thrown.try=Исключение ''{0}'' никогда не выбрасывается в соответствующем try-блоке
expected.boolean.expression=Ожидается логическое выражение
expected.catch.or.finally=Ожидается 'catch' или 'finally'
expected.class.or.package=Ожидается класс или пакет
expected.comma=Ожидается ','
expected.expression=Ожидается выражение
expected.identifier=Ожидается идентификатор
expected.identifier.or.type=Ожидается идентификатор или тип
expected.lbrace=Ожидается '{'
expected.lparen=Ожидается '('
expected.lparen.or.lbracket=Ожидается '(' или '['
expected.parameter=Ожидается параметр
expected.rbrace=Ожидается '}'
expected.rbracket=Ожидается ']'
expected.rparen=Ожидается ')'
expected.semicolon=Ожидается ';'
expected.statement=Ожидается оператор
expected.switch.label=Ожидается 'case', 'default' или '}'
expected.switch.rule=Ожидается выражение, блок или оператор throw
expected.while=Ожидается 'while'
expression.expected=Ожидается выражение
expression.with.type.void.not.allowed.as.string.template.embedded.expression=Выражение типа 'void' не допускается как встроенное выражение в строковом шаблоне
extends.after.enum=Для enum не разрешено использование extends
extension.method.in.class=Методы расширения могут использоваться только внутри интерфейса
extension.method.should.have.a.body=Метод расширения должен иметь тело
field.is.already.defined.in.single.static.import=Поле ''{0}'' уже определено в одиночном статическом импорте
field.is.ambiguous.in.single.static.import=Поле ''{0}'' неоднозначно в одиночном статическом импорте
field.is.not.used=Поле ''{0}'' никогда не используется
field.is.not.used.for.reading={0} полю ''{1}'' присваивается значение, но оно никогда не используется
final.method.override=''{0}'' не может переопределить ''{1}'' в ''{2}''; переопределяемый метод является final
finally.without.try='finally' без 'try'
floating.point.number.too.large=Слишком большое число с плавающей точкой
floating.point.number.too.small=Слишком маленькое число с плавающей точкой
foreach.not.applicable=Foreach не применим к типу ''{0}''
formal.varargs.element.type.inaccessible.here=Формальный тип элемента varargs {0} недоступен здесь
functional.interface.must.not.be.sealed.error.description=Функциональный интерфейс не может быть объявлен как ''{0}''
generic.array.creation=Создание обобщенного массива
generic.extend.exception=Обобщенный класс не может расширять 'java.lang.Throwable'
generics.annotation.members.may.not.have.type.parameters=Члены @interface не могут иметь параметры типа
generics.cannot.be.inherited.as.raw.and.generic=''{0}'' не может быть унаследован как сырой тип и с обобщенными аргументами типа ''{1}''
generics.cannot.be.inherited.with.different.type.arguments=''{0}'' не может быть унаследован с разными аргументами типа\: ''{1}'' и ''{2}''
generics.cannot.catch.type.parameters=Невозможно перехватить параметры типа
generics.cannot.instanceof.type.parameters=Ожидается класс или массив
generics.diamond.not.applicable=Ромбовидный оператор не применим к непараметризованным типам
generics.duplicate.type.parameter=Дублирующийся параметр типа\: ''{0}''
generics.enum.may.not.have.type.parameters=Enum не может иметь параметры типа
generics.holder.method=Метод
generics.holder.type=Тип
generics.inferred.type.for.type.parameter.is.not.within.its.bound.extend=Выведенный тип ''{2}'' для параметра типа ''{0}'' не соответствует его границе; должен расширять ''{1}''
generics.inferred.type.for.type.parameter.is.not.within.its.bound.implement=Выведенный тип ''{2}'' для параметра типа ''{0}'' не соответствует его границе; должен реализовывать ''{1}''
generics.methods.have.same.erasure={0}; оба метода имеют одинаковое стирание типов
generics.methods.have.same.erasure.hide={0}; оба метода имеют одинаковое стирание типов, но ни один не скрывает другой
generics.methods.have.same.erasure.override={0}; оба метода имеют одинаковое стирание типов, но ни один не переопределяет другой
generics.reference.parameters.not.allowed=Ссылочные параметры здесь не допускаются
generics.select.static.class.from.parameterized.type=Аргументы типа здесь не допускаются, так как класс ''{0}'' является статическим
generics.type.argument.cannot.be.of.primitive.type=Аргумент типа не может быть примитивным типом
generics.type.arguments.on.raw.method=Аргументы типа указаны для сырого метода
generics.type.arguments.on.raw.type=Аргументы типа указаны для сырого типа
generics.type.or.method.does.not.have.type.parameters={0} ''{1}'' не имеет параметров типа
generics.type.parameter.cannot.be.instantiated=Параметр типа ''{0}'' не может быть создан напрямую
generics.type.parameter.is.not.within.its.bound.extend=Параметр типа ''{0}'' выходит за пределы своей границы; должен расширять ''{1}''
generics.type.parameter.is.not.within.its.bound.implement=Параметр типа ''{0}'' выходит за пределы своей границы; должен реализовывать ''{1}''
generics.unchecked.assignment=Непроверенное присваивание\: ''{0}'' к ''{1}''
generics.unchecked.call=Непроверенный вызов метода ''{0}''
generics.unchecked.call.to.member.of.raw.type=Непроверенный вызов ''{0}'' как члена сырого типа ''{1}''
generics.unchecked.cast=Непроверенное приведение типов\: ''{0}'' к ''{1}''
generics.wildcard.not.expected=Wildcard здесь не ожидается
generics.wildcards.may.be.used.only.as.reference.parameters=Wildcards могут использоваться только как параметры-ссылки
generics.wrong.number.of.type.arguments=Неверное количество аргументов типа\: {0}; требуется\: {1}
guarded.pattern.variable.must.be.final=Переменная, используемая в защищенном шаблоне, должна быть final или effectively final
hexadecimal.numbers.must.contain.at.least.one.hexadecimal.digit=Шестнадцатеричные числа должны содержать хотя бы одну шестнадцатеричную цифру
identifier.is.not.allowed.here=Идентификатор здесь не разрешен
illegal.escape.character.in.character.literal=Недопустимый escape-символ в символьном литерале
illegal.escape.character.in.string.literal=Недопустимый escape-символ в строковом литерале
illegal.forward.reference=Недопустимая опережающая ссылка
illegal.forward.reference.enum=Невозможно сослаться на константу перечисления ''{0}'' до её определения
illegal.generic.type.for.instanceof=Недопустимый обобщенный тип для instanceof
illegal.initializer=Недопустимый инициализатор для ''{0}''
illegal.line.end.in.string.literal=Конец строки не разрешен в строковых литералах
illegal.self.reference=Недопустимая самоссылка
illegal.self.reference.enum=Невозможно сослаться на константу перечисления ''{0}'' из её собственного определения
illegal.to.access.static.member.from.enum.constructor.or.instance.initializer=Недопустимо обращаться к статическому члену ''{0}'' из {1, choice, 1\#конструктора enum|2\#инициализатора поля экземпляра|3\#инициализатора экземпляра}
illegal.type.void=Недопустимый тип\: 'void'
illegal.underscore=Недопустимое подчеркивание
illegal.unicode.escape=Недопустимая Unicode escape-последовательность
implements.after.interface=Для интерфейса не разрешена конструкция implements
implicit.class.can.not.be.referenced=Невозможно сослаться на неявно объявленный класс ''{0}''
impossible.assign.declared.outside.guard=Невозможно присвоить значение переменной ''{0}'', так как она объявлена вне guard
inaccessible.type=''{0}'' недоступен здесь
incompatible.modifiers=Недопустимая комбинация модификаторов\: ''{0}'' и ''{1}''
incompatible.parameter.types.in.lambda=Несовместимые типы параметров в lambda-выражении\: ожидается {0}, но найдено {1}
incompatible.parameter.types.in.lambda.wrong.number.of.parameters=Несовместимые типы параметров в lambda-выражении\: неверное количество параметров\: ожидается {0}, но найдено {1}
incompatible.return.type=попытка использовать несовместимый тип возвращаемого значения
incompatible.switch.null.type=''{0}'' не может быть преобразован в ''{1}''
incompatible.types=Несовместимые типы. Найдено\: ''{1}'', требуется\: ''{0}''
incompatible.types.html.tooltip=<html><body><table><tr><td style\=''padding\: 0px 16px 8px 4px;color\: {5}''>Требуемый тип\: </td><td style\=''padding\: 0px 4px 8px 0px;''>{0}</td>{1}</tr><tr><td style\=''padding\: 0px 16px 0px 4px;color\: {5}''>Предоставленный\: </td><td style\=''padding\: 0px 4px 0px 0px;''>{2}</td>{3}</tr></table>{4}</body></html>
incompatible.types.reason.ambiguous.method.reference=<br/>причина\: неоднозначная ссылка на метод\: подходят и ''{0}'', и ''{1}''
incomplete.project.state.pending.reference=Будет разрешено после полной загрузки проекта
inconvertible.type.cast=Несовместимые типы; невозможно привести ''{0}'' к ''{1}''
incorrect.number.of.nested.patterns=Неверное количество вложенных шаблонов\: ожидалось {0}, но найдено {1}
inheritance.from.final.class=Невозможно наследовать от {1} ''{0}''
initializer.must.be.able.to.complete.normally=Инициализатор должен иметь возможность завершиться нормально
instance.method.cannot.override.static.method=Метод экземпляра ''{0}'' в ''{1}'' не может переопределить статический метод ''{2}'' в ''{3}''
instanceof.pattern.equals=Тип шаблона ''{0}'' совпадает с типом выражения
instanceof.pattern.supertype=Тип шаблона ''{0}'' является супертипом типа выражения ''{1}''
insufficient.language.level={0} не поддерживаются на уровне языка ''{1}''
integer.number.too.large=Слишком большое целое число
interface.expected=Здесь ожидается интерфейс
interface.is.not.used=Интерфейс ''{0}'' никогда не используется
interface.methods.cannot.have.body=Абстрактные методы интерфейса не могут иметь тело
invalid.case.label.combination.constants.and.patterns=Недопустимая комбинация меток case\: метка case должна состоять либо из списка констант case, либо из одного шаблона case
invalid.case.label.combination.constants.and.patterns.unnamed=Недопустимая комбинация меток case\: метка case должна состоять либо из списка констант case, либо из списка шаблонов case
invalid.case.label.combination.several.patterns=Недопустимая комбинация меток case\: метка case не должна содержать более одного шаблона case
invalid.case.label.combination.several.patterns.unnamed=Недопустимая комбинация меток case\: несколько шаблонов разрешены только если ни один из них не объявляет переменные шаблона
invalid.default.and.null.order=Недопустимый порядок меток case\: 'null' должен быть первым, а 'default' - вторым
invalid.package.annotation.containing.file=Аннотации пакета должны находиться в файле package-info.java
invalid.permits.clause=Недопустимая конструкция permits\: ''{0}'' должен быть sealed
invalid.permits.clause.direct.implementation=Недопустимая конструкция permits\: ''{0}'' должен напрямую {1, choice, 1\#расширять|2\#реализовывать} ''{2}''
invalid.qualified.new=Недопустимый квалифицированный new
invalid.statement=Недопустимый оператор
is.not.an.enclosing.class=''{0}'' не является включающим классом
label.without.statement=Метка без оператора
lambda.expression.not.expected=Lambda-выражение здесь не ожидается
lambda.parameters.consistency.message=Нельзя смешивать 'var' и явно типизованные параметры в lambda-выражении
lambda.variable.must.be.final=Переменная, используемая в lambda-выражении, должна быть final или effectively final
local.class.is.not.used=Локальный класс ''{0}'' никогда не используется
local.class.referenced.from.other.switch.branch=Невозможно сослаться на локальный класс ''{0}'' из другой ветки switch
local.classes.must.not.extend.sealed.classes=Локальные классы не должны расширять sealed классы
local.variable.is.never.used=Переменная ''{0}'' никогда не используется
local.variable.is.not.assigned=Переменной ''{0}'' никогда не присваивается значение
local.variable.is.not.used.for.reading=Переменной ''{0}'' присваивается значение, но она никогда не используется
long.number.too.large=Слишком большое число типа long
lvti.array='var' не разрешен как тип элемента массива
lvti.compound='var' не разрешен в составном объявлении
lvti.lambda=Невозможно вывести тип\: lambda-выражение требует явного целевого типа
lvti.method.ref=Невозможно вывести тип\: ссылка на метод требует явного целевого типа
lvti.no.initializer=Невозможно вывести тип\: 'var' у переменной без инициализатора
lvti.null=Невозможно вывести тип\: инициализатор переменной - 'null'
lvti.selfReferenced=Невозможно вывести тип для ''{0}'', он используется в своем собственном инициализаторе
lvti.void=Невозможно вывести тип\: инициализатор переменной - 'void'
malformed.floating.point.literal=Неверный формат литерала с плавающей точкой
marked.for.removal.default.constructor=Конструктор по умолчанию в ''{0}'' помечен как устаревший и предназначен для удаления
marked.for.removal.symbol=''{0}'' помечен как устаревший и предназначен для удаления
marked.for.removal.symbol.since=''{0}'' помечен как устаревший начиная с версии {1} и предназначен для удаления
member.referenced.before.constructor.called=Невозможно обратиться к ''{0}'' до вызова конструктора супертипа
method.call.expected=Ожидается вызов метода
method.called.before.constructor.called=Невозможно вызвать ''{0}'' до вызова конструктора суперкласса
method.does.not.override.super=Метод не переопределяет метод из суперкласса
method.is.not.used=Метод ''{0}'' никогда не используется
method.reference.expression.is.not.expected=Выражение ссылки на метод здесь не ожидается
missing.method.body=Отсутствует тело метода, либо объявите его как abstract
missing.package.statement=Отсутствует оператор package\: ''{0}''
missing.package.statement.package.name.invalid=Отсутствует оператор package, а имя пакета ''{0}'', соответствующее пути файла, недопустимо
missing.return.statement=Отсутствует оператор return
missing.return.type=Недопустимое объявление метода; требуется тип возвращаемого значения
missing.return.value=Отсутствует возвращаемое значение
modifier.not.allowed=Модификатор ''{0}'' здесь не разрешен
modifier.not.allowed.on.classes.without.sealed.super=Модификатор 'non-sealed' не разрешен для классов без sealed суперкласса
modifier.not.allowed.on.local.classes=Модификатор ''{0}'' не разрешен для локальных классов
modifiers.for.enum.constants=Модификаторы не разрешены для констант enum
module.access.bad.name=Пакет ''{0}'' объявлен в модуле с недопустимым именем (''{1}'')
module.access.does.not.read=Пакет ''{0}'' объявлен в модуле ''{1}'', но модуль ''{2}'' его не читает
module.access.from.named=Пакет ''{0}'' объявлен в модуле ''{1}'', который не экспортует его в модуль ''{2}''
module.access.from.unnamed=Пакет ''{0}'' объявлен в модуле ''{1}'', который не экспортует его в безымянный модуль
module.access.not.in.graph=Пакет ''{0}'' объявлен в модуле ''{1}'', который отсутствует в графе модулей
module.access.to.unnamed=Пакет ''{0}'' объявлен в безымянном модуле, но модуль ''{1}'' его не читает
module.ambiguous=Неоднозначная ссылка на модуль\: {0}
module.bad.name=Недопустимое имя модуля ''{0}''
module.conflicting.packages=Пакет ''{0}'' существует в другом модуле\: {1}
module.conflicting.reads=Модуль ''{0}'' читает пакет ''{1}'' как из ''{2}'', так и из ''{3}''
module.cyclic.dependence=Циклическая зависимость\: {0}
module.does.not.read=Модуль ''{0}'' не читает ''{1}''
module.duplicate.exports=Дублирующийся ''exports''\: {0}
module.duplicate.exports.target=Дублирующаяся цель ''exports''\: {0}
module.duplicate.impl=Дублирующаяся реализация\: {0}
module.duplicate.opens=Дублирующийся ''opens''\: {0}
module.duplicate.opens.target=Дублирующаяся цель ''opens''\: {0}
module.duplicate.provides=Дублирующийся ''provides''\: {0}
module.duplicate.requires=Дублирующийся ''requires''\: {0}
module.duplicate.uses=Дублирующийся ''uses''\: {0}
module.file.duplicate='module-info.java' уже существует в модуле
module.file.wrong.location=Объявление модуля должно находиться в корне исходного кода модуля
module.file.wrong.name=Объявление модуля должно быть в файле 'module-info.java'
module.no.package=Файл модуля не должен содержать оператор 'package'
module.not.found=Модуль не найден\: {0}
module.not.in.graph=Модуль ''{0}'' отсутствует в графе модулей
module.not.on.path=Модуль отсутствует в зависимостях\: {0}
module.open.duplicate.text=Перейти к дубликату
module.opens.in.weak.module='opens' не разрешен в открытом модуле
module.service.abstract=Реализация сервиса является абстрактным классом\: {0}
module.service.alien=Реализация сервиса должна быть определена в том же модуле, что и директива provides
module.service.enum=Определение сервиса является enum\: {0}
module.service.impl=Тип реализации сервиса должен быть подтипом интерфейса сервиса или иметь public static метод 'provider' без аргументов
module.service.inner=Реализация сервиса является внутренним классом\: {0}
module.service.no.ctor=Реализация сервиса не имеет public конструктора по умолчанию\: {0}
module.service.provider.type=Возвращаемый тип метода ''provider'' должен быть подтипом интерфейса сервиса\: {0}
module.service.unused=Интерфейс сервиса предоставлен, но не экспортован и не используется
module.unwanted.modifier.warn=Модификаторы для 'requires java.base' запрещены начиная с Java 10
multiple.non.overriding.abstract.methods.found.in.0=Найдено несколько не переопределяющих abstract методов в {0}
multiple.non.overriding.abstract.methods.found.in.interface.0=Найдено несколько не переопределяющих abstract методов в интерфейсе {0}
multiple.switch.labels=Множественные метки switch разрешены для группы операторов switch только если ни одна из них не объявляет переменные шаблона
native.methods.cannot.have.a.body=Native методы не могут иметь тело
no.default.constructor.available=В ''{0}'' нет доступного конструктора по умолчанию
no.enclosing.instance.in.scope=В области видимости нет внешнего экземпляра типа ''{0}''
no.interface.expected=Здесь не ожидается интерфейс
no.target.method.found=Целевой метод не найден
non.static.method.cannot.be.referenced.from.a.static.context.method.reference.context=Нестатический метод не может быть использован в static контексте
non.static.symbol.referenced.from.static.context=Нестатический {0} ''{1}'' не может быть использован в static контексте
not.a.functional.interface={0} не является функциональным интерфейсом
not.a.statement=Не является оператором
not.allowed.in.interface=Не разрешено в интерфейсе
not.allowed.in.sealed.hierarchy=''{0}'' не разрешен в sealed иерархии
not.inner.class=''{0}'' не является внутренним классом
not.loop.label=Не метка цикла\: ''{0}''
null.label.not.allowed.here=Недопустимая комбинация меток case\: 'null' может использоваться только как отдельная метка case или в паре с 'default'
numeric.overflow.in.expression=Числовое переполнение в выражении
only.one.constructor.call.allowed.in.constructor=В конструкторе разрешен только один явный вызов конструктора
overridden.method.does.not.throw={0}; переопределённый метод не выбрасывает ''{1}''
overrides.deprecated.method=Переопределяет устаревший метод в ''{0}''
overrides.marked.for.removal.method=Переопределяет метод, который помечен как устаревший и предназначен для удаления в ''{0}''
package.clashes.with.class=Пакет ''{0}'' конфликтует с классом того же имени
package.is.empty=Пакет пуст\: {0}
package.local.symbol=''{0}'' не является public в ''{1}''. Нет доступа извне пакета
package.name.file.path.mismatch=Имя пакета ''{0}'' не соответствует пути к файлу ''{1}''
package.not.found=Пакет не найден\: {0}
parameter.excluding.hierarchy.disable.text=Не подсвечивать параметры для унаследованных методов
parameter.is.not.used=Параметр ''{0}'' никогда не используется
parameterized.qualifier.on.static.method.reference.context=Параметризованный квалификатор в ссылке на static метод
pattern.is.not.exhaustive=Шаблон ''{0}'' не является исчерпывающим для ''{1}''
pattern.variable.is.not.used=Переменная шаблона ''{0}'' никогда не используется
permit.list.must.contain.outside.inheritors=Конструкция permits sealed класса должна содержать все подклассы
permits.after.enum=Для enum не разрешена конструкция permits
permits.list.generics.are.not.allowed=Дженерики не разрешены в списке permits
permitted.subclass.must.have.modifier=Все подклассы sealed класса должны быть либо final, sealed или non-sealed
private.constructor.is.not.used=Private конструктор ''{0}'' никогда не используется
private.field.is.not.assigned=Private полю ''{0}'' никогда не присваивается значение
private.field.is.not.used=Private поле ''{0}'' никогда не используется
private.inner.class.is.not.used=Private внутренний класс ''{0}'' никогда не используется
private.inner.interface.is.not.used=Private внутренний интерфейс ''{0}'' никогда не используется
private.method.is.not.used=Private метод ''{0}'' никогда не используется
private.methods.in.interfaces.should.have.body=Private методы в интерфейсах должны иметь тело
private.symbol=''{0}'' имеет private доступ в ''{1}''
processor.missing.from.string.template.expression=Отсутствует процессор в выражении строкового шаблона
protected.symbol=''{0}'' имеет protected доступ в ''{1}''
public.class.should.be.named.after.file=Класс ''{0}'' является public, должен быть объявлен в файле ''{0}.java''
qualified.class.reference.not.allowed.in.qualified.new=Квалифицированная ссылка на класс не разрешена в квалифицированном new
qualified.enum.constant.in.switch=Метка case в switch по enum должна быть неквалифицированным именем константы перечисления
qualified.enum.constant.in.switch.remove.fix=Удалить квалификатор
qualified.new.of.static.class=Квалифицированное создание static класса
qualifier.must.be.expression=Квалификатор должен быть выражением
raw.processor.type.not.allowed=Сырой тип процессора не разрешен\: {0}
receiver.name.mismatch=Имя приёмника не соответствует типу внешнего класса
receiver.static.context=Приёмник не может использоваться в static контексте
receiver.type.mismatch=Тип приёмника не соответствует типу внешнего класса
receiver.wrong.context=Приёмники не разрешены вне списка параметров метода
receiver.wrong.position=Приёмник должен быть первым параметром
record.accessor=Аксессор компонента record
record.accessor.wrong.return.type=Неверный тип возвращаемого значения для аксессора компонента. Ожидается\: ''{0}'', найдено\: ''{1}''
record.canonical.constructor=Канонический конструктор
record.canonical.constructor.wrong.parameter.name=Имена параметров канонического конструктора должны совпадать с именами компонентов record. Ожидается\: ''{0}'', найдено\: ''{1}''
record.canonical.constructor.wrong.parameter.type=Неверный тип параметра для компонента record ''{0}''. Ожидается\: ''{1}'', найдено\: ''{2}''
record.compact.constructor=Компактный конструктор
record.compact.constructor.return=Оператор 'return' не разрешен в компактном конструкторе
record.component.cstyle.declaration=Объявление массива в стиле C не разрешено в компоненте record
record.component.not.initialized=Компонент record ''{0}'' может быть не инициализован в каноническом конструкторе
record.component.restricted.name=Недопустимое имя компонента record ''{0}''
record.component.vararg.not.last=Vararg компонент record должен быть последним в списке
record.constructor.call.in.canonical=Канонический конструктор не может делегировать другому конструктору
record.extends=Для record не разрешена конструкция extends
record.header.regular.class=Заголовок record объявлен для не-record
record.instance.field=Поле экземпляра не разрешено в record
record.instance.initializer=Инициализатор экземпляра не разрешен в record
record.is.not.used=Record ''{0}'' никогда не используется
record.no.constructor.call.in.non.canonical=Неканонический конструктор record должен делегировать другому конструктору
record.no.header=В record отсутствует объявление заголовка
record.permits=Для record не разрешена клауза permits
record.special.method.non.public={0} должен быть ''public''
record.special.method.stronger.access=Уровень доступа {0} не может быть более ограничительным, чем уровень доступа record (''{1}'')
record.special.method.throws={0} не может объявлять выбрасываемые исключения
record.special.method.type.parameters={0} не может иметь параметры типа
recursive.constructor.invocation=Рекурсивный вызов конструктора
redundant.semicolon.warn=Избыточные точки с запятой между операторами import запрещены начиная с Java 21
remove.unused.imports.quickfix.text=Удалить неиспользуемые import
repeated.annotation.target=Повторяющаяся цель аннотации
repeated.interface=Повторяющийся интерфейс
repeated.modifier=Повторяющийся модификатор ''{0}''
resource.variable.must.be.final=Переменная, используемая как ресурс try-with-resources, должна быть final или effectively final
restricted.identifier=''{0}'' является зарезервированным идентификатором и не может использоваться для объявления типов
restricted.identifier.reference=Недопустимая ссылка на зарезервированный тип ''{0}''
restricted.identifier.warn=Использование ''{0}'' в качестве имени класса не поддерживается начиная с Java {1}
return.from.constructor=Невозможно вернуть значение из конструктора
return.from.void.method=Невозможно вернуть значение из метода с типом результата void
return.outside.method=Return находится вне метода
return.outside.switch.expr=Return находится вне охватывающего switch-выражения
return.statement.not.allowed.before.explicit.constructor.call=Оператор 'return' не разрешен перед вызовом ''{0}''
safevararg.annotation.cannot.be.applied.for.record.component=@SafeVarargs не разрешен для компонента record
safevarargs.not.allowed.non.final.instance.methods=@SafeVarargs не разрешен для нефинальных методов экземпляра
safevarargs.not.allowed.on.methods.with.fixed.arity=@SafeVarargs не разрешен для методов с фиксированной арностью
safevarargs.not.applicable.for.reifiable.types=@SafeVarargs не применим к реифицируемым типам
safevarargs.not.suppress.potentially.unsafe.operations=@SafeVarargs не подавляет потенциально небезопасные операции
sealed.cannot.be.functional.interface=Sealed-класс не может использоваться как функциональный интерфейс
sealed.must.have.inheritors=Sealed-класс должен иметь подклассы
sealed.type.inheritor.expected.modifiers=Ожидаются модификаторы ''{0}'', ''{1}'' или ''{2}''
sealed.type.inheritor.expected.modifiers2=Ожидается модификатор ''{0}'' или ''{1}''
single.import.class.conflict=''{0}'' уже определен в импорте одиночного типа
statement.must.be.prepended.with.case.label=Перед оператором должна быть метка case
static.interface.method.call.qualifier=Статический метод может быть вызван только в содержащем его интерфейсе
static.member.accessed.via.instance.reference=Доступ к статическому члену ''{0}.{1}'' через ссылку на экземпляр
static.method.cannot.be.annotated.with.override=Переменная, используемая как ресурс try-with-resources, должна быть final или effectively final
static.method.cannot.override.instance.method=Статический метод ''{0}'' в ''{1}'' не может переопределить метод экземпляра ''{2}'' в ''{3}''
static.method.referenced.through.non.static.qualifier.method.reference.context=Статический метод вызывается через нестатический квалификатор
static.method.referenced.through.receiver.method.reference.context=Статический метод вызывается через получателя
static.methods.in.interfaces.should.have.body=Статические методы в интерфейсах должны иметь тело
suspicious.name.assignment=''{0}'' вероятно не следует присваивать ''{1}''
suspicious.name.parameter=''{0}'' вероятно не следует передавать как параметр ''{1}''
suspicious.name.return=''{0}'' вероятно не следует возвращать из метода ''{1}''
switch.class.or.array.type.expected=класс или массив
switch.constant.expression.required=Требуется константное выражение, паттерн или null
switch.dominance.of.preceding.label=Метка подавляется предшествующей меткой case ''{0}''
switch.expr.empty=В выражении 'switch' отсутствуют блоки case
switch.expr.incomplete=Выражение 'switch' не охватывает все возможные входные значения
switch.expr.no.result=В switch-выражении отсутствуют результирующие выражения
switch.expr.rule.should.produce.result=Правило switch-выражения должно производить результат во всех путях выполнения
switch.expr.should.produce.result=Switch-выражение должно производить результат во всех путях выполнения
switch.expression.cannot.be.void=Целевой тип для switch-выражения не может быть void
switch.illegal.fall.through.to=Недопустимое проваливание к паттерну
switch.invalid.selector.types=Тип селектора ''{0}'' не поддерживается
switch.pattern.expected=Для типа селектора switch ''{0}'' ожидается паттерн
switch.statement.empty=В операторе 'switch' отсутствуют блоки case
switch.statement.incomplete=Оператор 'switch' не охватывает все возможные входные значения
switch.unconditional.boolean.and.default.exist='switch' имеет все булевы значения и метку default
switch.unconditional.boolean.and.unconditional.exist='switch' имеет все булевы значения и безусловный шаблон
switch.unconditional.pattern.and.default.exist='switch' содержит и безусловный паттерн, и метку default
target.method.is.generic=Целевой метод является обобщенным
target.type.of.a.lambda.conversion.must.be.an.interface=Целевой тип лямбда-преобразования должен быть интерфейсом
text.block.new.line=Недопустимое начало текстового блока\: отсутствует новая строка после открывающих кавычек
text.block.unclosed=Незакрытый текстовый блок
text.class.cannot.access=Нет доступа к {0}
text.class.inherits.abstract.and.default={0} наследует abstract и default для {1} из типов {2} и {3}
text.class.inherits.unrelated.defaults={0} наследует несвязанные default для {1} из типов {2}
text.class.is.not.accessible={0} недоступен в текущем контексте
text.improper.formed.type=Неправильно сформированный тип\: отсутствуют некоторые параметры типа
too.many.array.dimensions=Слишком много измерений массива
too.many.characters.in.character.literal=Слишком много символов в символьном литерале
two.methods.are.inherited.with.same.signature=Методы {0} из {1} и {2} из {3} унаследованы с одинаковой сигнатурой
type.parameter.cannot.be.followed.by.other.bounds=После параметра типа не могут следовать другие границы
type.parameter.has.incompatible.upper.bounds=Параметр типа {0} имеет несовместимые верхние границы\: {1}
type.parameter.is.not.used=Параметр типа ''{0}'' никогда не используется
type.pattern.expected=Ожидается шаблон типа
unary.operator.not.applicable=Оператор ''{0}'' не может быть применен к ''{1}''
unchecked.overriding.incompatible.return.type=Непроверенное переопределение\: тип возвращаемого значения требует непроверенного приведения. Найдено ''{0}'', требуется ''{1}''
unclosed.char.literal=Незакрытый символьный литерал
unclosed.comment=Незакрытый комментарий
underscore.identifier.error=Начиная с Java 9, '_' является ключевым словом и не может использоваться как идентификатор
underscore.identifier.error.unnamed=Использование '_' в качестве ссылки не разрешено
underscore.identifier.warn=Использование '_' в качестве идентификатора не поддерживается начиная с Java 9
underscore.lambda.identifier=Использование '_' в качестве имени параметра лямбды не разрешено
unexpected.token=Неожиданный токен
unexpected.type=Неожиданный тип. Найдено\: ''{1}'', требуется\: ''{0}''
unexpected.type.class.expected=Неожиданный тип\: ожидается класс
unhandled.close.exceptions=Необработанное {1, choice, 0\#исключение|2\#исключения} из {2}\: {0}
unhandled.exceptions=Необработанное {1, choice, 0\#исключение|2\#исключения}\: {0}
unknown.class=Неизвестный класс\: ''{0}''
unqualified.super.disallowed=Неквалифицированная ссылка super не разрешена в методе расширения
unreachable.statement=Недостижимый оператор
unreachable.statement.false.condition=Условие цикла всегда false, что делает тело цикла недостижимым
unrelated.overriding.methods.return.types=методы имеют несвязанные типы возвращаемых значений
unresolved.label=Неопределённая метка\: ''{0}''
unsafe.cast.in.instanceof=''{0}'' не может быть безопасно приведен к ''{1}''
valid.switch.1_7.selector.types=char, byte, short, int, Character, Byte, Short, Integer, String или enum
valid.switch.selector.types=byte, char, short или int
vararg.cstyle.array.declaration=C-стиль объявления массива не разрешен в vararg-параметре
vararg.not.last.parameter=Vararg-параметр должен быть последним в списке
variable.already.assigned=Переменной ''{0}'' возможно уже присвоено значение
variable.already.defined=Переменная ''{0}'' уже определена в этой области видимости
variable.assigned.in.loop=Переменной ''{0}'' возможно присваивается значение в цикле
variable.expected=Ожидается переменная
variable.must.be.final=Переменная ''{0}'' используется во внутреннем классе, должна быть объявлена как final
variable.must.be.final.or.effectively.final=Переменная ''{0}'' используется во внутреннем классе, должна быть final или effectively final
variable.not.initialized=Переменная ''{0}'' может быть не инициализована
visibility.access.problem=Нет доступа к ''{0}'' в ''{1}''
visibility.module.access.problem=Доступ к ''{0}'' в ''{1}'' предотвращен {2}
void.type.is.not.allowed=Тип 'void' здесь не разрешен
weaker.privileges={0}; попытка назначить более слабые права доступа (''{1}''); было ''{2}''
when.expression.is.false=Этот case-метка имеет guard, который является константным выражением со значением 'false'
wildcard.type.cannot.be.instantiated=Wildcard-тип ''{0}'' не может быть создан напрямую
wrong.constructor.arguments=''{0}'' не может быть применен к ''{1}''
wrong.method.arguments=''{0}'' в ''{1}'' не может быть применен к ''{2}''
yield.unexpected=Yield вне выражения switch
yield.unqualified.method.warn=Неквалифицированный вызов метода 'yield' не поддерживается начиная с Java 14
yield.void=Тип выражения не должен быть 'void'