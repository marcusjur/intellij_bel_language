abstract.class.not.allowed=Абстрактный класс не разрешен
access.static.via.instance=Доступ к static члену через ссылку на экземпляр
accessible.name.change.modifier=Изменить модификатор
action.GotoSuperClass.MainMenu.text=Суперкласс или интерфейс [_U]
action.GotoSuperClass.description=Перейти к объявлению класса, который текущий класс расширяет или реализует
action.GotoSuperClass.text=Перейти к суперклассу или интерфейсу [_U]
action.analyzing.cyclic.dependencies.in.scope=Циклические зависимости {0}
action.create.new.class=Новый Java класс
action.create.new.class.description=Создать новый Java класс
action.create.new.module-info.description=Создать новый module-info.java
action.create.new.module-info.title=module-info.java
action.create.new.package-info.description=Создать новый package-info.java
action.create.new.package-info.title=package-info.java
action.cyclic.dependency.title=Анализ циклических зависимостей
action.description.copy.whole.thread.dump.to.clipboard=Копировать весь дамп потоков в буфер обмена
action.description.group.by.scope=Группировать по типу области видимости (production, test, libraries)
action.description.group.threads.with.identical.stacktraces=Группировать потоки с идентичными стектрейсами
action.description.infer.nullity.annotations=Вывести аннотации nullity
action.description.mark.directory.as.a.0.for.generated.files=Отметить директорию как {0} для сгенерированных файлов
action.description.mark.directory.as.an.ordinary.0=Отметить директорию как обычную {0}
action.description.show.only.threads.containing.a.specific.string=Показывать только потоки, содержащие определённую строку
action.dfa.from.stacktrace.text=Найти, почему ''{0}'' может быть {1}
action.expand.static.import.text=Развернуть static import
action.find.similar.stack.call.diverged=Номера строк, вероятно, разошлись. Попробуйте найти текущее местоположение внутри ''{0}.{1}()''
action.find.similar.stack.call.location.not.found=Не найдено похожих местоположений внутри ''{0}.{1}()''
action.find.similar.stack.call.methods=Методы, похожие на ''{0}.{1}()''
action.find.similar.stack.call.methods.not.found=Не найдено методов, похожих на ''{0}.{1}()''
action.find.similar.stack.call.similar.calls=Возможные местоположения внутри ''{0}.{1}()''
action.go.to.functional.implementation.text=Найти реализации функционального интерфейса
action.go.to.implementation.text=Перейти к реализации
action.go.to.overriding.methods.text=Перейти к переопределяющим методам
action.go.to.subclass.text=Перейти к подклассам
action.go.to.super.method.text=Перейти к super методу
action.group.by.package=Пакет
action.group.by.scope.type=Группировать по типу области видимости
action.implement.method=Реализовать метод
action.implement.methods=Реализовать методы
action.override.method=Переопределить метод
action.override.methods=Переопределить методы
action.sort.by.percent.classes.which.overrides.method.description=Сортировать по проценту подклассов, переопределяющих метод
action.sort.by.percent.classes.which.overrides.method.text=Сортировать по проценту подклассов, переопределяющих метод
action.text.0.on.parameter.1={0} для параметра ''{1}''
action.text.choose.class.in.0=выбрать класс в {0}…
action.text.copy.to.clipboard=Копировать в буфер обмена
action.text.edit.template=Редактировать шаблон
action.text.enter.class.name=введите имя класса…
action.text.generated.root.0=Сгенерированный {0}
action.text.merge.identical.stacktraces=Объединить идентичные стектрейсы
action.text.show.methods.to.implement=Показать методы для реализации
action.text.unmark.generated.0=Снять отметку сгенерированного {0}
action.title.infer.nullity.annotations=Вывести аннотации nullity
add.methods.dialog.or=\ или
add.to.permits.list=Добавить ''{0}'' в список permits sealed класса ''{1}''
add.to.permits.list.family.name=Добавить класс в список permits
adds.ext.library.preview=Добавляет библиотеку ''{0}'' в модуль ''{1}''
adds.ext.library.preview.import=Добавляет библиотеку ''{0}'' в зависимости модуля ''{1}'' и импортует ''{2}''
adds.library.preview=Добавляет {0, choice, 1\#библиотеку ''{1}''|2\#одну из {2}} в зависимости модуля ''{3}'' и импортует неразрешённые ''{4}''
adds.library.preview.no.import=Добавляет {0, choice, 1\#библиотеку ''{1}''|2\#одну из {2}} в зависимости модуля ''{3}''
adds.module.dependencies.preview=Добавляет {0, choice, 1\#модуль ''{1}''|2\#один из {2}} в зависимости модуля ''{3}'' и импортует неразрешённые классы
advanced.setting.code.vision.java.minimal.usages=Code Vision\: Минимальное количество использований для показа встроенных подсказок
advanced.setting.compiler.automake.allow.when.app.running=Разрешить автоматическую сборку даже если разрабатываемое приложение запущено
advanced.setting.compiler.automake.allow.when.app.running.description=Автоматически запущенная сборка может удалить некоторые классы, необходимые приложению
advanced.setting.compiler.lower.process.priority=Запускать компиляцию с пониженным приоритетом
advanced.setting.compiler.lower.process.priority.description=Запускать внешний JPS процесс с приоритетом IDLE в Windows и уровнем nice 10 в Linux/macOS
advanced.setting.compiler.unified.ic.implementation=Включить унифицированную реализацию инкрементальной компиляции Java/Kotlin
advanced.setting.compiler.unified.ic.implementation.description=Внешний JPS процесс будет использовать новую реализацию инкрементальной компиляции, способную обрабатывать байткод, созданный как Java, так и Kotlin
advanced.setting.java.completion.qualifier.as.argument=Включить автодополнение для static методов, использующих квалификатор как первый аргумент
advanced.setting.java.sdkmanrc.watcher=Начать отслеживание изменений в конфигурационных файлах ('.sdkmanrc', '.tool-versions', …) при открытии проекта
advanced.setting.java.show.irrelevant.templates.in.source.roots=Показывать нерелевантные шаблоны новых файлов в корнях исходного кода Java
advanced.settings.group.compiler=Компилятор
advanced.settings.group.java=Java
align.types.in.multi.catch=Выровнять типы в multi-catch
annotate.intention.chooser.title=Выберите аннотацию для добавления
annotation.types.cannot.be.inlined=Типы аннотаций не могут быть встроены
arch.checker.notification.content=JDK ''{0}'' ({1}) не соответствует архитектуре системы ({2})
arch.checker.notification.project.structure=Настроить JDK
arch.checker.notification.title=Выбранная JDK может вызвать медленную сборку
assignment.array.element.to.itself.problem.descriptor=Элементу массива присваивается его же значение
assignment.to.declared.variable.problem.descriptor=Переменная ''{0}'' инициализуется самоприсваиванием
assignment.to.itself.problem.descriptor=Переменной ''{0}'' присваивается её же значение
base.package.parameter.wizard.label=Базовый пакет [&P]\:
base.package.project.wizard.error.x.not.valid.package={0} не является допустимым именем пакета
bean.property=Bean свойство
boolean.method.is.always.inverted.display.name=Булев метод всегда инвертируется
boolean.method.is.always.inverted.problem.descriptor=Вызовы булева метода '\#ref()' всегда инвертируются
button.add=Добавить…
button.add.blank=Добавить пустой
button.add.class=Добавить класс…
button.add.dependency=Добавить зависимость
button.add.package=Добавить пакет…
button.add.pattern=Добавить шаблон…
button.annotations=Аннотации…
button.base.method=Базовый метод [&B]
button.code.patterns=Шаблоны кода…
button.current.method=Текущий метод [&C]
button.text.settings=Настройки…
button.to.another.directory=В директорию [&D]
button.to.another.source.root=В корень исходников [&S]
caller.chooser.referenced.code.title=Ссылающийся код
cast.expression=Вставить приведение типа
cast.to.0=Привести к ''{0}''
change.color.command.text=Изменить цвет
change.signature.from.usage.short.name=<html> Изменить сигнатуру {0}({1})</html>
change.uid.action.name=Случайно изменить инициализатор 'serialVersionUID'
checkbox.after.description=После описания
checkbox.after.parameter.descriptions=После описания параметров
checkbox.after.return.tag=После тега return
checkbox.align.parameter.descriptions=Выровнять описания параметров
checkbox.align.thrown.exception.descriptions=Выровнять описания выбрасываемых исключений
checkbox.annotate.local.variables=Аннотировать локальные переменные
checkbox.check.for.jdk.updates=Проверять обновления JDK
checkbox.collapse.annotations=Аннотации
checkbox.collapse.anonymous.classes=Анонимные классы
checkbox.collapse.closures="Замыкания" (анонимные классы, реализующие один метод, до Java 8)
checkbox.collapse.end.of.line.comments=Последовательность комментариев в конце строки
checkbox.collapse.generic.constructor.parameters=<html>Параметры обобщенных конструкторов и методов</html>
checkbox.collapse.i18n.messages=I18n строки
checkbox.collapse.inferred.type=Заменить 'var' на выведенный тип
checkbox.collapse.inner.classes=Внутренние классы
checkbox.collapse.multiline.comments=Многострочные комментарии
checkbox.collapse.one.line.methods=<html>Однострочные методы<html>
checkbox.collapse.simple.property.accessors=<html>Простые методы доступа к свойствам</html>
checkbox.collapse.suppress.warnings=<html>@SuppressWarnings</html>
checkbox.declare.var.type=Использовать 'var' для объявления локальных переменных
checkbox.deprecated.members=Устаревшие члены
checkbox.do.not.indent.top.level.class.members=Не делать отступ для членов класса верхнего уровня
checkbox.do.not.wrap.after.single.annotation=Не переносить после одиночной аннотации
checkbox.do.not.wrap.one.line.comments=Не переносить однострочные комментарии
checkbox.don.t.warn.in.case.of.multiline.lambda=Не предупреждать, если параметр 'List.replaceAll()' - многострочная лямбда
checkbox.enable.javadoc.formatting=Включить форматование JavaDoc
checkbox.enable.leading.asterisks=Включить ведущие звездочки
checkbox.generate.p.on.empty.lines=Генерировать "<p>" на пустых строках
checkbox.html.report.inaccessible.symbols=<html>Сообщать о недоступных символах<br>(инструмент javadoc может не создать гиперссылку)
checkbox.ignore.chains=Игнорировать цепочки методов
checkbox.ignore.fields.used.in.multiple.methods=Игнорировать поля, используемые в нескольких методах
checkbox.insert.imports.for.inner.classes=Вставлять импорты для внутренних классов
checkbox.iterate.unknown.stream.sources.via.stream.iterator=Итерировать неизвестные источники Stream через Stream.iterator()
checkbox.keep.empty.lines=Сохранять пустые строки
checkbox.keep.empty.param.tags=Сохранять пустые теги @param
checkbox.keep.empty.return.tags=Сохранять пустые теги @return
checkbox.keep.empty.throws.tags=Сохранять пустые теги @throws
checkbox.keep.invalid.tags=Сохранять недействительные теги
checkbox.make.generated.local.variables.final=Делать генерируемые локальные переменные final
checkbox.make.generated.parameters.final=Делать генерируемые параметры final
checkbox.param.description.on.new.line=Описания параметров с новой строки
checkbox.param.indent.on.continuation=Отступ для продолжающихся строк
checkbox.prefer.longer.names=Предпочитать более длинные имена
checkbox.preserve.line.feeds=Сохранять переносы строк
checkbox.spaces.around.annotation.eq=Вокруг '\=' в паре значений аннотации
checkbox.spaces.before.colon.in.foreach=Перед двоеточием в foreach
checkbox.spaces.before.deconstruction.list=Список деконструкции
checkbox.spaces.inside.block.braces.when.body.is.present=Внутри фигурных скобок блока при наличии тела
checkbox.spaces.inside.one.line.enum=Внутри фигурных скобок однострочного enum
checkbox.spaces.record.header=Заголовок record
checkbox.spaces.within.deconstruction.list=Список деконструкции
checkbox.suggest.conversion.to.map.computeifabsent=Предлагать преобразование в Map.computeIfAbsent
checkbox.suggest.conversion.to.map.getordefault=Предлагать преобразование в Map.getOrDefault
checkbox.suggest.conversion.to.map.merge=Предлагать преобразование в Map.merge
checkbox.suggest.conversion.to.map.putifabsent=Предлагать преобразование в Map.putIfAbsent
checkbox.suggest.conversion.to.map.replaceall=Предлагать преобразование в Map.replaceAll
checkbox.suggest.replacement.even.if.lambda.may.have.side.effects=Предлагать замену, даже если лямбда может иметь побочные эффекты
checkbox.suppress.with.suppresswarnings=Подавлять с помощью @SuppressWarnings
checkbox.treat.get.k.null.the.same.as.containskey.k.may.change.semantics=Считать 'get(k) \!\= null' эквивалентным 'containsKey(k)' (может изменить семантику)
checkbox.use.fully.qualified.class.names=Использовать полные имена классов
checkbox.use.single.class.import=Использовать импорт отдельных классов
checkbox.use.throws.rather.than.exception=Использовать @throws вместо @exception
checkbox.warn.if.only.foreach.replacement.is.available=Предупреждать, если доступна только замена на 'forEach'
checkbox.warn.if.the.loop.is.trivial=Предупреждать, если цикл тривиальный
checkbox.wrap.at.right.margin=Переносить по правому краю
choose.class=Выбрать класс
choose.super.class.popup.title=Выбрать суперкласс
chooser.text.choose.where.to.save.0=Выберите, куда сохранить ''{0}''
chooser.title.select.path.to.save.jar=Выберите путь для сохранения Jar
class.can.be.record.conversion.make.member.more.accessible=Если члены становятся более доступными\:
class.can.be.record.conversion.strategy.convert.silently=Преобразовать без уведомления
class.can.be.record.conversion.strategy.do.not.convert=Не предлагать преобразование
class.can.be.record.conversion.strategy.show.members=Показать конфликты
class.can.be.record.display.name=Класс может быть record-классом
class.can.be.record.quick.fix=Преобразовать в record-класс
class.can.be.record.suggest.renaming.accessors=Предлагать переименование методов доступа
class.can.be.record.suppress.conversion.if.annotated=Подавлять преобразование, если класс аннотирован\:
class.can.be.record.suppress.conversion.if.annotated.fix.name=Подавлять преобразование в record, если аннотировано ''{0}''
class.cannot.be.inlined.because.a.call.to.its.constructor.is.unresolved=Класс не может быть встроен, так как вызов его конструктора не разрешен
class.cannot.be.inlined.because.an.interface.implemented.by.it.cannot.be.resolved=Класс не может быть встроен, так как не может быть разрешен реализуемый им интерфейс
class.cannot.be.inlined.because.it.has.static.fields.with.non.constant.initializers=Класс не может быть встроен, так как имеет статические поля с неконстантными инициализаторами
class.cannot.be.inlined.because.it.has.static.initializers=Класс не может быть встроен, так как имеет статические инициализаторы
class.cannot.be.inlined.because.it.has.static.inner.classes=Класс не может быть встроен, так как имеет статические внутренние классы
class.cannot.be.inlined.because.it.has.static.methods=Класс не может быть встроен, так как имеет статические методы
class.cannot.be.inlined.because.it.has.static.non.final.fields=Класс не может быть встроен, так как имеет статические не final поля
class.cannot.be.inlined.because.it.has.usages.of.fields.not.inherited.from.its.superclass=Класс не может быть встроен, так как использует поля, не унаследованные от суперкласса
class.cannot.be.inlined.because.it.has.usages.of.its.class.literal=Класс не может быть встроен, так как имеет использования своего класс-литерала
class.cannot.be.inlined.because.it.has.usages.of.its.inner.classes=Класс не может быть встроен, так как имеет использования своих внутренних классов
class.cannot.be.inlined.because.it.is.used.as.a.this.qualifier=Класс не может быть встроен, так как используется как квалификатор 'this'
class.cannot.be.inlined.because.it.is.used.in.a.catch.clause=Класс не может быть встроен, так как используется в блоке 'catch'
class.cannot.be.inlined.because.it.is.used.in.a.throws.clause=Класс не может быть встроен, так как используется в конструкции 'throws'
class.cannot.be.inlined.because.its.constructor.contains.return.statements=Класс не может быть встроен, так как его конструктор содержит операторы 'return'
class.cannot.be.inlined.because.its.superclass.cannot.be.resolved=Класс не может быть встроен, так как не может быть разрешен его суперкласс
class.cannot.be.inlined.because.there.are.usages.of.its.methods.not.inherited.from.its.superclass.or.interface=Класс не может быть встроен, так как имеет использования методов, не унаследованных от суперкласса или интерфейса
class.decorator.or.has.default.constructor=''{0}'' должен иметь конструктор по умолчанию или реализовывать паттерн ''Decorator''
class.filter.editor.add.dialog.title=Новый фильтр
class.filter.editor.choose.class.title=Выбрать класс
class.filter.editor.table.model.column.name.isActive=Активен
class.filter.editor.table.model.column.name.pattern=Шаблон
class.has.no.default.constructor=''{0}'' не имеет конструктора по умолчанию
class.is.not.a.subclass=''{0}'' не может быть присвоен ''{1}''
class.is.not.concrete=''{0}'' не является конкретным классом
class.is.not.public=''{0}'' не является публичным
class.not.found.error.message=Класс ''{0}'' не найден
class.patterns.error.class.pattern.0.must.be.a.valid.java.qualifier=Шаблон должен быть допустимым полным именем Java, только '*' допускаются как подстановочные знаки
class.patterns.error.method.pattern.0.must.be.a.valid.java.identifier=Шаблон метода ''{0}'' должен быть допустимым идентификатором Java, только ''*'' допускаются как подстановочные знаки
class.patterns.panel.add.class=Добавить класс
class.patterns.separator.mark.code.as.entry.point.if.qualified.name.matches=Пометить код как точку входа, если полное имя соответствует
code.style.generation.override.method.signature=Сигнатура переопределяемого метода
code.style.generation.repeat.synchronized.modifier=Повторять модификатор synchronized [&S]
code.style.generation.replace.null.check=Заменить проверку на null с помощью Objects\:\:nonNull или Objects\:\:isNull
code.style.generation.settings.error.not.valid.identifier.part.in.prefix=Недопустимая часть идентификатора Java в префиксе ''{0}''
code.style.generation.settings.error.not.valid.identifier.part.in.suffix=Недопустимая часть идентификатора Java в суффиксе ''{0}''
code.style.generation.use.class.isInstance=Использовать Class\:\:isInstance и Class\:\:cast где возможно
code.style.generation.use.integer.sum=Использовать Integer\:\:sum и т.п. где возможно
code.style.settings.angle.spacing.brackets=Угловые скобки
code.style.settings.spacing.after.closing.angle.bracket=После закрывающей угловой скобки
code.style.settings.spacing.around.type.bounds=Вокруг границ типа
code.vision.implementations.hint={0, choice, 1\#1 реализация|2\#{0,number} реализации|5\#{0,number} реализаций}
code.vision.inheritors.hint={0, choice, 1\#1 наследник|2\#{0,number} наследника|5\#{0,number} наследников}
code.vision.overrides.hint={0, choice, 1\#1 переопределение|2\#{0,number} переопределения|5\#{0,number} переопределений}
column.name.class.entry.point=Класс
column.name.method.entry.point=Метод
column.name.with.subclasses.entry.point=С подклассами
combobox.paste.insert.imports=Вставлять импорты при вставке [&I]\:
command.create.class.from.template=Создать класс из шаблона
command.create.new.subdirectory=Создать новую поддиректорию
command.name.delegate.detected.change=Делегировать
command.name.generate.tostring=Сгенерировать toString()
command.name.insert.block.statement=Вставить блок кода
command.name.replace.type=Заменить тип
command.name.updating.package.statement=Обновление оператора package
comment.the.class.will.be.created.in.the.package.0=Класс будет создан в пакете ''{0}''
compiler.options=Параметры компилятора
completion.class.name.hint.2=Нажмите {0} еще раз, чтобы игнорировать зависимости модулей при поиске
completion.generate.via.wizard=(сгенерировать через мастер)
completion.inner.scope=внутренний
completion.inner.scope.tail.text=\ (из блока {0})
completion.no.suggestions.of.type=Нет предложений типа {0}
completion.override.implement.methods=Переопределить/реализовать методы…
completion.provider.method.declaration.type=объявление метода provider()
completion.smart.aslist.hint=Нажмите {0} еще раз для поиска массивов {1}
completion.smart.chain.hint=Нажмите {0} еще раз для поиска по цепочке вызовов методов
completion.smart.hint=Нажмите {0}, чтобы показать только подходящие по типу варианты
completion.smart.toar.hint=Нажмите {0} еще раз для поиска коллекций {1}
completion.smart.type.generate.anonymous.body=сгенерировать анонимное тело
completion.unknown.type=Неизвестный тип {0}
configurable.EqualsHashCodeTemplatesPanel.display.name=Шаблоны
configurable.GenerateToStringConfigurable.display.name=Настройки
configurable.TemplatesPanel.display.name=Шаблоны
configure.annotations.option=Настроить аннотации…
conflict.message.method.will.override.method.base.class=Переименованный {0} переопределит метод базового {1}
convert.compareto.expression.to.equals.call=Преобразовать выражение 'compareTo()' в вызов 'equals()'
convert.compareto.expression.to.equals.call.may.change.semantics=Преобразовать выражение 'compareTo()' в вызов 'equals()' (может изменить семантику)
convert.number.binary=двоичный
convert.number.decimal=десятичный
convert.number.hex=шестнадцатеричный
convert.number.octal=восьмеричный
convert.number.plain.format=обычный формат
convert.number.scientific.format=научный формат
copy.abstract.method.intention.name=Использовать существующую реализацию ''{0}''
copy.abstract.method.no.existing.implementations.found=Существующие реализации не найдены
copy.abstract.method.popup.title=Выберите реализацию для копирования
copy.abstract.method.title=Использовать реализацию абстрактного метода
copy.paste.reference.notification=<html>Добавлено {0} {0, choice, 1\#импорт|2\#импорта|5\#импортов}<p><span><a href\=''show''>Просмотреть добавленные импорты...</a></span></html>
create.class.mapping.dialog.title=Выберите класс {0}
cyclic.dependencies.progress.text=Построение графа зависимостей
cyclic.dependencies.scope.dialog.module.button={0} модуль ''{1}''  [&M]
cyclic.dependencies.scope.dialog.project.button={0} весь проект [&P]
cyclic.dependencies.scope.dialog.title=Укажите область {0}
cyclic.dependencies.scope.include.test.sources.option=Включить тестовые исходники [&T]
cyclic.dependencies.tree.cycle.node.text=цикл
cyclic.dependencies.usage.view.initial.text=Выберите пакет для анализа из дерева слева
cyclic.dependencies.usage.view.root.node.text=Использования пакета ''{0}'' в пакете ''{1}''
dataflow.from.here=Поток данных отсюда
dataflow.to.here=Поток данных сюда
deannotate.intention.action.family.name=Удалить аннотацию
deannotate.intention.action.several.text=Удалить аннотацию…
deannotate.intention.action.text=Удалить аннотацию {0}
deannotate.intention.chooser.title=Выберите аннотацию для удаления
default.package.presentable.name=<по умолчанию>
default.param.value.warning={0} уже существует
delete.assignment.completely=Полностью удалить присваивание
delete.initializer.completely=Полностью удалить инициализатор
dependant.sdk.unsatisfied.dependency.message=Сначала необходимо настроить Java SDK
dependencies.libraries.node.text=Библиотеки
dependencies.tree.node.default.package.abbreviation=<пакет по умолчанию>
destination.combo.source.root.not.expected.conflict=Выбран исходный корень, когда ожидается тестовый корень
destination.combo.test.root.not.expected.conflict=Выбран тестовый корень, когда ожидается исходный корень
dfa.constraint.0.not.null={0} (не-null)
dfa.constraint.not.null=не-null
dfa.constraint.null.or.0=null или {0}
dialog.create.class.destination.package.label=Целевой пакет\:
dialog.create.class.label=Создать {0}\:
dialog.create.class.name=Создать {0} {1}
dialog.create.class.package.chooser.title=Выберите целевой пакет
dialog.edit.template.checkbox.smart.type.completion=Автодополнение с учетом типов [&O]
dialog.edit.template.checkbox.use.static.import=По возможности использовать статический импорт [&I]
dialog.import.on.paste.title=Выберите классы для импорта
dialog.import.on.paste.title2=Выберите элементы для импорта
dialog.import.on.paste.title3=Выберите импорт для удаления
dialog.message.0.update.existing.class={0}. Обновить существующий класс?
dialog.message.class.not.found=Класс шаблона ''{0}'' не найден
dialog.message.create.test.in.the.same.source.root=Создать тест в том же корневом каталоге исходного кода?
dialog.message.infer.nullity.annotations.requires.the.project.language.level=Для вывода аннотаций nullity требуется установить уровень языка проекта 1.5 или выше.
dialog.message.jetbrains.annotations.library.is.missing=Отсутствует библиотека аннотаций JetBrains.\nБез этой библиотеки IntelliJ ИСРA не может выполнить анализ. Добавить её?
dialog.message.modules.dont.refer.to.existing.annotations.library={0, choice, 0\#Модуль|2\#Модули} {1} {0, choice, 0\#не ссылается|2\#не ссылаются} на существующую библиотеку ''{2}'' с аннотациями nullity IntelliJ ИСРA. Добавить {0, choice, 0\#зависимость|2\#зависимости} сейчас?
dialog.message.no.places.found.to.infer.nullable.notnull=Не найдено мест для вывода @Nullable/@NotNull
dialog.message.parameter.has.write.usages.inline.not.supported=Параметр имеет операции записи. Встраивание не поддерживается
dialog.message.template.not.applicable=Шаблон неприменим
dialog.message.template.not.found=Шаблон не найден
dialog.paste.on.import.text=<html>Вставленный фрагмент кода использует классы, недоступные через импорт в новом контексте.<br/>Выберите классы, которые нужно импортовать в новый файл.</html>
dialog.paste.on.import.text2=<html>Вставленный фрагмент кода использует элементы, недоступные через импорт в новом контексте.<br/>Выберите элементы, которые нужно импортовать в новый файл.</html>
dialog.paste.on.import.text3=<html>Вставленный фрагмент кода добавил новые импорты в текущий контекст.<br/>Выберите импорты, которые нужно удалить.</html>
dialog.title.check.configuration=Проверить конфигурацию…
dialog.title.check.functional.interface.candidates=Проверить кандидаты функционального интерфейса…
dialog.title.choose.0.parameters=Выбрать параметры {0}
dialog.title.choose.annotation=Выберите аннотацию {0}
dialog.title.choose.class=Выбрать класс
dialog.title.choose.logger=Выбрать логгер
dialog.title.configure.annotations=Настроить аннотации
dialog.title.configure.code.patterns=Настроить шаблоны кода
dialog.title.copy.template=Копировать шаблон
dialog.title.create.class.in.package=Создать класс в пакете
dialog.title.create.missing.tests=Создать отсутствующие тесты
dialog.title.create.new.template=Создать новый шаблон
dialog.title.edit.method.contract=Редактировать контракт метода
dialog.title.edit.range=Редактировать диапазон ''{0}''
dialog.title.infer.nullity=Вывод nullity
dialog.title.infer.nullity.results=Результаты вывода nullity
dialog.title.move.directory=Переместить каталог
dialog.title.no.test.roots.found=Не найдены корневые каталоги тестов
dialog.title.process.duplicates=Обработать дубликаты
dialog.title.super.method.found=Найден super метод
dialog.title.testdatapath.file.generate=Сгенерировать файлы из класса в @TestDataPath
dialog.title.testdatapath.method.generate=Сгенерировать методы из @TestDataPath
disable.report.inaccessible.symbols.fix=Не сообщать о недоступных символах
do.not.import.inner.classes.for=Исключить внутренние классы по короткому имени\:
do.not.import.inner.classes.no.classes=Внутренние классы не определены
edit.contract.dialog.checkbox.impure.method=Метод может иметь побочные эффекты [&S]
edit.contract.dialog.hint=<html>Пожалуйста, укажите текст контракта<p>Пример\: <code>_, null -> false</code><br><small>Подробности см. в описании действия намерения</small></html>
edit.contract.dialog.mutates.hint=Укажите через запятую элементы, которые могут быть изменены<p>Пример\: <code>this,param1</code><p>Оставьте пустым для неопределённых побочных эффектов.
edit.range.dialog.message=Оставьте пустым, если нет ограничений
edit.range.error.invalid.value=Недопустимое значение
edit.range.should.not.be.greater.than.to=Не должно быть больше 'to'
edit.range.should.not.be.less.than.from=Не должно быть меньше 'from'
edit.range.value.should.be.bigger.than=Не должно быть больше {0}
edit.range.value.should.be.less.than=Не должно быть меньше {0}
editbox.blank.lines.field.in.interface=Перед полем в интерфейсе
editbox.blank.lines.field.with.annotations=Перед полем с аннотациями\:
editbox.blank.lines.field.without.annotations=Перед полем без аннотаций\:
editbox.blanklines.around.initializer=Вокруг инициализатора\:
editbox.class.count.to.use.import.with.star=Количество классов для использования импорта со '*'\:
editbox.names.count.to.use.static.import.with.star=Количество имен для использования статического импорта со '*'\:
empty.title=Пусто
encapsulate.fields.dialog.javadoc.title=Javadoc
enum.constant.ordinal=Порядковый номер константы enum\: 
enum.not.allowed=Enum не разрешен
enums.cannot.be.inlined=Перечисления нельзя встраивать
environment.key.description.project.jdk=Абсолютный путь к JDK проекта
environment.key.description.project.jdk.name=Видимое в ИСР имя JDK проекта.
error.attempt.to.generate.constructor.for.anonymous.class=Невозможно добавить конструктор в анонимный класс
error.attempt.to.generate.constructor.for.implicit.class=Невозможно добавить конструктор в неявно объявленный класс
error.hint.no.expression.found=Выражение не найдено
error.message.ide.does.not.support.starting.processes.using.old.java=ИСР не поддерживает запуск Java-процессов с использованием Java {0}, минимальная поддерживаемая версия - 1.7. Измените конфигурацию запуска для использования более новой версии Java.
error.package.already.contains.package-info=''package-info.java'' уже существует для пакета ''{0}''
error.package.already.contains.package.html=Пакет ''{0}'' уже содержит файл ''package.html''. Создать ''package-info.java'' все равно?
error.package.html.found.title=Найден 'package.html'
error.text.this.is.not.a.valid.java.class.name=Это недопустимое имя класса Java
exclude.0.from.auto.import=Исключить ''{0}'' из автоимпорта
exclude.0.from.completion=Исключить ''{0}'' из автодополнения
exclude.accessors=Исключить аксессоры [&E]
exclude.from.completion.group=Исключить из автоимпорта и автодополнения\:
exclude.from.imports.no.exclusions=Добавить класс, пакет или член
exclude.from.imports.no.exclusions.2=для исключения из автоимпорта и автодополнения
exclude.import.wildcard.comment=Используйте символ * для исключения всех членов указанного класса или пакета
exclude.table.mask=Класс, пакет или член
exclude.table.scope.column=Область действия
export.to.html.generate.hyperlinks.checkbox=Генерировать гиперссылки на классы [&H]
external.annotation.prompt=Запрос внешней аннотации
external.annotations.external.option=Добавить внешне [&E]
external.annotations.in.code.option=Добавить в код [&C]
external.annotations.open.file=Открыть файл аннотаций
external.annotations.problem.parse.error=Файл\: {0}<br>Проблема\: {1}
external.annotations.problem.title=Не удаётся прочитать внешние аннотации
external.annotations.root.chooser.description=Внешние аннотации будут сохранены в соответствующей папке
external.annotations.root.chooser.title=Выберите корневой каталог внешних аннотаций для {0}
external.annotations.roots=Корневые каталоги аннотаций
external.annotations.suggestion.message=<html><body>Если вы не хотите хранить аннотации в коде, можно использовать внешнее хранилище.<br>Для настройки внешних аннотаций укажите корневой каталог, где будут размещены файлы с аннотациями</body></html>
extract.interface.command.name=Извлечь интерфейс
extract.superclass.command.name=Извлечь суперкласс
extracted.class.should.have.unique.name=Извлеченный класс должен иметь уникальное имя. Имя ''{0}'' уже используется одним из внутренних классов
filetype.spi.description=Service Provider Interface
find.field.accessors.prompt=Искать аксессоры поля ''{0}''?
find.field.accessors.title=Найдены аксессоры поля
find.jar.hint.text.no.libraries.found.for.fqn=Не найдены библиотеки для ''{0}''
find.options.include.accessors.base.checkbox=Искать базовые методы аксессоров [&E]
find.options.include.accessors.base.checkbox.comment=По умолчанию использовать методы верхнего уровня иерархии как цели поиска использований
find.options.include.accessors.checkbox=Искать аксессоры [&A]
find.options.include.overloaded.methods.checkbox=Перегруженные методы [&V]
find.options.search.overriding.methods.checkbox=Искать в переопределяющих методах [&O]
find.what.derived.classes.checkbox=Производные классы [&D]
find.what.derived.interfaces.checkbox=Производные интерфейсы [&D]
find.what.fields.usages.checkbox=Использования полей [&F]
find.what.implementing.classes.checkbox=Реализующие классы [&I]
find.what.implementing.methods.checkbox=Реализующие методы [&I]
find.what.implicit.to.string.checkbox=Неявные вызовы [&M]
find.what.methods.usages.checkbox=Использования методов [&M]
find.what.overriding.methods.checkbox=Переопределяющие методы [&R]
find.what.search.for.base.methods.checkbox=Искать использования базового метода [&E]
find.what.search.for.base.methods.checkbox.comment=По умолчанию использовать методы верхнего уровня иерархии как цели поиска использований
find.what.usages.checkbox=Использования [&U]
find.what.usages.of.classes.and.interfaces=Использования классов и интерфейсов [&C]
fix.move.to.source.root=Переместить в корень исходников
generate.button.title=Сгенерировать
generate.constructor.already.exists=Конструктор уже существует
generate.constructor.fields.chooser.title=Выберите поля для инициализации конструктором
generate.constructor.super.constructor.chooser.title=Выберите конструктор суперкласса
generate.delegate.target.chooser.title=Выберите цель для генерации делегатов
generate.equals.and.hashcode.already.defined.title=Сгенерировать equals() и hashCode()
generate.equals.and.hashcode.already.defined.warning=Методы ''boolean equals(Object)'' и ''int hashCode()'' уже определены\nдля класса {0}. Хотите удалить их и продолжить?
generate.equals.and.hashcode.already.defined.warning.anonymous=Методы 'boolean equals(Object)' и 'int hashCode()' уже определены\nдля этого анонимного класса. Хотите удалить их и продолжить?
generate.equals.hashcode.accept.sublcasses=Принимать подклассы как параметр метода equals() [&S]
generate.equals.hashcode.accept.sublcasses.explanation=<html><body>Хотя обычно это не соответствует контракту Object.equals(),<br>принятие подклассов может быть необходимо для корректной работы<br>сгенерированного метода с фреймворками, которые генерируют прокси-подклассы, такими как Hibernate.</body></html>
generate.equals.hashcode.comparison.table=<html><table><tr><th><th>instanceof<th>getClass()<tr><td>Позволяет экземплярам подклассов быть равными экземплярам суперкласса<td align\=center>да<td align\=center>нет<tr><td>Позволяет экземплярам разных подклассов быть равными друг другу<td align\=center>да<td align\=center>нет<tr><td>Переопределение сгенерированного метода equals() не нарушает его контракт<td align\=center>нет<td align\=center>да<tr><td>Избегает дополнительной проверки на null<td align\=center>да<td align\=center>нет<tr><td>Соблюдает\\&nbsp;принцип\\&nbsp;подстановки\\&nbsp;Лисков<td align\=center>да<td align\=center>нет</table></html>
generate.equals.hashcode.equals.fields.chooser.title=Выберите поля для включения в equals() [&F]
generate.equals.hashcode.getclass.type.comparison=Выражение сравнения get&Class()
generate.equals.hashcode.hashcode.fields.chooser.title=Выберите поля для включения в hashCode() [&F]
generate.equals.hashcode.instanceof.type.comparison=Выражение instanceof [&I]
generate.equals.hashcode.internal.error=Внутренняя ошибка
generate.equals.hashcode.non.null.fields.chooser.title=Выбрать все поля, не допускающие null [&F]
generate.equals.hashcode.template=Шаблон [&T]\:
generate.equals.hashcode.type.comparison.label=Для сравнения типов классов в методе equals() сгенерировать\:
generate.equals.hashcode.use.getters=Использовать геттеры, где возможно [&G]
generate.equals.hashcode.warning.hashcode.for.arrays.is.not.supported=hashCode() не поддерживается для массивов
generate.equals.hashcode.wizard.title=Сгенерировать equals() и hashCode()
generate.equals.no.fields.for.generation=Не найдены поля для включения в equals/hashCode
generate.equals.template.title=Шаблон equals\:
generate.equals.warning.equals.for.nested.arrays.not.supported=equals() не поддерживается для вложенных массивов
generate.equals.warning.generated.equals.could.be.incorrect=Сгенерированный equals() для Object[] может быть некорректным
generate.equals.wizard.title=Сгенерировать equals()
generate.file.extension.text=Введите расширение файла\: .php, .java, .kt, .cpp ....
generate.file.extension.validation.error=Расширение файла ''{0}'' недопустимо. Оно должно начинаться с ''.'', не может содержать пробелы или быть пустым
generate.getter.and.setter.error.no.fields=Не найдены поля для генерации геттеров/сеттеров
generate.getter.and.setter.error.no.fields.without.getters.and.setters=Не найдены поля без геттеров/сеттеров
generate.getter.and.setter.error.setters.for.read.only.not.generated=Сеттеры для полей только для чтения не были сгенерированы
generate.getter.error.no.fields=Не найдены поля для генерации геттеров
generate.getter.error.no.fields.without.getters=Не найдены поля без геттеров
generate.getter.fields.chooser.title=Выберите поля для генерации геттеров
generate.getter.setter.generate.all.annotations=Копировать все аннотации [&A]
generate.getter.setter.generate.all.annotations.tooltip=Копировать все применимые аннотации из полей. В противном случае будут скопированы только аннотации допустимости null
generate.getter.setter.header.visibility.hint.=Видимость применяется согласно Файл | Настройки | Редактор | Стиль кода | Java | Генерация кода
generate.getter.setter.title=Выберите поля для генерации геттеров и сеттеров
generate.getter.template=Шаблон геттера [&G]\:
generate.hashcode.template.title=Шаблон HashCode\:
generate.hashcode.wizard.title=Сгенерировать hashCode()
generate.logger.no.place.found.dialog.message=Не удалось найти места для вставки логгера
generate.logger.no.place.found.dialog.title=Места не найдены
generate.logger.specify.place.popup.title=Выберите место
generate.members.implement.command=реализовать
generate.members.nothing.to.insert=Не найдено содержимое для вставки
generate.method.nofiles.warn=Тестовые методы не найдены в классе {0}
generate.method.nosuites.warn=Тестовые наборы не найдены в @TestDataPath("{0}")
generate.missed.tests.action.error.no.tests.found=Тесты не найдены.
generate.missed.tests.action.failed.to.detect.framework=Не удалось определить тестовый фреймворк для {0}
generate.quickfix.files=Создать сценарии QF (с суффиксом '.after')
generate.record.constructor.title=Сгенерировать конструктор записи
generate.select.default.modifier.text=Выберите модификатор
generate.setter.fields.chooser.title=Выберите поля для генерации сеттеров
generate.setter.template=Шаблон сеттера [&S]\:
generate.setters.no.fields=Не найдены поля для генерации сеттеров
generate.setters.no.fields.without.setters=Не найдены поля без сеттеров
generate.test.support.method.error.cannot.generate.method=Невозможно сгенерировать метод\: {0}
generate.test.support.method.error.method.already.exists=Метод {0} уже существует
generate.test.support.method.error.no.template.found.for.framework=Шаблон не найден для {0}\: {1}
generate.tostring.already.exist.border=Когда метод уже существует
generate.tostring.available.implicit.variables.label=Доступные неявные переменные\:<br/>{0}
generate.tostring.exclude..transient=Исключить transient поля
generate.tostring.exclude.by.field.name=Исключить поля по имени (регулярное выражение)
generate.tostring.exclude.by.field.type=Исключить поля по имени типа (регулярное выражение)
generate.tostring.exclude.by.name=Исключить методы по имени (регулярное выражение)
generate.tostring.exclude.by.return.type=Исключить методы по имени возвращаемого типа (регулярное выражение)
generate.tostring.exclude.constant.fields=Исключить константные поля
generate.tostring.exclude.enum.fields=Исключить поля перечислений
generate.tostring.exclude.logger=Исключить поля логгеров (Log4j, JDK Logging, Jakarta Commons Logging)
generate.tostring.exclude.static.fields=Исключить статические поля
generate.tostring.fully.qualified.class.name=Использовать полное имя класса в сгенерированном toString() ($classname)
generate.tostring.getters.in.generated.code=Использовать геттеры в сгенерированном toString(), где возможно ($methods)
generate.tostring.handle.exception.error.message=При выполнении действия произошло неустранимое исключение - см. лог ИСРA для подробностей (стек вызовов должен быть в idea.log)\:\n{0}
generate.tostring.handle.exception.plugin.warning.message=При выполнении действия произошло исключение PluginException - см. лог ИСРA для подробностей (стек вызовов должен быть в idea.log)\:\n{0}
generate.tostring.handle.exception.velocity.error.message=Ошибка Velocity при генерации кода - см. лог ИСРA для подробностей (стек вызовов должен быть в idea.log)\:\n{0}
generate.tostring.insert.border=Куда вставить?
generate.tostring.method.already.exists.dialog.me=ssage\=Заменить существующий метод {0}
generate.tostring.method.already.exists.dialog.title=Метод уже существует
generate.tostring.move.to.generated.checkbox=Переместить курсор к сгенерированному методу
generate.tostring.settings=Настройки
generate.tostring.sort.ascending=По возрастанию
generate.tostring.sort.checkbox=Сортировать элементы
generate.tostring.sort.descending=По убыванию
generate.tostring.sort.super=Сначала члены суперкласса
generate.tostring.tab.title=Настройки генерации toString()
generate.tostring.template.label=Шаблон [&T]\:
generate.tostring.title=Сгенерировать toString()
generate.type.use.before.type=Помещать сгенерированные аннотации с целью TYPE_USE между модификаторами и типом
generate.type.use.before.type.description=<html>Аннотации с целью TYPE_USE будут размещены после всех модификаторов и непосредственно<br>перед типом. При отключении они будут размещены перед всеми модификаторами.</html>
goto.super.class.chooser.title=Выберите суперкласс или интерфейс
group.javadoc.alignment=Выравнивание
group.javadoc.blank.lines=Пустые строки
group.javadoc.invalid.tags=Недопустимые теги
group.javadoc.other=Прочее
gutter.implemented.method=Реализованный метод
gutter.implementing.method=Реализующий метод
gutter.overridden.method=Переопределённый метод
gutter.overriding.method=Переопределяющий метод
gutter.service=Сервис
gutter.sibling.inherited.method=Унаследованный метод того же уровня
header.method.to.be.converted=Метод для преобразования
hide.out.of.cyclic.packages.action.description=Скрыть пакеты без циклических зависимостей
hide.out.of.cyclic.packages.action.text=Скрыть пакеты без циклических зависимостей
highlight.exceptions.thrown.chooser.title=Выберите классы исключений для подсветки
highlight.imported.classes.chooser.title=Выберите импортованные классы для подсветки
highlight.imported.members.chooser.title=Выберите импортованные члены для подсветки
highlight.overridden.classes.chooser.title=Выберите классы для подсветки переопределённых методов
highlight.suppressed.warnings.choose.inspections=Выберите проверки для подсветки подавленных проблем
highlight.throws.class.name=Подсветить Throws {0}
highlight.throws.popup.throwing.places=Места выброса {0}
highlight.throws.popup.usages=Использования {0}
hint.text.added.imports=, добавлено {0} {1, choice, 0\#импорт|1\#импортов}
hint.text.not.valid.java.identifier=Недопустимый идентификатор Java
hint.text.occurrences.were.inlined={0} вхождений были встроены
hint.text.press.to.go.through.inlined.occurrences=Нажмите {0} для перехода по {1} встроенным вхождениям
hint.text.rearranged.imports=Импорты переупорядочены
hint.text.removed.imports=Удалено {0} {1, choice, 0\#импорт|1\#импортов}
hint.text.tostring.method.could.not.be.created.from.template=Метод ''toString()'' не может быть создан из шаблона ''{0}''
hint.text.tostring.template.invalid=Шаблон toString() ''{0}'' недействителен
icon.preview=Предпросмотр иконки
ignore.imports.and.formatting=Игнорировать импорты и форматование
illegal.name.validation.info=Недопустимое имя\: {0}
implement.abstract.method.potential.implementations.with.weaker.access=Найдены потенциальные реализации с более слабыми правами доступа\: {0}
implement.method.no.methods.to.implement=Не найдено методов для реализации
import.layout.panel.all.other.imports=все остальные импорты
import.layout.panel.blank.line.entry=<пустая строка>
import.layout.panel.down.button=Вниз
import.layout.panel.up.button=Вверх
import.layout.static.imports.separately=Размещать статические импорты отдельно
import.statically=Импортовать статически
include.accessors=Включить аксессоры [&I]
increase.language.level.preview.description=Уровень языка для модуля ''{0}'' будет изменен на ''{1}''
infer.nullity.progress=Постобработка результатов…
inlay.MethodChainsInlayProvider.description=Типы возвращаемых значений методов в цепочках вызовов.
inlay.annotation.hints.external.annotations=Аннотации, хранящиеся вне исходного кода.<br>Эти аннотации полезны, когда нужна аннотация, но добавить её в исходный код невозможно (например, при работе с кодом библиотеки).<br><br><a href\='https\://www.jetbrains.com/help/idea/external-annotations.html'>Документация</a>
inlay.annotation.hints.inferred.annotations=Аннотации, которые IntelliJ ИСРA генерирует путем сканирования библиотек и кода проекта. Эти аннотации помогают понять контракты кода и улучшают возможности статического анализа. Они включают\: <br> @Contract <br> @Nullable <br> @NotNull <br> @Unmodifiable <br>@UnmodifiableView <br><br><a href\='https\://www.jetbrains.com/help/idea/inferring-nullity.html\#inferred-annotations'>Документация</a>
inlay.parameters.java.build.like.method=Методы, возвращающие экземпляр класса, с которым они работают, например вызовы в цепочках StringBuilder или промежуточные операции в Java 8 Stream API.
inlay.parameters.java.clear.expression.type=Вызовы методов, использующие сложное выражение в качестве аргумента, например тернарный оператор или оператор switch в Java 13.
inlay.parameters.java.enums=Объявления констант перечисления, использующие параметризованный конструктор.
inlay.parameters.java.method.name.contains.parameter.name=Методы, принимающие один аргумент, когда ожидаемый аргумент понятен из имени метода, например в методах доступа.
inlay.parameters.java.multiple.params.same.type=Вызовы методов с несколькими нелитеральными аргументами одного типа.
inlay.parameters.java.new.expr=Вызовы параметризованных конструкторов.
inlay.parameters.java.simple.sequentially.numbered=Методы, принимающие несколько параметров, имена которых состоят из одной буквы и числа.
insert.override.annotation=Вставить аннотацию @Override [&O]
inspection.anonymous.2.method.ref.display.name=Анонимный тип может быть заменен ссылкой на метод
inspection.assert.quickfix=Проверить ''{0}''
inspection.auto.add.module.requirements.quickfix=Заполнить зависимости модулей
inspection.bulk.file.attributes.read.description=Можно использовать массовый вызов 'Files.readAttributes()'
inspection.bulk.file.attributes.read.message=Множественные вызовы атрибутов файла можно заменить одним вызовом 'Files.readAttributes()'
inspection.call.message=Избыточный вызов ''{0}()''
inspection.capturing.cleaner=Runnable, переданный в Cleaner.register(), захватывает ссылку ''{0}''
inspection.capturing.cleaner.description=Cleaner захватывает ссылку на объект
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=Изменить тип переменной и удалить приведение типа
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=Изменить тип ''{0}'' на ''{1}'' и удалить приведение типа
inspection.cast.can.be.removed.narrowing.variable.type.message=Приведение типа может быть удалено путем изменения типа ''{0}'' на ''{1}''
inspection.cast.can.be.removed.narrowing.variable.type.name=Слишком слабый тип переменной приводит к ненужному приведению типа
inspection.charset.object.can.be.used.display.name=Можно использовать стандартный объект 'Charset'
inspection.charset.object.can.be.used.fix.family.name=Использовать константу Charset
inspection.charset.object.can.be.used.message=Можно использовать {0}
inspection.collection.add.all.can.be.replaced.with.constructor.display.name=Избыточный вызов 'Collection.addAll()'
inspection.collection.factories.fix.family.name=Заменить на вызов фабрики коллекций
inspection.collection.factories.fix.name=Заменить на вызов ''{0}.{1}()''
inspection.collection.factories.message=Можно заменить на вызов ''{0}.{1}()''
inspection.collection.factories.option.ignore.non.constant=Сообщать только когда содержимое константно
inspection.collection.factories.option.suggest.ofentries=Предлагать 'Map.ofEntries()'
inspection.collection.used.as.vararg.display.name=Iterable используется как vararg
inspection.collection.used.as.vararg.message=Iterable передается как vararg\: вероятно, предполагался массив
inspection.comparator.combinators.display.name=Можно использовать комбинатор 'Comparator'
inspection.comparator.result.comparison.display.name=Подозрительное использование метода compare
inspection.comparator.result.comparison.fix.family.name=Исправить сравнение результата компаратора
inspection.comparator.result.comparison.problem.display.name=Сравнение результата метода compare с конкретной константой
inspection.condition.covered.by.further.condition.display.name=Условие покрывается последующим условием
inspection.conditional.break.in.infinite.loop=Переместить условие в цикл
inspection.conditional.break.in.infinite.loop.allow.condition.fusion=Разрешить слияние с существующим условием цикла
inspection.conditional.break.in.infinite.loop.description=Условный break внутри цикла
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=Не предлагать замену на 'do while'
inspection.conditional.break.in.infinite.loop.suggest.conversion.when.if.is.single.stmt.in.loop=Предлагать преобразование, когда 'if' является единственным оператором в цикле
inspection.conditional.can.be.optional.display.name=Условие может быть заменено на Optional
inspection.convert.2.method.ref.display.name=Лямбда может быть заменена ссылкой на метод
inspection.convert.2.streamapi.display.name=Цикл может быть свернут с помощью Stream API
inspection.convert.to.local.quickfix=Преобразовать в локальную переменную
inspection.data.flow.constant.values.display.name=Константные значения
inspection.data.flow.display.name=Проблемы с null и потоком данных
inspection.data.flow.filter.notnull.quickfix=Вставить шаг 'filter(Objects\:\:nonNull)'
inspection.data.flow.ignore.assert.statements=Игнорировать assert-утверждения
inspection.data.flow.nullable.quickfix.option=Предлагать аннотацию @Nullable для методов/полей/параметров, где используются nullable значения
inspection.data.flow.optional.of.nullable.misuse.display.name=Использование Optional.ofNullable с null или не-null аргументом
inspection.data.flow.report.not.null.required.parameter.with.null.literal.argument.usages=Сообщать о not-null параметрах с null-литералами в качестве аргументов
inspection.data.flow.report.nullable.methods.that.always.return.a.non.null.value=Сообщать о nullable методах, которые всегда возвращают не-null значение
inspection.data.flow.report.problems.that.happen.only.on.some.code.paths=Сообщать о проблемах, возникающих только на некоторых путях выполнения
inspection.data.flow.treat.non.annotated.members.and.parameters.as.nullable=Рассматривать неаннотированные члены и параметры как @Nullable
inspection.data.flow.true.asserts.option=Не сообщать об утверждениях с условием, статически доказанным как всегда истинное
inspection.data.flow.unreachable.code.display.name=Недостижимый код
inspection.data.flow.unreachable.code.option.ignore.trivial.description=Не сообщать о недостижимых операторах вроде <code>return 0</code>, <code>break</code> и т.д., так как они могут быть необходимы для соблюдения правил управления потоком в Java.
inspection.data.flow.unreachable.code.option.ignore.trivial.name=Игнорировать тривиальные операторы выхода
inspection.data.flow.unreachable.code.option.respect.suppression.description=Пытаться не сообщать о недостижимом коде, если это вызвано константным условием, где соответствующее предупреждение подавлено.
inspection.data.flow.unreachable.code.option.respect.suppression.name=Учитывать подавление инспекции 'Constant value'
inspection.data.flow.use.computeifpresent.quickfix=Заменить 'compute' на 'computeIfPresent'
inspection.dead.code.option.applet=Апплеты
inspection.dead.code.option.external=Классы с использованием в не-Java файлах
inspection.dead.code.option.main=<html>Методы <code>void main(String args[])</code></html>
inspection.dead.code.option.servlet=Сервлеты
inspection.default.annotation.param=Значение параметра аннотации по умолчанию
inspection.duplicate.branches.in.switch.default.message=Ветка в 'switch' дублирует ветку по умолчанию
inspection.duplicate.branches.in.switch.delete.fix.family.name=Удалить избыточные ветки 'switch'
inspection.duplicate.branches.in.switch.delete.fix.name=Удалить избыточную ветку 'switch'
inspection.duplicate.branches.in.switch.display.name=Дублирующиеся ветки в 'switch'
inspection.duplicate.branches.in.switch.merge.fix.family.name=Объединить дублирующиеся ветки в 'switch'
inspection.duplicate.branches.in.switch.merge.fix.name=Объединить с ''{0}''
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=Объединить с веткой по умолчанию 'switch'
inspection.duplicate.branches.in.switch.message=Дублирующаяся ветка в 'switch'
inspection.duplicate.expressions.complexity.threshold=Порог сложности выражения
inspection.duplicate.expressions.display.name=Множественные вхождения одного и того же выражения
inspection.duplicate.expressions.introduce.variable.fix.family.name=Ввести переменную
inspection.duplicate.expressions.introduce.variable.fix.name=Ввести переменную для ''{0}''
inspection.duplicate.expressions.message=Множественные вхождения <code>\#ref</code> \#loc
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=Заменить другие вхождения выражения переменной
inspection.duplicate.expressions.replace.other.occurrences.fix.name=Заменить ''{0}'' другими вхождениями ''{1}''
inspection.duplicate.expressions.reuse.variable.fix.family.name=Повторно использовать переменную
inspection.duplicate.expressions.reuse.variable.fix.name=Повторно использовать переменную ''{0}'' для ''{1}''
inspection.empty.module.info.file=Пустой файл 'module-info.java'
inspection.endless.stream.description=Не короткозамкнутая операция потребляет бесконечный поток
inspection.equals.hashcode.display.name='equals()' и 'hashCode()' не согласованы
inspection.equals.hashcode.generate.equals.quickfix=Сгенерировать 'equals()'
inspection.equals.hashcode.generate.equals.quickfix.preview=Открывает диалог для настройки генерации 'equals()'.
inspection.equals.hashcode.generate.hashcode.quickfix=Сгенерировать 'hashCode()'
inspection.equals.hashcode.generate.hashcode.quickfix.preview=Открывает диалог для настройки генерации 'hashCode()'.
inspection.excessive.lambda.fix.family.name=Заменить лямбду константой
inspection.excessive.lambda.fix.name=Использовать метод ''{0}'' без лямбды
inspection.excessive.lambda.message=Избыточное использование лямбды
inspection.excessive.lambda.usage.display.name=Избыточное использование лямбды
inspection.excessive.range.check.display.name=Избыточная проверка диапазона
inspection.explicit.argument.can.be.lambda.display.name=Явный аргумент может быть лямбдой
inspection.explicit.argument.can.be.lambda.fix.family.name=Заменить явный аргумент функцией
inspection.explicit.argument.can.be.lambda.fix.name=Использовать метод ''{0}'' с функциональным аргументом
inspection.explicit.argument.can.be.lambda.message=Явный аргумент может быть преобразован в лямбду
inspection.explicit.array.filling.description=Может быть заменено одним вызовом метода ''Arrays.{0}()''
inspection.explicit.array.filling.display.name=Явное заполнение массива
inspection.explicit.array.filling.fix.family.name=Заменить цикл вызовом метода ''Arrays.{0}()''
inspection.explicit.array.filling.no.suggestion.for.set.all=Не предлагать использовать 'Arrays.setAll()'
inspection.explicit.array.filling.redundant.loop.description=Избыточная инициализация только что созданного массива
inspection.explicit.array.filling.suggest.set.all=Предлагать 'Arrays.setAll()'
inspection.explicit.to.implicit.class.migration.fix.name=Преобразовать в неявно объявленный класс
inspection.explicit.to.implicit.class.migration.name=Явное объявление класса может быть преобразовано в неявно объявленный класс
inspection.export.results.callees=Цепочка вызовов
inspection.export.results.implicit.constructor=неявный конструктор
inspection.export.results.overrides.library.methods=Переопределяет методы библиотеки
inspection.export.results.package=пакет
inspection.export.results.type.references=Следующие используют этот тип
inspection.field.can.be.local.display.name=Поле может быть локальным
inspection.field.can.be.local.problem.descriptor=Поле может быть преобразовано в локальную переменную
inspection.field.can.be.local.quickfix.constructor=Преобразовать поле в локальную переменную в конструкторе
inspection.field.can.be.local.quickfix.initializer=Преобразовать поле в локальную переменную в секции инициализации
inspection.field.can.be.local.quickfix.one.method=Преобразовать поле в локальную переменную в методе ''{0}''
inspection.fill.permits.list.display.name=Подклассы из того же файла отсутствуют в предложении permits sealed-класса
inspection.fill.permits.list.fix.name=Добавить отсутствующие подклассы в предложение permits
inspection.fill.permits.list.no.missing.inheritors=У sealed-класса нет отсутствующих наследников
inspection.fold.expression.fix.family.name=Свернуть выражение
inspection.fold.expression.into.stream.display.name=Выражение может быть свёрнуто в цепочку Stream
inspection.fold.expression.into.stream.fix.name=Свернуть выражение в цепочку Stream
inspection.fold.expression.into.string.display.name=Выражение может быть свёрнуто в 'String.join'
inspection.fold.expression.into.string.fix.name=Свернуть выражение в 'String.join'
inspection.forward.compatibility.name=Прямая совместимость
inspection.frequently.used.inheritor.inspection.display.name=Класс может расширять часто используемый базовый класс
inspection.functional.expression.can.be.folded.display.name=Функциональное выражение может быть свёрнуто
inspection.fuse.stream.operations.display.name=Последующие шаги могут быть объединены в цепочку Stream API
inspection.fuse.stream.operations.fix.family.name=Объединить больше операторов в цепочку Stream API
inspection.fuse.stream.operations.fix.name=Объединить {0} в цепочку Stream API
inspection.fuse.stream.operations.message=Stream может быть расширен заменой {0}
inspection.fuse.stream.operations.option.strict.mode=Не предлагать коллекторы 'toList()' или 'toSet()'
inspection.handle.signature.change.type.fix.name=Изменить тип на ''{0}''
inspection.handle.signature.field.cannot.resolve=Невозможно разрешить поле ''{0}''
inspection.handle.signature.field.not.static=Поле ''{0}'' не является статическим
inspection.handle.signature.field.static=Поле ''{0}'' является статическим
inspection.handle.signature.field.type=Тип поля ''{0}'' - ''{1}''
inspection.handle.signature.method.abstract=Метод ''{0}'' является абстрактным в ''{1}''
inspection.handle.signature.method.not.static=Метод ''{0}'' не является статическим
inspection.handle.signature.method.static=Метод ''{0}'' является статическим
inspection.handle.signature.name=Несоответствие типов MethodHandle/VarHandle
inspection.handle.signature.not.subclass=Вызывающий класс ''{0}'' должен быть подклассом ''{1}''
inspection.handle.signature.use.constructor.fix.family.name=Использовать одну из перегрузок конструктора
inspection.handle.signature.use.constructor.fix.name=Использовать конструктор ''{0}''
inspection.handle.signature.use.method.fix.family.name=Использовать одну из перегрузок метода
inspection.handle.signature.use.method.fix.name=Использовать метод ''{0}''
inspection.idempotent.loop.body=Идемпотентное тело цикла
inspection.illegal.character=Недопустимый символ
inspection.implicit.to.explicit.class.backward.migration.fix.name=Преобразовать неявно объявленный класс в обычный класс
inspection.implicit.to.explicit.class.backward.migration.name=Неявно объявленный класс можно заменить обычным классом
inspection.inconsistent.text.block.indent.message=Отступ текстового блока состоит из табуляций и пробелов
inspection.inconsistent.text.block.indent.name=Непоследовательный отступ пробелами в текстовом блоке
inspection.inconsistent.text.block.indent.spaces.to.tabs.many.to.one.fix=Заменить пробелы табуляциями ({0} пробелов \= 1 табуляция)
inspection.inconsistent.text.block.indent.spaces.to.tabs.one.to.one.fix=Заменить пробелы табуляциями (1 пробел \= 1 табуляция)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.many.fix=Заменить табуляции пробелами (1 табуляция \= {0} пробелов)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.one.fix=Заменить табуляции пробелами (1 табуляция \= 1 пробел)
inspection.input.stream.constructor.message='InputStream' можно создать с помощью 'Files.newInputStream()'
inspection.insert.literal.underscores.display.name=Нечитаемый числовой литерал
inspection.insert.literal.underscores.family.name=Вставить символы подчеркивания в числовой литерал
inspection.io.stream.constructor.description='InputStream' и 'OutputStream' можно создать с помощью методов 'Files'
inspection.java.8.collection.remove.if.display.name=Цикл можно заменить на 'Collection.removeIf()'
inspection.java.8.list.replace.all.display.name=Цикл можно заменить на 'List.replaceAll()'
inspection.java.8.map.api.display.name=Упрощаемые операции с 'Map'
inspection.java.9.collection.factory.display.name=Создание неизменяемой коллекции можно заменить вызовом фабрики коллекций
inspection.javadoc.blank.lines.display.name=Пустая строка должна быть заменена на <p> для разрыва строк
inspection.javadoc.blank.lines.fix.family.name=Заменить пустые строки на <p>
inspection.javadoc.blank.lines.fix.name=Вставить <p>
inspection.javadoc.blank.lines.message=Пустая строка будет проигнорирована
inspection.javadoc.label.text=Дополнительные теги Javadoc\:
inspection.javadoc.link.as.plain.text.display.name=Ссылка указана как обычный текст
inspection.javadoc.link.as.plain.text.message=Ссылка указана как обычный текст
inspection.javadoc.lint.display.name=Проблемы HTML в Javadoc (DocLint)
inspection.javadoc.method.problem.missing.param.tag=Отсутствует обязательный тег <code>@param</code> для параметра {0}
inspection.javadoc.method.problem.missing.tag.description=Отсутствует описание тега {0}
inspection.javadoc.option.ignore.deprecated=Игнорировать элементы, помеченные как @deprecated
inspection.javadoc.option.ignore.period=Игнорировать проблемы с точками
inspection.javadoc.option.ignore.self.ref=Игнорировать Javadoc, указывающий на себя
inspection.javadoc.option.ignore.simple=Игнорировать простые методы доступа к свойствам
inspection.javadoc.option.ignore.throws=Игнорировать дублирующиеся теги 'throws'
inspection.javadoc.option.tab.title=Класс
inspection.javadoc.option.tab.title.field=Поле
inspection.javadoc.option.tab.title.inner.class=Внутренний класс
inspection.javadoc.option.tab.title.method=Метод
inspection.javadoc.option.tab.title.module=Модуль
inspection.javadoc.option.tab.title.package=Пакет
inspection.javadoc.problem.add.param.tag=Добавить тег @param для параметра ''{0}''
inspection.javadoc.problem.add.param.tag.family=Добавить отсутствующий тег параметра Javadoc
inspection.javadoc.problem.add.tag=Добавить тег @{0} {1}
inspection.javadoc.problem.add.tag.family=Добавить отсутствующий тег Javadoc
inspection.javadoc.problem.cannot.resolve=Не удаётся разрешить символ {0}
inspection.javadoc.problem.descriptor=Отсутствует обязательный Javadoc
inspection.javadoc.problem.descriptor1=В документации отсутствует точка. Точка используется инструментом Javadoc для генерации комментария на странице обзора
inspection.javadoc.problem.disallowed.tag=Тег {0} здесь не разрешен
inspection.javadoc.problem.duplicate.param=Дублирующийся тег @param для параметра ''{0}''
inspection.javadoc.problem.duplicate.tag=Дублирующийся тег @{0}
inspection.javadoc.problem.duplicate.throws=Дублирующийся тег @throws или @exception для исключения ''{0}''
inspection.javadoc.problem.inaccessible=Символ {0} недоступен отсюда
inspection.javadoc.problem.missing.tag=Отсутствует обязательный тег {0}
inspection.javadoc.problem.missing.tag.description={0} отсутствует после тега @{1}
inspection.javadoc.problem.name.expected=Ожидается имя
inspection.javadoc.problem.pointing.to.itself=Javadoc указывает на себя
inspection.javadoc.problem.see.tag.expecting.ref=После тега @see ожидается ссылка на класс/метод, цитируемый текст или HTML-ссылка
inspection.javadoc.problem.snippet.tag.is.not.available=Тег '@snippet' недоступен на этом уровне языка
inspection.javadoc.problem.wrong.tag=Неверный тег {0}
inspection.javadoc.ref.display.name=Проблемы в ссылках Javadoc в объявлении
inspection.javadocDeclaration.display.name=Проблемы в объявлениях Javadoc
inspection.join.declaration.and.assignment.display.name=Присваивание можно объединить с объявлением
inspection.join.declaration.and.assignment.fix.family.name=Объединить объявление и присваивание
inspection.join.declaration.and.assignment.fix.title=Объединить объявление и присваивание
inspection.join.declaration.and.assignment.message=Присваивание можно объединить с объявлением ''{0}''
inspection.labeled.switch.rule.redundant.code.block.display.name=Помеченное правило switch имеет избыточный блок кода
inspection.labeled.switch.rule.redundant.code.block.message=Блок кода помеченного правила избыточен
inspection.labeled.switch.rule.redundant.code.fix.name=Развернуть блок кода помеченного правила
inspection.lambda.can.be.method.call.display.name=Лямбда может быть заменена вызовом метода
inspection.lambda.to.method.call.fix.family.name=Заменить лямбда-выражение вызовом метода
inspection.lambda.to.method.call.fix.name=Заменить лямбда-выражение на ''{0}''
inspection.magic.constant.display.name=Магическая константа
inspection.magic.constants.should.be.one.of.values=Должно быть одним из\: {0}{1,choice,0\#|1\# или их комбинацией}
inspection.manual.min.max.calculation.description=Можно заменить вызовом ''Math.{0}()''
inspection.manual.min.max.calculation.disable.for.non.integral=Отключить для float и double
inspection.manual.min.max.calculation.display.name=Ручной расчет min/max
inspection.map.foreach.display.name=Можно использовать Map.forEach()
inspection.map.foreach.option.no.loops=Не сообщать о циклах
inspection.mapping.before.count.family.name=Вызов mapping перед count()
inspection.mapping.before.count.message=Вызов ''{0}()'' не изменяет итоговый подсчет и может быть оптимизован.
inspection.meaningless.record.annotation.description=Бессмысленная аннотация record
inspection.meaningless.record.annotation.message.method=Аннотация не имеет эффекта\: её цель - METHOD, но соответствующий аксессор объявлен явно
inspection.meaningless.record.annotation.message.method.and.parameter=Аннотация не имеет эффекта\: её цели - METHOD и PARAMETER, но и аксессор, и канонический конструктор объявлены явно
inspection.meaningless.record.annotation.message.parameter=Аннотация не имеет эффекта\: её цель - PARAMETER, но канонический конструктор объявлен явно
inspection.message.anonymous.ref.loc.can.be.replaced.with.method.reference=Анонимный \#ref \#loc можно заменить ссылкой на метод
inspection.message.can.be.replaced.with.0.constructor=Можно заменить конструктором ''{0}''
inspection.message.can.be.replaced.with.files.readstring=Можно заменить на 'Files.readString()'
inspection.message.can.be.replaced.with.files.writestring=Можно заменить на 'Files.writeString()'
inspection.message.can.be.replaced.with.optional.of.nullable=Можно заменить на Optional.ofNullable()
inspection.message.can.be.replaced.with.single.expression.in.functional.style=Можно заменить одним выражением в функциональном стиле
inspection.message.can.be.replaced.with.string.repeat=Можно заменить на 'String.repeat()'
inspection.message.external.snippet.differs.from.inline.snippet=Внешний сниппет отличается от встроенного сниппета
inspection.message.filter.is.present.chain.can.be.replaced.with.anymatch=Цепочку ''filter().{0}().isPresent()'' можно заменить на ''anyMatch()''
inspection.message.full.description=Полное описание
inspection.message.lambda.parameter.type.is.redundant=Тип параметра лямбды избыточен
inspection.message.pattern.variables.can.be.replaced.with.cast=Использование 'instanceof' с паттернами
inspection.message.pattern.variables.can.be.replaced.with.cast.family.name=Заменить без паттернов
inspection.message.pattern.variables.can.be.replaced.with.cast.fix.name=Заменить ''{0}'' на приведения типов
inspection.message.pattern.variables.can.be.replaced.with.cast.preserve.option=Пытаться сохранять неиспользуемые переменные из паттернов при быстром исправлении
inspection.message.pseudo.functional.style.code=Псевдофункциональный стиль кода
inspection.message.record.can.be.converted.to.class=Record может быть преобразован в класс
inspection.message.redundant.default.parameter.value.assignment=Избыточное присваивание значения параметру по умолчанию
inspection.message.replace.optional.with.if.statements=Заменить Optional на условные операторы if
inspection.message.snippet.file.not.found=Файл сниппета ''{0}'' не найден
inspection.message.snippet.region.not.found=Регион не найден
inspection.missingJavadoc.display.name=Отсутствует Javadoc
inspection.missingJavadoc.label.minimalVisibility=Минимальная видимость\:
inspection.missingJavadoc.label.requiredTags=Обязательные теги\:
inspection.move.field.assignment.to.initializer.display.name=Присваивание полю может быть перемещено в инициализатор
inspection.no.jdk.error.message=JDK не настроен правильно для этого проекта. Инспекция не может быть выполнена.
inspection.no.modules.error.message=Этот проект не содержит модулей. Инспекция не может быть выполнена.
inspection.notnull.field.not.initialized.display.name=Поле с аннотацией @NotNull не инициализовано
inspection.notnull.field.not.initialized.message=Поля {0} должны быть инициализованы
inspection.notnull.field.not.initialized.option.implicit=Игнорировать поля, которые могут быть инициализованы неявно
inspection.notnull.field.not.initialized.option.implicit.description=Если отмечено, поля, которые заведомо инициализуются неявно (например, через внедрение зависимостей), не будут отмечаться
inspection.notnull.field.not.initialized.option.setup=Игнорировать поля, инициализованные в методе setUp()
inspection.notnull.field.not.initialized.option.setup.description=Если отмечено, поля в тестовых классах, инициализуемые в методах настройки (например, с аннотациями <code>@Before</code> или <code>@BeforeEach</code>), не будут отмечаться.
inspection.null.value.for.optional.assigned.ignore.fix.name=Не предупреждать при сравнении Optional с null
inspection.null.value.for.optional.assigned.message=Значение Optional сравнивается с null
inspection.null.value.for.optional.context.assignment=присваивание
inspection.null.value.for.optional.context.declaration=объявление
inspection.null.value.for.optional.context.lambda=лямбда-выражение
inspection.null.value.for.optional.context.parameter=параметр
inspection.null.value.for.optional.context.return=оператор return
inspection.null.value.for.optional.fix.family.name=Заменить на метод пустого Optional
inspection.null.value.for.optional.message=Null используется для типа ''Optional'' в {0}
inspection.null.value.for.optional.option.comparisons=Сообщать о сравнении Optional с null
inspection.nullable.problems.display.name=Проблемы @NotNull/@Nullable
inspection.nullable.problems.ignore.external.notnull=Игнорировать внешние @NotNull [&I]
inspection.nullable.problems.method.overrides.notnull.option=Сообщать о параметрах @NotNull, переопределяющих @Nullable и наоборот [&P]
inspection.nullable.problems.method.overrides.option=Сообщать о неаннотированных параметрах или методах, переопределяющих @NotNull [&A]
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=Сообщать о неаннотированных параметрах setter или getter для аннотированных полей [&S]
inspection.nullable.problems.notnull.overrides.option=Сообщать о параметрах @NotNull, переопределяющих неаннотированные [&P]
inspection.nullable.problems.notnull.parameters.with.null.literal.option=Сообщать о параметрах @NotNull с использованием null-литералов в аргументах
inspection.obvious.null.check.display.name=Метод проверки на null вызывается с заведомо не-null аргументом
inspection.optional.assigned.to.null.display.name=Значение null для типа Optional
inspection.optional.get.without.is.present.display.name=Optional.get() вызывается без проверки isPresent()
inspection.optional.get.without.is.present.message=<code>{0}.\#ref()</code> без проверки ''isPresent()''
inspection.optional.get.without.is.present.method.reference.message=<code>\#ref</code> без проверки 'isPresent()'
inspection.optional.is.present.display.name=Нефункциональное использование 'Optional.isPresent()'
inspection.optional.to.if.display.name='Optional' может быть заменен последовательностью операторов 'if'
inspection.output.stream.constructor.message='OutputStream' может быть создан с помощью 'Files.newOutputStream()'
inspection.overflowing.loop.index.inspection.description=Цикл выполняется ноль или миллиарды раз
inspection.overflowing.loop.index.inspection.name=Цикл выполняется ноль или миллиарды раз
inspection.overwritten.key.array.message=Перезаписанный элемент массива
inspection.overwritten.key.display.name=Перезаписанный элемент Map, Set или массива
inspection.overwritten.key.map.message=Дублирующийся ключ Map
inspection.overwritten.key.set.message=Дублирующийся элемент Set
inspection.parameter.can.be.local.display.name=Значение, переданное как параметр, никогда не читается
inspection.parameter.can.be.local.problem.descriptor=Параметр может быть преобразован в локальную переменную
inspection.preview.feature=Предупреждение о Preview-функциональности
inspection.preview.feature.0.is.preview.api.message={0} является preview API и может быть удален в будущих версиях
inspection.quickfix.assert.family=Assert
inspection.raw.use.of.parameterized.type.problem.descriptor=Сырое использование параметризованного класса <code>\#ref</code> \#loc
inspection.read.write.string.can.be.used.display.name=Можно использовать 'Files.readString()' или 'Files.writeString()'
inspection.redundant.array.creation.display.name=Избыточное создание массива
inspection.redundant.array.creation.for.varargs.call.descriptor=Избыточное создание массива при вызове varargs метода
inspection.redundant.array.creation.quickfix=Удалить явное создание массива
inspection.redundant.explicit.close=Избыточный 'close()'
inspection.redundant.file.creation.description=<code>\#ref</code> избыточно \#loc
inspection.redundant.file.creation.display.name=Избыточное создание экземпляра 'File'
inspection.redundant.file.creation.quickfix=Заменить на имя файла
inspection.redundant.lambda.parameter.type.display.name=Избыточные типы параметров лямбда-выражения
inspection.redundant.null.check.always.fail.message=Проверка на null всегда будет неудачной\: {0} никогда не null
inspection.redundant.null.check.fix.family.name=Удалить избыточную проверку на null
inspection.redundant.null.check.fix.notnull.family.name=Удалить ошибочное '\!\= null'
inspection.redundant.null.check.message=Избыточная проверка на null\: {0} никогда не null
inspection.redundant.operation.on.empty.array.message=Массив <code>\#ref</code> всегда пуст
inspection.redundant.operation.on.empty.collection.message=Коллекция <code>\#ref</code> всегда пуста
inspection.redundant.operation.on.empty.container.display.name=Избыточная операция над пустым контейнером
inspection.redundant.operation.on.empty.map.message=Map <code>\#ref</code> всегда пуст
inspection.redundant.record.constructor.can.be.compact.message=Канонический конструктор может быть преобразован в компактную форму
inspection.redundant.record.constructor.canonical.message=Избыточный канонический конструктор
inspection.redundant.record.constructor.compact.message=Избыточный компактный конструктор
inspection.redundant.record.constructor.description=Избыточный конструктор record
inspection.redundant.record.constructor.fix.family.name=Преобразовать канонический конструктор в компактную форму
inspection.redundant.record.constructor.statement.message=Избыточное присваивание полю в компактном конструкторе
inspection.redundant.stream.optional.call.display.name=Избыточный шаг в цепочке вызовов 'Stream' или 'Optional'
inspection.redundant.stream.optional.call.explanation.at.most.one=поток содержит не более одного элемента
inspection.redundant.stream.optional.call.explanation.distinct=в цепочке есть предыдущий вызов 'distinct()'
inspection.redundant.stream.optional.call.explanation.distinct.set=элементы будут уникальными при сборе в Set
inspection.redundant.stream.optional.call.explanation.filter=предикат всегда 'true'
inspection.redundant.stream.optional.call.explanation.map.flatMap=предыдущий вызов 'map()' может заменить шаг 'flatMap()'
inspection.redundant.stream.optional.call.explanation.parallel=существует последующий вызов ''{0}()'', который переопределяет этот вызов
inspection.redundant.stream.optional.call.explanation.parallel.single=поток, созданный из одного элемента, не будет распараллелен
inspection.redundant.stream.optional.call.explanation.parallel.source=поток был создан через 'parallelStream()', поэтому он уже параллельный
inspection.redundant.stream.optional.call.explanation.sequential.source=поток был создан через 'stream()', поэтому он уже последовательный
inspection.redundant.stream.optional.call.explanation.sorted=последующий вызов ''{0}()'' не зависит от порядка сортировки
inspection.redundant.stream.optional.call.explanation.sorted.parallel=последующая операция ''{0}()'' не зависит от порядка сортировки для параллельных потоков
inspection.redundant.stream.optional.call.explanation.sorted.twice=в цепочке есть последующий вызов 'sorted()'
inspection.redundant.stream.optional.call.explanation.unordered=в цепочке есть предыдущий вызов 'unordered()'
inspection.redundant.stream.optional.call.fix.bind.name=Объединить шаг ''{0}()'' с предыдущим шагом ''{1}()''
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=Собрать в 'LinkedHashSet'
inspection.redundant.stream.optional.call.fix.family.name=Удалить избыточный вызов в цепочке
inspection.redundant.stream.optional.call.fix.name=Удалить вызов ''{0}()''
inspection.redundant.stream.optional.call.fix.replace.terminal=Заменить терминальную операцию
inspection.redundant.stream.optional.call.fix.replace.terminal.text=Заменить терминальную операцию на ''{0}()''
inspection.redundant.stream.optional.call.message.with.explanation=Избыточный вызов ''{0}()''\: {1}
inspection.redundant.stream.optional.call.option.streamboxing=Сообщать о избыточной упаковке в Stream.map()
inspection.redundant.unmodifiable.call.description=Избыточное использование оберток неизменяемых коллекций
inspection.redundant.unmodifiable.call.display.name=Избыточное использование обертки ''{0}''
inspection.redundant.unmodifiable.call.unwrap.argument.quickfix=Развернуть аргумент
inspection.reflect.handle.invocation.argument.not.array=Аргумент не является массивом
inspection.reflect.handle.invocation.argument.not.exact=Тип аргумента должен быть точно ''{0}''
inspection.reflect.handle.invocation.primitive.argument.null=Аргумент типа ''{0}'' не может быть ''null''
inspection.reflect.handle.invocation.receiver.incompatible=Тип получателя вызова несовместим\: ожидается ''{0}''
inspection.reflect.handle.invocation.receiver.null=Получатель вызова равен 'null'
inspection.reflect.handle.invocation.result.not.assignable=Должно быть приведено к ''{0}'' или его суперклассу
inspection.reflect.handle.invocation.result.not.exact=Должно быть приведено к ''{0}''
inspection.reflect.handle.invocation.result.null=Возвращаемое значение всегда 'null'
inspection.reflect.handle.invocation.result.void=Тип возвращаемого значения 'void'
inspection.reflection.invocation.argument.count=Ожидается {0,choice,0\#0 аргументов|1\#1 аргумент|1<{0} аргументов}
inspection.reflection.invocation.argument.not.assignable=Аргумент не может быть присвоен типу ''{0}''
inspection.reflection.invocation.array.not.assignable=Элемент{0,choice,1\#|1\#ы} массива име{0,choice,1\#ет|1\#ют} несовместим{0,choice,1\#ый тип|1\#ые типы}
inspection.reflection.invocation.item.count=Ожидается {0,choice,0\#пустой массив|1\#массив из одного элемента|1<массив из {0} элементов}
inspection.reflection.invocation.item.not.assignable=Элемент массива не может быть присвоен типу ''{0}''
inspection.reflection.invocation.name=Несоответствие аргументов рефлексивного вызова
inspection.reflection.member.access.cannot.resolve.constructor.arguments=Не удаётся найти конструктор с указанными типами аргументов
inspection.reflection.member.access.cannot.resolve.field=Не удаётся найти поле ''{0}''
inspection.reflection.member.access.cannot.resolve.method=Не удаётся найти метод ''{0}''
inspection.reflection.member.access.cannot.resolve.method.arguments=Не удаётся найти метод ''{0}'' с указанными типами аргументов
inspection.reflection.member.access.check.exists=Проверять существование поля/метода в не-final классах
inspection.reflection.member.access.check.exists.exclude.chooser=Класс для исключения
inspection.reflection.member.access.check.exists.exclude.label=Исключить классы\:
inspection.reflection.member.access.constructor.not.public=Конструктор не является public
inspection.reflection.member.access.field.not.in.class=Поле ''{0}'' не объявлено в классе ''{1}''
inspection.reflection.member.access.field.not.public=Поле ''{0}'' не является public
inspection.reflection.member.access.fix.family.name=Использовать подходящий метод рефлексии
inspection.reflection.member.access.method.not.in.class=Метод ''{0}'' не объявлен в классе ''{1}''
inspection.reflection.member.access.method.not.public=Метод ''{0}'' не является public
inspection.reflection.member.access.name=Рефлексивный доступ к несуществующему или невидимому члену класса
inspection.reflection.visibility.name=Проблемы рефлексивного доступа между модулями
inspection.remove.literal.underscores.display.name=Подчеркивания в числовом литерале
inspection.remove.literal.underscores.family.name=Удалить подчеркивания из числового литерала
inspection.replace.inefficient.stream.count.display.name=Неэффективные цепочки вызовов Stream API, заканчивающиеся count()
inspection.replace.javadoc.display.name=Комментарий, заменяемый на Javadoc
inspection.replace.methodref.ternary.quickfix=Заменить на лямбду с проверкой на null
inspection.replace.ternary.quickfix=Заменить на ''{0} \!\= null ?\:''
inspection.replace.with.bulk.file.attributes.read.fix.family.name=Заменить на массовый вызов 'Files.readAttributes()'
inspection.replace.with.bulk.fix.family.name=Заменить на массовый вызов метода
inspection.replace.with.bulk.fix.name=Заменить итерацию на массовый вызов ''{0}()''
inspection.replace.with.bulk.message=Итерацию можно заменить массовым вызовом ''{0}()''
inspection.replace.with.bulk.wrap.arrays=Использовать 'Arrays.asList()' для обертывания массивов
inspection.replace.with.enhanced.switch.statement.fix.name=Заменить на расширенный оператор 'switch'
inspection.replace.with.javadoc=Заменить на Javadoc-комментарий
inspection.replace.with.javadoc.comment=Комментарий можно преобразовать в Javadoc
inspection.replace.with.old.style.switch.statement.fix.name=Заменить на старый стиль оператора 'switch'
inspection.replace.with.regular.string.literal.fix=Заменить на обычный строковый литерал
inspection.replace.with.string.concatenation.fix=Заменить на конкатенацию строк
inspection.replace.with.string.template.fix=Заменить на строковый шаблон
inspection.replace.with.switch.expression.fix.family.name=Перейти на расширенный switch
inspection.replace.with.switch.expression.fix.name=Заменить на выражение 'switch'
inspection.replace.with.text.block.fix=Заменить на текстовый блок
inspection.replace.with.trivial.lambda.fix.family.name=Заменить на тривиальную лямбду
inspection.replace.with.trivial.lambda.fix.name=Заменить на лямбду, возвращающую ''{0}''
inspection.require.non.null=Заменить проверку на null статическим вызовом Objects/Stream
inspection.require.non.null.description=Проверку на null можно заменить вызовом метода
inspection.require.non.null.message={0, choice, 1\#Оператор ''if''|2\#Условное выражение} можно заменить вызовом ''{1}()''
inspection.require.non.null.no.warning.replacement.bigger=Не предупреждать, если замена длиннее оригинала
inspection.require.non.null.quickfix=Заменить {0, choice, 1\#оператор ''if''|2\#условное выражение} на вызов ''{1}()''
inspection.return.separated.from.computation.descriptor=Return отделен от вычисления значения ''{0}''
inspection.return.separated.from.computation.family.quickfix=Переместить 'return' ближе к вычислению результата
inspection.return.separated.from.computation.name='return' отделен от вычисления результата
inspection.return.separated.from.computation.quickfix=Переместить ''return'' ближе к вычислению значения ''{0}''
inspection.same.parameter.display.name=Параметр метода всегда имеет одно и то же значение
inspection.same.parameter.fix.family.name=Встроить параметр как константное значение
inspection.same.parameter.fix.name=Встроить значение ''{1}'' для параметра ''{0}''
inspection.same.parameter.problem.descriptor=Значение параметра <code>\#ref</code> всегда равно ''{0}''
inspection.simplifiable.comparator.comparing.message=Ненужный вызов ''{0}()''
inspection.simplifiable.comparator.display.name=Метод компаратора можно упростить
inspection.simplifiable.comparator.entry.comparator.message=Можно использовать ''{0}''
inspection.simplifiable.comparator.fix.comparing.family.name=Удалить избыточный вызов
inspection.simplifiable.comparator.fix.entry.comparator.family.name=Использовать предопределённый компаратор 'Map.Entry'
inspection.simplifiable.comparator.fix.remove.name=Удалить вызов ''{0}()''
inspection.simplifiable.comparator.fix.replace.name=Удалить вызов ''{0}()'' и использовать ''{1}()''
inspection.simplifiable.comparator.fix.reversed.family.name=Упростить метод компаратора, заменив 'max' на 'min'
inspection.simplifiable.comparator.fix.reversed.name=Заменить на ''{0}'', упростив компаратор
inspection.simplifiable.comparator.reversed.message=Метод компаратора можно упростить, если заменить вызов ''{0}()'' на ''{1}()''
inspection.simplify.collector.display.name=Упрощаемый коллектор
inspection.simplify.collector.fix.family.name=Упростить каскадный коллектор
inspection.simplify.collector.fix.name=Использовать коллектор ''Collectors.{0}()''
inspection.simplify.collector.message=Можно упростить, используя коллектор ''{0}()''
inspection.simplify.for.each.extract.intermediate.operations=Извлечь промежуточные операции
inspection.simplify.foreach.display.name=Упрощаемый вызов forEach()
inspection.simplify.optional.call.chains.display.name=Цепочку вызовов Optional можно упростить
inspection.simplify.stream.api.call.chains.display.name=Цепочку вызовов Stream API можно упростить
inspection.slow.abstract.set.remove.all.description=Вызов 'set.removeAll(list)' может работать медленно
inspection.slow.abstract.set.remove.all.fix.family.name=Использовать 'Set.remove' вместо 'Set.removeAll'
inspection.slow.list.contains.all.description=Вызов 'list.containsAll(collection)' может иметь низкую производительность
inspection.slow.list.contains.all.fix.family.name=Обернуть в конструктор 'HashSet'
inspection.slow.list.contains.all.fix.name=Обернуть ''{0}'' в конструктор ''HashSet''
inspection.sorted.collection.with.non.comparable.keys.display.name=Сортированная коллекция с несравнимыми элементами
inspection.sorted.collection.with.non.comparable.keys.message=Создание сортированной коллекции с несравнимыми элементами
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=Не сообщать о несравнимых параметрах типа
inspection.static.pseudo.functional.style.method.display.name=Псевдо-функциональный вызов Guava можно преобразовать в вызов Stream API
inspection.stream.api.migration.can.be.replaced.with.call=Можно заменить вызовом ''{0}''
inspection.stream.to.loop.display.name=Цепочку вызовов Stream API можно заменить циклом
inspection.string.repeat.can.be.used.display.name=Можно использовать String.repeat()
inspection.string.template.migration.concatenation.message=Конкатенацию можно заменить на строковый шаблон
inspection.string.template.migration.name=Можно использовать строковый шаблон
inspection.string.template.migration.string.message=Строку можно заменить на шаблон
inspection.string.template.reverse.migration.name=Строковый шаблон может быть конкатенированной строкой
inspection.string.template.reverse.migration.string.message=Строковый шаблон можно заменить на конкатенацию строк
inspection.surround.if.family=Обернуть в if
inspection.surround.if.quickfix=Обернуть в ''if ({0}{1})''
inspection.suspicious.list.remove.display.name=Подозрительный 'List.remove()' в цикле
inspection.suspicious.return.byte.input.stream.convert.to.unsigned=Преобразовать в беззнаковый байт
inspection.suspicious.return.byte.input.stream.name=Подозрительное байтовое значение, возвращаемое из 'InputStream.read()'
inspection.suspicious.ternary.in.varargs.description=Тернарный оператор в вызове varargs содержит ветви с массивом и не-массивом
inspection.suspicious.ternary.in.varargs.display.name=Подозрительный тернарный оператор в вызове метода с varargs
inspection.suspicious.ternary.in.varargs.quickfix=Обернуть в инициализатор массива
inspection.switch.expression.backward.expression.migration.inspection.name=Выражение 'switch' можно заменить на старый стиль оператора 'switch'
inspection.switch.expression.backward.migration.inspection.name=Улучшенный 'switch'
inspection.switch.expression.backward.statement.migration.inspection.name=Оператор 'switch' можно заменить на старый стиль оператора 'switch'
inspection.switch.expression.migration.expression.max.statements=Максимальное количество операторов в одной ветви для преобразования в выражение switch
inspection.switch.expression.migration.inspection.name=Оператор можно заменить на улучшенный 'switch'
inspection.switch.expression.migration.inspection.switch.description=Оператор switch можно заменить на улучшенный 'switch'
inspection.switch.expression.migration.option.expression.max.statements=Не сообщать о switch с более чем {0} {0, choice, 1\#оператором|2\#операторами} в одной ветви
inspection.switch.expression.migration.warn.only.on.expression=Показывать предупреждение только если возможно преобразование в выражение
inspection.switch.labeled.rule.can.be.code.block.display.name=Помеченное правило switch может иметь блок кода
inspection.switch.labeled.rule.can.be.code.block.expression.message=Выражение результата помеченного правила можно обернуть в блок кода
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=Обернуть выражение результата помеченного правила в блок кода
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=Обернуть оператор помеченного правила в блок кода
inspection.switch.labeled.rule.can.be.code.block.statement.message=Оператор помеченного правила можно обернуть в блок кода
inspection.text.block.backward.migration.message=Текстовый блок можно преобразовать в обычный строковый литерал
inspection.text.block.backward.migration.name=Текстовый блок можно заменить на обычный строковый литерал
inspection.text.block.migration.concatenation.message=Конкатенацию можно заменить на текстовый блок
inspection.text.block.migration.name=Можно использовать текстовый блок
inspection.text.block.migration.string.message=Строку можно заменить на текстовый блок
inspection.text.block.migration.suggest.literal.replacement=Сообщать об одиночных строковых литералах
inspection.trailing.whitespaces.in.text.block.message=Завершающие пробельные символы внутри текстового блока
inspection.trailing.whitespaces.in.text.block.name=Завершающие пробелы в текстовом блоке
inspection.trailing.whitespaces.in.text.block.remove.whitespaces=Удалить завершающие пробельные символы
inspection.trailing.whitespaces.in.text.block.replaces.whitespaces.with.escapes=Экранировать завершающие пробельные символы
inspection.trivial.functional.expression.usage.display.name=Тривиальное использование функционального выражения
inspection.unchecked.warning.display.name=Непроверенное предупреждение
inspection.undeclared.service.usage.message=Использование сервиса ''{0}'' не объявлено в module-info
inspection.undeclared.service.usage.name=Использование сервиса не объявлено в 'module-info'
inspection.unresolved.module.dependencies.problem.descriptor=Неразрешённые зависимости модуля
inspection.unused.assignment.display.name=Неиспользуемое присваивание
inspection.unused.assignment.option=Сообщать о префиксных выражениях, которые можно заменить бинарным выражением
inspection.unused.assignment.option1=Сообщать о постфиксных выражениях, где измененное значение не используется
inspection.unused.assignment.option2=Сообщать о избыточных инициализаторах
inspection.unused.assignment.option3=Сообщать о переменных шаблона, значения которых никогда не используются
inspection.unused.assignment.option4=Сообщать о параметрах итерации, значения которых никогда не используются
inspection.unused.assignment.problem.descriptor1=Переменная <code>\#ref</code> \#loc никогда не используется
inspection.unused.assignment.problem.descriptor2=Инициализатор <code>\#ref</code> \#loc переменной <code>{0}</code> избыточен
inspection.unused.assignment.problem.descriptor3=Значение <code>{0}</code>, присвоенное <code>\#ref</code> \#loc, никогда не используется
inspection.unused.assignment.problem.descriptor4=Значение, измененное в <code>\#ref</code> \#loc, никогда не используется
inspection.unused.assignment.problem.descriptor5=Значение переменной шаблона <code>\#ref</code> \#loc никогда не используется
inspection.unused.assignment.problem.descriptor6=Значение параметра итерации foreach <code>\#ref</code> \#loc никогда не используется
inspection.unused.assignment.remove.assignment.quickfix=Удалить избыточное присваивание
inspection.unused.assignment.remove.assignment.quickfix.title=Удалить избыточное присваивание
inspection.unused.assignment.remove.initializer.quickfix=Удалить избыточный инициализатор
inspection.unused.assignment.remove.initializer.quickfix.title=Удалить избыточный инициализатор
inspection.unused.display.name=Неиспользуемое объявление
inspection.unused.parameter.composer=Параметр <code>\#ref</code> не используется ни в одной реализации
inspection.unused.parameter.composer1=Параметр <code>\#ref</code> не используется ни в этом методе, ни в его переопределяющих методах
inspection.unused.parameter.delete.family=Безопасно удалить неиспользуемый(е) параметр(ы)
inspection.unused.parameter.delete.quickfix=Безопасно удалить неиспользуемый параметр ''{0}''
inspection.unused.parameter.problem.descriptor=Параметр <code>\#ref</code> не используется
inspection.unused.return.value.display.name=Метод может быть 'void'
inspection.unused.return.value.make.void.quickfix=Сделать метод void
inspection.unused.return.value.problem.descriptor=Возвращаемое значение метода никогда не используется
inspection.unused.symbol.check.accessors=Геттеры/сеттеры
inspection.unused.symbol.check.classes=Классы\:
inspection.unused.symbol.check.fields=Поля\:
inspection.unused.symbol.check.inner.classes=Внутренние классы\:
inspection.unused.symbol.check.localvars=Локальные переменные
inspection.unused.symbol.check.methods=Методы\:
inspection.unused.symbol.check.parameters=Параметры в
inspection.unused.symbol.check.parameters.excluding.hierarchy=Исключая иерархию
inspection.use.bulk.operation.display.name=Вместо итерации можно использовать массовую операцию
inspection.value.based.warnings=Предупреждения на основе значений
inspection.value.based.warnings.synchronization=Попытка синхронизации экземпляра класса на основе значений
inspection.variable.assigned.to.itself.display.name=Переменной присваивается она сама
inspection.wrapper.type.may.be.primitive.display.name=Тип-обертка может быть примитивным
inspection.wrapper.type.may.be.primitive.fix.name=Преобразовать тип-обертку в примитивный тип
inspection.wrapper.type.may.be.primitive.name=Тип может быть примитивным
intention.add.explicit.type.arguments.family=Добавить явные аргументы типа
intention.add.on.demand.static.import.family=Добавить статический импорт по требованию
intention.add.on.demand.static.import.text=Добавить статический импорт по требованию для ''{0}''
intention.add.single.member.import.text=Добавить импорт для ''{0}''
intention.add.single.member.static.import.family=Добавить статический импорт одного члена
intention.add.single.member.static.import.text=Добавить статический импорт для ''{0}''
intention.assign.field.from.parameter.family=Присвоить параметр полю
intention.assign.field.from.parameter.text=Присвоить параметр полю ''{0}''
intention.bind.fields.from.parameters.family=Привязать параметры к полям
intention.bind.fields.from.parameters.text=Привязать {0} параметров к полям
intention.break.string.on.line.breaks.text=Разбить строку по '\\n'
intention.category.annotations=Java/Аннотации
intention.category.collections=Java/Коллекции
intention.category.comments=Java/Комментарии
intention.category.concurrency=Java/Многопоточность
intention.category.conditional.operator=Java/Условия
intention.category.control.flow=Java/Поток управления
intention.category.declaration=Java/Объявление
intention.category.expressions=Java/Выражения
intention.category.i18n=Java/Интернационализация
intention.category.imports=Java/Импорты
intention.category.junit=Java/JUnit
intention.category.other=Java/Прочее
intention.category.refactorings=Java/Рефакторинг
intention.category.streams=Java/Потоки
intention.category.strings=Java/Строки
intention.category.try.statements=Java/Try операторы
intention.compose.function.family=Заменить вложенный вызов функции на композицию
intention.compose.function.text=Заменить вложенный вызов функции на вызов andThen
intention.convert.color.representation.family=Преобразовать представление Color
intention.convert.color.representation.text=Преобразовать в ''new Color{0}''
intention.convert.compact.constructor.to.canonical=Преобразовать компактный конструктор в канонический
intention.convert.to.single.return.command.text=Преобразовать тело в форму с единственной точкой выхода
intention.convert.to.single.return.name=Преобразовать тело в форму с единственной точкой выхода
intention.convert.to.single.return.progress.title=Преобразование тела в форму с единственной точкой выхода
intention.create.annotation.method.from.usage=Создать метод @interface ''{0}()''
intention.create.field.from.parameter.family=Создать поле для параметра
intention.create.field.from.parameter.text=Создать поле для параметра ''{0}''
intention.create.switch.statement=Создать оператор switch
intention.create.test.dialog.choose.super.class=Выберите суперкласс
intention.create.test.dialog.class.name=Имя класса\:
intention.create.test.dialog.fix.library=Исправить
intention.create.test.dialog.generate=Сгенерировать\:
intention.create.test.dialog.java=Java
intention.create.test.dialog.library.not.found=Библиотека {0} не найдена в модуле
intention.create.test.dialog.select.methods=Сгенерировать тестовые методы для [&M]\:
intention.create.test.dialog.setUp=set&Up/@Before
intention.create.test.dialog.show.inherited=Показать унаследованные методы [&I]
intention.create.test.dialog.super.class=Суперкласс\:
intention.create.test.dialog.tearDown=tear&Down/@After
intention.create.test.dialog.testing.library=Тестовая библиотека [&L]\:
intention.encapsulate.field.text=Инкапсулировать поле
intention.error.cannot.create.class.message=Невозможно создать класс ''{0}''
intention.error.cannot.create.class.title=Не удалось создать класс
intention.error.make.sealed.class.different.modules=Некоторые наследники находятся в разных модулях
intention.error.make.sealed.class.different.packages=Модуль без имени и некоторые наследники находятся в другом пакете
intention.error.make.sealed.class.has.anonymous.or.local.inheritors=Некоторые наследники являются анонимными или локальными
intention.error.make.sealed.class.inheritors.not.in.java.file=Некоторые наследники не в Java файлах
intention.error.make.sealed.class.interface.has.no.inheritors=Интерфейс не имеет наследников
intention.error.make.sealed.class.is.used.in.functional.expression=Класс используется в функциональном выражении
intention.extract.if.condition.family=Извлечь условие 'if'
intention.extract.if.condition.text=Извлечь if ({0})
intention.extract.map.step.family=Извлечь в отдельный метод отображения
intention.extract.map.step.text=Извлечь переменную ''{0}'' в операцию ''{1}''
intention.extract.method.text=Извлечь метод
intention.extract.set.from.comparison.chain.family=Извлечь Set из цепочки сравнений
intention.extract.set.from.comparison.chain.popup.title=Извлечь Set из цепочки сравнений
intention.extract.set.from.comparison.chain.replace.all=Заменить все вхождения
intention.extract.set.from.comparison.chain.replace.only.this=Заменить только это вхождение
intention.family.add.javadoc=Добавить Javadoc
intention.family.copy.abstract.method.implementation=Копировать реализацию abstract метода
intention.family.create.a.class.in.package=Создать класс в пакете
intention.family.edit.method.contract=Редактировать контракт метода
intention.family.edit.range=Редактировать диапазон
intention.family.expand.static.import=Развернуть static import
intention.family.fix.bounded.wildcards=Исправить ограниченные wildcards
intention.family.make.external.annotations.explicit=Сделать внешние аннотации явными
intention.family.make.inferred.annotations.explicit=Сделать выведенные аннотации явными
intention.family.move.it=Переместить
intention.family.name.add.main.method=Добавить метод 'main'
intention.family.name.box.primitive.in.conditional.branch=Упаковать примитивное значение в условной ветви
intention.family.name.convert.record.to.class=Преобразовать record в класс
intention.family.name.delete.possible.side.effects=Удалить возможные побочные эффекты
intention.family.name.delete.private.method=Удалить private метод
intention.family.name.dismiss=Закрыть
intention.family.name.extract.possible.side.effects=Извлечь возможные побочные эффекты
intention.family.name.ignore.project=Больше не показывать в этом проекте
intention.family.name.make.sealed=Сделать класс sealed
intention.family.name.move.class.to.test.root=Переместить класс в корень тестов
intention.family.name.rename.to.ignored=Переименовать в игнорируемое
intention.family.name.set.explicit.variable.type=Установить явный тип переменной
intention.family.name.synchronize.inline.snippet=Синхронизовать встроенный фрагмент
intention.family.name.upgrade.jdk=Обновить JDK
intention.family.put.arguments.on.one.line=Поместить аргументы на одну строку
intention.family.put.arguments.on.separate.lines=Поместить аргументы на отдельные строки
intention.family.put.parameters.on.one.line=Поместить параметры на одну строку
intention.family.put.parameters.on.separate.lines=Поместить параметры на отдельные строки
intention.family.put.record.components.on.one.line=Поместить компоненты record на одну строку
intention.family.put.record.components.on.separate.lines=Поместить компоненты record на отдельные строки
intention.family.replace.optional.ispresent.condition.with.functional.style.expression=Заменить условие наличия Optional на функциональное выражение
intention.family.sort.content=Отсортировать содержимое
intention.family.swap.if.statements=Поменять местами операторы 'if'
intention.family.unimplement.interface.class=Отменить реализацию интерфейса/класса
intention.family.variable.access.from.inner.class=Переместить в анонимный объект
intention.implement.abstract.class.default.text=Реализовать абстрактный класс
intention.implement.abstract.class.family=Реализовать абстрактный класс или интерфейс
intention.implement.abstract.method.command.name=Реализовать метод
intention.implement.abstract.method.error.no.classes.message=Не найдено классов, где можно реализовать этот метод
intention.implement.abstract.method.error.no.classes.title=Классы не найдены
intention.implement.abstract.method.family=Реализовать abstract метод
intention.implement.abstract.method.searching.for.descendants.progress=Поиск наследников…
intention.implement.abstract.method.text=Реализовать метод ''{0}''
intention.inline.map.family=Встроить метод отображения потока
intention.inline.map.inline.text=Встроить тело ''{0}()'' в следующий вызов ''{1}()''
intention.inline.map.merge.text=Объединить вызовы ''{0}()'' и ''{1}()''
intention.introduce.variable.text=Ввести локальную переменную
intention.invert.if.condition=Инвертировать условие 'if'
intention.make.final.fixer.if=Сделать ''{0}'' эффективно final перемещением инициализатора в оператор ''if''
intention.make.final.fixer.stream=Сделать ''{0}'' эффективно final используя Stream API
intention.merge.filter.family=Объединить фильтры
intention.merge.filter.text=Объединить цепочку фильтров
intention.move.field.assignment.to.declaration=Переместить присваивание в объявление поля
intention.move.initializer.to.constructor=Переместить инициализатор в конструктор
intention.move.initializer.to.set.up=Переместить инициализатор в метод setUp
intention.name.collapse.into.loop=Свернуть в цикл
intention.name.copy.to.final.temp.variable=Скопировать ''{0}'' в {1, choice, 0\#|1\#эффективно }final временную переменную
intention.name.delete.method=Удалить метод ''{0}()''
intention.name.delete.method.only=... и ничего больше
intention.name.delete.method.title=Удалить метод ''{0}()''
intention.name.delete.method.with.callees=... вместе с другими private методами, используемыми только там
intention.name.extract.method.to.new.interface=Извлечь метод ''{0}'' в новый интерфейс
intention.name.iterate.over=Итерировать по {0}
intention.name.make.variable.final=Сделать {1, choice, 0\#''{0}''|1\#переменные} final
intention.name.move.class.to.test.root=Переместить ''{0}'' в корень тестов
intention.name.move.into.if.branches=Переместить вверх в ветки оператора 'if'
intention.name.pull.method.up=Поднять метод ''{0}''
intention.name.pull.method.up.and.make.it.abstract.conditionally=Поднять метод ''{0}'' в ''{1}''{2, choice, 0\# и сделать его абстрактным|1\#}
intention.name.pull.method.up.make.it.abstract=Поднять метод ''{0}'' и сделать его абстрактным
intention.name.set.variable.type=Установить тип переменной ''{0}''
intention.name.transform.variables.into.final.one.element.array=Преобразовать {1, choice, 0\#''{0}''|1\#переменные} в final массив с одним элементом
intention.name.upgrade.jdk.to=Обновить JDK до {0}+
intention.override.method.text=Переопределить метод ''{0}''
intention.replace.concatenation.with.formatted.output.family=Заменить конкатенацию форматованным выводом
intention.replace.concatenation.with.formatted.output.text=Заменить '+' на 'java.text.MessageFormat.format()'
intention.sequenced.collection.can.be.used.display.name=Можно использовать метод SequencedCollection
intention.sequenced.collection.can.be.used.fix.name=Заменить на вызов метода SequencedCollection
intention.split.declaration.assignment.text=Разделить на объявление и присваивание
intention.split.declaration.family=Разделить объявление
intention.split.filter.family=Разделить фильтр
intention.split.filter.text=Разделить на цепочку фильтров
intention.split.if.family=Разделить 'if'
intention.split.if.text=Разделить на 2 оператора 'if'
intention.split.switch.branch.with.several.case.values.copy.text=Копировать ветку 'switch'
intention.split.switch.branch.with.several.case.values.family=Разделить ветку switch с несколькими значениями case на отдельные ветки 'switch'
intention.split.switch.branch.with.several.case.values.split.text=Разделить значения ветки 'switch'
intention.surround.resource.with.ARM.block=Обернуть в блок try-with-resources
intention.surround.with.ARM.block.template=try-with-resources
intention.text.add.method.contract.to.0=Добавить контракт метода к ''{0}()''…
intention.text.add.range.to.0=Добавить диапазон к ''{0}''…
intention.text.annotate.externally=Аннотировать извне
intention.text.collapse.repeating.annotations=Свернуть повторяющиеся аннотации
intention.text.create.a.class.in.0=Создать класс в ''{0}''
intention.text.create.a.class.in.package.preview=Открывает диалог для создания класса в пакете ''{0}''
intention.text.edit.method.contract.of.0=Редактировать контракт метода ''{0}()''…
intention.text.edit.range.of.0=Редактировать диапазон ''{0}''…
intention.text.fix.method.0.parameters.with.bounded.wildcards=Исправить параметры метода ''{0}'' с ограниченными wildcard-типами
intention.text.generate.missing.test.methods=Сгенерировать отсутствующие тестовые методы
intention.text.implements.list.remove.others=Удалить другие ссылки на ''{0}''
intention.text.replace.all.delete.import=Заменить все и удалить import
intention.text.replace.implements.with.static.import=Заменить implements на static import
intention.text.replace.static.import.with.qualified.access.to.0=Заменить static import на квалифицированный доступ к {0}
intention.text.replace.this.occurrence.keep.import=Заменить это вхождение и сохранить import
intention.text.unimplement.0=Отменить реализацию {0}
intention.unroll.loop.family=Развернуть цикл
intention.unwrap.else.branch=Развернуть ветку 'else'
intention.unwrap.else.branch.changes.semantics=Развернуть ветку 'else' (изменяет семантику)
intention.use.single.member.static.import.text=Использовать static import для ''{0}''
intention.wrap.with.unmodifiable=Обернуть в неизменяемую коллекцию или отображение
intention.wrap.with.unmodifiable.list=Обернуть в неизменяемый список
intention.wrap.with.unmodifiable.map=Обернуть в неизменяемое отображение
intention.wrap.with.unmodifiable.set=Обернуть в неизменяемое множество
interface.not.allowed=Интерфейс не разрешен
interfaces.cannot.be.inlined=Интерфейсы нельзя встроить
introduce.functional.variable.accessibility.conflict=Переменная {0} не является эффективно final и не будет доступна внутри функционального выражения
introduce.functional.variable.interface.chooser.title=Выберите подходящий функциональный интерфейс\: {0} -> {1}
introduce.functional.variable.nothing.found.message=Не найдено подходящих функциональных интерфейсов
introduce.parameter.advertisement.text=Нажмите {0} для делегирования через перегруженный метод или {1} для отображения дополнительных опций
introduce.parameter.inlay.title.delegate=Делегировать
introduce.parameter.inlay.tooltip.delegate=Делегировать через перегруженный метод
introduce.parameter.object.no.accessor.conflict.message=Для поля ''{1}'' требуется {0, choice, 0\#геттер|1\#сеттер}
introduce.variable.change.semantics.warning=Извлечение выбранного выражения изменит семантику всего выражения.
introduce.variable.change.type.adv=Нажмите {0} для изменения типа
introduce.variable.reassign.adv=Нажмите {0} для переназначения существующей переменной
invalid.extracted.class.name=''{0}'' - недопустимое имя извлеченного класса
invert.quickfix.preview=Открывает диалог для инвертирования выбранного логического значения и выбора его нового имени.
java.completion.tag={0, choice, 1\#Тег\:|2\#Теги\:}
java.configurable.logger.identifier.long=Идентификатор слишком длинный
java.configurable.logger.not.found=Логгер не найден в проекте
java.configurable.logger.unspecified=Не указан
java.implicit.types.lambda.inlay.provider.name=Типы параметров лямбда-выражений
java.implicit.types.local.inlay.provider.name=Неявные типы
java.line.markers=Маркеры строк Java
java.method.chains.inlay.provider.name=Цепочки методов
java.platform.module.system.name=Модульная система Java Platform
java.preview.features.accept.notification.link=Принять
java.preview.features.alert.title=Предупреждение об экспериментальной функции
java.preview.features.legal.notice=Вы должны принять условия юридического уведомления бета-версии спецификации Java для включения поддержки "{0}".<br/><br/><b>Реализация предварительной версии спецификации, разработанной в рамках Java Community Process (JCP), доступна только для тестования и оценки и не совместима ни с одной спецификацией JCP.</b>{1}
java.preview.features.notification.title=Предварительные функции Java
java.preview.features.unsupported=Языковой уровень Java <b>{0} (Preview)</b>, используемый в этом проекте, больше не поддерживается. Анализ кода для предварительных функций может работать некорректно.<br>Настоятельно рекомендуется перейти на более новую версию Java или прекратить использование предварительных функций.
java.preview.features.unsupported.title=Неподдерживаемые предварительные функции Java
java.preview.features.warning=Более новые версии ИСР могут прекратить поддержку предварительных функций Java. После выхода Java {0} поддержка языкового уровня {1} (Preview) может быть прекращена.
java.preview.level={0} (Preview)
java.terms.exception=исключение
java.terms.instance.initializer=инициализатор экземпляра
java.terms.of.annotation.type={0} типа аннотации {1}
java.terms.of.anonymous.class={0} анонимного класса
java.terms.of.class={0} класса {1}
java.terms.of.enum={0} перечисления {1}
java.terms.of.interface={0} интерфейса {1}
java.terms.region=регион
java.terms.static.initializer=статический инициализатор
java.terms.type.parameter=параметр типа
java.terms.variable.of.method={0}/{1}
javadoc.apiNote=Примечание к API\:
javadoc.author=Автор\:
javadoc.candidates.not.found=<html>Не найдено кандидатов для вызова метода <b>{0}</b>.</html>
javadoc.constructor.candidates=<html>Кандидаты для new <b>{0}</b>() это\:<br>{1}</html>
javadoc.deprecated=Устарело
javadoc.description.copied.from.class=Из класса\:
javadoc.description.copied.from.field=Из поля\:
javadoc.description.copied.from.interface=Из интерфейса\:
javadoc.description.inferred.annotation.hint=i
javadoc.documentation.url.checked=Проверены следующие {0, choice, 1\#URL-адрес|2\#URL-адреса} документации\:
javadoc.edit.api.docs.paths=Редактировать пути к документации API
javadoc.gen.error.module.source.path.is.not.evaluated=ИСРA не может сгенерировать Javadoc, так как невозможно вычислить module-source-path
javadoc.gen.error.modules.without.module.info=ИСРA не может сгенерировать Javadoc, так как модули {0} не содержат файл module-info.java
javadoc.generate.arguments=Аргументы командной строки\:
javadoc.generate.exited=\n"javadoc" завершился с кодом выхода $EXIT_CODE$
javadoc.generate.heap.size=&Максимальный размер кучи\:
javadoc.generate.include.jdk.library.sources.in.sourcepath.option=Включить исходники JDK и библиотек в -sourcepath
javadoc.generate.link.to.jdk.documentation.option=Ссылка на документацию JDK (использовать опцию -link)
javadoc.generate.locale=&Локаль\:
javadoc.generate.no.classes.in.selected.packages.error=Выбранная область не содержит Java-классов
javadoc.generate.no.javadoc.tool=Невозможно сгенерировать JavaDoc - инструмент javadoc не найден в {0} или {1}. Укажите корректный Java SDK в Настройки | Структура проекта.
javadoc.generate.no.jdk=Невозможно сгенерировать JavaDoc - для проекта не настроен Java SDK. Укажите Java SDK в Настройки | Структура проекта.
javadoc.generate.ok=Сгенерировать
javadoc.generate.open.in.browser=Открыть с&генерированную документацию в браузере
javadoc.generate.options.hierarchy=Генерировать дерево иерархии
javadoc.generate.options.index=Генерировать индекс
javadoc.generate.options.index.per.letter=Отдельный индекс для каждой буквы
javadoc.generate.options.navigator=Генерировать панель навигации
javadoc.generate.options.separator=Параметры JavaDoc
javadoc.generate.output.directory=Каталог вывода  [&D]\:
javadoc.generate.output.directory.browse=Выбрать каталог вывода
javadoc.generate.scope.row=Уровень видимости\:
javadoc.generate.sources.progress=Поиск исходников для генерации Javadoc
javadoc.generate.tag.list.deprecated=Список устаревших элементов
javadoc.generate.temp.file.does.not.exist=Временный файл не существует или не может быть открыт
javadoc.generate.temp.file.error=Невозможно создать временный файл
javadoc.generate.title=Сгенерировать JavaDoc
javadoc.generate.validation.error=Укажите каталог вывода.
javadoc.implNote=Примечание к<br>реализации\:
javadoc.implSpec=Требования к<br>реализации\:
javadoc.method.in.class={0} в классе {1}
javadoc.method.in.interface={0} в интерфейсе {1}
javadoc.method.overrides=Переопределяет\:
javadoc.method.specified.by=Определено в\:
javadoc.option.automatically.insert.closing.tag.javadoc=Автоматически вставлять закрывающий тег в JavaDoc
javadoc.option.javadoc.title=JavaDoc
javadoc.see.also=См. также\:
javadoc.settings.title=Javadoc
javadoc.since=С версии\:
javadoc.snippet.error.both.substring.and.regex=@{0}\: должен быть указан либо regex, либо substring, но не оба
javadoc.snippet.error.duplicate.attribute=@{0}\: дублирующийся атрибут\: ''{1}''
javadoc.snippet.error.malformed.regular.expression=@{0}\: некорректное регулярное выражение\: {1}
javadoc.snippet.error.malformed.replacement=@{0}\: некорректная замена регулярного выражения ''{1}''\: {2}
javadoc.snippet.error.markup.tag.expected=Ожидается тег разметки или атрибут
javadoc.snippet.error.missing.required.attribute=@{0}\: отсутствует атрибут ''{1}''
javadoc.snippet.error.regex.too.complex=@{0}\: слишком сложное регулярное выражение ''{1}''
javadoc.snippet.error.unknown.enum.value=@{0}\: неизвестное значение {1} ''{2}''; поддерживаются только {3}
javadoc.snippet.error.unsupported.attribute=@{0}\: неподдерживаемый атрибут\: ''{1}''
javadoc.snippet.not.found=Сниппет не найден\: {0}
javadoc.snippet.region.not.found=Регион не найден\: {0}
javadoc.type.parameters=Параметры типа\:
javadoc.version=Версия\:
jrt.node.short=[JRT]
jvm.logging.configurable.display.name=Логирование JVM
jvm.logging.configurable.id=jvm.logging
jvm.logging.configurable.java.group.display.name=Java
label.add.math.max.0.count.to.avoid.possible.semantics.change=Добавить Math.max(0, count) во избежание возможного изменения семантики
label.canonical.constructor=Канонический конструктор
label.class.filter.editor.add.dialog.filter.pattern=Введите шаблон фильтра\:
label.class.pattern.syntax.explanation=Оставьте метод пустым для обозначения конструкторов\nЛюбой символ * будет соответствовать одному или нескольким символам в полном имени (включая точки)
label.compact.constructor=Компактный конструктор
label.configurable.logger.generation.variable.name=Имя переменной\:
label.configurable.logger.type=Логгер\:
label.contract=&Контракт\:
label.enter.fully.qualified.class.name=Введите полное имя класса
label.entry.points=Точки входа\:
label.forbid.api.usages=Запретить использование API новее чем
label.forbid.api.usages.project=(согласно настройкам проекта)
label.from.inclusive=&От (включительно)\:
label.ignore.complicated.fix=Игнорировать, когда быстрое исправление невозможно
label.ignored.exceptions=Игнорируемые исключения\:
label.implementation=Реализация\:
label.implements.method.of_class_or_interface.name=реализует метод {0, choice, 0\#интерфейса|1\#класса} ''{1}''.
label.implements.method.of_interfaces=реализует методы следующих классов/интерфейсов\:
label.jvm.class.name=Имя класса JVM
label.jvm.field.name=Имя поля JVM
label.jvm.method.name=Имя метода JVM
label.maximal.reported.method.visibility=Максимальная видимость метода\:
label.method=Метод ''{0}''
label.minimal.reported.method.usage.count=Минимальное количество использований метода для отчёта о параметре\:
label.mutates=&Изменяет\:
label.name.prefix=Префикс имени\:
label.name.suffix=Суффикс имени\:
label.naming.field=Поле\:
label.naming.local.variable=Локальная переменная\:
label.naming.parameter=Параметр\:
label.naming.static.field=Static поле\:
label.naming.subclass=Подкласс\:
label.naming.test.class=Тестовый класс\:
label.new.template.name=Имя нового шаблона\:
label.overrides.method.of_class_or_interface.name=переопределяет метод {0, choice, 0\#интерфейса|1\#класса} ''{1}''.
label.show.import.popup.for=Показывать подсказку автоимпорта для\:
label.to.inclusive=До (включительно) [&T]\:
label.unused.declaration.reachable.from.tests.option=Когда точки входа находятся в тестовых исходниках, помечать вызываемые методы как\:
lambda.tree.node.presentation=Lambda
leave.in.same.source.root.item=Оставить в том же корне исходников
library.classes.cannot.be.inlined=Классы библиотеки не могут быть встроены
line.marker.recursive.call=Рекурсивный вызов
line.marker.type.external.annotations=Внешние аннотации
line.marker.type.inferred.contract.annotations=Выведенные аннотации контракта
line.marker.type.inferred.nullability.annotations=Выведенные аннотации обнуляемости
link.configurable.logger.generator.display.name=<a href\='link'>Настройки</a>
link.configure.classes.excluded.from.completion=Настроить классы, исключенные из автодополнения
list.item.configuration=[конфигурация] {0}
list.item.suite=[сюита] {0}
listbox.import.package=Пакет
listbox.import.static=Static
listbox.import.with.subpackages=С подпакетами
live.template.context.consumer.function=Функция-потребитель
live.template.context.declaration=Объявление
live.template.context.else=Позиция 'else'
live.template.context.expression=Выражение
live.template.context.statement=Оператор
loading.additional.annotations=Загрузка дополнительных аннотаций…
macro.array.variable=arrayVariable()
macro.class.name=Имя класса
macro.classpath.entry=Элемент в classpath, к которому принадлежит элемент
macro.component.type.of.array=componentTypeOf(Array)
macro.descendant.classes.enum=descendantClassesEnum(String)
macro.expression.type=expressionType(Expression)
macro.file.fully.qualified.package=Полное имя пакета файла
macro.file.package=Пакет файла
macro.guess.element.type.of.container=guessElementType(Container)
macro.iterable.component.type=iterableComponentType(ArrayOrIterable)
macro.iterable.variable=iterableVariable()
macro.javadoc.output.directory=Директория вывода JavaDoc
macro.project.classpath=Classpath проекта
macro.variable.of.type=variableOfType(Type)
megabytes.unit=МБ
methods.to.implement.chooser.title=Выберите методы для реализации
methods.to.override.chooser.title=Выберите методы для переопределения
methods.to.override.generate.javadoc=Сгенерировать отсутствующий JavaDoc
methods.to.override.implement.chooser.title=Выберите методы для переопределения/реализации
module.not.in.requirements=Модуль ''{0}'' не содержит модуль ''{1}'' в требованиях
module.package.not.exported=Модуль ''{0}'' не экспортует пакет ''{1}'' в модуль ''{2}''
module.package.not.open=Модуль ''{0}'' не открывает пакет ''{1}'' для модуля ''{2}''
module.type.java.description=Java модули используются для разработки <b>JVM-based</b> десктопных и веб-приложений, включая приложения, использующие <b>Java EE</b> и другие фреймворки для корпоративной разработки.
module.type.java.name=Java модуль
move.class.import.from.default.package.conflict={0} не будет доступен из пакета по умолчанию
move.classes.destination.class.not.found.message=Целевой класс не найден
move.classes.invalid.destination.package.name.message=''{0}'' является недопустимым именем целевого пакета
move.inner.select.target.package.title=Выберите целевой пакет
move.member.enum.conflict=Тип enum не будет применим в текущем контексте
move.member.final.initializer.conflict=Инициализатор final {0} будет оставлен.
multiple.usages.of.static.import.found=Найдено несколько использований статического импорта
navigate.to.duplicate.fix=Перейти к дубликату
new.line.when.body.is.presented=Новая строка при наличии тела
no.jre.description=<нет JRE>
no.methods.overriding.0.are.found=Не найдены методы, переопределяющие {0, choice, 0\#|1\#''{1}''|2\#эти классы}
no.patterns=Не настроены шаблоны классов
node.call.hierarchy.unknown.jsp=неизвестный jsp
node.hierarchy.java.lang.object=Все классы наследуются от java.lang.Object
non.code.annotations.explanation.external.and.inferred.available=Доступны внешние и <i>выведенные</i> аннотации.
non.code.annotations.explanation.external.available=Доступны внешние аннотации.
non.code.annotations.explanation.full.signature=Полная сигнатура\:
non.code.annotations.explanation.inferred.available=Доступны <i>выведенные</i> аннотации.
notification.content.added.annotations=Добавлено {0} {0, choice, 1\#аннотация|2\#аннотации|5\#аннотаций}
notification.content.change.jdk=Изменить JDK
notification.content.was.set.up=JDK ''{0}'' был настроен для проекта
notification.group.arch.checker=Архитектуры JDK и системы различаются
notification.group.jdk.resolve.problems=Не удалось разрешить JDK
notification.group.jshell=Возникла проблема с JShell
notification.group.language.level=Предварительный уровень языка Java требует принятия лицензии
notification.group.legacy.library=Устаревшая библиотека зависит от установки ИСР
notification.group.preview.features=Предварительный уровень языка Java может быть прекращен
notification.group.redundant.exports=Избыточные exports/opens могут быть удалены
notification.group.repository=JAR файлы синхронизованы с репозиторием
notification.group.setup.external.annotations=Не удалось загрузить внешние аннотации
notification.group.setup.jdk=JDK настроен
notification.group.source.searcher=Не удалось найти исходники для JAR файла
notification.group.testintegration=Не удалось сгенерировать тесты для @TestDataPath
notification.navigation.to.overriding.classes=Навигация к переопределяющим классам невозможна во время обновления индекса
notification.navigation.to.overriding.methods=Навигация к переопределяющим методам невозможна во время обновления индекса
notification.text.full.thread.dump.was.successfully.copied.to.clipboard=Полный дамп потоков успешно скопирован в буфер обмена
null.check.surrounder.description=if (expr \!\= null) {...}
nullable.notnull.annotation.used.label=Аннотация, используемая для генерации кода\:
nullable.notnull.annotations.panel.title=Аннотации {0}\:
nullable.notnull.annotations.runtime.instrumentation.tooltip=Добавить проверки времени выполнения для методов и параметров с аннотацией notnull
nullable.notnull.configuration.dialog.title=Настройка Nullable/NotNull
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=Перейти к использованию аргумента 'null'
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.preview=Показывает список использований, где 'null' передается как аргумент.
nullable.stuff.inspection.navigate.null.argument.usages.view.name=Использования аргумента ''null'' для параметра {0}
offline.inspections.jdk.not.found=Не найден {0}
offline.inspections.library.urls.were.not.resolved=Корни {0} библиотеки ''{1}'' из модуля ''{2}'' не были разрешены
offline.inspections.library.was.not.resolved=Пожалуйста, настройте библиотеку ''{0}'', используемую в модуле ''{1}''
offline.inspections.no.source.roots=Не обнаружены корни исходников для модуля ''{0}''
open.settings.dialog.for.module.preview.text=Открыть диалог настроек для модуля ''{0}''
options.java.attribute.descriptor.abstract.class=Классы и интерфейсы//Абстрактный класс
options.java.attribute.descriptor.abstract.method=Методы//Abstract метод
options.java.attribute.descriptor.annotation.attribute.name=Аннотации//Имя атрибута аннотации
options.java.attribute.descriptor.annotation.name=Аннотации//Имя аннотации
options.java.attribute.descriptor.anonymous.class=Классы и интерфейсы//Анонимный класс
options.java.attribute.descriptor.class=Классы и интерфейсы//Класс
options.java.attribute.descriptor.constructor.call=Методы//Вызов конструктора
options.java.attribute.descriptor.constructor.declaration=Методы//Объявление конструктора
options.java.attribute.descriptor.enum=Классы и интерфейсы//Enum
options.java.attribute.descriptor.implicit.anonymous.parameter=Параметры//Неявный параметр анонимного класса
options.java.attribute.descriptor.inherited.method=Методы//Унаследованный метод
options.java.attribute.descriptor.instance.field=Поля класса//Поле экземпляра
options.java.attribute.descriptor.instance.final.field=Поля класса//Final поле экземпляра
options.java.attribute.descriptor.interface=Классы и интерфейсы//Интерфейс
options.java.attribute.descriptor.javadoc.comment=Комментарии//JavaDoc//Текст
options.java.attribute.descriptor.javadoc.markup=Комментарии//JavaDoc//Разметка
options.java.attribute.descriptor.javadoc.tag=Комментарии//JavaDoc//Тег
options.java.attribute.descriptor.javadoc.tag.value=Комментарии//JavaDoc//Значение тега
options.java.attribute.descriptor.lambda.parameter=Параметры//Lambda параметр
options.java.attribute.descriptor.method.call=Методы//Вызов метода
options.java.attribute.descriptor.method.declaration=Методы//Объявление метода
options.java.attribute.descriptor.method.imported.call=Методы//Вызов статически импортованного метода
options.java.attribute.descriptor.package.private=Видимость//Package-private
options.java.attribute.descriptor.private=Видимость//Private
options.java.attribute.descriptor.protected=Видимость//Protected
options.java.attribute.descriptor.public=Видимость//Public
options.java.attribute.descriptor.reassigned.local.variable=Переменные//Переприсвоенная локальная переменная
options.java.attribute.descriptor.reassigned.parameter=Параметры//Переприсвоенный параметр
options.java.attribute.descriptor.static.field=Поля класса//Статическое поле
options.java.attribute.descriptor.static.final.field=Поля класса//Константа (static final поле)
options.java.attribute.descriptor.static.final.imported.field=Поля класса//Константа (static final импортованное поле)
options.java.attribute.descriptor.static.imported.field=Поля класса//Static импортованное поле
options.java.attribute.descriptor.static.method=Методы//Статический метод
options.java.attribute.descriptor.type.parameter=Параметры//Параметр типа
options.java.display.name=Java
override.implement.broken.file.template.message=Пожалуйста, исправьте шаблон "Тело переопределённого/реализованного метода"
override.implement.broken.file.template.title=Ошибка шаблона файла
override.methods.error.no.methods=Не найдены методы для переопределения
package.chooser.modal.progress.title=Поиск пакетов…
package.classes=Классы пакета\:
package.dependencies.production.node.text=Производственные классы
package.dependencies.test.node.text=Тестовые классы
package.pattern.provider.hint.label=Используйте <b>*.txt</b> для поиска всех файлов 'txt' в проекте, <b>file\:path_in_project//*</b> для рекурсивного поиска всех файлов в директории, <b>src\:foo..*</b> для рекурсивного поиска всех классов в пакете.
packaging.jlink.artifact.name=JLink
packaging.jlink.artifact.title=Runtime-образ (JLink)
packaging.jlink.compression.first.level=Разделение строк
packaging.jlink.compression.level=Уровень сжатия
packaging.jlink.compression.second.level=Zip
packaging.jlink.compression.zero.level=Без сжатия
packaging.jlink.verbose.tracing=Включить подробную трассировку
paste.class.command.name=Вставить класс ''{0}''
please.report.a.bug=Пожалуйста, сообщите об ошибке
popup.content.tests.were.not.found.in.module=Тесты не найдены в модуле ''{0}''.\n
popup.content.tests.were.not.found.in.module.search.in.dependencies=Искать в зависимостях модуля
popup.content.tests.were.not.found.in.module.use.instead=Используйте {0, choice, 0\#модуль {1} |1\#один из\n{2}\n}вместо этого
popup.title.choose.framework=Выбрать фреймворк
popup.title.choose.target.class=Выбрать целевой класс
popup.title.choose.test=Выбрать тест
popup.title.debug.recent.tests=Отладка последних тестов
popup.title.remove.unused.variable=Удалить неиспользуемую переменную
popup.title.select.a.jar.file=Выбрать JAR файл
popup.title.select.qualified.name=Выбрать полное имя
popup.title.select.target.code.block=Выбрать целевой блок кода
postfix.template.condition.array.name=массив
postfix.template.condition.boolean.name=boolean
postfix.template.condition.non.void.name=не void
postfix.template.condition.not.primitive.type.name=не примитивный тип
postfix.template.condition.number.name=число
postfix.template.condition.void.name=void
postfix.template.editor.choose.class.title=Выбрать класс
postfix.template.language.level.title=Минимальный уровень языка\:
postfix.template.provider.name=Java
presentable.text.anonymous.class=Анонимный класс
presentable.text.code.display=Код
presentable.text.code.from.context=Код из {0}
presentable.text.invalid.element.name=НЕДОПУСТИМО
press.0.to.see.inheritors.of.1=Нажмите {0}, чтобы увидеть наследников {1}
press.0.to.see.non.imported.classes=Нажмите {0}, чтобы увидеть неимпортованные классы
pressing.0.twice.without.a.class.qualifier=Двойное нажатие {0} без квалификатора класса покажет все доступные статические методы
progress.creating.class=Создание класса {0}
progress.title.calculate.applicable.types=Вычисление применимых типов…
progress.title.check.applicability=Проверка применимости…
progress.title.checking.if.class.exists=Проверка существования целевого класса ''{0}''
progress.title.collect.method.overriders=Сбор переопределяющих методов…
progress.title.detect.overridden.methods=Проверка переопределённых методов
progress.title.detecting.jdk=Определение JDK
progress.title.download.library.descriptor=Загрузка дескриптора библиотеки
progress.title.find.references.in.implement.extends.lists=Поиск ссылок в списках Implement/Extends…
progress.title.finding.cause=Поиск причины
progress.title.looking.for.jdk=Поиск JDK…
progress.title.looking.for.libraries=Поиск библиотек
progress.title.optimize.imports=Оптимизация импортов…
progress.title.preprocess.usages=Предварительная обработка использований
progress.title.restore.references=Восстановление ссылок
progress.title.search.for.overriding.methods=Поиск переопределяющих методов…
progress.title.searching.for.sub.classes=Поиск подклассов
project.problems.fix.description=Найдены проблемы, связанные с ''{0}''
project.problems.fix.text=Показать связанные проблемы
project.problems.hint.text={0} связанных {0, choice, 0\#проблем|1\#проблема|2\#проблемы|5\#проблем}
project.problems.title=Связанные проблемы
project.problems.window.title=Проблемы, связанные с {0}
prompt.choose.base.class.of.the.hierarchy=Выберите базовый класс иерархии для поиска
prompt.create.non.existing.package=Пакет {0} не существует.\nСоздать его?
prompt.delete.class={0,choice,1\#класс|2\#класса}
prompt.delete.field={0,choice,1\#поле|2\#поля}
prompt.delete.interface={0,choice,1\#интерфейс|2\#интерфейса}
prompt.delete.method={0,choice,1\#метод|2\#метода}
prompt.delete.package={0,choice,1\#пакет|2\#пакета}
prompt.delete.type.parameter={0,choice,1\#параметр типа|2\#параметра типа}
prompt.do.you.want.to.action_verb.the.method.from_class=Хотите {1} базовый {0,choice,1\#метод|2\#метода} вместо этого?
psi.error.incorrect.class.template.message=Невозможно создать {0} - некорректный шаблон {1}.
psi.search.overriding.progress=Поиск переопределяющих методов…
pull.members.up.fix.name=Поднять члены класса
pull.up.accessible.conflict={0} будет недоступен
pull.up.accessible.conflict.1={0} будет недоступен из {1}
pull.up.concrete.inherit.abstract.method.conflict=Конкретный {0} унаследует новый абстрактный метод
pull.up.members.usage.view.description.code.references.node=Класс для поднятия членов в "{0}"
pull.up.members.usage.view.description.processed.elements.node=Поднять члены из класса {0}
push.down.anonymous.conflict=Невозможно передать реализацию в анонимный класс
push.down.missed.implementation.conflict=Неабстрактный {0} будет пропускать реализацию {1}
push.down.static.nonstatic.conflict=Статический {0} нельзя передать в нестатический {1}
push.down.super.method.call.changed.conflict=Вызов метода super будет разрешен в другой метод
push.method.down.command.name=Опустить метод…
qualify.static.access.command.name=Уточнить статический доступ
qualify.static.call.fix.text=Уточнить статический вызов
qualify.static.constant.access=Уточнить доступ к статической константе
quickfix.add.variable.family.name=Инициализовать переменную
quickfix.add.variable.text=Инициализовать переменную ''{0}''
quickfix.family.avoid.mutation.using.stream.api=Избежать мутации с помощью Stream API
quickfix.family.change.javadoc.to=Изменить на…
quickfix.family.find.cause=Найти причину
quickfix.family.remove.javadoc.tag=Удалить тег
quickfix.family.remove.redundant.parameter=Удалить избыточный параметр
quickfix.family.remove.redundant.parameter.types=Удалить избыточные типы параметров
quickfix.family.replace.cast.type=Заменить тип приведения
quickfix.family.replace.inefficient.stream.count=Заменить неэффективный Stream.count()
quickfix.family.replace.optional.chain.with.if.statements=Заменить цепочку Optional на операторы if
quickfix.family.replace.stream.api.chain.with.loop=Заменить цепочку Stream API на цикл
quickfix.family.replace.with.java.stream.api.pipeline=Заменить на конвейер Java Stream API
quickfix.family.replace.with.magic.constant=Заменить магической константой
quickfix.family.replace.with.method.reference=Заменить ссылкой на метод
quickfix.family.replace.with.optional.of.nullable.chain=Заменить на цепочку Optional.ofNullable()
quickfix.family.replace.with.stream.api.equivalent=Заменить эквивалентом Stream API
quickfix.family.simplify.foreach.lambda=Упростить лямбда-выражение forEach
quickfix.family.simplify.stream.call.chain=Упростить цепочку вызовов потока
quickfix.family.use.flatmap=Использовать 'flatMap'
quickfix.family.wrap.with.mutable.collection=Обернуть изменяемой коллекцией
quickfix.find.cause.description=Пытается подсветить элементы кода, которые привели к этому предупреждению, и объяснить, как именно они влияют.
quickfix.name.find.jar.on.web=Найти JAR в интернете
quickfix.text.0.may.not.work.before.jdk.11.0.2={0} (может не работать до JDK 11.0.2)
quickfix.text.avoid.mutation.using.stream.api.0.operation=Избежать мутации с помощью операции Stream API ''{0}()''
quickfix.text.remove.javadoc.0=Удалить тег ''@{0}''
quickfix.text.remove.javadoc.0.1=Удалить @{0} {1}
quickfix.text.remove.not.null.annotation=Удалить аннотацию not-null
quickfix.text.replace.0.stream.with.1.2=Заменить {0}.stream() на {1}.{2}()
quickfix.text.replace.collect.0.with.1.2=Заменить ''collect({0}())'' на ''{1}''{2}
quickfix.text.replace.filter.0.is.present.with.any.match=Заменить ''filter().{0}().isPresent()'' на ''anyMatch()''
quickfix.text.replace.stream.0.with.1.2=Заменить ''stream().{0}()'' на ''{1}()''{2}
quickfix.text.replace.url.with.link=Заменить URL ссылкой
quickfix.text.suffix.may.change.semantics=\ (может изменить семантику)
quickfix.text.wrap.0.with.1=Обернуть ''{0}'' в ''{1}''
radio.button.subclass.of.0=Подкласс ''{0}''
radio.button.unused.declaration.unused.option=не используется
radio.button.unused.declaration.used.option=используется
radio.button.with.provider.method=С методом 'provider()'
radio.use.fully.qualified.class.names.in.javadoc=Использовать полные имена классов в JavaDoc\:
radio.use.fully.qualified.class.names.in.javadoc.always=Всегда
radio.use.fully.qualified.class.names.in.javadoc.if.not.imported=Если еще не импортован
radio.use.fully.qualified.class.names.in.javadoc.never=Никогда, использовать короткое имя и добавить импорт
raw.use.of.parameterized.type.ignore.new.objects.option=Игнорировать создание новых объектов
raw.use.of.parameterized.type.ignore.overridden.parameter.option=Игнорировать типы параметров переопределяющих методов
raw.use.of.parameterized.type.ignore.quickfix.not.available.option=Игнорировать, когда автоматическое исправление недоступно
raw.use.of.parameterized.type.ignore.type.casts.option=Игнорировать приведения типов
raw.use.of.parameterized.type.ignore.uncompilable.option=Игнорировать случаи, когда параметр типа не скомпилируется
raw.variable.type.can.be.generic.cast.quickfix=Изменить тип приведения на {0}
raw.variable.type.can.be.generic.cast.quickfix.family=Параметризовать тип приведения
raw.variable.type.can.be.generic.family.quickfix=Добавить параметры обобщенного типа
raw.variable.type.can.be.generic.quickfix=Изменить тип {0} на {1}
records.cannot.be.inlined=Классы-записи не могут быть встроены
refactoring.method.reference.to.lambda.conflict=Ссылка на метод будет преобразована в лямбда-выражение
remove.var.keyword.text=Удалить 'var'
rename.package.class.already.exist.conflict=Класс с полным именем ''{0}'' уже существует
rename.package.command.name=Переименовать пакет
rename.package.ignored.name.warning=Попытка создать пакет с игнорируемым именем, результат не будет виден
rename.package.invalid.name.error=Недопустимое имя пакета
rename.super.base.chooser.popup.title={0} {1, choice, 0\#реализует|1\#переопределяет} метод {2}
rename.super.methods.chooser.popup.title={0} имеет методы super
replace.implements.with.static.import.field.usages.progress=Поиск использований константных полей…
scheduled.thread.pool.executor.with.zero.core.threads.description='ScheduledThreadPoolExecutor' не должен иметь нулевое количество основных потоков
scheduled.thread.pool.executor.with.zero.core.threads.display.name='ScheduledThreadPoolExecutor' с нулевым количеством основных потоков
scope.hierarchy=Иерархия {0}
sdk.cannot.create=Невозможно создать SDK
sdk.configured=''{0}'' установлен как JDK проекта.
sdk.configured.external.config.title=JDK настроен ({0})
sdk.java.no.classes=Не удаётся найти классы JDK в ''{0}''
section.title.inspection.suspicious.names.ignore.methods=Игнорировать методы\:
separator.annotations.to.copy=Аннотации для копирования
separator.mark.as.entry.point.if.annotated.by=Пометить как точку входа, если аннотировано\:
separator.mark.field.as.implicitly.written.if.annotated.by=Пометить поле как неявно записываемое, если аннотировано\:
set.language.level=Установить уровень языка
set.language.level.to.0=Установить уровень языка на {0}
settings.completion.ml.java.display.name=Java
settings.inlay.java.annotations=Аннотации
settings.inlay.java.builder.like.methods=Методы в стиле builder
settings.inlay.java.complex.expressions.binary.functional.array.access.and.other=Сложные выражения в качестве аргументов
settings.inlay.java.enum.constants=Константы enum
settings.inlay.java.external.annotations=Внешние аннотации
settings.inlay.java.implicit.types.lambda=Типы lambda-выражений
settings.inlay.java.implicit.types.lambda.description=Показывать подсказки для типов параметров lambda-выражений
settings.inlay.java.implicit.types.local=Неявные типы
settings.inlay.java.implicit.types.local.description=Локальные переменные, объявленные с ключевым словом var, когда выведенный тип может быть неочевиден из правой части присваивания, например при использовании фабричного метода.
settings.inlay.java.inferred.annotations=Выведенные аннотации
settings.inlay.java.inheritors=Наследники
settings.inlay.java.insert.annotation=Вставить аннотацию
settings.inlay.java.methods.with.same.named.numbered.parameters=Методы с одноименными нумерованными параметрами
settings.inlay.java.new.expressions=Выражения 'new'
settings.inlay.java.non.literals.in.case.of.multiple.parameters.with.the.same.type=Нелитералы для множественных параметров одного типа
settings.inlay.java.parameters.with.names.that.are.contained.in.the.method.name=Параметры с именами, содержащимися в имени метода
settings.inlay.java.show.hints.for=Показывать подсказки для\:
settings.inlay.java.show.parameter.hints.for=Показывать подсказки параметров для\:
settings.inlay.java.show.parameter.hints.when.expression.type.is.clear.description=Инициализаторы массивов, switch, условные выражения, ссылки, instanceof, присваивания, вызовы, уточнения, приведения типов, доступ к объектам классов.
settings.inlay.java.turn.off.external.annotations=Отключить внешние аннотации
settings.inlay.java.turn.off.inferred.annotations=Отключить выведенные аннотации
settings.inlay.java.usages=Использования
show.import.popup.for.classes=Классы [&C]
show.import.popup.for.static.methods.and.fields=Static методы и поля [&S]
show.siblings.choose.super.class.title=Выберите суперкласс или интерфейс
show.siblings.find.usages.class.title=Суперклассы/интерфейсы
show.siblings.find.usages.method.title=Супер-методы
side.effects.expression.presentation=выражение ''{0}''
side.effects.pattern.message=<html>\n<body>\nОбнаружены возможные побочные эффекты в {0}<br>\nВы можете\:\n<br>\n-\\&nbsp;<b>Удалить</b> использования переменной вместе со всеми связанными выражениями, или<br>\n-\\&nbsp;<b>Преобразовать</b> выражения, присвоенные переменной, в отдельные операторы.<br>\n<div style\="padding-left\: 0.6cm;">\n  То есть,<br>\n  <table border\="0">\n    <tr>\n      <td><code>{1};</code></td>\n    </tr>\n  </table>\n  станет\: <br>\n  <table border\="0">\n    <tr>\n      <td><code>{2};</code></td>\n    </tr>\n  </table>\n</div>\n</body>\n</html>
simplify.optional.chain.inspection.fix.description.optional.chain.can.be.eliminated=Цепочка Optional может быть устранена
simplify.optional.chain.inspection.fix.description.replace.with.value.of.description=Цепочка Optional может быть заменена на 'String.valueOf()'
simplify.optional.chain.inspection.fix.description.replace.with.value.of.name=Заменить на 'String.valueOf()'
simplify.optional.chain.inspection.fix.name.remove.redundant.optional.chain=Удалить избыточную цепочку Optional
simplify.optional.chain.inspection.map.or.else.description=Цепочка Optional может быть упрощена
simplify.optional.chain.inspection.optional.rewrapping.description=Ненужная переупаковка Optional
simplify.optional.chain.inspection.optional.rewrapping.name=Развернуть
simplify.optional.chain.inspection.or.else.non.null.fix.description=Проверка на null может быть устранена с помощью 'ifPresent'
simplify.optional.chain.inspection.or.else.non.null.fix.name=Заменить проверку на null на ifPresent()
simplify.optional.chain.inspection.or.else.return.fix.description=Проверка на null может быть устранена
simplify.optional.chain.inspection.or.else.return.fix.name=Заменить проверку на null на {0}({1})
simplify.optional.chain.inspection.remove.redundant.steps.from.optional.chain=Удалить избыточные шаги из цепочки Optional
simplify.optional.chain.inspection.to.x=Упростить цепочку Optional до ''{0}''
simplify.stream.collection.creation.fix.name=Заменить на конструктор ''{0}''
simplify.stream.inspection.iterate.take.while.fix.message=Можно заменить на трехаргументный 'iterate()'
simplify.stream.inspection.iterate.take.while.fix.name=Заменить на трехаргументный 'iterate()'
simplify.stream.inspection.message.can.be.replaced=''{0}'' можно заменить на ''{1}''
simplify.stream.inspection.message.can.be.replaced.may.change.semantics=''{0}'' можно заменить на ''{1}'' (может изменить семантику)
simplify.stream.match.negation.fix.name=Заменить {0} на {1}(...)
simplify.stream.remove.boolean.identity.fix.message=Можно объединить с предыдущим вызовом 'map()'
simplify.stream.remove.boolean.identity.fix.name=Объединить с предыдущим вызовом 'map()'
simplify.stream.replace.support.with.collection.fix.message=Можно заменить на вызов ''{0}.{1}()''
simplify.stream.replace.support.with.collection.fix.name=Заменить на вызов ''{0}.{1}()''
simplify.stream.replace.with.element.iteration.fix.message=Можно заменить на итерацию по элементам
simplify.stream.simple.stream.of.fix.name.use.stream.element.explicitly=Использовать элемент Stream явно
simplify.stream.simple.stream.of.message=Ненужный однoэлементный Stream
simplify.stream.swap.filter.and.map.fix.message='filter()' и 'map()' можно поменять местами
simplify.stream.swap.filter.and.map.fix.name=Поменять местами 'filter()' и 'map()'
slice.filter.parse.error.enum.constant.not.found=Константа enum не найдена\: {0}
slice.filter.parse.error.expression.must.evaluate.to.constant=Выражение должно вычисляться в константу\: {0}
slice.filter.parse.error.incorrect.constant.expected.number=Некорректная константа (ожидается число)\: {0}
slice.filter.parse.error.incorrect.constant.type=Некорректный тип константы (требуется\: {0})
slice.filter.parse.error.incorrect.expression=Некорректное выражение\: {0}
slice.filter.parse.error.not.null.filter.not.applicable.for.primitive.type=Фильтр ''\!null'' не применим к примитивному типу {0}
slice.filter.parse.error.null.filter.not.applicable.for.primitive.type=Фильтр ''null'' не применим к примитивному типу {0}
slice.usage.message.assertion.violated=(нарушение утверждения\!)
slice.usage.message.in.file.stopped.here=(в файле {0} - остановлено здесь)
slice.usage.message.location=в {0}
slice.usage.message.tracking.container.contents=(Отслеживание содержимого контейнера ''{0}{1}'')
sort.threads.by.name=Сортировать потоки по имени
sort.threads.by.type=Сортировать потоки по типу
special.annotations.annotations.list=Дополнительные специальные аннотации\:
special.annotations.annotations.preview=Добавляет ''@{0}'' в список аннотаций, которые будут игнорироваться этой проверкой
special.annotations.list.add.annotation.class=Добавить класс аннотации
special.annotations.list.annotation.class=Класс аннотации
special.annotations.list.annotation.pattern=Добавить шаблон аннотаций
special.annotations.list.annotation.pattern.message=Добавить шаблон аннотаций
special.annotations.list.remove.pattern=Удалить
spi.extension.error.message=Зарегистрированное расширение должно реализовывать {0}
spi.no.provider.error.message=Сервис-провайдер "{0}" не найден
status.bar.overridden.methods.highlighted.message=Найдено {0} переопределённых {0, choice, 1\#метод|2\#методов} (нажмите {1} снова для снятия подсветки, Escape для снятия всей подсветки)
stream.to.loop.inspection.message.replace.foreach.call.with.loop=Заменить вызов 'forEach()' на цикл
stream.to.loop.inspection.message.replace.stream.api.chain.with.loop=Заменить цепочку Stream API на цикл
surround.with.cast=Окружить приведением типа
surround.with.dowhile.template=do / while
surround.with.for.template=for
surround.with.ifelse.expression.template=if (expr) {...} else {...}
surround.with.not.instanceof.template=\!(expr instanceof Type)
surround.with.runnable.template=Runnable
surround.with.synchronized.template=synchronized
surround.with.try.catch.finally.template=try / catch / finally
surround.with.try.catch.incorrect.template.message=Некорректный шаблон файла для блока catch
surround.with.try.catch.template=try / catch
switch.stmt.template.description=switch (expr) {...}
tab.title.entry.points=Точки входа
tab.title.infer.nullity.preview=Предпросмотр вывода null-значений
tab.title.members.to.report=Элементы для отчёта
tab.title.slices.grouped.by.nullness=\ (Сгруппировано по null-значениям)
table.cell.constructors=конструкторы
target.code.block.presentable.text=Содержащий блок
title.cannot.create.class=Невозможно создать класс
title.code.vision=Code Vision
title.code.vision.inlay.hints=Code Vision
title.import.layout=Структура импортов
title.javadoc=JavaDoc
title.naming=Именование
title.naming.final.modifier=Объявление переменной
title.naming.functional.expressions=Тело лямбды
title.naming.variable=Переменная
title.package.not.found=Пакет не найден
title.packages=Пакеты
title.packages.to.use.import.with=Пакеты для импорта с '*'\:
title.related.problems.inlay.hints=Связанные проблемы
to.import.a.method.statically.press.0=Для статического импорта метода нажмите {0}
todo.index.not.available=Н/Д
tooltip.anonymous=Анонимный
tooltip.has.several.functional.implementations=Имеет несколько функциональных реализаций
tooltip.implements.method=Реализует метод
tooltip.implements.method.in=Реализует метод в
tooltip.incorrect.file.template=Некорректный шаблон файла ''{0}''
tooltip.is.functionally.implemented.in=Функционально реализован в
tooltip.is.implemented.by=Реализован
tooltip.is.implemented.by.several.subclasses=Реализован несколькими подклассами
tooltip.is.implemented.in=Реализован в
tooltip.is.implemented.in.several.subclasses=Реализован в нескольких подклассах
tooltip.is.overridden.by.several.subclasses=Переопределен несколькими подклассами
tooltip.is.overridden.in=Переопределен в
tooltip.is.overridden.in.several.subclasses=Переопределен в нескольких подклассах
tooltip.is.subclassed.by=Унаследован
tooltip.overrides.method=Переопределяет метод
tooltip.overrides.method.in=Переопределяет метод в
tooltip.reassigned.local.variable=Переприсвоенная локальная переменная
tooltip.reassigned.parameter=Переприсвоенный параметр
tooltip.recursive.call=Рекурсивный вызов
tooltip.variable.used=Переменная ''{0}'' используется
tooltip.via.subclass=через подкласс
type.information.constraints=Ограничения
type.information.local.object=локальный объект
type.information.locality=Локальность
type.information.mutability=Изменяемость
type.information.not.equal.to=Не равно
type.information.nullability=Обнуляемость
type.information.range=Диапазон
type.information.type=Тип
type.information.value=Значение
type.migration.cannot.convert.message=Невозможно преобразовать тип выражения <b>{0}</b>{3, choice, 0\#|1\# из '<'b'>'{1}'<'/b'>'} в <b>{2}</b>
type.migration.cannot.convert.tooltip=Невозможно преобразовать тип выражения из {0} в {1}
type.migration.cannot.convert.vararg.message=Невозможно преобразовать вызов <b>{0}</b> из vararg в не-vararg
type.migration.cannot.convert.vararg.tooltip=Невозможно преобразовать вызов из vararg в не-vararg
type.migration.command.name=TypeMigration
type.migration.dialog.message.disjunction.type.not.applicable=Только параметр блока catch можно мигрировать в объединенный тип
type.migration.dialog.message.invalid.type=''{0}'' не является допустимым типом
type.migration.dialog.message.vararg.type.not.applicable=Только последний параметр метода можно мигрировать в vararg тип
type.migration.dialog.message.void.not.applicable=Только возвращаемые типы методов можно мигрировать в 'void'
type.migration.getter.rename.suggestion.always.migrate.method.names=Всегда мигрировать имена методов
type.migration.getter.rename.suggestion.never.migrate.method.names=Никогда не мигрировать имена методов
type.migration.getter.rename.suggestion.text=Переименовать геттер с ''{0}'' на ''{1}'', так как возвращаемый тип мигрирован в ''{2}''?
type.migration.multi.root.toolwindow.title=Миграция типа {0}
type.migration.processed.elements.header=Корень для миграции типа
type.migration.replaced.notification=Заменено на {0}
type.migration.single.root.toolwindow.title=Миграция типа {0} с ''{1}'' на ''{2}''
type.parameters.cannot.be.inlined=Параметры типа не могут быть инлайнированы
unchecked.warning.inspection.message.unchecked.generics.array.creation.for.varargs.parameter=Непроверенное создание массива дженериков для varargs параметра
unchecked.warning.inspection.reason.expr.has.raw.type.so.result.erased=. Причина\: ''{0}'' имеет сырой тип, поэтому результат {1} стерт
unchecked.warning.inspection.settings.ignore.unchecked.assignment=Игнорировать непроверенное присваивание
unchecked.warning.inspection.settings.ignore.unchecked.call.as.member.of.raw.type=Игнорировать непроверенный вызов как член сырого типа
unchecked.warning.inspection.settings.ignore.unchecked.cast=Игнорировать непроверенное приведение типов
unchecked.warning.inspection.settings.ignore.unchecked.generics.array.creation.for.vararg.parameter=Игнорировать непроверенное создание массива дженериков для vararg параметра
unchecked.warning.inspection.settings.ignore.unchecked.overriding=Игнорировать непроверенное переопределение
unknown.library=Неизвестная библиотека
unscramble.detect.analyze.threaddump.from.clipboard.item=Автоматически определять и анализовать дампы потоков, скопированные в буфер обмена вне IntelliJ ИСРA
unscramble.log.path.label=Лог-файл\:  [&L]
unscramble.no.unscrambler.item=<Дешифратор не установлен>
unscramble.normalize.button=Нормализовать  [&N]
unscramble.stacktrace.caption=Вставьте стек-трейс или полный дамп потоков сюда\:
unscramble.unscrambled.deadlock.tab=<Дедлок>
unscramble.unscrambled.stacktrace.tab=<Стек-трейс>
unscramble.unscrambled.threaddump.tab=<Потоки>
unscramble.unscrambler.combobox=Дешифратор [&S]\:
unscramble.use.unscrambler.checkbox=Дешифровать стек-трейс [&U]
unwrap.anonymous=Развернуть 'anonymous...'
unwrap.array.initializer=Развернуть инициализатор массива
unwrap.conditional=Развернуть 'f ? a \: b'
unwrap.lambda=Развернуть 'lambda...'
unwrap.switch.expression=Развернуть выражение 'switch'
unwrap.switch.statement=Развернуть оператор 'switch'
unwrap.synchronized=Развернуть 'synchronized...'
update.external.annotations=Обновить внешние аннотации
usage.target.exception=Исключение
usage.target.package.in.directory={0} (в {1})
usages.telescope={0,choice, 0\#не используется|1\#1 использование|2\#{0,number} использований}
use.external.annotations=Использовать внешние аннотации  [&E]
validator.text.class.not.found=Класс не найден
validator.text.no.annotation=Должно быть аннотацией
validator.text.not.valid.class.name=Недопустимое имя класса
validator.text.wrong.superclass=Неверный суперкласс
vm.option.description.category=Категория\:
vm.option.description.default.value=Значение по умолчанию\:
vm.option.description.description=Описание\:
vm.option.description.diagnostic=Диагностическая
vm.option.description.experimental=Экспериментальная
vm.option.description.option=Опция\:
vm.option.description.product=Продуктовая
vm.option.description.requires=\ (требуется {0})
vm.option.description.standard=Стандартная
vm.option.description.type=Тип\:
warning.java.file.outside.source.root=Java файл находится вне корневого каталога исходников модуля и не будет скомпилирован
where.do.you.want.to.move.directory.prompt={0}\n\nПереместить директорию в другой корневой каталог исходников или в другую директорию?
wrap.return.value.anonymous.class.presentation=Анонимный {0}
wrap.return.value.created.class.not.accessible.conflict=Созданный класс будет недоступен в месте вызова
wrap.return.value.existing.class.does.not.have.appropriate.constructor.conflict=Существующий класс не имеет подходящего конструктора
wrap.return.value.existing.class.does.not.have.getter.conflict=Существующий класс не имеет геттера для выбранного поля
wrapping.annotation.enums=Аннотации полей enum
wrapping.annotation.parameters=Параметры аннотаций
wrapping.deconstruction.patterns=Паттерны деконструкции
wrapping.multi.catch.types=Типы в multi-catch
wrapping.record.components=Компоненты record
wrapping.semicolon.after.call.chain=Перенести ';' на новую строку
wrapping.switch.statement.or.expression=Оператор/выражение 'switch'
wrapping.text.blocks=Текстовые блоки
wrong.package.statement=Неверный оператор package