always.null=Всегда null
cannot.be.inferred=не может быть выведен
defined.in=определено в
found.space=найдено\:
function.arguments=аргументы\:
function.receiver.0=получатель\: {0}
gutter.name.suspend.call=Вызов suspend-функции
html.0.has.no.corresponding.expected.declaration.1.html={0} не имеет соответствующего ожидаемого объявления{1}
html.0.is.not.abstract.and.does.not.implement.abstract.base.class.member.br.1.html={0} не является абстрактным и не реализует абстрактный член базового класса<br/>{1}
html.0.is.not.abstract.and.does.not.implement.abstract.member.br.1.html={0} не является абстрактным и не реализует абстрактный член<br/>{1}
html.0.method.may.be.missing.none.of.the.following.functions.will.be.called.ul.1.ul.html=Возможно, отсутствует метод ''{0}''. Ни одна из следующих функций не будет вызвана\: <ul>{1}</ul>
html.0.must.override.1.br.because.it.inherits.many.implementations.of.it.html={0} должен переопределить {1}<br />поскольку наследует несколько его реализаций
html.accidental.override.0.html=Случайное переопределение\: {0}
html.actual.class.0.has.no.corresponding.members.for.expected.class.members.1.html=Фактический класс ''{0}'' не имеет соответствующих членов для ожидаемых членов класса\:{1}
html.assignment.operators.ambiguity.all.these.functions.match.ul.0.ul.table.html=Неоднозначность операторов присваивания. Все эти функции подходят.<ul>{0}</ul></table>
html.candidate.resolution.will.be.changed.soon.please.use.fully.qualified.name.to.invoke.the.following.closer.candidate.explicitly.ul.0.ul.html=Разрешение кандидатов скоро изменится, используйте полное имя для явного вызова следующего ближайшего кандидата\: <ul>{0}</ul>
html.cannot.choose.among.the.following.candidates.without.completing.type.inference.ul.0.ul.html=Невозможно выбрать среди следующих кандидатов без завершения вывода типов\: <ul>{0}</ul>
html.expected.0.has.no.actual.declaration.in.module.1.2.html=Ожидаемый {0} не имеет фактического объявления в модуле {1}{2}
html.function.return.type.mismatch.table.tr.td.expected.td.td.1.td.tr.tr.td.found.td.td.2.td.tr.table.html=Несоответствие возвращаемого типа функции.<table><tr><td>Ожидается\:</td><td>{1}</td></tr><tr><td>Найдено\:</td><td>{2}</td></tr></table>
html.getter.return.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=Возвращаемый тип геттера должен совпадать с типом свойства.<table><tr><td>Ожидается\:</td><td>{0}</td></tr><tr><td>Найдено\:</td><td>{1}</td></tr></table>
html.internal.error.occurred.while.analyzing.this.expression.br.0.html=<strong>При анализе этого выражения произошла внутренняя ошибка\:</strong><br/>{0}
html.javascript.0.html=JavaScript\: {0}
html.loop.parameter.type.mismatch.table.tr.td.iterated.values.td.td.0.td.tr.tr.td.parameter.td.td.1.td.tr.table.html=Несоответствие типа параметра цикла.<table><tr><td>Итерируемые значения\:</td><td>{0}</td></tr><tr><td>Параметр\:</td><td>{1}</td></tr></table>
html.method.contains.from.concurrenthashmap.may.have.unexpected.semantics.it.calls.containsvalue.instead.of.containskey.br.use.explicit.form.of.the.call.to.containskey.containsvalue.contains.or.cast.the.value.to.kotlin.collections.map.instead.br.see.https.youtrack.jetbrains.com.issue.kt.18053.for.more.details.html=Метод 'contains' из ConcurrentHashMap может иметь неожиданную семантику\: он вызывает 'containsValue' вместо 'containsKey'.<br/>Используйте явную форму вызова 'containsKey'/'containsValue'/'contains' или приведите значение к kotlin.collections.Map.<br/>Подробности см. на https\://youtrack.jetbrains.com/issue/KT-18053
html.method.iterator.is.ambiguous.for.this.expression.ul.0.ul.html=Метод ''iterator()'' неоднозначен для этого выражения.<ul>{0}</ul>
html.non.final.expect.class.and.its.actual.class.must.declare.exactly.the.same.non.private.members.html={0}\: actual и его не final expect класс должны объявлять в точности одинаковые не private члены. Следующие не private члены в actual классе не совпадают\:{1}<br/>Эта ошибка возникает, потому что expect класс ''{2}'' не является final. Это предупреждение станет ошибкой в будущих версиях.<br/>Подробности см. на https\://youtrack.jetbrains.com/issue/KT-22841
html.none.of.the.following.functions.can.be.called.with.the.arguments.supplied.ul.0.ul.html=Ни одна из следующих функций не может быть вызвана с предоставленными аргументами. <ul>{0}</ul>
html.overload.resolution.ambiguity.all.these.functions.match.ul.0.ul.html=Неоднозначность разрешения перегрузки. Все эти функции подходят. <ul>{0}</ul>
html.overload.resolution.ambiguity.on.method.0.all.these.functions.match.ul.1.ul.html=Неоднозначность разрешения перегрузки для метода ''{0}''. Все эти функции подходят. <ul>{1}</ul>
html.platform.declaration.clash.0.html=Конфликт платформенных объявлений\: {0}
html.property.delegate.must.have.a.0.method.none.of.the.following.functions.are.suitable.ul.1.ul.html=Делегат свойства должен иметь метод ''{0}''. Ни одна из следующих функций не подходит. <ul>{1}</ul>
html.property.type.is.0.which.is.not.a.subtype.type.of.overridden.br.1.html=Тип свойства {0} не является подтипом переопределяемого свойства<br/>{1}
html.return.type.is.0.which.is.not.a.subtype.of.overridden.br.1.html=Возвращаемый тип ''{0}'' не является подтипом переопределяемого<br/>{1}
html.return.types.of.inherited.members.are.incompatible.br.0.br.1.html=Возвращаемые типы унаследованных членов несовместимы\:<br/>{0},<br/>{1}
html.setter.parameter.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=Тип параметра сеттера должен совпадать с типом свойства.<table><tr><td>Ожидается\:</td><td>{0}</td></tr><tr><td>Найдено\:</td><td>{1}</td></tr></table>
html.type.argument.is.not.within.its.bounds.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=Аргумент типа выходит за границы.<table><tr><td>Ожидается\:</td><td>{0}</td></tr><tr><td>Найдено\:</td><td>{1}</td></tr></table>
html.type.inference.failed.0.html=Не удалось вывести тип\: {0}
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.br.projected.type.2.restricts.use.of.br.3.html=Несоответствие типов.<table><tr><td>Требуется\:</td><td>{0}</td></tr><tr><td>Найдено\:</td><td>{1}</td></tr></table><br />\nПроецируемый тип {2} ограничивает использование <br />\n{3}\n
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=Несоответствие типов.<table><tr><td>Требуется\:</td><td>{0}</td></tr><tr><td>Найдено\:</td><td>{1}</td></tr></table>
html.types.of.inherited.properties.are.incompatible.br.0.br.1.html=Типы унаследованных свойств несовместимы\:<br/>{0},<br/>{1}
html.types.of.inherited.var.properties.do.not.match.br.0.br.1.html=Типы унаследованных var-свойств не совпадают\:<br/>{0},<br/>{1}
html.unresolved.reference.br.none.of.the.following.candidates.is.applicable.because.of.receiver.type.mismatch.ul.0.ul.html=Неразрешённая ссылка. <br/> Ни один из следующих кандидатов не применим из-за несоответствия типа получателя\: <ul>{0}</ul>
html.val.property.cannot.override.var.property.br.1.html=val-свойство не может переопределить var-свойство<br />{1}
html.var.property.type.is.0.which.is.not.a.type.of.overridden.br.1.html=Тип var-свойства {0} не является типом переопределяемого свойства<br/>{1}
i.for.i.br.0=<i> for </i><br/>{0}
kotlin.compiler.error=Ошибка компилятора Kotlin
kotlin.compiler.warning=Предупреждение компилятора Kotlin
required.space=требуется\:
root.package=корневой пакет
smart.cast.to.0.for.1.call=Умное приведение к {0} (для вызова {1})
the.following.declarations.have.the.same.jvm.signature.code.0.1.code.br.ul.2.ul=Следующие объявления имеют одинаковую JVM-сигнатуру (<code>{0}{1}</code>)\:<br/>\n<ul>\n{2}</ul>
type.inference.failed.expected.type.mismatch=Не удалось вывести тип. Несоответствие ожидаемого типа\:
type.parameters.where=where
unknown.receiver=Неизвестный получатель
value.captured.in.a.closure=Значение захвачено в замыкании
wrapped.into.a.reference.object.to.be.modified.when.captured.in.a.closure=Обернуто в объект-ссылку для модификации при захвате в замыкании