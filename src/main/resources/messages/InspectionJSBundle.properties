add.require.amd.module.fix=Добавить зависимость модуля {0}
add.require.amd.module.group.name=Node.js
add.return.statement.fix.name=Добавить оператор return
anonymous.function.contains.multiple.loops.error.string=\#ref содержит {0} циклов \#loc
anonymous.function.contains.multiple.return.points.error.string=\#ref имеет {0} точек возврата \#loc
anonymous.function.contains.too.many.negation.error.string=\#ref содержит {0} отрицаний \#loc
anonymous.function.display.name=Анонимная функция
anonymous.function.error.string=Анонимная функция \#loc
anonymous.function.has.inconsistent.return.points.error.string=\#ref имеет несогласованные точки возврата \#loc
anonymous.function.has.too.many.parameters.error.string=\#ref имеет слишком много параметров (количество параметров \= {0}) \#loc
anonymous.function.is.overly.complex.cyclomatic.complexity.error.string=\#ref слишком сложная (цикломатическая сложность \= {0}) \#loc
anonymous.function.is.overly.long.statement.error.string=\#ref слишком длинная (количество операторов \= {0}) \#loc
anonymous.function.is.overly.nested.error.string=\#ref слишком вложенная (глубина вложенности {0}, при допустимом максимуме {1}) \#loc
assignment.replaceable.with.operator.assignment.display.name=Присваивание можно заменить на оператор присваивания
assignment.replaceable.with.operator.assignment.error.string=\#ref можно упростить до {0} \#loc
assignment.to.for.loop.parameter.display.name=Присваивание параметру цикла 'for'
assignment.to.for.loop.parameter.error.string=Присваивание параметру цикла for \#ref \#loc
assignment.to.function.parameter.display.name=Присваивание параметру функции
assignment.to.function.parameter.error.string=Присваивание параметру функции '\#ref' \#loc
break.statement.display.name=Оператор 'break'
break.statement.error.string=Оператор '\#ref' \#loc
break.statement.with.label.display.name=Оператор 'break' с меткой
break.statement.with.label.error.string=Оператор '\#ref' с меткой \#loc
call.to.document.write.display.name=Вызов 'document.write()'
caller.display.name=Использование свойства 'caller'
caller.error.string=Использование свойства '\#ref' \#loc
chained.equality.display.name=Цепочка сравнений на равенство
chained.equality.error.string=Цепочка сравнений на равенство <code>\#ref</code> \#loc
chained.function.call.display.name=Цепочка вызовов функций
chained.function.call.problem.descriptor=Цепочка вызовов функции '\#ref' \#loc
class.name.doesnt.match.regex.error.string=Имя класса ''{0}'' не соответствует регулярному выражению ''{1}'' \#loc
class.name.is.too.long.error.string=Имя класса ''{0}'' слишком длинное \#loc
class.name.is.too.short.error.string=Имя класса ''{0}'' слишком короткое \#loc
class.naming.convention.display.name=Соглашение об именовании классов
collapse.conditional.expression.fix=Свернуть условное выражение
collapse.if.statement.fix=Свернуть оператор 'if'
comma.expression.display.name=Выражение с запятой
comma.expression.error.string=Выражение с запятой \#loc
conditional.expression.display.name=Условное выражение
conditional.expression.error.string=Условное выражение \#loc
conditional.expression.with.identical.branches.display.name=Условное выражение с идентичными ветвями
conditional.expression.with.identical.branches.error.string=Условное выражение <code>\#ref</code> с идентичными ветвями \#loc
confusing.floating.point.literal.change.quickfix=Изменить на каноническую форму
confusing.floating.point.literal.display.name=Неоднозначный литерал с плавающей точкой
confusing.floating.point.literal.problem.descriptor=Неоднозначный литерал с плавающей точкой <code>\#ref</code> \#loc
confusing.pluses.or.minuses.display.name=Неоднозначная последовательность '+' или '-'
confusing.pluses.or.minuses.error.string=Последовательность '+' или '-' может изменить значение при удалении пробелов \#loc
constant.conditional.expression.display.name=Константное условное выражение
constant.conditional.expression.error.string=<code>\#ref</code> можно упростить \#loc
constant.on.left.side.of.comparison.display.name=Константа в левой части сравнения
constant.on.left.side.of.comparison.error.string=\#ref\: константа в левой части сравнения \#loc
constant.on.right.side.of.comparison.display.name=Константа в правой части сравнения
constant.on.right.side.of.comparison.error.string=\#ref\: константа в правой части сравнения \#loc
constructor.name.doesnt.match.regex.error.string=Имя конструктора ''{0}'' не соответствует регулярному выражению ''{1}'' \#loc
constructor.name.is.too.long.error.string=Имя конструктора ''{0}'' слишком длинное \#loc
constructor.name.is.too.short.error.string=Имя конструктора ''{0}'' слишком короткое \#loc
continue.or.break.inside.finally.block.display.name='continue' или 'break' внутри блока 'finally'
continue.or.break.inside.finally.block.error.string='\#ref' внутри блока 'finally' \#loc
continue.statement.display.name=Оператор 'continue'
continue.statement.error.string=Оператор '\#ref' \#loc
continue.statement.with.label.display.name=Оператор 'continue' с меткой
continue.statement.with.label.error.string=Оператор '\#ref' с меткой \#loc
debugger.statement.display.name=Оператор 'debugger'
debugger.statement.error.string=Оператор '\#ref' \#loc
default.branch.not.last.case.in.switch.error.string=Ветвь <code>\#ref</code> не последний case в 'switch' \#loc
default.not.last.case.in.switch.display.name='default' не последний case в 'switch'
divide.by.zero.display.name=Деление на ноль
division.by.zero.error.string=Деление на ноль \#loc
document.write.error.string=Вызов '\#ref()' \#loc
duplicate.case.label.display.name=Дублирующаяся метка 'case'
duplicate.case.label.error.string=Дублирующаяся метка case \#ref \#loc
duplicate.condition.error.string=Дублирующееся условие <code>\#ref</code> \#loc
duplicate.condition.in.if.statement.display.name=Дублирующееся условие в операторе 'if'
dynamically.generated.code.display.name=Выполнение динамически сгенерированного кода
dynamically.generated.code.error.string=Функция '\#ref' указывает на динамически генерируемый код \#loc
empty.catch.block.display.name=Пустой блок 'catch'
empty.catch.block.error.string=Пустой блок '\#ref' \#loc
empty.finally.block.display.name=Пустой блок 'finally'
empty.finally.block.error.string=Пустой блок 'finally' \#loc
empty.try.block.display.name=Пустой блок 'try'
empty.try.block.error.string=Пустой блок '\#ref' \#loc
exception.caught.locally.error.string='\#ref' исключения перехвачено локально \#loc
exception.used.for.local.control.flow.display.name=Исключение используется для локального управления потоком
expression.statement.is.not.assignment.or.call.error.string=Выражение не является присваиванием или вызовом \#loc
expression.statement.which.is.not.assignment.or.call.display.name=Выражение, не являющееся присваиванием или вызовом
fall.through.in.switch.statement.display.name=Проваливание в операторе 'switch'
fall.through.in.switch.statement.error.string=Проваливание в операторе 'switch' \#loc. Отсутствует 'break' или 'return'
flip.comparison.fix=Инвертировать сравнение
for.loop.not.use.loop.variable.display.name=Цикл 'for', где update или condition не использует переменную цикла
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update=В операторе <code>\#ref</code> условие и update не используют переменную цикла for \#loc
for.loop.not.use.loop.variable.problem.descriptor.condition=В операторе <code>\#ref</code> условие не использует переменную цикла for \#loc
for.loop.not.use.loop.variable.problem.descriptor.update=В операторе <code>\#ref</code> update не использует переменную цикла for \#loc
for.loop.replaceable.by.while.display.name=Цикл 'for' можно заменить на цикл 'while'
for.loop.replaceable.by.while.ignore.option=Игнорировать 'бесконечные' циклы for без условий
for.loop.replaceable.by.while.problem.descriptor=Цикл <code>\#ref</code> можно заменить на цикл 'while' \#loc
for.loop.replaceable.by.while.replace.quickfix=Заменить на 'while'
function.complexity.limit.parameter=Предел сложности функции\:
function.contains.multiple.loops.error.string=Функция ''\#ref'' содержит {0} циклов \#loc
function.contains.multiple.return.points.error.string=Функция ''\#ref'' имеет {0} точек возврата \#loc
function.contains.too.many.negation.error.string=Функция ''\#ref'' содержит {0} отрицаний \#loc
function.has.inconsistent.return.points.error.string=Функция '\#ref' имеет несогласованные точки возврата \#loc
function.has.too.many.parameters.error.string=Функция ''\#ref'' имеет слишком много параметров (количество параметров \= {0}) \#loc
function.is.overly.long.statement.error.string=Функция ''\#ref'' слишком длинная (количество операторов \= {0}) \#loc
function.is.overly.nested.error.string=Функция ''\#ref'' чрезмерно вложена (глубина вложенности {0}, при допустимом максимуме {1}) \#loc
function.name.doesnt.match.regex.error.string=Имя функции ''{0}'' не соответствует регулярному выражению ''{1}'' \#loc
function.name.is.too.long.error.string=Имя функции ''{0}'' слишком длинное \#loc
function.name.is.too.short.error.string=Имя функции ''{0}'' слишком короткое \#loc
function.naming.convention.display.name=Соглашение об именовании функций
function.parameter.limit=Лимит параметров функции\:
function.parameter.naming.convention.display.name=Соглашение об именовании параметров функции
function.ref.is.overly.complex.cyclomatic.complexity.error.string=Функция ''\#ref'' чрезмерно сложная (цикломатическая сложность \= {0}) \#loc
function.with.inconsistent.returns.display.name=Функция с несогласованными возвратами
function.with.more.than.three.negations.display.name=Функция с более чем тремя отрицаниями
function.with.multiple.loops.display.name=Функция с несколькими циклами
function.with.multiple.return.points.display.name=Функция с несколькими точками возврата
function.with.too.many.parameters.display.name=Функция с большим количеством параметров
group.path.javascript=JavaScript
if.statement.with.identical.branches.display.name=Оператор 'if' с идентичными ветвями
if.statement.with.too.many.branches.display.name=Оператор 'if' с большим количеством ветвей
if.statement.with.too.many.branches.error.string=''\#ref'' имеет слишком много ветвей ({0}) \#loc
include.anonymous.functions.parameter=Включать анонимные функции
include.statement.bodies.that.are.empty.code.blocks.parameter=Включать тела операторов, являющиеся пустыми блоками кода
incompatible.mask.operation.display.name=Несовместимая побитовая операция с маской
incompatible.mask.operation.problem.descriptor.always.false=<code>\#ref</code> всегда false \#loc
incompatible.mask.operation.problem.descriptor.always.true=<code>\#ref</code> всегда true \#loc
infinite.loop.error.string=Оператор <code>\#ref</code> не может завершиться без выброса исключения \#loc
infinite.loop.statement.display.name=Бесконечный цикл
infinite.recursion.display.name=Бесконечная рекурсия
infinite.recursion.problem.descriptor=Функция <code>\#ref</code> рекурсивно вызывает себя бесконечно и может завершиться только выбросом исключения \#loc
inner.html.error.string=Использование свойства '\#ref' \#loc
invert.condition.fix=Инвертировать условие
invert.if.condition.fix=Инвертировать условие 'if'
javascript.dom.issues.group.name=Проблемы DOM
js.inspection.group.path=JavaScript и TypeScript
js.inspection.switch.group.name=Проблемы оператора switch
labeled.statement.display.name=Помеченный оператор
local.variable.naming.convention.display.name=Соглашение об именовании локальных переменных
loop.statement.that.doesn.t.loop.display.name=Оператор цикла, который не выполняет итерации
loop.statement.that.doesnt.loop.error.string=Оператор <code>\#ref</code> не выполняет итерации \#loc
magic.number.display.name=Магическое число
magic.number.problem.descriptor=Магическое число '\#ref' \#loc
maximum.number.of.branches.parameter=Максимальное количество ветвей\:
maximum.number.of.terms.parameter=Максимальное количество элементов\:
maximum.statements.per.function=Максимальное количество операторов в функции\:
missing.return.statement.error.string=Отсутствует оператор return \#loc
negated.conditional.expression.display.name=Отрицательное условное выражение
negated.conditional.expression.error.string=Отрицательное условное выражение \#loc
negated.if.statement.display.name=Отрицательный оператор 'if'
negated.ref.statement.error.string=Отрицательный оператор '\#ref' \#loc
nested.anonymous.function.error.string=Вложенная \#ref \#loc
nested.assignment.display.name=Вложенное присваивание
nested.assignment.error.string=Вложенное присваивание <code>\#ref</code> \#loc
nested.conditional.expression.display.name=Вложенное условное выражение
nested.conditional.expression.error.string=Вложенное условное выражение \#loc
nested.function.call.display.name=Вложенный вызов функции
nested.function.call.problem.descriptor=Вложенный вызов функции '\#ref' \#loc
nested.function.display.name=Вложенная функция
nested.function.error.string=Вложенная функция '\#ref' \#loc
nested.switch.statement.display.name=Вложенный оператор 'switch'
nested.switch.statement.error.string=Вложенный оператор '\#ref' \#loc
nesting.depth.limit=Лимит глубины вложенности\:
non.block.body.error.string=Оператор <code>\#ref</code> имеет тело без блока \#loc
non.block.branch.error.string=Оператор <code>\#ref</code> имеет ветвь без блока \#loc
non.block.statement.body.display.name=Тело оператора без фигурных скобок
octal.integer.display.name=Восьмеричное целое число
overly.complex.arithmetic.expression.display.name=Чрезмерно сложное арифметическое выражение
overly.complex.arithmetic.expression.error.string=Чрезмерно сложное арифметическое выражение \#loc
overly.complex.boolean.expression.display.name=Чрезмерно сложное логическое выражение
overly.complex.boolean.expression.error.string=Чрезмерно сложное логическое выражение \#loc
overly.complex.function.display.name=Чрезмерно сложная функция
overly.long.function.display.name=Слишком длинная функция
overly.nested.function.display.name=Чрезмерно вложенная функция
parameter.name.doesnt.match.regex.error.string=Имя параметра ''\#ref'' не соответствует регулярному выражению ''{0}'' \#loc
parameter.name.is.too.long.error.string=Имя параметра '\#ref' слишком длинное \#loc
parameter.name.is.too.short.error.string=Имя параметра '\#ref' слишком короткое \#loc
platform.detection.display.name=Неточное определение платформы
platform.detection.error.string='\#ref' вероятно используется для определения платформы \#loc
pointless.arithmetic.error.message=\#ref может быть заменено на {0} \#loc
pointless.arithmetic.expression.display.name=Бессмысленное арифметическое выражение
pointless.bitwise.expression.display.name=Побитовое выражение может быть упрощено
pointless.bitwise.expression.ignore.option=Игнорировать именованные константы при определении бессмысленных выражений
pointless.bitwise.expression.problem.descriptor=''{1}'' может быть заменено на ''{0}'' \#loc
pointless.bitwise.expression.simplify.quickfix=Упростить
pointless.boolean.error.string=Может быть упрощено до {0} \#loc
pointless.boolean.expression.display.name=Бессмысленный оператор или логическое выражение
pointless.statement.error.string=Оператор {0} может быть упрощен \#loc
redundant.conditional.expression.display.name=Избыточное условное выражение
redundant.if.statement.display.name=Избыточный оператор 'if'
redundant.local.variable.display.name=Избыточная локальная переменная
redundant.local.variable.ignore.option=Игнорировать немедленно возвращаемые или выбрасываемые переменные
redundant.local.variable.quickfix=Встроить переменную
ref.statement.with.identical.branches.error.string=Оператор <code>\#ref</code> с идентичными ветвями \#loc
remove.label.fix=Удалить метку
remove.unnecessary.continue.fix=Удалить лишний continue
remove.unnecessary.return.fix=Удалить лишний return
rename.fix=Переименовать
replace.redundant.await.family.name=Заменить избыточный await
replace.with.operator.assign.fix=Заменить \= на {0}\=
reserved.word.used.as.name.display.name=Зарезервированное слово используется как имя
reserved.word.used.as.name.error.string=Зарезервированное слово '\#ref' используется как имя
result.of.assignment.expression.used.error.string=Используется результат выражения присваивания \#loc
result.of.assignment.used.displayName=Используется результат присваивания
result.of.increment.or.decrement.expression.used.error.string=Используется результат выражения инкремента или декремента \#loc
result.of.increment.or.decrement.used.display.name=Используется результат инкремента или декремента
result.of.object.allocation.ignored.display.name=Игнорируется результат создания объекта
result.of.object.allocation.ignored.error.string=Результат <code>new \#ref()</code> игнорируется \#loc
return.inside.finally.block.display.name='return' внутри блока 'finally'
return.inside.finally.block.error.string='\#ref' внутри блока 'finally' \#loc
reuse.of.local.variable.display.name=Повторное использование локальной переменной
reuse.of.local.variable.problem.descriptor=Повторное использование локальной переменной <code>\#ref</code> \#loc
set.return.type.to.void.fix.name=Установить тип возвращаемого значения void
shift.operation.by.inappropriate.constant.display.name=Операция сдвига с возможно неверной константой
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Операция сдвига <code>\#ref</code> с отрицательным значением константы \#loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Операция сдвига <code>\#ref</code> со слишком большим значением константы \#loc
shift.out.of.range.family.name=Исправить значение сдвига
silly.assignment.display.name=Переменная присваивается сама себе
silly.assignment.error.string=Переменная присваивается сама себе \#loc
simplify.fix=Упростить
statement.has.empty.body.error.string=Оператор <code>\#ref</code> имеет пустое тело \#loc
statement.has.empty.branch.error.string=Оператор <code>\#ref</code> имеет пустую ветвь \#loc
statement.label.error.string=Метка оператора '\#ref' \#loc
statement.simplify.quickfix=Упростить оператор
statement.with.empty.body.display.name=Оператор с пустым телом
string.literal.breaks.html.display.name=Строковый литерал, нарушающий парсинг HTML
string.literal.breaks.html.error.string=Строковый литерал \#ref может нарушить работу HTML парсеров \#loc
tail.recursion.display.name=Хвостовая рекурсия
tail.recursion.problem.descriptor=Хвостовая рекурсия \#loc
terminate.statement.fix=Завершить оператор
text.label.in.switch.statement.display.name=Текстовая метка в операторе 'switch'
text.label.in.switch.statement.error.string=Текстовая метка <code>\#ref\:</code> в операторе 'switch' \#loc
this.expression.references.global.object.error.string=Выражение '\#ref' верхнего уровня \#loc
this.expression.which.references.the.global.object.display.name=Выражение 'this', ссылающееся на глобальный объект
throw.inside.finally.block.display.name='throw' внутри блока 'finally'
throw.inside.finally.block.error.string='\#ref' внутри блока 'finally' \#loc
trivial.conditional.error.string=''{0}'' можно упростить до ''{1}'' \#loc
trivial.if.error.string=Оператор <code>\#ref</code> можно упростить \#loc
typeof.using.incorrect.case.display.name=Сравнение 'typeof' с нестандартным значением
typeof.using.incorrect.case.error=typeof сравнивается с нестандартным значением
typeof.using.incorrect.convert=Преобразовать в {0}
typeof.using.incorrect.family.name=Преобразовать в стандартное значение
unnecessary.block.statement.display.name=Ненужный блок кода
unnecessary.block.statement.error.string=Ненужный блок кода \#loc
unnecessary.continue.error.string=<code>\#ref</code> не нужен как последний оператор в цикле \#loc
unnecessary.continue.statement.display.name=Ненужный оператор 'continue'
unnecessary.label.display.name=Ненужная метка
unnecessary.label.error.string=Ненужная метка <code>\#ref</code> \#loc
unnecessary.label.on.break.error.string=Оператор <code>\#ref</code> с ненужной меткой \#loc
unnecessary.label.on.break.statement.display.name=Ненужная метка в операторе 'break'
unnecessary.label.on.continue.error.string=Оператор <code>\#ref</code> с ненужной меткой \#loc
unnecessary.label.on.continue.statement.display.name=Ненужная метка в операторе 'continue'
unnecessary.local.variable.problem.descriptor=Локальная переменная {0} избыточна
unnecessary.return.error.string=<code>\#ref</code> не нужен как последний оператор в функции без возвращаемого значения \#loc
unnecessary.return.statement.display.name=Ненужный оператор 'return'
unreachable.code.display.name=Недостижимый код
unreachable.code.error.string=Недостижимый код \#loc
unterminated.statement.display.name=Незавершённый оператор
unterminated.statement.error.string=Незавершённый оператор \#loc
unterminated.statement.ignore.atend.of.block=Разрешить отсутствие точки с запятой в конце блока
unterminated.statement.possibly.unterminated.statement.error=Возможно незавершённый оператор \#loc
unused.catch.parameter.display.name=Неиспользуемый параметр 'catch'
unused.catch.parameter.ignore.catch.option=Игнорировать блоки catch, содержащие комментарии
unused.catch.parameter.problem.descriptor=Неиспользуемый параметр catch <code>\#ref</code> \#loc
use.of.innerhtml.property.display.name=Использование свойства 'innerHTML'
variable.name.doesnt.match.regex.error.string=Имя переменной ''\#ref'' не соответствует регулярному выражению ''{0}'' \#loc
variable.name.is.too.long.error.string=Имя переменной '\#ref' слишком длинное \#loc
variable.name.is.too.short.error.string=Имя переменной '\#ref' слишком короткое \#loc
void.expression.display.name=Выражение 'void'
void.expression.error.string=Выражение '\#ref' \#loc
with.expression.error.string=Оператор '\#ref' \#loc
with.statement.display.name=Оператор 'with'
wrap.statement.body.fix=Обернуть тело оператора
xhtml.incompatabilities.error.string='\#ref' может давать противоречивые результаты для XHTML документов \#loc
xhtml.incompatibilities.display.name=Несовместимое использование XHTML