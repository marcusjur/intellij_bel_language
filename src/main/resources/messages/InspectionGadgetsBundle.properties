0.will.no.longer.be.overridable.by.1={0} больше не сможет быть переопределен {1}
absolute.alignment.in.user.interface.display.name=Абсолютное выравнивание в коде AWT/Swing
absolute.alignment.in.user.interface.fix.family.name=Заменить константой
absolute.alignment.in.user.interface.problem.descriptor=Использована константа абсолютного выравнивания <code>{0}.\#ref</code> \#loc
abstract.class.extends.concrete.class.display.name=Абстрактный класс наследует конкретный класс
abstract.class.extends.concrete.class.problem.descriptor=Класс <code>\#ref</code> объявлен как 'abstract' и наследует конкретный класс \#loc
abstract.class.naming.convention.element.description=Абстрактный класс
abstract.class.never.implemented.display.name=Абстрактный класс без конкретных подклассов
abstract.class.never.implemented.problem.descriptor=Абстрактный класс <code>\#ref</code> не имеет конкретных подклассов \#loc
abstract.class.with.only.one.direct.inheritor.display.name=Абстрактный класс с единственным прямым наследником
abstract.class.with.only.one.direct.inheritor.problem.descriptor=Абстрактный класс <code>\#ref</code> имеет только одного прямого наследника \#loc
abstract.class.without.abstract.methods.display.name=Абстрактный класс без абстрактных методов
abstract.class.without.abstract.methods.ignore.utility.class.option=Игнорировать служебные классы
abstract.class.without.abstract.methods.problem.descriptor=Класс <code>\#ref</code> объявлен как 'abstract', но не имеет абстрактных методов \#loc
abstract.method.call.in.constructor.display.name=Вызов абстрактного метода во время конструирования объекта
abstract.method.call.in.constructor.problem.descriptor=Вызов абстрактного метода <code>\#ref()</code> во время конструирования объекта \#loc
abstract.method.overrides.abstract.method.display.name=Абстрактный метод переопределяет абстрактный метод
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=Игнорировать методы с Javadoc, отличающимся от их super методов
abstract.method.overrides.abstract.method.problem.descriptor=Абстрактный метод <code>\#ref()</code> переопределяет абстрактный метод \#loc
abstract.method.overrides.abstract.method.remove.quickfix=Удалить избыточное объявление абстрактного метода
abstract.method.overrides.concrete.method.display.name=Абстрактный метод переопределяет конкретный метод
abstract.method.overrides.concrete.method.problem.descriptor=Абстрактный метод <code>\#ref()</code> переопределяет конкретный метод \#loc
abstract.method.with.missing.implementations.display.name=Абстрактный метод с отсутствующими реализациями
abstract.method.with.missing.implementations.problem.descriptor=Абстрактный метод <code>\#ref()</code> не реализован во всех подклассах \#loc
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=Выбрать потоконебезопасный класс
access.to.non.thread.safe.static.field.from.instance.display.name=Доступ к потоконебезопасному статическому полю
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=Доступ к потоконебезопасному статическому полю <code>\#ref</code> типа ''{0}'' \#loc
access.to.non.thread.safe.static.field.from.instance.option.title=Потоконебезопасные классы\:
access.to.static.field.locked.on.instance.display.name=Доступ к статическому полю заблокирован на данных экземпляра
access.to.static.field.locked.on.instance.fix.name=Игнорировать статические поля типа ''{0}''
access.to.static.field.locked.on.instance.problem.descriptor=Доступ к статическому полю <code>\#ref</code> заблокирован на данных экземпляра \#loc
accessing.non.public.field.of.another.object.display.name=Доступ к непубличному полю другого объекта
accessing.non.public.field.of.another.object.problem.descriptor=Прямой доступ к непубличному полю <code>\#ref</code> другого объекта \#loc
add.0.to.ignore.if.annotated.by.list.quickfix=Добавить ''{0}'' в список "Игнорировать, если аннотировано"
add.catch.section.fix.family.name=Добавить блок 'catch'
add.read.write.object.methods.fix.family.name=Добавить методы 'readObject()' и 'writeObject()', которые всегда выбрасывают исключение
add.read.write.object.methods.fix.text=Добавить метод 'writeObject()', который всегда выбрасывает исключение
add.read.write.object.methods.fix.text2=Добавить метод 'readObject()', который всегда выбрасывает исключение
add.serialversionuidfield.quickfix=Добавить поле 'serialVersionUID'
add.this.qualifier.quickfix=Добавить квалификатор 'this'
add.throws.clause.fix.family.name=Исправить объявление 'throws'
all.levels.option=все уровни логования
allow.resource.to.be.opened.inside.a.try.block=Разрешить открытие ресурса внутри блока 'try'
ambiguous.field.access.display.name=Доступ к унаследованному полю выглядит как доступ к элементу из окружающего кода
ambiguous.field.access.hides.field.problem.descriptor=Доступ к полю <code>\#ref</code> из суперкласса ''{0}'' выглядит как доступ к полю из окружающего класса \#loc
ambiguous.field.access.hides.local.variable.problem.descriptor=Доступ к полю <code>\#ref</code> из суперкласса ''{0}'' выглядит как доступ к локальной переменной \#loc
ambiguous.field.access.hides.parameter.problem.descriptor=Доступ к полю <code>\#ref</code> из суперкласса ''{0}'' выглядит как доступ к параметру \#loc
ambiguous.field.access.navigate.quickfix=Перейти к предположительно доступной {0, choice, 1\#локальной переменной|2\#параметру|3\#полю}
ambiguous.field.access.quickfix=Добавить квалификатор 'super' к доступу к полю
ambiguous.method.call.display.name=Вызов унаследованного метода выглядит как вызов локального метода
ambiguous.method.call.problem.descriptor=Вызов метода <code>\#ref()</code> из суперкласса ''{0}'' выглядит как вызов метода из класса ''{1}'' \#loc
ambiguous.method.call.quickfix=Добавить квалификатор 'super' к вызову метода
annotation.class.display.name=Интерфейс аннотации
annotation.class.problem.descriptor=Интерфейс аннотации <code>\#ref</code> \#loc
annotation.display.name=Аннотация
annotation.naming.convention.element.description=Интерфейс аннотации
annotation.problem.descriptor=Аннотация <code>\#ref</code> \#loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=Поле анонимного класса <code>\#ref</code> скрывает переменную содержащего метода \#loc
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=Параметр анонимного класса <code>\#ref</code> скрывает переменную содержащего метода \#loc
anonymous.class.variable.hides.containing.method.variable.display.name=Переменная анонимного класса скрывает переменную содержащего метода
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=Локальная переменная анонимного класса <code>\#ref</code> скрывает переменную содержащего метода \#loc
anonymous.extends.concrete.collection.problem.descriptor=Анонимный класс явно наследует ''{0}'' \#loc
anonymous.extends.thread.problem.descriptor=Анонимный класс напрямую наследует 'java.lang.Thread' \#loc
anonymous.extends.throwable.problem.descriptor=Анонимный класс напрямую наследует 'java.lang.Throwable' \#loc
anonymous.inner.class.display.name=Анонимный класс может быть заменен внутренним классом
anonymous.inner.class.problem.descriptor=Анонимный класс <code>\#ref</code> \#loc
anonymous.inner.class.with.too.many.methods.display.name=Анонимный класс со слишком большим количеством методов
anonymous.inner.class.with.too.many.methods.problem.descriptor=Анонимный класс со слишком большим количеством методов (количество методов \= {0}) \#loc
anonymous.inner.may.be.named.static.inner.class.display.name=Анонимный класс может быть именованным статическим внутренним классом
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=Анонимный класс <code>\#ref</code> может быть именованным статическим внутренним классом \#loc
anonymous.inner.may.be.named.static.inner.class.quickfix=Преобразовать в именованный статический внутренний класс
any.method.may.close.resource.argument=Любой метод может закрыть ресурс-аргумент
array.allocation.zero.length.display.name=Выделение массива нулевой длины
array.allocation.zero.length.problem.descriptor=Выделение массива нулевой длины \#loc
array.can.be.replaced.with.enum.values=Массив может быть заменен значениями перечисления
array.can.be.replaced.with.enum.values.family.quickfix=Заменить массив на EnumType.values()
array.can.be.replaced.with.enum.values.quickfix=Заменить массив на {0}.values()
array.comparison.display.name=Сравнение массивов с помощью '\=\=' вместо 'Arrays.equals()'
array.comparison.problem.descriptor=Объекты массивов сравниваются с помощью <code>\#ref</code>, а не 'Arrays.equals()' \#loc
array.creation.without.new.keyword.family.quickfix=Добавить выражение 'new'
array.creation.without.new.keyword.name=Создание массива без выражения 'new'
array.creation.without.new.keyword.quickfix=Добавить ''new {0}''
array.equals.problem.descriptor=Сравнение массивов вероятно должно выполняться с помощью ''{0}''
array.hash.code.display.name='hashCode()' вызван для массива
array.hash.code.fix.family.name=Заменить на вызов 'Arrays.hashCode()'
array.hash.code.problem.descriptor=<code>\#ref()</code>, вызванный для массива, вероятно должен быть 'Arrays.hashCode()' \#loc
array.hashcode.problem.descriptor=Вычисление хэш-кода массива вероятно должно выполняться с помощью ''{0}''
array.length.in.loop.condition.display.name=Array.length в условии цикла
array.length.in.loop.condition.problem.descriptor=Проверка массива <code>\#ref</code> в условии цикла \#loc
array.objects.equals.display.name=Использование поверхностных методов или методов 'Objects' с массивами
arrays.as.list.with.one.argument.problem.descriptor=Вызов <code>\#ref()</code> только с одним аргументом \#loc
arrays.as.list.with.zero.arguments.problem.descriptor=Вызов <code>\#ref()</code> для создания пустого списка \#loc
arrays.as.list.with.zero.or.one.argument.display.name=Вызов 'Arrays.asList()' со слишком малым количеством аргументов
assert.can.be.if.quickfix=Заменить 'assert' на оператор 'if'
assert.keyword.is.considered.an.assertion=Ключевое слово 'assert' рассматривается как утверждение
assert.message.not.string.display.name=Сообщение 'assert' не является строкой
assert.message.not.string.only.warn.boolean.option=Предупреждать только когда сообщение 'assert' имеет тип 'boolean' или 'java.lang.Boolean'
assert.message.of.type.boolean.problem.descriptor=Сообщение ''assert'' типа ''{0}'' \#loc
assert.statement.display.name=Оператор 'assert'
assert.with.side.effects.call.mutates.expression=вызов ''{0}()'' изменяет ''{1}''
assert.with.side.effects.call.mutates.field=вызов ''{0}()'' изменяет поле ''{1}''
assert.with.side.effects.call.performs.io=вызов ''{0}()'' выполняет операцию ввода/вывода
assert.with.side.effects.display.name=Оператор 'assert' с побочными эффектами
assert.with.side.effects.problem.descriptor=<code>\#ref</code> имеет побочные эффекты\: {0} \#loc
assert.without.message.problem.descriptor=<code>\#ref()</code> без сообщения \#loc
assert.without.message.quick.fix.family.name=Добавить сообщение об ошибке
assertion.can.be.if.name=Утверждение может быть заменено оператором 'if'
asserts.without.messages.display.name=Отсутствует сообщение в утверждении
assignment.of.field.with.mutable.type.problem.descriptor=Присваивание {0} полю ''{1}'' из параметра <code>\#ref</code> \#loc
assignment.or.return.of.field.with.mutable.type.display.name=Присваивание или возврат поля изменяемого типа
assignment.replaceable.with.operator.assignment.display.name=Присваивание может быть заменено на оператор присваивания
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=Игнорировать условные операторы
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=Игнорировать неочевидные операторы ^ и %
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>\#ref</code> можно упростить до ''{0}'' \#loc
assignment.to.catch.block.parameter.display.name=Присваивание параметру блока 'catch'
assignment.to.catch.block.parameter.problem.descriptor=Присваивание параметру блока catch <code>\#ref</code> \#loc
assignment.to.for.loop.parameter.check.foreach.option=Проверять параметры расширенного цикла 'for'
assignment.to.for.loop.parameter.display.name=Присваивание параметру цикла 'for'
assignment.to.for.loop.parameter.problem.descriptor=Присваивание параметру цикла for <code>\#ref</code> \#loc
assignment.to.lambda.parameter.display.name=Присваивание параметру лямбды
assignment.to.lambda.parameter.problem.descriptor=Присваивание параметру лямбды <code>\#ref</code> \#loc
assignment.to.method.parameter.display.name=Присваивание параметру метода
assignment.to.method.parameter.ignore.transformation.option=<html>Игнорировать, если присваивание является преобразованием исходного параметра</html>
assignment.to.method.parameter.problem.descriptor=Присваивание параметру метода <code>\#ref</code> \#loc
assignment.to.null.display.name=Присваивание 'null'
assignment.to.null.option=Игнорировать присваивания полям
assignment.to.null.problem.descriptor='null' присвоен переменной <code>\#ref</code> \#loc
assignment.to.static.field.from.instance.method.display.name=Присваивание static полю из контекста экземпляра
assignment.to.static.field.from.instance.method.problem.descriptor=Присваивание static полю <code>\#ref</code> из контекста экземпляра \#loc
assignment.to.superclass.field.display.name=Конструктор присваивает значение полю, определённому в суперклассе
assignment.to.superclass.field.problem.descriptor=Присваивание полю ''{0}'', определённому в суперклассе ''{1}'' \#loc
assignment.used.as.condition.display.name=Присваивание используется как условие
assignment.used.as.condition.problem.descriptor=Присваивание <code>\#ref</code> используется как условие \#loc
atomic.field.updater.issues.display.name=Несогласованное объявление 'AtomicFieldUpdater'
atomic.field.updater.not.static.final.display.name=Поле 'AtomicFieldUpdater' не объявлено как 'static final'
atomic.field.updater.not.static.final.problem.descriptor=Поле {0} <code>\#ref</code> не объявлено как ''static final'' \#loc
auto.boxing.display.name=Автоупаковка
auto.boxing.ignore.added.to.collection.option=Игнорировать выражения, добавляемые в коллекцию
auto.boxing.make.boxing.explicit.quickfix=Сделать упаковку явной
auto.boxing.problem.descriptor=Автоупаковка <code>\#ref</code> \#loc
auto.closeable.resource.display.name=AutoCloseable используется без 'try-with-resources'
auto.closeable.resource.problem.descriptor=''{0}'' используется без оператора ''try-with-resources'' \#loc
auto.closeable.resource.quickfix=Игнорировать 'AutoCloseable', возвращаемый этим методом
auto.closeable.resource.quickfix.preview=Добавить метод <code>{0}</code> в список игнорируемых методов
auto.closeable.resource.returned.option=Игнорировать экземпляры AutoCloseable, возвращаемые всеми вызовами методов
auto.unboxing.display.name=Автораспаковка
auto.unboxing.make.unboxing.explicit.quickfix=Сделать распаковку явной
auto.unboxing.problem.descriptor=Автораспаковка <code>\#ref</code> \#loc
await.not.in.loop.display.name='await()' не вызывается в цикле
await.not.in.loop.problem.descriptor=Вызов <code>\#ref()</code> не в цикле \#loc
await.without.corresponding.signal.display.name='await()' без соответствующего 'signal()'
await.without.corresponding.signal.problem.descriptor=Вызов <code>\#ref()</code> без соответствующего <code>signal()</code> или <code>signalAll()</code> \#loc
bad.exception.caught.display.name=Перехвачено запрещенное исключение
bad.exception.caught.problem.descriptor=Перехвачено запрещенное исключение <code>\#ref</code> \#loc
bad.exception.declared.display.name=Объявлено запрещенное исключение
bad.exception.declared.problem.descriptor=Объявлено запрещенное исключение <code>\#ref</code> \#loc
bad.exception.thrown.display.name=Выброшено запрещенное исключение
bad.exception.thrown.problem.descriptor=Выброшено запрещенное исключение ''{0}'' \#loc
bad.oddness.display.name=Подозрительная проверка на нечетность
bad.oddness.problem.descriptor=Проверка на нечетность не сработает для отрицательных значений \#loc
big.decimal.equals.display.name='equals()' вызван для 'BigDecimal'
big.decimal.equals.problem.descriptor=<code>\#ref()</code> между значениями BigDecimal вероятно должен быть 'compareTo()' \#loc
big.decimal.method.without.rounding.called.display.name=Вызов метода 'BigDecimal' без аргумента режима округления
big.decimal.method.without.rounding.called.problem.descriptor='BigDecimal.\#ref()' вызван без аргумента режима округления
bigdecimal.legacy.method.display.name=Вызван устаревший метод 'BigDecimal'
bigdecimal.legacy.method.problem.descriptor=Вызов 'BigDecimal.\#ref()' может использовать константу перечисления 'RoundingMode'
bigdecimal.legacy.method.quickfix=Использовать константу перечисления 'RoundingMode'
boolean.constructor.display.name=Вызов конструктора Boolean
boolean.constructor.problem.descriptor=Вызов конструктора Boolean \#loc
boolean.constructor.simplify.quickfix=Упростить
boolean.expression.can.be.simplified.problem.descriptor=<code>\#ref</code> можно упростить до ''{0}'' \#loc
boolean.expression.does.not.modify.problem.descriptor=<code>\#ref</code> не изменяет значение ''{0}'' \#loc
boolean.expression.may.be.conditional.display.name=Булево выражение может быть заменено условным выражением
boolean.expression.remove.compound.assignment.quickfix=Удалить бессмысленное составное присваивание
boolean.field.always.inverted.problem.descriptor=Булево поле <code>\#ref</code> всегда инвертируется \#loc
boolean.method.name.must.start.with.question.display.name=Имя булева метода должно начинаться с вопросительного слова
boolean.method.name.must.start.with.question.problem.descriptor=Имя булева метода <code>\#ref</code> не начинается с вопросительного слова \#loc
boolean.method.name.must.start.with.question.table.label=Префиксы имен булевых методов\:
boolean.parameter.constructor.problem.descriptor='public' конструктор <code>\#ref()</code> с параметром типа 'boolean' \#loc
boolean.parameter.display.name='public' метод с параметром типа 'boolean'
boolean.parameter.only.report.multiple.option=Сообщать только о методах с несколькими булевыми параметрами
boolean.parameter.problem.descriptor='public' метод <code>\#ref()</code> с параметром типа 'boolean' \#loc
boolean.parameters.constructor.problem.descriptor='public' конструктор <code>\#ref()</code> с параметрами типа 'boolean' \#loc
boolean.parameters.problem.descriptor='public' метод <code>\#ref()</code> с параметрами типа 'boolean' \#loc
boolean.variable.always.inverted.display.name=Булева переменная всегда инвертируется
boolean.variable.always.inverted.problem.descriptor=Булева переменная <code>\#ref</code> всегда инвертируется \#loc
bounded.wildcard.contravariant.descriptor=Можно обобщить до <code>? super \#ref</code> \#loc
bounded.wildcard.covariant.descriptor=Можно обобщить до <code>? extends \#ref</code> \#loc
bounded.wildcard.display.name=Возможно использование ограниченного wildcard
bounded.wildcard.report.instance.option=Сообщать об методах экземпляра
bounded.wildcard.report.invariant.option=Сообщать об инвариантных классах
bounded.wildcard.report.private.option=Сообщать о private методах
boxing.boxed.value.display.name=Упаковка уже упакованного значения
boxing.boxed.value.problem.descriptor=Упаковка уже упакованного <code>\#ref</code> \#loc
boxing.boxed.value.quickfix=Удалить ненужную упаковку
break.statement.display.name=Оператор 'break'
break.statement.with.label.display.name=Оператор 'break' с меткой
break.statement.with.label.problem.descriptor=Оператор <code>\#ref</code> с меткой \#loc
busy.wait.display.name=Активное ожидание
busy.wait.problem.descriptor=Вызов <code>Thread.\#ref()</code> в цикле, возможно активное ожидание \#loc
c.style.array.declaration.display.name=Объявление массива в стиле C
c.style.array.declaration.replace.quickfix=Заменить на объявление массива в стиле Java
cached.number.constructor.call.display.name=Вызов конструктора Number с примитивным аргументом
cached.number.constructor.call.ignore.string.arguments.option=Игнорировать выражения new number со строковым аргументом
cached.number.constructor.call.problem.descriptor=Вызов конструктора Number с примитивным аргументом \#loc
cached.number.constructor.call.report.only.deprecated=Сообщать только когда конструктор помечен @Deprecated
call.to.date.tostring.display.name=Вызов 'Date.toString()'
call.to.date.tostring.problem.descriptor=<code>Date.\#ref()</code> используется в интернационализованном контексте \#loc
call.to.native.method.while.locked.display.name=Вызов 'native' метода при захваченной блокировке
call.to.native.method.while.locked.problem.descriptor=Вызов нативного метода <code>\#ref()</code> в синхронизованном контексте \#loc
call.to.numeric.tostring.display.name=Вызов 'Number.toString()'
call.to.numeric.tostring.problem.descriptor=<code>Number.\#ref()</code> вызван в интернационализованном контексте \#loc
call.to.private.setter.in.class.option=Сообщать только когда сеттер 'private'
call.to.private.simple.getter.in.class.option=Сообщать только когда геттер 'private'
call.to.simple.getter.in.class.display.name=Вызов простого геттера внутри класса
call.to.simple.getter.in.class.ignore.option=Игнорировать вызовы геттеров других объектов
call.to.simple.getter.in.class.inline.quickfix=Встроить вызов геттера
call.to.simple.getter.in.class.problem.descriptor=Вызов простого геттера <code>\#ref()</code> внутри класса \#loc
call.to.simple.setter.in.class.display.name=Вызов простого сеттера внутри класса
call.to.simple.setter.in.class.ignore.option=Игнорировать вызовы сеттеров других объектов
call.to.simple.setter.in.class.inline.quickfix=Встроить вызов сеттера
call.to.simple.setter.in.class.problem.descriptor=Вызов простого сеттера <code>\#ref()</code> внутри класса \#loc
call.to.string.concat.can.be.replaced.by.operator.display.name=Вызов 'String.concat()' может быть заменен на '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=Вызов <code>\#ref()</code> может быть заменен выражением с '+' \#loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=Заменить вызов 'concat()' на '+'
call.to.suspicious.string.method.display.name=Вызов подозрительного метода 'String'
call.to.suspicious.string.method.problem.descriptor=<code>String.\#ref()</code> вызван в интернационализованном контексте \#loc
cast.conflicts.with.instanceof.display.name=Приведение конфликтует с 'instanceof'
cast.conflicts.with.instanceof.problem.descriptor=Приведение к типу ''{0}'' конфликтует с предшествующей проверкой ''instanceof {1}''
cast.conflicts.with.instanceof.quickfix1=Заменить ''{0}'' на ''{1}'' в приведении типа
cast.conflicts.with.instanceof.quickfix2=Заменить ''{0}'' на ''{1}'' в instanceof
cast.that.loses.precision.display.name=Числовое приведение с потерей точности
cast.that.loses.precision.negative.problem.descriptor=Приведение из ''{0}'' к <code>\#ref</code> может привести к потере точности для отрицательного аргумента \#loc
cast.that.loses.precision.option=Игнорировать приведения из int в char
cast.that.loses.precision.problem.descriptor=Приведение из ''{0}'' к <code>\#ref</code> может привести к потере точности \#loc
cast.to.concrete.class.problem.descriptor=Приведение к конкретному классу <code>{0}</code> \#loc
casting.to.incompatible.interface.display.name=Приведение к несовместимому типу
casting.to.incompatible.interface.problem.descriptor=Приведение выражения типа ''{1}'' к несовместимому {0, choice, 1\#интерфейсу|2\#классу} <code>\#ref</code> \#loc
caught.exception.immediately.rethrown.display.name=Перехваченное исключение сразу же перебрасывается
caught.exception.immediately.rethrown.problem.descriptor=Перехваченное исключение <code>\#ref</code> сразу же перебрасывается \#loc
chain.of.class.equality.checks.problem.descriptor=Цепочка проверок равенства классов указывает на нарушение абстракции \#loc
chain.of.instanceof.checks.display.name=Цепочка проверок 'instanceof'
chain.of.instanceof.checks.problem.descriptor=Цепочка проверок 'instanceof' указывает на нарушение абстракции \#loc
chained.equality.comparisons.display.name=Цепочка сравнений на равенство
chained.equality.comparisons.problem.descriptor=Цепочка сравнений на равенство <code>\#ref</code> \#loc
chained.method.call.display.name=Цепочка вызовов методов
chained.method.call.ignore.option=Игнорировать цепочки вызовов методов в инициализаторах полей
chained.method.call.ignore.self.types.option=Игнорировать вызовы методов, возвращающих тот же тип, что и их включающий класс
chained.method.call.problem.descriptor=Цепочка вызовов методов <code>\#ref()</code> \#loc
change.modifier.fix.family.name=Изменить модификатор
change.modifier.package.private.quickfix=Сделать package-private
change.modifier.quickfix=Сделать ''{0}''
channel.opened.not.closed.display.name='Channel' открыт, но не закрыт безопасно
char.used.in.arithmetic.content.cast.fix.family.name=Вставить приведение типа
char.used.in.arithmetic.context.cast.quickfix=Вставить приведение к {0}
char.used.in.arithmetic.context.display.name=Выражение 'char' используется в арифметическом контексте
char.used.in.arithmetic.context.problem.descriptor='char' используется в арифметическом контексте \#loc
char.used.in.arithmetic.context.quickfix=Преобразовать в строковый литерал
character.comparison.display.name=Сравнение символов
character.comparison.problem.descriptor=Сравнение символов <code>\#ref</code> в интернационализованном контексте \#loc
checkbox.ignore.null.on.wrong.side=Игнорировать 'null' не с той стороны
checked.exception.class.display.name=Класс проверяемого исключения
checked.exception.class.problem.descriptor=Класс проверяемого исключения <code>\#ref</code> \#loc
choose.autocloseable.type.to.ignore.title=Выберите тип AutoCloseable ресурса для игнорирования
choose.class=Выберите класс
choose.class.hierarchy.to.ignore.title=Выберите иерархию классов для игнорирования
choose.class.type.to.ignore=Выберите класс для игнорирования
choose.exception.class=Выберите класс исключения
choose.exception.label=Запрещенные исключения\:
choose.io.resource.type.to.ignore=Выберите тип I/O ресурса для игнорирования
choose.logger.class=Выберите класс логгера
class.escapes.defined.scope.display.module.option=Сообщать о неэкспортуемых классах, доступных через API модуля (Java 9+)
class.escapes.defined.scope.display.name=Класс доступен за пределами области видимости
class.escapes.defined.scope.display.package.option=Сообщать о приватных классах, доступных через package-local API
class.escapes.defined.scope.display.public.option=Сообщать о недоступных классах, доступных через публичный API
class.escapes.defined.scope.java9.modules.descriptor=Класс <code>\#ref</code> не экспортуется из модуля ''{0}''
class.escapes.defined.scope.problem.descriptor=Класс <code>\#ref</code> доступен за пределами определённой области видимости \#loc
class.extends.utility.class.display.name=Класс наследует утилитарный класс
class.extends.utility.class.ignore.utility.class.option=Игнорировать, если переопределяющий класс является утилитарным
class.extends.utility.class.problem.descriptor=Класс <code>\#ref</code> наследует утилитарный класс ''{0}'' \#loc
class.independent.of.module.display.name=Класс независим от своего модуля
class.independent.of.module.problem.descriptor=Класс <code>\#ref</code> не имеет зависимостей или зависимых в своем модуле \#loc
class.initializer.display.name=Нестатический инициализатор
class.initializer.may.be.static.display.name=Инициализатор класса может быть 'static'
class.initializer.may.be.static.problem.descriptor=Инициализатор класса может быть 'static' \#loc
class.initializer.move.code.to.constructor.quickfix=Переместить код инициализатора в конструктор
class.initializer.option=Предупреждать только когда класс имеет один или более конструкторов
class.initializer.problem.descriptor=Нестатический инициализатор \#loc
class.loader.instantiation.display.name=Создание экземпляра 'ClassLoader'
class.loader.instantiation.problem.descriptor=Создание экземпляра <code>\#ref</code> может представлять угрозу безопасности \#loc
class.may.be.interface.convert.quickfix=Преобразовать класс в интерфейс
class.may.be.interface.display.name=Абстрактный 'class' может быть 'interface'
class.may.be.interface.java8.option=Сообщать о классах, содержащих неабстрактные методы при использовании Java 8
class.may.be.interface.problem.descriptor=Абстрактный класс <code>\#ref</code> может быть интерфейсом \#loc
class.name=Имя класса
class.name.differs.from.file.name.display.name=Имя класса отличается от имени файла
class.name.differs.from.file.name.problem.descriptor=Имя класса <code>\#ref</code> отличается от имени файла \#loc
class.name.prefixed.with.package.name.display.name=Имя класса с префиксом имени пакета
class.name.prefixed.with.package.name.problem.descriptor=Имя класса <code>\#ref</code> начинается с имени его пакета \#loc
class.name.same.as.ancestor.name.display.name=Имя класса совпадает с именем предка
class.name.same.as.ancestor.name.problem.descriptor=Имя класса <code>\#ref</code> совпадает с именем одного из его суперклассов \#loc
class.naming.convention.display.name=Соглашение об именовании классов
class.naming.convention.element.description=Класс
class.new.instance.display.name=Небезопасный вызов 'Class.newInstance()'
class.new.instance.problem.descriptor=Вызов <code>\#ref()</code> может выбросить необъявленные проверяемые исключения \#loc
class.only.used.in.one.module.display.name=Класс используется только из одного другого модуля
class.only.used.in.one.module.problem.descriptor=Класс <code>\#ref</code> имеет зависимости и/или зависимые классы только в модуле ''{0}'' \#loc
class.only.used.in.one.package.display.name=Класс используется только из одного другого пакета
class.only.used.in.one.package.problem.descriptor=Класс <code>\#ref</code> имеет зависимости и/или зависимые классы только в пакете ''{0}'' \#loc
class.references.subclass.display.name=Класс ссылается на один из своих подклассов
class.references.subclass.problem.descriptor=Класс ''{0}'' ссылается на подкласс <code>\#ref</code> \#loc
class.references.subclass.problem.descriptor.anonymous=Анонимный класс ссылается на подкласс <code>\#ref</code> \#loc
class.too.deep.display.name=Слишком глубокая иерархия наследования класса
class.too.deep.inheritance.depth.limit.option=Предел глубины наследования\:
class.too.deep.problem.descriptor=<code>\#ref</code> имеет слишком глубокую иерархию наследования (глубина \= {0}) \#loc
class.unconnected.to.package.display.name=Класс, независимый от своего пакета
class.unconnected.to.package.problem.descriptor=Класс <code>\#ref</code> не имеет зависимостей или зависимых классов в своем пакете
class.with.only.private.constructors.display.name=Класс только с 'private' конструкторами должен быть объявлен как 'final'
class.with.only.private.constructors.problem.descriptor=Класс <code>\#ref</code> только с 'private' конструкторами должен быть объявлен как 'final'
class.with.too.many.dependencies.display.name=Класс с большим количеством зависимостей
class.with.too.many.dependencies.max.option=Максимальное количество зависимостей
class.with.too.many.dependencies.problem.descriptor=Класс ''{0}'' имеет слишком много зависимостей ({1} > {2})
class.with.too.many.dependents.display.name=Класс с большим количеством зависимых классов
class.with.too.many.dependents.max.option=Максимальное количество зависимых классов
class.with.too.many.dependents.problem.descriptor=Класс ''{0}'' имеет слишком много зависимых классов ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=Класс с большим количеством транзитивных зависимостей
class.with.too.many.transitive.dependencies.max.option=Максимальное количество транзитивных зависимостей
class.with.too.many.transitive.dependencies.problem.descriptor=Класс ''{0}'' имеет слишком много транзитивных зависимостей ({1} > {2})
class.with.too.many.transitive.dependents.display.name=Класс с большим количеством транзитивных зависимых классов
class.with.too.many.transitive.dependents.max.option=Максимальное количество транзитивных зависимых классов
class.with.too.many.transitive.dependents.problem.descriptor=Класс ''{0}'' имеет слишком много транзитивных зависимостей ({1} > {2})
class.without.constructor.create.quickfix=Сгенерировать пустой конструктор
class.without.constructor.display.name=Класс без конструктора
class.without.constructor.problem.descriptor=Класс <code>\#ref</code> не имеет конструктора \#loc
class.without.logger.annotations.tab=Аннотации
class.without.logger.loggers.tab=Логгеры
class.without.no.arg.constructor.display.name=Класс без конструктора без аргументов
class.without.no.arg.constructor.ignore.option=Игнорировать, если класс имеет конструктор по умолчанию
class.without.no.arg.constructor.problem.descriptor=В классе <code>\#ref</code> отсутствует конструктор без аргументов \#loc
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=Добавить 'CloneNotSupportedException' в throws
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' не объявляет 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>\#ref()</code> \#loc не объявляет 'CloneNotSupportedException'
clone.instantiates.new.array.problem.descriptor=''clone()'' создает новый массив {0} \#loc
clone.instantiates.objects.with.constructor.display.name='clone()' создает объекты через конструктор
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' создает новые экземпляры <code>\#ref</code> \#loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>\#ref()</code> определен в не-Cloneable анонимном классе, производном от ''{0}'' \#loc
clone.method.in.non.cloneable.class.display.name=Метод 'clone()' в не-Cloneable классе
clone.method.in.non.cloneable.class.problem.descriptor=<code>\#ref()</code> определен в не-Cloneable классе ''{0}'' \#loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>\#ref()</code> определен в не-Cloneable интерфейсе ''{0}'' \#loc
clone.returns.class.type.display.name='clone()' должен возвращать тип класса, в котором он содержится
clone.returns.class.type.family.quickfix=Изменить возвращаемый тип на тип класса
clone.returns.class.type.problem.descriptor=''clone()'' должен возвращать тип ''{0}'' \#loc
clone.returns.class.type.quickfix=Изменить возвращаемый тип на ''{0}''
cloneable.class.in.secure.context.display.name=Cloneable класс в защищенном контексте
cloneable.class.in.secure.context.problem.descriptor=Класс <code>\#ref</code> может быть клонован, что ставит под угрозу безопасность \#loc
cloneable.class.in.secure.context.quickfix=Сгенерировать метод 'clone()', всегда выбрасывающий исключение
cloneable.class.without.clone.display.name=Cloneable класс без метода 'clone()'
cloneable.class.without.clone.ignore.option=Игнорировать классы, наследующие Cloneable
cloneable.class.without.clone.ignore.when.clone.called.option=Игнорировать, если Cloneable необходим для вызова метода clone() суперкласса
cloneable.class.without.clone.problem.descriptor=<code>\#ref</code> реализует 'Cloneable', но не определяет метод 'clone()' \#loc
cloneable.class.without.clone.quickfix=Сгенерировать метод 'clone()'
cloneable.class.without.clone.todo.message=TODO\: скопировать изменяемое состояние здесь, чтобы клон не мог изменить внутреннее состояние оригинала
collection.added.to.self.display.name=Коллекция добавлена сама в себя
collection.added.to.self.problem.descriptor=''{0}()'' вызван для коллекции <code>\#ref</code> с ней же в качестве аргумента \#loc
collection.declared.by.class.display.name=Коллекция объявлена классом, а не интерфейсом
collection.declared.by.class.ignore.locals.option=Игнорировать локальные переменные
collection.declared.by.class.ignore.private.members.option=Игнорировать 'private' поля и методы
collection.declared.by.class.problem.descriptor=Объявление <code>\#ref</code> следует ослабить до ''{0}'' \#loc
collections.field.access.replaceable.by.method.call.display.name=Ссылку на пустое поле коллекции можно заменить вызовом метода
collections.field.access.replaceable.by.method.call.fix.family.name=Заменить Collections.EMPTY_* вызовом метода
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>\#ref</code> можно заменить на ''Collections.{0}'' \#loc
collections.must.have.initial.capacity.display.name=Коллекция без начальной емкости
collections.must.have.initial.capacity.problem.descriptor=<code>new \#ref()</code> без начальной емкости \#loc
commented.out.code.delete.quickfix=Удалить комментарий
commented.out.code.uncomment.quickfix=Раскомментировать код
comments.as.content.option=Считать комментарии содержимым
comparable.implemented.but.equals.not.overridden.display.name='Comparable' реализован, но 'equals()' не переопределен
comparable.implemented.but.equals.not.overridden.fix.add.note.name=Добавить JavaDoc-примечание 'ordering inconsistent with equals'
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=Сгенерировать метод 'equals()'
comparable.implemented.but.equals.not.overridden.problem.descriptor=Класс <code>\#ref</code> реализует 'java.lang.Comparable', но не переопределяет 'equals()' \#loc
comparator.not.serializable.display.name=Класс 'Comparator' не объявлен как 'Serializable'
comparator.not.serializable.problem.descriptor=Класс компаратора <code>\#ref</code> не объявлен как Serializable \#loc
comparison.of.short.and.char.display.name=Сравнение значений типов 'short' и 'char'
comparison.of.short.and.char.problem.descriptor=Сравнение на равенство <code>\#ref</code> значений типов short и char \#loc
comparison.to.nan.display.name=Сравнение с 'Double.NaN' или 'Float.NaN'
comparison.to.nan.problem.descriptor1=Сравнение с <code>\#ref</code> всегда возвращает false \#loc
comparison.to.nan.problem.descriptor2=Сравнение с <code>\#ref</code> всегда возвращает true \#loc
concrete.class.method.parameter.problem.descriptor=Параметр ''{0}'' конкретного класса <code>\#ref</code> \#loc
concrete.class.use.display.name=Использование конкретного класса
condition.signal.display.name=Вызов 'signal()' вместо 'signalAll()'
condition.signal.problem.descriptor=<code>\#ref</code> следует заменить на 'signalAll()' \#loc
conditional.can.be.pushed.inside.expression.display.name=Условное выражение можно переместить внутрь ветви
conditional.can.be.pushed.inside.expression.option=Игнорировать, когда условие будет единственным аргументом вызова метода
conditional.can.be.pushed.inside.expression.problem.descriptor=Условное выражение можно переместить внутрь ветви \#loc
conditional.can.be.pushed.inside.expression.quickfix=Переместить условное выражение внутрь ветви
conditional.expression.display.name=Условное выражение
conditional.expression.expression.context.option=Игнорировать места, где невозможно использовать оператор if
conditional.expression.option=Игнорировать для простых присваиваний и возвратов
conditional.expression.problem.descriptor=Условное выражение <code>\#ref</code> \#loc
conditional.expression.quickfix=Заменить на оператор 'if'
conditional.expression.with.identical.branches.collapse.quickfix=Свернуть условное выражение
conditional.expression.with.identical.branches.display.name=Условное выражение с идентичными ветвями
conditional.expression.with.identical.branches.problem.descriptor=Условное выражение <code>\#ref</code> с идентичными ветвями \#loc
confusing.else.option=Сообщать, когда после оператора 'if' нет других операторов
confusing.floating.point.literal.change.quickfix=Изменить в каноническую форму
confusing.floating.point.literal.display.name=Неоднозначный литерал с плавающей точкой
confusing.floating.point.literal.option=Игнорировать литералы с плавающей точкой в научной нотации
confusing.floating.point.literal.problem.descriptor=Неоднозначный литерал с плавающей точкой <code>\#ref</code> \#loc
confusing.main.method.display.name=Неоднозначный метод 'main()'
confusing.main.method.problem.descriptor=Метод <code>\#ref</code> не имеет сигнатуры 'public static void main(String[])' \#loc
confusing.octal.escape.sequence.display.name=Неоднозначная восьмеричная escape-последовательность
confusing.octal.escape.sequence.problem.descriptor=За восьмеричной escape-последовательностью <code>\#ref</code> сразу следует цифра \#loc
connection.opened.not.safely.closed.display.name=Соединение открыто, но не закрыто безопасно
consider.static.final.fields.constant.option=Считать поля 'static final' константами
constant.assert.condition.display.name=Константное условие в операторе 'assert'
constant.assert.condition.problem.descriptor=Условие assert <code>\#ref</code> является константой \#loc
constant.conditional.expression.display.name=Константное условное выражение
constant.conditional.expression.problem.descriptor=<code>\#ref</code> можно упростить до ''{0}'' \#loc
constant.conditional.expression.simplify.quickfix=Упростить
constant.conditional.expression.simplify.quickfix.sideEffect=Извлечь побочные эффекты и упростить
constant.declared.in.abstract.class.display.name=Константа объявлена в 'abstract' классе
constant.declared.in.abstract.class.problem.descriptor=Константа <code>\#ref</code> объявлена в абстрактном классе \#loc
constant.declared.in.interface.display.name=Константа объявлена в интерфейсе
constant.declared.in.interface.problem.descriptor=Константа <code>\#ref</code> объявлена в интерфейсе \#loc
constant.for.zero.length.array.display.name=Избыточное использование массива нулевой длины
constant.for.zero.length.array.problem.descriptor=Массив нулевой длины можно заменить константой \#loc
constant.for.zero.length.array.quickfix.family=Заменить константой
constant.junit.assert.argument.display.name=Константный аргумент assert
constant.junit.assert.argument.problem.descriptor=Аргумент <code>\#ref</code> является константой \#loc
constant.math.call.display.name=Константный вызов 'Math'
constant.math.call.problem.descriptor=Константный вызов <code>\#ref()</code> можно упростить \#loc
constant.naming.convention.element.description=Константа
constant.on.lhs.of.comparison.options.item.left=слева
constant.on.lhs.of.comparison.options.item.right=справа
constant.on.lhs.of.comparison.problem.descriptor=Константа <code>\#ref</code> в левой части сравнения \#loc
constant.on.rhs.of.comparison.problem.descriptor=Константа <code>\#ref</code> в правой части сравнения \#loc
constant.on.side.of.comparison.display.name=Константа на неверной стороне сравнения
constant.value.variable.use.display.name=Использование переменной с известным константным значением
constant.value.variable.use.problem.descriptor=Значение <code>\#ref</code> известно как константа \#loc
constant.with.mutable.field.naming.convention.element.description=Константа изменяемого типа
constructor.visibility.option=Игнорировать конструкторы с видимостью\:
continue.or.break.from.finally.block.display.name='continue' или 'break' внутри блока 'finally'
continue.or.break.from.finally.block.problem.descriptor=<code>\#ref</code> внутри блока 'finally' \#loc
continue.statement.display.name=Оператор 'continue'
continue.statement.with.label.display.name=Оператор 'continue' с меткой
continue.statement.with.label.problem.descriptor=Оператор <code>\#ref</code> с меткой \#loc
control.flow.statement.without.braces.add.quickfix=Добавить фигурные скобки к оператору
control.flow.statement.without.braces.display.name=Оператор управления без фигурных скобок
control.flow.statement.without.braces.message=Добавить фигурные скобки к оператору ''{0}''
control.flow.statement.without.braces.problem.descriptor=<code>{0}</code> без фигурных скобок \#loc
convert.double.unary.quickfix=Заменить на ''{0}{1}''
convert.empty.anonymous.to.new.fix.family.name=Удалить '{}'
convert.octal.literal.to.decimal.literal.quickfix=Преобразовать восьмеричный литерал в десятичный
convert.octal.literals.to.decimal.literals.quickfix=Преобразовать восьмеричные литералы в десятичные
convert.system.out.to.log.call.family.name=Преобразовать вызов 'System.out' в вызов логгера
convert.system.out.to.log.call.name=Преобразовать вызов ''System.out'' в вызов ''{0}''
convert.to.variable.arity.method.quickfix=Преобразовать в метод с переменным числом аргументов
copy.constructor.misses.field.display.name=Конструктор копирования пропускает поле
copy.constructor.misses.field.problem.descriptor.1=Конструктор копирования не копирует поле ''{0}''
copy.constructor.misses.field.problem.descriptor.2=Конструктор копирования не копирует поля ''{0}'' и ''{1}''
copy.constructor.misses.field.problem.descriptor.3=Конструктор копирования не копирует поля ''{0}'', ''{1}'' и ''{2}''
copy.constructor.misses.field.problem.descriptor.many=Конструктор копирования не копирует {0} полей
covariant.equals.display.name=Ковариантный метод 'equals()'
covariant.equals.problem.descriptor=<code>\#ref()</code> должен принимать 'Object' в качестве аргумента \#loc
create.default.branch.fix.family.name=Создать ветвь 'default'
create.missing.boolean.switch.branches.fix.family.name=Создать отсутствующие ветви boolean switch
create.missing.branches.with.null.branch.fix.family.name=Создать отсутствующие ветви и ветвь 'null'
create.missing.enum.switch.branches.fix.family.name=Создать отсутствующие ветви enum switch
create.missing.record.deconstructions.switch.branches.fix.family.name=Создать отсутствующие ветви деконструкции record switch
create.missing.sealed.class.switch.branches.fix.family.name=Создать отсутствующие ветви sealed class switch
create.missing.switch.branch=Создать отсутствующую ветвь {0}
create.missing.switch.branches=Создать отсутствующие ветви {0}
create.null.branch.fix.family.name=Создать ветвь 'null'
create.package.info.java.family.name=Создать 'package-info.java'
cstyle.array.method.declaration.problem.descriptor=Метод <code>{0}()</code> имеет объявление возвращаемого типа массива в стиле C \#loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1\#Поле|2\#Параметр|3\#Компонент записи|4\#Локальная переменная} <code>{1}</code> имеет объявление массива в стиле C \#loc
custom.classloader.display.name=Объявлен пользовательский 'ClassLoader'
custom.classloader.problem.descriptor=Пользовательский класс ClassLoader <code>\#ref</code> \#loc
custom.security.manager.display.name=Пользовательский 'SecurityManager'
custom.security.manager.problem.descriptor=Пользовательский класс SecurityManager <code>\#ref</code> \#loc
cyclic.class.dependency.1.problem.descriptor=Класс ''{0}'' циклически зависит от класса ''{1}''
cyclic.class.dependency.2.problem.descriptor=Класс ''{0}'' циклически зависит от классов ''{1}'' и ''{2}''
cyclic.class.dependency.display.name=Циклическая зависимость классов
cyclic.class.dependency.ignore.in.same.file=Игнорировать циклы между классами в одном файле
cyclic.class.dependency.problem.descriptor=Класс ''{0}'' циклически зависит от {1} других классов
cyclic.package.dependency.1.problem.descriptor=Пакет ''{0}'' циклически зависит от пакета ''{1}''
cyclic.package.dependency.2.problem.descriptor=Пакет ''{0}'' циклически зависит от пакетов ''{1}'' и ''{2}''
cyclic.package.dependency.display.name=Циклическая зависимость пакетов
cyclic.package.dependency.problem.descriptor=Пакет ''{0}'' циклически зависит от {1} других пакетов
cyclomatic.complexity.display.name=Чрезмерно сложный метод
cyclomatic.complexity.limit.option=Предел цикломатической сложности\:
cyclomatic.complexity.problem.descriptor=Чрезмерно сложный метод <code>\#ref()</code> (цикломатическая сложность \= {0}) \#loc
dangling.javadoc.convert.line.comment.quickfix=Заменить строчными комментариями
dangling.javadoc.convert.quickfix=Заменить блочным комментарием
dangling.javadoc.delete.quickfix=Удалить висячий комментарий
dangling.javadoc.display.name=Висячий комментарий Javadoc
dangling.javadoc.ignore.copyright.option=Игнорировать заголовок файла в формате JavaDoc
dangling.javadoc.problem.descriptor=Висячий комментарий Javadoc \#loc
debug.level.and.lower.option=уровень debug и ниже
declare.collection.as.interface.fix.family.name=Ослабить тип
declare.collection.as.interface.quickfix=Ослабить до ''{0}''
default.not.last.case.in.switch.display.name='default' не последний case в 'switch'
default.not.last.case.in.switch.problem.descriptor=Ветка ''default'' не последний case в ''switch'' {0} \#loc
default.tostring.call.display.name=Вызов стандартного 'toString()'
default.tostring.call.problem.descriptor=Вызов стандартного 'toString()' для <code>\#ref</code> \#loc
delete.catch.section.fix.family.name=Удалить оператор catch
delete.catch.section.quickfix=Удалить секцию 'catch'
delete.import.quickfix=Удалить ненужный импорт
delete.unnecessary.statement.fix.family.name=Удалить избыточный оператор
deserializable.class.in.secure.context.problem.descriptor=Класс <code>\#ref</code> может быть десериализован, что ставит под угрозу безопасность \#loc
design.for.extension.display.name=Проектирование для расширения
design.for.extension.problem.descriptor=Метод <code>\#ref()</code> может быть переопределен и его функциональность проигнорирована \#loc
diamond.can.be.replaced.with.explicit.type.arguments.name=Diamond может быть заменен явными аргументами типа
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=Заменить '<>' явными аргументами типа
disjoint.package.display.name=Пакет с несвязным графом зависимостей
disjoint.package.problem.descriptor=Пакет {0} может быть разделен на {1} независимых пакетов
divide.by.zero.display.name=Деление на ноль
divide.by.zero.problem.descriptor=Деление на ноль \#loc
dollar.sign.in.name.display.name=Использование '$' в идентификаторе
dollar.sign.in.name.problem.descriptor=Идентификатор <code>\#ref</code> содержит '$' \#loc
double.brace.initialization.display.name=Инициализация двойными фигурными скобками
double.brace.initialization.quickfix=Заменить обычной инициализацией
double.checked.locking.display.name=Double-checked locking
double.checked.locking.fix.family.name=Сделать поле volatile
double.checked.locking.problem.descriptor=Double-checked locking \#loc
double.checked.locking.quickfix=Сделать ''{0}'' volatile
double.literal.may.be.float.literal.display.name=Приведение к 'float' может быть литералом 'float'
double.negation.display.name=Двойное отрицание
double.negation.problem.descriptor=Двойное отрицание в <code>\#ref</code> \#loc
double.negation.quickfix=Удалить двойное отрицание
drivermanager.call.display.name=Использование 'DriverManager' для получения JDBC-соединения
drivermanager.call.problem.descriptor=Вызов <code>DriverManager.\#ref()</code> \#loc
dumpstack.call.display.name=Вызов 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=Вызов <code>Thread.\#ref()</code> следует заменить более надежным логованием \#loc
duplicate.condition.display.name=Дублирующееся условие
duplicate.condition.ignore.method.calls.option=Игнорировать условия с возможными побочными эффектами
duplicate.condition.ignore.method.calls.option.description=Если отмечено, условия с потенциальными побочными эффектами (например, неизвестные вызовы методов) не будут отмечаться. Методы, заведомо имеющие побочные эффекты, не отмечаются в любом случае.
duplicate.condition.problem.descriptor=Дублирующееся условие <code>\#ref</code> \#loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=Динамическое регулярное выражение может быть заменено скомпилированным 'Pattern'
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>\#ref()</code> может быть заменен конструкцией скомпилированного 'java.util.regex.Pattern' \#loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=Заменить вызовом метода скомпилированной константы 'Pattern'
empty.anonymous.class.problem.descriptor=Анонимный класс пуст \#loc
empty.class.display.name=Пустой класс
empty.class.file.without.class.problem.descriptor=Java-файл не объявляет ни одного класса \#loc
empty.class.ignore.parameterization.option=Игнорировать класс, если это параметризация супертипа
empty.class.initializer.delete.quickfix=Удалить пустой инициализатор класса
empty.class.initializer.display.name=Пустой инициализатор класса
empty.class.initializer.problem.descriptor=Пустой инициализатор класса \#loc
empty.class.problem.descriptor=Класс <code>\#ref</code> пуст \#loc
empty.enum.problem.descriptor=Enum <code>\#ref</code> пуст \#loc
empty.finally.block.display.name=Пустой блок 'finally'
empty.finally.block.problem.descriptor=Пустой блок <code>\#ref</code> \#loc
empty.synchronized.statement.display.name=Пустой оператор 'synchronized'
empty.synchronized.statement.problem.descriptor=Пустой оператор <code>\#ref</code> \#loc
empty.try.block.display.name=Пустой блок 'try'
empty.try.block.problem.descriptor=Пустой блок <code>\#ref</code> \#loc
encapsulate.variable.fix.family.name=Инкапсулировать поле
encapsulate.variable.quickfix=Инкапсулировать поле ''{0}''
enum.singleton.problem.descriptor=Enum <code>\#ref</code> является синглтоном \#loc
enum.switch.statement.which.misses.cases.display.name='switch' по enum пропускает case
enum.switch.statement.which.misses.cases.option=Игнорировать switch с веткой по умолчанию
enum.switch.statement.which.misses.cases.problem.descriptor=Оператор <code>\#ref</code> для enum-типа ''{0}'' пропускает cases {1} \#loc
enum.switch.statement.which.misses.cases.problem.descriptor.single=Оператор <code>\#ref</code> для enum-типа ''{0}'' пропускает case ''{1}'' \#loc
enumerated.class.display.name=Перечисляемый класс
enumerated.class.naming.convention.element.description=Enum-класс
enumerated.class.problem.descriptor=Перечисляемый класс <code>\#ref</code> \#loc
enumerated.constant.naming.convention.element.description=Константа enum
enumeration.can.be.iteration.display.name=Enumeration может быть заменен на итерацию
enumeration.can.be.iteration.problem.descriptor=<code>\#ref()</code> может быть заменен конструкцией ''{0}'' \#loc
enumeration.can.be.iteration.quickfix=Заменить конструкцией 'Iterator'
equality.to.safe.equals.quickfix=Заменить '\=\=' на null-безопасный 'equals()'
equals.between.inconvertible.types.display.name='equals()' между объектами несовместимых типов
equals.between.inconvertible.types.mutual.subclass.option=Предупреждать, если не найден общий подкласс
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=Не найден класс, являющийся подтипом и ''{0}'', и ''{1}'' \#loc
equals.between.inconvertible.types.problem.descriptor=<code>\#ref</code> между объектами несовместимых типов ''{0}'' и ''{1}'' \#loc
equals.called.on.array.display.name=Вызов 'equals()' для массива
equals.called.on.array.problem.descriptor=<code>\#ref()</code> между массивами должен быть заменен на 'Arrays.equals()' \#loc
equals.called.on.enum.constant.display.name='equals()' вызван для значения enum
equals.called.on.enum.constant.problem.descriptor=<code>\#ref()</code> вызван для значения enum \#loc
equals.called.on.suspicious.object.display.name='equals()' вызван для классов, не переопределяющих его
equals.called.on.suspicious.object.fix.family.name=Заменить сравнением репрезентативных значений
equals.called.on.suspicious.object.fix.name=Заменить сравнением результатов вызова ''{0}()''
equals.called.on.suspicious.object.problem.descriptor=Подозрительный вызов ''equals()'' для объекта ''{0}''
equals.doesnt.check.class.parameter.display.name=Метод 'equals()', не проверяющий класс параметра
equals.doesnt.check.class.parameter.problem.descriptor=<code>\#ref()</code> должен проверять класс своего параметра \#loc
equals.replaceable.by.objects.call.display.name=Выражение 'equals()' может быть заменено выражением 'Objects.equals()'
equals.replaceable.by.objects.call.problem.descriptor=<code>\#ref</code> может быть заменен выражением 'Objects.equals()' \#loc
equals.replaceable.by.objects.check.not.null.option=Подсвечивать выражения вида 'a \!\= null \\&\\& a.equals(b)'
equals.with.itself.display.name='equals()' вызван для самого себя
equals.with.itself.option=Игнорировать возможное тестование контракта
equals.with.itself.option.description=Если отмечено, некоторые случаи вроде <code>assertEquals(myObj, myObj)</code> не будут отмечаться, чтобы избежать предупреждений в тестах, проверяющих корректность метода <code>equals()</code>.
equals.with.itself.problem.descriptor=<code>\#ref()</code> вызван для самого себя
error.rethrown.display.name='Error' не перевыброшен
error.rethrown.problem.descriptor=Ошибка <code>\#ref</code> не перевыброшена \#loc
exception.from.catch.which.doesnt.wrap.display.name='throw' внутри блока 'catch', игнорирующего пойманное исключение
exception.from.catch.which.doesnt.wrap.problem.descriptor=<code>\#ref</code> внутри блока 'catch' игнорирует пойманное исключение \#loc
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=Игнорировать, если выброшенное исключение не может обернуть исключение
exception.from.catch.which.doesntwrap.ignore.option=Игнорировать, если используется результат вызова метода исключения
exception.name.doesnt.end.with.exception.display.name=Имя класса исключения не оканчивается на 'Exception'
exception.name.doesnt.end.with.exception.problem.descriptor=Имя класса исключения <code>\#ref</code> не оканчивается на 'Exception' \#loc
exception.package.display.name=Пакет исключений
exception.package.problem.descriptor=Пакет ''{0}'' содержит только классы исключений
explicit.array.to.string.problem.descriptor=Вызов '\#ref()' для массива \#loc
expression.can.be.replaced.no.quotes.problem.descriptor={0} может быть заменено на {1}
expression.can.be.replaced.problem.descriptor=<code>\#ref</code> может быть заменено на ''{0}'' \#loc
expression.may.be.factorized.display.name=Выражение может быть факторизовано
extend.exception.fix.family.name=Сделать класс наследником 'Exception'
extended.for.statement.display.name=Расширенный оператор 'for'
extended.for.statement.problem.descriptor=Расширенный оператор <code>\#ref</code> \#loc
extended.for.statement.replace.quickfix=Заменить на старый стиль оператора 'for'
extends.annotation.display.name=Класс наследует интерфейс аннотации
extends.annotation.interface.problem.descriptor=Интерфейс ''{0}'' расширяет интерфейс аннотации <code>\#ref</code> \#loc
extends.annotation.problem.descriptor=Класс ''{0}'' реализует интерфейс аннотации <code>\#ref</code> \#loc
extends.concrete.collection.display.name=Класс явно наследует класс 'Collection'
extends.concrete.collection.problem.descriptor=Класс <code>\#ref</code> явно наследует ''{0}'' \#loc
extends.object.display.name=Класс явно наследует 'Object'
extends.object.problem.descriptor=Класс <code>\#ref</code> явно наследует 'java.lang.Object' \#loc
extends.object.remove.quickfix=Удалить избыточное 'extends Object'
extends.thread.display.name=Класс напрямую наследует 'Thread'
extends.thread.problem.descriptor=Класс <code>\#ref</code> напрямую наследует 'java.lang.Thread' \#loc
extends.throwable.display.name=Класс напрямую наследует 'Throwable'
extends.throwable.problem.descriptor=Класс <code>\#ref</code> напрямую наследует 'java.lang.Throwable' \#loc
externalizable.with.serialization.methods.display.name=Externalizable класс с 'readObject()' или 'writeObject()'
externalizable.with.serialization.methods.problem.descriptor.both=Externalizable {0, choice, 1\#класс|2\#интерфейс|3\#анонимный класс, производный от|4\#тип аннотации|5\#перечисление|6\#запись} <code>\#ref</code> определяет 'readObject()' и 'writeObject()' \#loc
externalizable.with.serialization.methods.problem.descriptor.read=Externalizable {0, choice, 1\#класс|2\#интерфейс|3\#анонимный класс, производный от|4\#тип аннотации|5\#перечисление|6\#запись} <code>\#ref</code> определяет 'readObject()' \#loc
externalizable.with.serialization.methods.problem.descriptor.write=Externalizable {0, choice, 1\#класс|2\#интерфейс|3\#анонимный класс, производный от|4\#тип аннотации|5\#перечисление|6\#запись} <code>\#ref</code> определяет 'writeObject()' \#loc
externalizable.without.public.no.arg.constructor.display.name='Externalizable' класс без публичного конструктора без аргументов
externalizable.without.public.no.arg.constructor.problem.descriptor=Externalizable класс <code>\#ref</code> не имеет публичного конструктора без аргументов \#loc
extract.method.quickfix=Извлечь метод
extract.parameter.as.local.variable.quickfix=Извлечь параметр как локальную переменную
fallthru.in.switch.statement.display.name=Проваливание в операторе 'switch'
fallthru.in.switch.statement.problem.descriptor=Проваливание в операторе 'switch' \#loc
fallthru.in.switch.statement.quickfix=Добавить ''{0}''
feature.envy.display.name=Привязанность к функциональности
feature.envy.problem.descriptor=Класс ''{0}'' многократно используется в методе <code>\#ref()</code> \#loc
field.accessed.synchronized.and.unsynchronized.display.name=Поле используется как в synchronized, так и в несинхронизованных контекстах
field.accessed.synchronized.and.unsynchronized.option=Простые геттеры и сеттеры также считаются доступом к полям
field.accessed.synchronized.and.unsynchronized.problem.descriptor=Поле <code>\#ref</code> используется как в синхронизованном, так и в несинхронизованном контексте \#loc
field.count.inspection.include.constant.fields.in.count.checkbox=Включать константные поля в подсчет
field.count.inspection.include.enum.constants.in.count=Включать константы перечисления в подсчет
field.count.inspection.static.final.fields.count.as.constant.checkbox=Считать 'static final' поля константами
field.has.setter.but.no.getter.display.name=У поля есть setter, но нет getter
field.has.setter.but.no.getter.problem.descriptor=Поле <code>\#ref</code> имеет setter, но не имеет getter \#loc
field.has.static.modifier.problem.descriptor=Поле ''{0}'' имеет модификатор ''static''
field.incorrect.type.problem.descriptor=Поле ''{0}'' не имеет тип ''{1}''
field.may.be.final.display.name=Поле может быть 'final'
field.may.be.final.problem.descriptor=Поле <code>\#ref</code> может быть 'final' \#loc
field.may.be.static.display.name=Поле может быть 'static'
field.may.be.static.problem.descriptor=Поле <code>\#ref</code> может быть 'static' \#loc
field.missing.volatile.modifier.problem.descriptor=Поле ''{0}'' не имеет модификатор ''volatile''
field.name.hides.in.superclass.display.name=Поле подкласса скрывает поле суперкласса
field.name.hides.in.superclass.ignore.option=Игнорировать недоступные поля
field.name.hides.in.superclass.ignore.static.field.option=Игнорировать static поля, скрывающие static поля
field.name.hides.in.superclass.problem.descriptor=Поле <code>\#ref</code> скрывает поле в суперклассе \#loc
field.naming.convention.display.name=Соглашение об именовании полей
field.not.found.in.class.problem.descriptor=Поле с именем ''{0}'' не найдено в классе ''{1}''
final.class.display.name=Класс закрыт для наследования
final.class.problem.descriptor=Класс ''{0}'' объявлен как <code>\#ref</code> \#loc
final.method.display.name=Метод не может быть переопределен
final.method.in.final.class.display.name='final' метод в 'final' классе
final.method.in.final.class.problem.descriptor=Метод объявлен как <code>\#ref</code> в 'final' классе \#loc
final.method.problem.descriptor=Метод объявлен как <code>\#ref</code> \#loc
final.private.method.display.name='private' метод объявлен как 'final'
final.private.method.problem.descriptor='private' метод объявлен как <code>\#ref</code> \#loc
final.static.method.display.name='static' метод объявлен как 'final'
final.static.method.problem.descriptor='static' метод объявлен как <code>\#ref</code> \#loc
finalize.called.explicitly.display.name='finalize()' вызван явно
finalize.called.explicitly.problem.descriptor=<code>\#ref()</code> вызван явно \#loc
finalize.declaration.display.name='finalize()' не должен переопределяться
finalize.declaration.problem.descriptor='finalize()' не должен переопределяться \#loc
finalize.not.declared.protected.display.name='finalize()' должен быть protected, а не public
finalize.not.declared.protected.problem.descriptor='finalize()' должен иметь модификатор доступа protected, а не public \#loc
finally.block.cannot.complete.normally.display.name=Блок 'finally', который не может завершиться нормально
finally.block.cannot.complete.normally.problem.descriptor=Блок <code>\#ref</code> не может завершиться нормально \#loc
fix.add.argument.family.name=Добавить аргумент
fix.add.argument.name=Добавить аргумент ''{0}''
fix.eliminate.folded.if.present.description=Свернутый вызов 'ifPresent()' может быть удален
fix.eliminate.folded.if.present.name=Удалить свернутый вызов 'ifPresent()'
fix.replace.map.with.flat.map.description='map()' может быть заменен на 'flatMap()'
flip.comparison.quickfix=Инвертировать сравнение
floating.point.equality.display.name=Сравнение чисел с плавающей точкой на равенство
floating.point.equality.problem.descriptor=<code>\#ref</code>\: значения с плавающей точкой сравниваются на точное равенство \#loc
for.can.be.foreach.display.name=Цикл 'for' может быть заменен расширенным циклом for
for.can.be.foreach.fix.no.indexed=Не сообщать о циклах с индексацией 'java.util.List'
for.can.be.foreach.option=Сообщать о циклах с индексацией 'java.util.List'
for.can.be.foreach.option2=Не сообщать об итерациях по коллекциям без типа
for.can.be.foreach.problem.descriptor=Цикл <code>\#ref</code> может быть заменен расширенным 'for' \#loc
for.loop.replaceable.by.while.display.name=Цикл 'for' может быть заменен циклом 'while'
for.loop.replaceable.by.while.ignore.option=Игнорировать 'бесконечные' циклы for без условий
for.loop.replaceable.by.while.problem.descriptor=Оператор цикла <code>\#ref</code> может быть заменен циклом 'while' \#loc
for.loop.with.missing.component.collection.loop.option=Игнорировать итерации по коллекциям
for.loop.with.missing.component.display.name=Цикл 'for' с отсутствующими компонентами
for.loop.with.missing.component.problem.descriptor1=В операторе <code>\#ref</code> отсутствует инициализатор \#loc
for.loop.with.missing.component.problem.descriptor2=В операторе <code>\#ref</code> отсутствует условие \#loc
for.loop.with.missing.component.problem.descriptor3=В операторе <code>\#ref</code> отсутствует обновление \#loc
for.loop.with.missing.component.problem.descriptor4=В операторе <code>\#ref</code> отсутствуют инициализатор и условие \#loc
for.loop.with.missing.component.problem.descriptor5=В операторе <code>\#ref</code> отсутствуют инициализатор и обновление \#loc
for.loop.with.missing.component.problem.descriptor6=В операторе <code>\#ref</code> отсутствуют условие и обновление \#loc
for.loop.with.missing.component.problem.descriptor7=В операторе <code>\#ref</code> отсутствуют инициализатор, условие и обновление \#loc
foreach.replace.quickfix=Заменить на расширенный 'for'
format.string.error.duplicate.flag=повторяющийся флаг ''{0}'' в ''{1}''
format.string.error.flags.not.allowed={2, choice, 1\#флаг|1<флаги} ''{0}'' недопустимы в ''{1}''
format.string.error.illegal.flag.combination=недопустимая комбинация флагов ''{0}'' и ''{1}'' в ''{2}''
format.string.error.illegal.position.specifier=недопустимый спецификатор позиции ''{0}'' в ''{1}''
format.string.error.invalid.precision=указана недопустимая точность в ''{0}''
format.string.error.left.justify.no.width=использован флаг выравнивания по левому краю ''-'', но не указана ширина в ''{0}''
format.string.error.precision.not.allowed=точность (''{0}'') недопустима в ''{1}''
format.string.error.previous.element.not.found=использован предыдущий флаг ''<'', но не найден предыдущий спецификатор формата для ''{0}''
format.string.error.unexpected.flag=неожиданный символ ''{0}'' в ''{1}''
format.string.error.unknown.conversion=неизвестное преобразование в ''{0}''
format.string.error.unnecessary.position.specifier=лишний спецификатор позиции аргумента ''{0}'' в ''{1}''
format.string.error.width.not.allowed=ширина (''{0}'') недопустима в ''{1}''
format.string.error.zero.padding.no.width=использован флаг заполнения нулями ''0'', но не указана ширина в ''{0}''
gc.call.display.name=Вызов 'System.gc()' или 'Runtime.gc()'
gc.call.problem.descriptor=<code>\#ref</code> не должен вызываться в production-коде \#loc
generate.to.string.quick.fix.family.name=Сгенерировать
generate.to.string.quick.fix.text=Сгенерировать toString()
groups.of.modules.loaded.together.description=Каждая строка определяет список имен модулей через запятую, которые загружаются одним классзагрузчиком.\nДоступ к package-private членам между такими модулями не должен отмечаться.
groups.of.modules.loaded.together.label=Группы модулей, загружаемых вместе\:
hardcoded.file.separator.display.name=Жестко закодованный разделитель файлов
hardcoded.file.separator.ignore.methods.option=Игнорировать аргументы для следующих методов\:
hardcoded.file.separator.include.option=Включить 'example/*' в распознаваемые MIME медиа-типы
hardcoded.file.separator.problem.descriptor=Жестко закодованный разделитель файлов <code>\#ref</code> \#loc
hardcoded.line.separator.display.name=Жестко закодованный разделитель строк
hardcoded.line.separator.problem.descriptor=Жестко закодованный разделитель строк <code>\#ref</code> \#loc
hibernate.resource.opened.not.closed.display.name=Ресурс Hibernate открыт, но не закрыт безопасно
html.tag.can.be.javadoc.tag.display.name='<code>…</code>' может быть заменен на '{@code …}'
html.tag.can.be.javadoc.tag.problem.descriptor=<code>\#ref...\\&lt;/code\\&gt;</code> может быть заменен на '{@code …}' \#loc
i.o.resource.opened.not.closed.display.name=I/O ресурс открыт, но не закрыт безопасно
if.can.be.assertion.name=Оператор может быть заменен на 'assert' или 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=Заменить оператор на оператор 'assert'
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=Заменить оператор на 'Objects.requireNonNull()'
if.can.be.switch.display.name='if' может быть заменен на 'switch'
if.can.be.switch.enum.option=Предлагать switch для перечислений
if.can.be.switch.int.option=Предлагать switch для чисел
if.can.be.switch.minimum.branch.option=Минимальное количество веток условия 'if'\:
if.can.be.switch.null.safe.option=Предлагать только для null-safe выражений
if.can.be.switch.problem.descriptor=Оператор <code>\#ref</code> может быть заменен оператором 'switch' \#loc
if.may.be.conditional.problem.descriptor=<code>\#ref</code> может быть заменен условным выражением \#loc
if.may.be.conditional.quickfix=Заменить условным выражением
if.may.be.factorized.problem.descriptor=<code>\#ref</code> может быть факторизован \#loc
if.may.be.factorized.quickfix=Заменить факторизованным выражением
if.statement.with.identical.branches.display.name=Оператор 'if' с идентичными ветками или общими частями
if.statement.with.too.many.branches.display.name=Оператор 'if' с слишком большим количеством веток
if.statement.with.too.many.branches.max.option=Максимальное количество веток\:
if.statement.with.too.many.branches.problem.descriptor=<code>\#ref</code> имеет слишком много веток ({0}) \#loc
ignore.accesses.from.equals.method=Игнорировать доступы из метода 'equals()'
ignore.accesses.from.the.same.class=Игнорировать доступы из того же класса
ignore.anonymous.inner.classes=Игнорировать анонимные классы
ignore.boolean.methods.in.an.interface.option=Игнорировать булевы методы в @&interface
ignore.branches.of.switch.statements=Игнорировать ветки операторов 'switch'
ignore.calls.to.property.getters=Игнорировать вызовы геттеров свойств
ignore.calls.to.static.methods=Игнорировать вызовы статических методов
ignore.classes.annotated.by=Игнорировать классы, аннотированные\:
ignore.classes.in.hierarchy.column.name=Игнорировать подклассы\:
ignore.cloneable.option=Игнорировать 'java.lang.Cloneable'
ignore.constructor.method.references=Игнорировать ссылки на конструкторы, создающие AutoCloseable
ignore.enhanced.for.loop.statements=Игнорировать расширенные циклы for
ignore.equals.hashcode.and.tostring=Игнорировать методы 'equals()', 'hashCode()' и 'toString()'
ignore.exceptions.declared.on.library.override.option=Игнорировать исключения, объявленные в методах, переопределяющих методы &библиотеки
ignore.for.equals.methods.option=Игнорировать для методов '&equals()'
ignore.getters.returning.resource=Игнорировать геттеры, возвращающие ресурс
ignore.guard.clauses.option=Игнорировать защитные условия [&G]
ignore.if.annotated.by=Игнорировать, если аннотировано\:
ignore.in.module.statements.option=Игнорировать в операторах модулей Java 9
ignore.instanceof.on.library.classes=Игнорировать instanceof для библиотечных классов
ignore.methods.in.anonymous.classes=Игнорировать методы в анонимных классах
ignore.methods.overriding.super.method=Игнорировать методы, переопределяющие/реализующие метод суперкласса(O&)
ignore.methods.with.boolean.return.type.option=Игнорировать методы с возвращаемым типом 'java.lang.&Boolean'
ignore.overflowing.byte.casts.option=Игнорировать приведения из int 128-255 к byte
ignore.parentheses.around.single.no.formal.type.lambda.parameter=Игнорировать скобки вокруг одиночного параметра лямбды без формального типа
ignore.private.methods.option=Игнорировать присваивания и возвраты в private методах
ignore.serializable.option=Игнорировать 'java.io.Serializable'
ignore.single.field.static.imports.option=Игнорировать одиночные static import полей [&F]
ignore.single.method.static.imports.option=Игнорировать одиночные static import методов [&M]
ignore.trivial.finalizers.option=Игнорировать для тривиальных реализаций 'finalize()'
ignored.autocloseable.types.label=Игнорируемые типы AutoCloseable ресурсов\:
ignored.class.hierarchies.border.title=Игнорировать подклассы\:
ignored.class.label=Игнорируемые классы (включая подклассы)\:
ignored.class.names=Игнорировать классы (включая подклассы)
ignored.io.resource.types.label=Игнорируемые типы I/O ресурсов\:
implicit.array.to.string.display.name=Вызов 'toString()' для массива
implicit.array.to.string.fix.family.name=Сделать Array.toString() неявным
implicit.array.to.string.method.call.problem.descriptor=Неявный вызов 'toString()' для массива, возвращаемого вызовом <code>\#ref</code> \#loc
implicit.array.to.string.problem.descriptor=Неявный вызов 'toString()' для массива <code>\#ref</code> \#loc
implicit.array.to.string.quickfix=Обернуть выражением ''{0}''
implicit.call.to.super.display.name=Неявный вызов 'super()'
implicit.call.to.super.ignore.option=Игнорировать для прямых подклассов 'java.lang.Object'
implicit.call.to.super.make.explicit.quickfix=Сделать вызов 'super()' явным
implicit.call.to.super.problem.descriptor=Неявный вызов 'super()' \#loc
implicit.default.charset.usage.constructor.problem.descriptor=Вызов <code>new \#ref()</code> использует платформенное кодование по умолчанию
implicit.default.charset.usage.display.name=Неявное платформенное кодование по умолчанию
implicit.default.charset.usage.fix.family.name=Указать кодование UTF-8
implicit.default.charset.usage.problem.descriptor=Вызов <code>\#ref()</code> использует платформенное кодование по умолчанию
implicit.numeric.conversion.assignment.problem.descriptor=Неявное числовое преобразование результата из ''{0}'' в ''{1}'' \#loc
implicit.numeric.conversion.display.name=Неявное числовое преобразование
implicit.numeric.conversion.ignore.char.conversion.option=Игнорировать преобразования из и в 'char'
implicit.numeric.conversion.ignore.constant.conversion.option=Игнорировать преобразования из констант и литералов
implicit.numeric.conversion.ignore.widening.conversion.option=Игнорировать расширяющие преобразования
implicit.numeric.conversion.make.explicit.quickfix=Сделать преобразование явным
implicit.numeric.conversion.problem.descriptor=Неявное числовое преобразование <code>\#ref</code> из ''{0}'' в ''{1}'' \#loc
import.display.name=Импорт '*'
import.from.same.package.display.name=Ненужный импорт из того же пакета
import.from.same.package.problem.descriptor=Ненужный импорт из того же пакета <code>\#ref</code> \#loc
import.problem.descriptor=Импорт пакета <code>\#ref</code> \#loc
include.java.system.classes.option=Включать связи с системными классами Java
include.library.classes.option=Включать связи с библиотечными классами
incompatible.mask.operation.display.name=Несовместимая операция побитовой маски
incompatible.mask.operation.problem.descriptor.always.false=<code>\#ref</code> всегда false \#loc
incompatible.mask.operation.problem.descriptor.always.true=<code>\#ref</code> всегда true \#loc
incorrect.date.format.fix.family.name=Исправить некорректный формат даты
increment.decrement.display.name=Используется результат '++' или '--'
increment.decrement.used.as.expression.fix.family.name=Извлечь в отдельный оператор
increment.decrement.used.as.expression.quickfix=Извлечь ''{0}'' в отдельный оператор
inequality.to.safe.not.equals.quickfix=Заменить '\!\=' на null-безопасный '\!equals()'
infinite.loop.statement.display.name=Бесконечный цикл
infinite.loop.statement.problem.descriptor=Оператор <code>\#ref</code> не может завершиться без выброса исключения \#loc
infinite.recursion.display.name=Бесконечная рекурсия
infinite.recursion.problem.descriptor=Метод <code>\#ref()</code> рекурсивно вызывает сам себя бесконечно и может завершиться только выбросом исключения \#loc
info.level.and.lower.option=уровень info и ниже
inline.call.quickfix=Встроить вызов
inline.variable.quickfix=Встроить переменную
inner.class.field.hides.outer.display.name=Поле внутреннего класса скрывает поле внешнего класса
inner.class.field.hides.outer.ignore.option=Игнорировать поля внешнего класса, невидимые из внутреннего класса
inner.class.field.hides.outer.problem.descriptor=Поле внутреннего класса <code>\#ref</code> скрывает поле внешнего класса \#loc
inner.class.may.be.static.display.name=Внутренний класс может быть 'static'
inner.class.may.be.static.problem.descriptor=Внутренний класс <code>\#ref</code> может быть 'static' \#loc
inner.class.on.interface.display.name=Внутренний класс интерфейса
inner.class.on.interface.ignore.option=Игнорировать внутренние интерфейсы интерфейсов
inner.class.on.interface.problem.descriptor=Интерфейс ''{0}'' имеет внутренний класс <code>\#ref</code> \#loc
inner.class.referenced.via.subclass.display.name=Внутренний класс используется через подкласс
inner.class.referenced.via.subclass.problem.descriptor=Внутренний класс <code>\#ref</code> объявлен в классе ''{0}'', но используется через подкласс ''{1}'' \#loc
inner.class.referenced.via.subclass.quickfix=Рационализовать доступ к внутреннему классу
inner.class.too.deeply.nested.display.name=Слишком глубокая вложенность внутреннего класса
inner.class.too.deeply.nested.nesting.limit.option=Предел вложенности\:
inner.class.too.deeply.nested.problem.descriptor=<code>\#ref</code> имеет слишком глубокую вложенность (уровень вложенности \= {0}) \#loc
inspection.autocloseable.resource.ignored.methods.title=Игнорировать экземпляры AutoCloseable, возвращаемые этими методами\:
inspection.byte.array.output.stream.to.string.message=Неэффективное преобразование из ByteArrayOutputStream
inspection.case.mismatch.display.name=Несоответствие регистра в операции со 'String'
inspection.case.mismatch.message.arg.is.lower=Метод ''{0}()'' всегда возвращает {1}\: аргумент содержит символ в нижнем регистре, а квалификатор не содержит символов в нижнем регистре
inspection.case.mismatch.message.arg.is.upper=Метод ''{0}()'' всегда возвращает {1}\: аргумент содержит символ в верхнем регистре, а квалификатор не содержит символов в верхнем регистре
inspection.case.mismatch.message.label.is.lower=Ветка switch недостижима\: метка содержит символ в нижнем регистре, а селектор содержит только символы в верхнем регистре
inspection.case.mismatch.message.label.is.upper=Ветка switch недостижима\: метка содержит символ в верхнем регистре, а селектор содержит только символы в нижнем регистре
inspection.cast.can.be.replaced.with.variable.display.name=Приведение типа может быть заменено переменной
inspection.cast.can.be.replaced.with.variable.family.name=Заменить приведение типа переменной
inspection.cast.can.be.replaced.with.variable.message=Вместо ''{1}'' может быть использована переменная ''{0}''
inspection.catch.ignores.exception.display.name=Блок catch может игнорировать исключение
inspection.catch.ignores.exception.empty.message=Пустой блок <code>\#ref</code> \#loc
inspection.catch.ignores.exception.option.comments=Не предупреждать, когда блок 'catch' содержит комментарий
inspection.catch.ignores.exception.option.ignored.used=Не предупреждать, когда исключение с именем 'ignore(d)' фактически не игнорируется
inspection.catch.ignores.exception.option.nonempty=Не предупреждать, когда блок 'catch' не пуст
inspection.catch.ignores.exception.unused.message=Неиспользуемый параметр 'catch' <code>\#ref</code> \#loc
inspection.catch.ignores.exception.used.message=Параметр 'catch' с именем <code>\#ref</code> используется \#loc
inspection.catch.ignores.exception.vm.ignored.message=Неожиданное исключение VM типа ''{0}'' может быть проигнорировано в блоке <code>\#ref</code> \#loc
inspection.collection.must.have.initial.capacity.initializers.option=Не сообщать об инициализаторах полей
inspection.commented.out.code.disable.short.fragments=Не сообщать о таких коротких фрагментах
inspection.commented.out.code.display.name=Закомментированный код
inspection.commented.out.code.min.lines.options=Минимальное количество строк кода
inspection.commented.out.code.problem.descriptor=Закомментированный код ({0} {0, choice, 1\#строка|1<строк})
inspection.common.if.parts.description.complete.duplicate=Оператор ''if'' может быть свёрнут{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=Оператор 'if' может быть свёрнут с извлечением побочного эффекта
inspection.common.if.parts.description.variables.only=Переменные могут быть извлечены из ''if''{0}
inspection.common.if.parts.description.whole.branch=Общая часть может быть извлечена с удалением ветки{0}
inspection.common.if.parts.description.with.variables.extract=Общие части с переменными могут быть извлечены из ''if''{0}
inspection.common.if.parts.description.without.variables.extract=Общая часть может быть извлечена из ''if''{0}
inspection.common.if.parts.message.complete.duplicate=Свернуть оператор ''if''{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=Свернуть оператор 'if' и извлечь побочный эффект
inspection.common.if.parts.message.variables.only=Извлечь переменные из ''if''{0}
inspection.common.if.parts.message.whole.branch=Извлечь общую часть с удалением ветки{0}
inspection.common.if.parts.message.with.variables.extract=Извлечь общую часть с переменными из ''if''{0}
inspection.common.if.parts.message.without.variables.extract=Извлечь общую часть из ''if''{0}
inspection.common.subexpression.in.switch.display.name=Общее подвыражение может быть извлечено из 'switch'
inspection.common.subexpression.in.switch.fix.family.name=Опустить выражение 'switch'
inspection.comparator.combinators.description=Может быть заменено цепочкой 'Comparator'
inspection.comparator.combinators.description2=Может быть заменено на ''{0}''
inspection.comparator.combinators.fix.chain=Заменить цепочкой 'Comparator'
inspection.condition.covered.by.further.condition.descr=Условие ''{0}'' покрывается последующим{1, choice, 1\#и условиями ''''{2}''''|2\# условиями}
inspection.constant.expression.display.name=Константное выражение может быть вычислено
inspection.constant.expression.fix.family.name=Вычислить константное значение
inspection.constant.expression.fix.name=Вычислить константное значение ''{0}''
inspection.constant.expression.fix.name.short=Заменить константным значением
inspection.constant.expression.message=Константное выражение может быть вычислено как ''{0}''
inspection.constant.expression.report.compile.time=Сообщать только о константах времени компиляции
inspection.constant.expression.report.compile.time.description=По умолчанию инспекция может вычислять некоторые константы, включающие вызовы методов библиотек, или даже выводить константное значение на основе окружающего кода. Отметьте эту опцию, чтобы сообщать только о константах времени компиляции согласно спецификации языка Java.
inspection.constant.expression.skip.non.literal=Не сообщать о выражениях, содержащих ссылки на определённые константы
inspection.constant.expression.skip.non.literal.description=Игнорировать выражения, содержащие ссылки на нелитеральные операнды, такие как поля и переменные.
inspection.deconstruction.can.be.used.display.name=Может быть использован паттерн записи
inspection.deconstruction.can.be.used.fix.family.name=Заменить на паттерн записи
inspection.deconstruction.can.be.used.message=Может быть заменено на паттерн записи
inspection.empty.catch.block.generate.body=Сгенерировать тело 'catch' из шаблона
inspection.empty.class.ignore.subclasses.option=Игнорировать подклассы {0}
inspection.enhanced.for.with.record.pattern.can.be.used.components.option=Максимальное количество компонентов записи для деконструкции\:
inspection.enhanced.for.with.record.pattern.can.be.used.display.name=Может быть использован расширенный 'for' с паттерном записи
inspection.enhanced.for.with.record.pattern.can.be.used.fix.family.name=Заменить на паттерн записи
inspection.enhanced.for.with.record.pattern.can.be.used.level.option=Предел глубины вложенности\:
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.depth.disabled=Не предлагать для паттернов с {0} и более вложенными паттернами
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.number.disabled=Не предлагать для записей с {0} или более компонентами
inspection.enhanced.for.with.record.pattern.can.be.used.message=Может быть заменено на расширенный 'for' с паттерном записи
inspection.enhanced.for.with.record.pattern.can.be.used.not.used.option=Максимальное количество неиспользуемых компонентов записи\:
inspection.excessive.range.check.fix.family.name=Упростить избыточную проверку диапазона
inspection.excessive.range.check.message=Можно заменить на ''{0}''
inspection.if.statement.missing.break.in.loop.description=Цикл может быть прерван после выполнения условия
inspection.if.statement.missing.break.in.loop.name=Ранний выход из цикла в условии 'if'
inspection.if.statement.missing.break.in.loop.quickfix=Добавить 'break'
inspection.incorrect.date.format.display.name=Некорректный шаблон 'DateTimeFormat'
inspection.incorrect.date.format.message.literal=Открывающая одинарная кавычка ({0}) без закрывающей одинарной кавычки
inspection.incorrect.date.format.message.padding=Модификатор заполнения ''{0}'' без последовательных букв шаблона
inspection.incorrect.date.format.message.reserved.character=Использование зарезервированного символа ''{0}''
inspection.incorrect.date.format.message.unpaired=Закрывающий <code>\#ref</code> без предшествующего открывающего ''{0}''
inspection.incorrect.date.format.message.unsupported=Недопустимая буква шаблона ''{0}''
inspection.incorrect.date.format.too.few.letters=Слишком мало последовательных букв шаблона ''{0}''; минимум\: {1}; указано\: {2}
inspection.incorrect.date.format.too.many.letters=Слишком много последовательных букв шаблона ''{0}''; максимум\: {1}; указано\: {2}
inspection.incorrect.date.format.wrong.number.of.letters=Неверное количество последовательных букв шаблона ''{0}''; разрешено\: {1}; указано\: {2}
inspection.incorrect.message.custom.classes.methods=Пользовательские методы MessageFormat\:
inspection.incorrect.message.format.choice.limit.incorrect=Нижняя граница ''{0}'' в шаблоне выбора некорректна
inspection.incorrect.message.format.choice.limit.not.found=Пустая нижняя граница в шаблоне выбора
inspection.incorrect.message.format.display.name=Некорректный шаблон 'MessageFormat'
inspection.incorrect.message.format.incorrect.index=Некорректный индекс ''{0}''
inspection.incorrect.message.format.incorrect.order.choice=Нижние границы не в порядке возрастания в шаблоне выбора
inspection.incorrect.message.format.incorrect.quotes.number=Возможно некорректное количество кавычек, будет напечатано более 1 кавычки
inspection.incorrect.message.format.not.found.argument=Нет аргумента для индекса ''{0}''
inspection.incorrect.message.format.not.found.arguments=Нет аргументов для индексов\: {0}
inspection.incorrect.message.format.not.used.argument=Аргумент с индексом ''{0}'' не используется в шаблоне
inspection.incorrect.message.format.pattern={0} в шаблоне формата сообщения ''{1}''
inspection.incorrect.message.format.quotes.around.parameter=Заполнитель ''{0}'' не будет подставлен, так как он заключен в кавычки
inspection.incorrect.message.format.unclosed.brace=Незакрытая фигурная скобка
inspection.incorrect.message.format.unknown.format.type=Неизвестный тип формата ''{0}''
inspection.incorrect.message.format.unmatched.brace=Несогласованная фигурная скобка
inspection.incorrect.message.format.unpaired.quote=Непарная кавычка в шаблоне сообщения
inspection.list.remove.in.loop.display.name='List.remove()' вызывается в цикле
inspection.list.remove.in.loop.message=Можно заменить на 'List.subList().clear()'
inspection.lossy.conversion.compound.assignment.display.name=Неявное приведение из ''{0}'' в ''{1}'' в составном присваивании может привести к потере данных
inspection.lossy.conversion.compound.assignment.name=Возможно потеря данных при неявном приведении типов в составном присваивании
inspection.meta.annotation.without.runtime.description={0} должен иметь @Retention(RetentionPolicy.RUNTIME)
inspection.method.call.in.loop.ignore.known.methods.option=Игнорировать известные методы с побочными эффектами
inspection.new.object.equality.display.name=Новый объект сравнивается через '\=\='
inspection.new.object.equality.message=Новый объект сравнивается через ''{0}''
inspection.non.strict.comparison.equality.display.name=Нестрогое неравенство '>\=' или '<\=' можно заменить на '\=\='
inspection.non.strict.comparison.equality.message=Можно заменить на равенство
inspection.note.may.change.semantics=может изменить семантику
inspection.only.one.element.used.array=Используется только один элемент массива
inspection.only.one.element.used.display.name=Используется только один элемент
inspection.only.one.element.used.fix.family=Заменить на используемый элемент
inspection.only.one.element.used.list=Используется только один элемент списка
inspection.only.one.element.used.string=Используется только один символ строки
inspection.option.ignore.as.initial.capacity=Игнорировать начальную емкость для StringBuilders и Collections
inspection.option.ignore.assert=Игнорировать для аргументов описания оператора assert
inspection.option.ignore.constant.initializers=Игнорировать для инициализаторов константных полей
inspection.option.ignore.exceptions=Игнорировать для аргументов конструктора подклассов Throwable
inspection.option.ignore.in.annotations=Игнорировать в аннотациях
inspection.option.ignore.in.hashcode=Игнорировать константы в методах 'hashCode()'
inspection.option.ignore.in.tostring=Игнорировать внутри методов toString()
inspection.option.ignore.nonnls=Игнорировать при аннотации через @NonNls
inspection.option.ignore.system.err=Игнорировать для аргументов 'System.err.print'
inspection.option.ignore.system.out=Игнорировать для аргументов 'System.out.print'
inspection.pattern.variable.can.be.used.display.name=Можно использовать переменную шаблона
inspection.pattern.variable.can.be.used.existing.cast.message=Можно использовать существующую переменную шаблона ''{0}'' вместо выражения приведения типа
inspection.pattern.variable.can.be.used.existing.fix.family.name=Заменить на существующую переменную шаблона
inspection.pattern.variable.can.be.used.existing.fix.name=Заменить ''{0}'' на существующую переменную шаблона ''{1}''
inspection.pattern.variable.can.be.used.existing.message=Можно использовать существующую переменную шаблона ''{0}'' вместо ''{1}''
inspection.pattern.variable.can.be.used.fix.family.name=Заменить на переменную шаблона
inspection.pattern.variable.can.be.used.fix.name=Заменить ''{0}'' на переменную шаблона
inspection.pattern.variable.can.be.used.instead.of.cast.message=Выражение приведения типа можно заменить на переменную шаблона
inspection.pattern.variable.can.be.used.message=Переменную ''{0}'' можно заменить на переменную шаблона
inspection.pattern.variable.can.be.used.report.cast.only=Сообщать о выражениях приведения типа, которые можно заменить на новые переменные шаблона
inspection.pattern.variable.instead.of.cast.can.be.used.existing.fix.name=Заменить выражение приведения типа на существующую переменную шаблона ''{0}''
inspection.pattern.variable.instead.of.cast.can.be.used.fix.family.name=Заменить выражения приведения типа на переменную шаблона
inspection.redundant.arguments.message=Ненужные аргументы
inspection.redundant.class.call.display.name=Избыточный вызов 'isInstance()' или 'cast()'
inspection.redundant.collection.operation.display.name=Избыточная операция с 'Collection'
inspection.redundant.collection.operation.fix.family.name=Упростить операцию с коллекцией
inspection.redundant.collection.operation.problem.arraycopy=Ненужная коллекция создана для копирования массива
inspection.redundant.collection.removal.by.index.fix=Использовать удаление по объекту
inspection.redundant.collection.removal.by.index.problem=Удаление по индексу можно заменить на удаление по объекту
inspection.redundant.collection.unnecessary.contains.fix=Удалить проверку ''{0}()''
inspection.redundant.collection.unnecessary.contains.problem=Ненужная проверка ''{0}()''
inspection.redundant.compare.call.display.name=Избыточный вызов метода 'compare()'
inspection.redundant.compare.call.fix.name=Встроить вызов 'compare()'
inspection.redundant.embedded.expression.display.name=Избыточное встроенное выражение в строковом шаблоне
inspection.redundant.embedded.expression.fix.family.name=Встроить встроенное выражение
inspection.redundant.embedded.expression.message.empty=Избыточное пустое встроенное выражение
inspection.redundant.embedded.expression.message.literal=Избыточный встроенный литерал
inspection.redundant.empty.string.argument.message=Ненужный пустой строковый аргумент
inspection.redundant.explicit.variable.type.description=Явный тип локальной переменной можно опустить
inspection.redundant.java.time.operation.compare.java.time.family.name=Упростить выражение с вызовом 'java.time' 'compareTo()'
inspection.redundant.java.time.operation.compare.java.time.problem.descriptor=Выражение с вызовом 'java.time' <code>\#ref()</code> можно упростить
inspection.redundant.java.time.operation.creation.java.time.error.message=Избыточное создание объекта ''{0}''
inspection.redundant.java.time.operation.creation.java.time.error.remove.fix.message=Удалить вызов ''{0}''
inspection.redundant.java.time.operation.creation.java.time.error.replace.fix.message=Заменить на вызов ''{0}''
inspection.redundant.java.time.operation.creation.java.time.family.name=Упростить создание объекта 'java.time'
inspection.redundant.java.time.operation.creation.java.time.redundant.call.message=Избыточный вызов ''{0}''
inspection.redundant.java.time.operation.creation.java.time.remove.family.name=Удалить ненужный вызов
inspection.redundant.java.time.operation.display.name=Избыточная операция над объектом 'java.time'
inspection.redundant.java.time.operation.explicit.chrono.field.family.name=Упростить вызовы с явными аргументами 'ChronoField' или 'ChronoUnit'
inspection.redundant.java.time.operation.explicit.chrono.field.problem.descriptor=Вызовы с явными аргументами 'ChronoField' или 'ChronoUnit' можно упростить
inspection.redundant.length.check.display.name=Избыточная проверка длины массива
inspection.redundant.string.call.message=Вызов <code>\#ref()</code> избыточен \#loc
inspection.redundant.string.constructor.message=<code>new \#ref()</code> избыточен \#loc
inspection.redundant.string.fix.family.name=Удалить избыточный вызов
inspection.redundant.string.fix.remove.str.processor.description=Строковый шаблон можно преобразовать в обычный строковый литерал
inspection.redundant.string.intern.on.constant.message=Вызов <code>\#ref()</code> для константы времени компиляции не нужен \#loc
inspection.redundant.string.length.argument.message=Лишний аргумент длины строки
inspection.redundant.string.new.array.message=<code>\#ref</code> избыточен \#loc
inspection.redundant.string.operation.display.name=Избыточная операция со строкой
inspection.redundant.string.option.do.not.report.single.argument.substring=Не сообщать об избыточных вызовах substring() с одним аргументом
inspection.redundant.string.option.do.not.report.string.constructors=Не сообщать о вызовах конструктора String
inspection.redundant.string.remove.argument.fix.name=Удалить аргумент
inspection.redundant.string.replace.with.arg.fix.name=Заменить аргументом
inspection.redundant.string.replace.with.empty.fix.name=Заменить пустой строкой
inspection.redundant.zero.argument.message=Лишний нулевой аргумент
inspection.refused.bequest.super.annotated.option=Сообщать только когда super метод аннотирован\:
inspection.remove.redundant.call.fix.name=Удалить избыточный вызов ''{0}()''
inspection.replace.on.literal.display.name=Операция замены не имеет эффекта
inspection.simplifiable.if.statement.display.name='if' можно заменить условным или логическим выражением
inspection.simplifiable.if.statement.fix.family.name=Заменить 'if else' условным выражением
inspection.simplifiable.if.statement.fix.name=Заменить ''if else'' на ''{0}''
inspection.simplifiable.if.statement.message=Оператор if можно заменить на ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=Не предлагать оператор '?\:'
inspection.suspicious.date.format.display.name=Подозрительный шаблон формата даты
inspection.suspicious.date.format.message.lower=Используется шаблон со строчной буквой ''{0}'' ({1})\: возможно, имелось в виду ''{2}'' ({3})
inspection.suspicious.date.format.message.upper=Используется шаблон с заглавной буквой ''{0}'' ({1})\: возможно, имелось в виду ''{2}'' ({3})
inspection.suspicious.package.private.access.description={0} является {1}, но объявлен в другом модуле ''{2}''
inspection.suspicious.package.private.access.problem={0} переопределяет package-private метод из {1}, который объявлен в другом модуле ''{2}''
inspection.test.method.without.assertion.list.name=Методы проверки\:
inspection.test.method.without.assertions.exceptions.option=Игнорировать тестовые методы, объявляющие исключения
inspection.trivial.functional.expression.usage.description=Вызов метода можно упростить
inspection.type.may.be.weakened.add.stop.class.family=Добавить стоп-класс
inspection.type.may.be.weakened.add.stop.class.selection.popup=Выбрать стоп-класс
inspection.type.may.be.weakened.add.stop.class.selection.table=Стоп-классы
inspection.type.may.be.weakened.add.stop.class.selection.table.label=Стоп-классы\:
inspection.type.may.be.weakened.add.stopper=Добавить как стоп-класс для ослабления
inspection.type.may.be.weakened.add.stopper.preview=Стоп-класс будет добавлен в список стоп-классов для этой проверки.
inspection.type.may.be.weakened.add.stopper.single=Добавить {0} как стоп-класс для ослабления
inspection.type.may.be.weakened.display.name=Тип может быть ослаблен
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=Не предлагать ослабление переменных, объявленных как 'var'
inspection.type.may.be.weakened.field.problem.descriptor=Тип поля <code>\#ref</code> может быть ослаблен до {0} \#loc
inspection.type.may.be.weakened.method.problem.descriptor=Возвращаемый тип метода <code>\#ref()</code> может быть ослаблен до {0} \#loc
inspection.type.may.be.weakened.only.weaken.to.an.interface=Ослаблять только до интерфейса
inspection.type.may.be.weakened.parameter.problem.descriptor=Тип параметра <code>\#ref</code> может быть ослаблен до {0} \#loc
inspection.type.may.be.weakened.problem.descriptor=Тип переменной <code>\#ref</code> может быть ослаблен до {0} \#loc
inspection.type.may.be.weakened.quickfix=Ослабить тип до ''{0}''
inspection.type.may.be.weakened.weaken.type.family=Ослабить тип
inspection.unnecessary.string.escape.report.char.literals.option=Сообщать о символьных литералах
inspection.unsupported.chrono.field.unit.call.display.name=Вызов методов с неподдерживаемыми 'java.time.temporal.ChronoUnit' и 'java.time.temporal.ChronoField'
inspection.unsupported.chrono.value.message=Неподдерживаемое значение аргумента\: {0}
inspection.unsupported.chrono.values.message=Неподдерживаемые значения аргументов\: {0}
inspection.use.of.private.field.inner.classes.option=Игнорировать доступ из внутренних классов
inspection.use.of.slash.s.display.name=Нетерминальное использование escape-последовательности '\\s'
inspection.use.of.slash.s.fix.family=Заменить последовательности '\\s' пробелами
inspection.use.of.slash.s.message=Использование escape-последовательности '\\s' в качестве не конечного пробела
inspection.use.of.slash.s.non.text.block.message=Использование escape-последовательности '\\s' вне текстовых блоков
inspection.while.can.be.replaced.with.do.while.display.name='while' можно заменить на 'do while'
inspection.while.can.be.replaced.with.do.while.family.name=Заменить 'while' на 'do while'
inspection.while.can.be.replaced.with.do.while.message=Заменить 'while' на 'do while'
inspection.x.call.can.be.replaced.with.y=Вызов <code>\#ref()</code> можно заменить на ''{0}()''
instance.Variable.may.not.be.initialized.problem.descriptor.junit=Поле экземпляра <code>\#ref</code> может быть не инициализовано при создании объекта или вызове 'setUp()' \#loc
instance.method.naming.convention.element.description=Метод экземпляра
instance.variable.may.not.be.initialized.display.name=Поле экземпляра может быть не инициализовано
instance.variable.may.not.be.initialized.problem.descriptor=Поле экземпляра <code>\#ref</code> может быть не инициализовано при создании объекта \#loc
instance.variable.naming.convention.element.description=Поле экземпляра
instance.variable.of.concrete.class.problem.descriptor=Поле экземпляра ''{0}'' конкретного класса <code>\#ref</code> \#loc
instance.variable.used.before.initialized.display.name=Поле экземпляра используется до инициализации
instance.variable.used.before.initialized.problem.descriptor=Поле экземпляра <code>\#ref</code> используется до инициализации \#loc
instanceof.catch.parameter.display.name='instanceof' для параметра 'catch'
instanceof.catch.parameter.problem.descriptor='instanceof' для параметра 'catch' <code>\#ref</code> \#loc
instanceof.check.for.this.display.name=Проверка 'instanceof' для 'this'
instanceof.check.for.this.equality.problem.descriptor=Сравнение класса для 'this' \#loc
instanceof.check.for.this.problem.descriptor=Проверка 'instanceof' для <code>\#ref</code> \#loc
instanceof.concrete.class.equality.problem.descriptor=Сравнение с конкретным классом <code>\#ref</code> \#loc
instanceof.concrete.class.pattern.problem.descriptor=Проверка паттерна для конкретного класса <code>\#ref</code> \#loc
instanceof.concrete.class.problem.descriptor='instanceof' конкретного класса <code>\#ref</code> \#loc
instanceof.with.incompatible.interface.display.name='instanceof' с несовместимым типом
instanceof.with.incompatible.interface.problem.descriptor=''instanceof'' выражения типа ''{1}'' с несовместимым {0, choice, 1\#интерфейсом|2\#классом} <code>\#ref</code> \#loc
instantiating.datetimeformatter.without.locale.problem.descriptor=Вызов <code>DateTimeFormatter.\#ref()</code> без указания локали в интернационализованном контексте \#loc
instantiating.object.to.get.class.object.display.name=Создание объекта для получения объекта 'Class'
instantiating.object.to.get.class.object.problem.descriptor=Создание объекта для получения объекта Class \#loc
instantiating.object.to.get.class.object.replace.quickfix=Заменить на прямой доступ к объекту класса
instantiating.simpledateformat.without.locale.display.name='SimpleDateFormat' без локали
instantiating.simpledateformat.without.locale.problem.descriptor=Создание экземпляра <code>\#ref</code> без указания локали в интернационализованном контексте \#loc
instantiation.utility.class.display.name=Создание экземпляра служебного класса
instantiation.utility.class.problem.descriptor=Создание экземпляра служебного класса <code>\#ref</code> \#loc
int.literal.may.be.long.literal.display.name=Приведение к 'long' может быть литералом 'long'
int.literal.may.be.long.literal.problem.descriptor=<code>\#ref</code> можно заменить на ''{0}'' \#loc
integer.division.in.floating.point.context.display.name=Целочисленное деление в контексте чисел с плавающей точкой
integer.division.in.floating.point.context.fix.family.name=Привести числитель к типу с плавающей точкой
integer.division.in.floating.point.context.fix.name=Привести числитель к типу ''{0}''
integer.division.in.floating.point.context.problem.descriptor=<code>\#ref</code>\: целочисленное деление в контексте чисел с плавающей точкой \#loc
integer.multiplication.implicit.cast.to.long.display.name=Неявное приведение умножения или сдвига целых чисел к типу 'long'
integer.multiplication.implicit.cast.to.long.option=<html>Игнорировать выражения, для которых статически доказано отсутствие переполнения</html>
integer.multiplication.implicit.cast.to.long.problem.descriptor=\#ref\: неявное приведение умножения целых чисел к типу long \#loc
integer.multiplication.implicit.cast.to.long.quickfix=Привести к типу long
integer.shift.implicit.cast.to.long.problem.descriptor=\#ref\: неявное приведение сдвига целых чисел к типу long \#loc
interface.clashes.with.object.class.display.name=Метод интерфейса конфликтует с методом в 'Object'
interface.clashes.with.object.class.problem.descriptor=<code>\#ref()</code> конфликтует с методом в 'java.lang.Object'
interface.may.be.annotated.functional.display.name=Интерфейс может быть помечен как '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor=Интерфейс <code>\#ref</code> может быть помечен аннотацией @FunctionalInterface
interface.naming.convention.element.description=Интерфейс
interface.never.implemented.display.name=Интерфейс без конкретных подклассов
interface.never.implemented.option=Игнорировать интерфейсы, объявляющие только константы
interface.never.implemented.problem.descriptor=У интерфейса <code>\#ref</code> нет конкретных подклассов \#loc
interface.one.inheritor.display.name=Интерфейс с единственным прямым наследником
interface.one.inheritor.problem.descriptor=Интерфейс <code>\#ref</code> имеет только одного прямого наследника \#loc
introduce.holder.class.quickfix=Создать класс-держатель
introduce.variable.may.change.semantics.quickfix=Создать переменную (может изменить семантику)
introduce.variable.quickfix=Создать переменную
invert.method.quickfix=Инвертировать метод
invert.quickfix=Инвертировать ''{0}''
invert.quickfix.family.name=Инвертировать логическое значение
iterator.hasnext.which.calls.next.display.name='Iterator.hasNext()', который вызывает 'next()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code> содержит вызов ''\#ref()'' \#loc
iterator.next.does.not.throw.nosuchelementexception.display.name='Iterator.next()', который не может выбросить 'NoSuchElementException'
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=<code>Iterator.\#ref()</code>, который не может выбросить 'NoSuchElementException' \#loc
java.lang.import.display.name=Ненужный импорт из пакета 'java.lang'
java.lang.import.problem.descriptor=Ненужный импорт из пакета 'java.lang' \#loc
jdbc.execute.with.non.constant.string.display.name=Вызов 'Statement.execute()' с неконстантной строкой
jdbc.execute.with.non.constant.string.problem.descriptor=Вызов <code>Statement.\#ref()</code> с неконстантным аргументом \#loc
jdbc.prepare.statement.with.non.constant.string.display.name=Вызов 'Connection.prepare*()' с неконстантной строкой
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=Вызов <code>Connection.\#ref()</code> с неконстантным аргументом \#loc
jdbc.resource.opened.not.closed.display.name=Ресурс JDBC открыт, но не закрыт безопасно
jndi.resource.opened.not.closed.display.name=Ресурс JNDI открыт, но не закрыт безопасно
junit.abstract.test.class.naming.convention.element.description=Абстрактный тестовый класс
junit.test.class.naming.convention.element.description=Тестовый класс
junit.test.suite.naming.convention.element.description=Набор тестов
junit3.method.naming.convention.element.description=Тестовый метод JUnit 3
junit4.method.naming.convention.element.description=Тестовый метод JUnit 4+
key.set.iteration.may.use.entry.set.display.name=Итерация по 'keySet()' может быть оптимизована
key.set.iteration.may.use.entry.set.problem.descriptor=Итерация по <code>\#ref</code> может быть заменена на итерацию ''{0}'' \#loc
key.set.iteration.may.use.entry.set.quickfix=Оптимизовать итерацию по Map
labeled.statement.display.name=Помеченный оператор
labeled.statement.problem.descriptor=Помеченный оператор <code>\#ref\:</code> \#loc
lambda.body.can.be.code.block.name=Тело лямбды может быть блоком кода
lambda.body.can.be.code.block.quickfix=Развернуть тело лямбды в {...}
lambda.can.be.replaced.with.anonymous.name=Лямбда может быть заменена анонимным классом
lambda.can.be.replaced.with.anonymous.quickfix=Заменить лямбду анонимным классом
lambda.parameter.hides.member.variable.display.name=Параметр лямбды скрывает поле
lambda.parameter.hides.member.variable.ignore.invisible.option=Игнорировать поля, фактически невидимые из лямбды
lambda.parameter.hides.member.variable.problem.descriptor=Параметр лямбды <code>\#ref</code> скрывает поле в классе ''{0}'' \#loc
lambda.parameter.naming.convention.display.name=Соглашение об именовании параметров лямбды
lambda.parameter.naming.convention.element.description=Параметр лямбды
lambda.parameter.type.can.be.specified.descriptor=Типы параметров лямбды могут быть развернуты в {0}
lambda.parameter.type.can.be.specified.family.quickfix=Указать тип параметра лямбды
lambda.parameter.type.can.be.specified.name=Тип параметра лямбды может быть указан
lambda.parameter.type.can.be.specified.quickfix=Развернуть типы параметров в {0}
lambda.unfriendly.constructor.overload.problem.descriptor=Недружественная к лямбдам перегрузка конструктора <code>\#ref()</code>
lambda.unfriendly.method.overload.display.name=Перегрузка метода, недружественная к лямбдам
lambda.unfriendly.method.overload.problem.descriptor=Недружественная к лямбдам перегрузка метода <code>\#ref()</code>
large.array.allocation.no.outofmemoryerror.display.name=Выделение большого массива без проверки OutOfMemoryError
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=Максимальное количество элементов\:
large.array.allocation.no.outofmemoryerror.problem.descriptor=Выделение большого массива без проверки на нехватку памяти \#loc
large.initializer.primitive.type.array.display.name=Слишком большой инициализатор для массива примитивного типа
large.initializer.primitive.type.array.maximum.number.of.elements.option=Максимальное количество элементов\:
large.initializer.primitive.type.array.problem.descriptor=Инициализатор примитивного массива содержит слишком много элементов ({0}) \#loc
law.of.demeter.display.name=Закон Деметры
law.of.demeter.field.problem.descriptor=Доступ к <code>\#ref</code> нарушает закон Деметры \#loc
law.of.demeter.ignore.library.calls.option=Игнорировать вызовы методов библиотек и доступ к полям библиотек
law.of.demeter.problem.descriptor=Вызов <code>\#ref()</code> нарушает закон Деметры \#loc
length.one.string.in.indexof.display.name=Строковый аргумент из одного символа в вызове 'String.indexOf()'
length.one.strings.in.concatenation.display.name=Конкатенация строк из одного символа
length.one.strings.in.concatenation.replace.quickfix=Заменить символом
limited.scope.inner.class.display.name=Локальный класс
limited.scope.inner.class.problem.descriptor=Локальный класс <code>\#ref</code> \#loc
list.indexof.replaceable.by.contains.display.name=Выражение 'List.indexOf()' можно заменить на 'contains()'
listener.may.use.adapter.display.name=Класс может расширять адаптер вместо реализации слушателя
listener.may.use.adapter.emtpy.methods.option=Предупреждать только при обнаружении пустых реализующих методов [&O]
listener.may.use.adapter.fix.family.name=Заменить адаптером
listener.may.use.adapter.problem.descriptor=Класс ''{0}'' может расширять ''{1}'' вместо реализации <code>\#ref</code> \#loc
literal.as.arg.to.string.equals.display.name=Строковый литерал может быть квалификатором 'equals()'
literal.as.arg.to.string.equals.flip.quickfix=Инвертировать ''{0}()''
literal.as.arg.to.string.equals.problem.descriptor=Литерал \#ref является аргументом ''{0}()'', а не его квалификатором \#loc
load.library.with.non.constant.string.display.name=Вызов 'System.loadLibrary()' с неконстантной строкой
load.library.with.non.constant.string.problem.descriptor=Вызов <code>{0}.\#ref()</code> с неконстантным аргументом \#loc
local.variable.hides.member.variable.display.name=Локальная переменная скрывает поле
local.variable.hides.member.variable.ignore.option=Игнорировать локальные переменные в статическом контексте, скрывающие нестатические поля
local.variable.hides.member.variable.problem.descriptor=Локальная переменная <code>\#ref</code> скрывает поле в классе ''{0}'' \#loc
local.variable.naming.convention.display.name=Соглашение об именовании локальных переменных
local.variable.naming.convention.element.description=Локальная переменная
local.variable.naming.convention.ignore.catch.option=Игнорировать параметры блока 'catch'
local.variable.naming.convention.ignore.option=Игнорировать параметры цикла for
local.variable.of.concrete.class.problem.descriptor=Локальная переменная ''{0}'' конкретного класса <code>\#ref</code> \#loc
log.condition.text=Текст условия логования
log.method.name=Имя метода логования
log.statement.guarded.by.log.condition.display.name=Вызов логования не защищен условием логования
log.statement.guarded.by.log.condition.flag.all.unguarded.option=Отмечать все незащищенные вызовы логования
log.statement.guarded.by.log.condition.problem.descriptor=Вызовы логования <code>\#ref()</code> не защищены условием логования \#loc
log.statement.guarded.by.log.condition.quickfix=Обернуть условием логования
logger.class.name=Имена классов логгера\:
logger.factory.class.name=Имя фабричного класса логгера
logger.factory.method.name=Имя фабричного метода логгера
logger.initialized.with.foreign.class.display.name=Логгер инициализован внешним классом
logger.initialized.with.foreign.class.fix.family.name=Заменить внешний класс
logger.initialized.with.foreign.class.ignore.non.public.classes.option=Игнорировать логгеры в непубличных классах
logger.initialized.with.foreign.class.ignore.not.final.field=Игнорировать логгеры, не инициализованные в final-поле
logger.initialized.with.foreign.class.ignore.super.class.option=Игнорировать логгеры, инициализованные суперклассом
logger.initialized.with.foreign.class.problem.descriptor=Логгер инициализован внешним классом <code>\#ref</code> \#loc
logger.name.option=Имя класса логгера [&C]\:
long.literals.ending.with.lowercase.l.display.name=Литерал 'long', оканчивающийся на 'l' вместо 'L'
long.literals.ending.with.lowercase.l.problem.descriptor=Литерал 'long' <code>\#ref</code> оканчивается на строчную 'l' \#loc
loop.condition.not.updated.inside.loop.display.name=Переменная цикла не обновляется внутри цикла
loop.condition.not.updated.inside.loop.problem.descriptor=Условие '\#ref' не обновляется внутри цикла \#loc
loop.statements.that.dont.loop.display.name=Оператор цикла, который не выполняет итерации
loop.statements.that.dont.loop.problem.descriptor=Оператор <code>\#ref</code> не выполняет цикл \#loc
loop.variable.not.updated.inside.loop.option.nonlocal=Игнорировать возможные нелокальные изменения
loop.variable.not.updated.inside.loop.problem.descriptor=Переменная '\#ref' не обновляется внутри цикла \#loc
loop.with.implicit.termination.condition.display.name=Цикл с неявным условием завершения
loop.with.implicit.termination.condition.dowhile.problem.descriptor=Цикл <code>\#ref-while</code> с неявным условием завершения \#loc
loop.with.implicit.termination.condition.problem.descriptor=Цикл <code>\#ref</code> с неявным условием завершения \#loc
loop.with.implicit.termination.condition.quickfix=Сделать условие явным
magic.character.display.name=Магический символ
magic.character.problem.descriptor=Магический символ <code>\#ref</code> в интернационализованном контексте \#loc
magic.number.display.name=Магическое число
magic.number.problem.descriptor=Магическое число <code>\#ref</code> \#loc
make.class.final.fix.family.name=Сделать класс final
make.class.final.fix.name=Сделать класс ''{0}'' ''final''
make.constructor.public=Сделать конструктор 'public'
make.field.final.fix.family.name=Сделать final
make.field.final.quickfix=Сделать ''{0}'' ''final''
make.field.static.final.fix.family.name=Сделать static final
make.initialization.explicit.quickfix=Сделать инициализацию явной
make.method.ctr.quickfix=Сделать метод конструктором
make.method.final.fix.family.name=Сделать метод 'final'
make.method.final.fix.name=Сделать метод ''{0}()'' ''final''
make.package.private.fix.family.name=Сделать package-private
make.static.final.quickfix=Сделать ''{0}'' static final
make.static.quickfix=Сделать 'static'
malformed.format.string.display.name=Некорректная строка форматования
malformed.format.string.problem.descriptor.arguments.do.not.match.type=Тип аргумента ''{0}'' не соответствует типу спецификатора форматования ''{1}'' \#loc
malformed.format.string.problem.descriptor.at.least.too.few.arguments=Недостаточно аргументов для строки форматования (найдено\: {0}, ожидалось как минимум\: {1}) \#loc
malformed.format.string.problem.descriptor.illegal=Недопустимый спецификатор форматования\: {0} \#loc
malformed.format.string.problem.descriptor.malformed=Строка форматования <code>\#ref</code> некорректна \#loc
malformed.format.string.problem.descriptor.too.few.arguments=Недостаточно аргументов для строки форматования (найдено\: {0}, ожидалось\: {1}) \#loc
malformed.format.string.problem.descriptor.too.many.arguments=Слишком много аргументов для строки форматования (найдено\: {0}, ожидалось\: {1}) \#loc
manual.array.copy.display.name=Ручное копирование массива
manual.array.copy.problem.descriptor=Ручное копирование массива \#loc
manual.array.to.collection.copy.display.name=Ручное копирование массива в коллекцию
manual.array.to.collection.copy.problem.descriptor=Ручное копирование массива в коллекцию \#loc
map.replaceable.by.enum.map.display.name='Map' может быть заменен на 'EnumMap'
map.replaceable.by.enum.map.problem.descriptor=<code>\#ref</code> может быть заменен на 'EnumMap' \#loc
mark.modules.as.loaded.together.fix.family.name=Отметить модули как загружаемые вместе
mark.modules.as.loaded.together.fix.text=Отметить модули ''{0}'' и ''{1}'' как загружаемые вместе
markdown.documentation.comments.migration.display.name=Javadoc комментарий может быть комментарием документации Markdown
markdown.documentation.comments.migration.fix=Преобразовать в комментарий документации Markdown
marker.interface.display.name=Маркерный интерфейс
marker.interface.problem.descriptor=Маркерный интерфейс <code>\#ref</code> \#loc
masked.assertion.display.name=Утверждение подавлено блоком 'catch'
masked.assertion.problem.description=''{0}'' не может завершиться неудачей, так как подавлено окружающим ''catch''
math.random.cast.to.int.display.name=Приведение 'Math.random()' к 'int'
math.random.cast.to.int.problem.descriptor=<code>\#ref</code> приведенное к ''{0}'' всегда округляется вниз до ''0'' \#loc
math.random.cast.to.int.quickfix=Добавить скобки для выполнения умножения перед приведением типа
math.rounding.with.int.argument.display.name=Вызов математического округления с аргументом типа 'int'
math.rounding.with.int.argument.family.name=Упростить вызовы округления
math.rounding.with.int.argument.problem.descriptor=<code>\#ref()</code> с аргументом типа 'int' \#loc
math.rounding.with.int.argument.quickfix=Упростить вызов ''{0}()''
meta.annotation.without.runtime.retention=Тестовая аннотация без аннотации '@Retention(RUNTIME)'
method.call.in.loop.condition.display.name=Вызов метода в условии цикла
method.call.in.loop.condition.problem.descriptor=Вызов метода <code>\#ref()</code> в условии цикла \#loc
method.can.be.variable.arity.method.display.name=Метод может иметь varargs параметр
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=Игнорировать все примитивные типы массивов
method.can.be.variable.arity.method.ignore.byte.short.option=Игнорировать параметры типа byte[] или short[]
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=Игнорировать многомерные параметры-массивы
method.can.be.variable.arity.method.ignore.multiple.arrays.option=Игнорировать методы с несколькими параметрами-массивами
method.can.be.variable.arity.method.problem.descriptor=<code>\#ref()</code> может быть преобразован в varargs метод \#loc
method.complexity.limit.option=Лимит сложности метода\:
method.count.ignore.getters.setters.option=Игнорировать простые методы getter и setter [&I]
method.count.limit.option=Лимит количества методов\:
method.coupling.display.name=Чрезмерно связанный метод
method.coupling.limit.option=Лимит связанности метода\:
method.coupling.problem.descriptor=<code>\#ref</code> чрезмерно связан (\# ссылающихся классов \= {0}) \#loc
method.may.be.static.display.name=Метод может быть 'static'
method.may.be.static.empty.option=Игнорировать пустые методы
method.may.be.static.ignore.default.methods.option=Игнорировать 'default' методы
method.may.be.static.only.option=Проверять только 'private' или 'final' методы
method.may.be.static.problem.descriptor=Метод <code>\#ref()</code> может быть 'static' \#loc
method.may.be.static.replaces.qualifiers.with.class.references.option=Быстрое исправление заменяет квалификаторы экземпляров на ссылки на классы
method.may.be.synchronized.display.name=Метод с единственным 'synchronized' блоком может быть заменен на 'synchronized' метод
method.may.be.synchronized.problem.descriptor=Метод <code>\#ref()</code> с synchronized блоком может быть synchronized методом \#loc
method.may.be.synchronized.quickfix=Сделать метод synchronized и удалить synchronized блок
method.name.regex=Регулярное выражение для имени метода
method.name.same.as.class.name.display.name=Имя метода совпадает с именем класса
method.name.same.as.class.name.problem.descriptor=Имя метода <code>\#ref</code> совпадает с именем его класса \#loc
method.name.same.as.parent.name.display.name=Имя метода совпадает с именем родительского класса
method.name.same.as.parent.name.problem.descriptor=Имя метода <code>\#ref</code> совпадает с именем его родительского класса \#loc
method.names.differ.only.by.case.display.name=Имена методов отличаются только регистром
method.names.differ.only.by.case.problem.descriptor=Имя метода <code>\#ref</code> и имя метода ''{0}'' отличаются только регистром \#loc
method.only.used.from.inner.class.display.name=Private метод используется только из внутреннего класса
method.only.used.from.inner.class.ignore.option=Игнорировать методы, вызываемые из анонимного или локального класса [&A]
method.only.used.from.inner.class.problem.descriptor=Метод <code>\#ref()</code>\#loc используется только из {0, choice, 1\#внутреннего |2\#локального |3\#}{1, choice, 1\#класса|2\#интерфейса|3\#анонимного класса, производного от|4\#типа аннотации|5\#перечисления|6\#записи} ''{2}'' \#loc
method.overloads.display.name=Возможно непреднамеренная перегрузка метода суперкласса
method.overloads.problem.descriptor=Метод <code>\#ref()</code> перегружает совместимый метод суперкласса, когда возможно предполагалось переопределение \#loc
method.overloads.report.incompatible.option=Сообщать даже если типы параметров несовместимы
method.overrides.inaccessible.method.display.name=Метод переопределяет недоступный метод суперкласса
method.overrides.package.local.method.problem.descriptor=Метод <code>\#ref()</code> переопределяет package-private метод суперкласса, находящегося в другом пакете \#loc
method.overrides.private.display.name.problem.descriptor=Метод <code>\#ref()</code> переопределяет 'private' метод суперкласса \#loc
method.overrides.static.display.name=Метод пытается переопределить 'static' метод суперкласса
method.overrides.static.problem.descriptor=Метод <code>\#ref()</code> пытается переопределить static метод суперкласса \#loc
method.ref.can.be.replaced.with.lambda.name=Ссылка на метод может быть заменена лямбдой
method.ref.can.be.replaced.with.lambda.quickfix=Заменить ссылку на метод лямбдой
method.return.always.constant.display.name=Метод возвращает константу для класса
method.return.always.constant.problem.descriptor=Метод <code>\#ref()</code> и все его производные всегда возвращают константы
method.return.concrete.class.problem.descriptor=Метод возвращает конкретный класс <code>\#ref</code> \#loc
method.with.multiple.loops.display.name=Метод с несколькими циклами
method.with.multiple.loops.problem.descriptor=<code>\#ref</code> содержит {0} циклов \#loc
mismatched.read.write.array.display.name=Несоответствие чтения и записи массива
mismatched.read.write.array.problem.descriptor.read.not.write=Содержимое массива <code>\#ref</code> читается, но никогда не записывается \#loc
mismatched.read.write.array.problem.descriptor.write.not.read=Содержимое массива <code>\#ref</code> записывается, но никогда не читается \#loc
mismatched.string.builder.queried.problem.descriptor=Содержимое <code>{0} \#ref</code> запрашивается, но никогда не обновляется \#loc
mismatched.string.builder.query.update.display.name=Несоответствие запросов и обновлений 'StringBuilder'
mismatched.string.builder.updated.problem.descriptor=Содержимое <code>{0} \#ref</code> обновляется, но никогда не запрашивается \#loc
mismatched.update.collection.display.name=Несоответствие запросов и обновлений коллекции
mismatched.update.collection.problem.description.queried.not.updated=Содержимое коллекции <code>\#ref</code> запрашивается, но никогда не обновляется \#loc
mismatched.update.collection.problem.descriptor.updated.not.queried=Содержимое коллекции <code>\#ref</code> обновляется, но никогда не запрашивается \#loc
misordered.assert.equals.arguments.display.name=Неправильный порядок аргументов 'assertEquals()'
misordered.assert.equals.arguments.flip.quickfix=Поменять местами сравниваемые аргументы
misordered.assert.equals.arguments.problem.descriptor=Неправильный порядок аргументов в <code>\#ref()</code> \#loc
missing.add.deprecated.javadoc.tag.quickfix=Добавить пояснение тега '@deprecated' в Javadoc
missing.deprecated.annotation.add.quickfix=Добавить аннотацию '@Deprecated'
missing.deprecated.annotation.display.name=Отсутствует аннотация '@Deprecated'
missing.deprecated.annotation.problem.descriptor=Отсутствует аннотация '@Deprecated' \#loc
missing.deprecated.tag.option=Предупреждать об отсутствии пояснения тега @deprecated в Javadoc
missing.deprecated.tag.problem.descriptor=Отсутствует пояснение тега '@deprecated' в Javadoc \#loc
missing.override.annotation.display.name=Отсутствует аннотация '@Override'
missing.override.annotation.in.overriding.problem.descriptor=Переопределяющие методы не аннотированы '@Override'
missing.override.annotation.problem.descriptor=Отсутствует аннотация '@Override' для <code>\#ref()</code> \#loc
missing.override.warn.on.super.option=Подсвечивать метод, когда не все его переопределяющие методы имеют аннотацию '@Override'
missing.package.html.problem.descriptor=В пакете ''{0}'' отсутствует файл <code>package.html</code>
missing.package.info.display.name=Отсутствует 'package-info.java'
missing.package.info.problem.descriptor=В пакете ''{0}'' отсутствует файл <code>package-info.java</code>
missing.serial.annotation.display.name=Можно использовать аннотацию '@Serial'
missing.serial.annotation.on.field.problem.descriptor=<code>\#ref</code> можно аннотировать с помощью '@Serial'
missing.serial.annotation.on.method.problem.descriptor=<code>\#ref()</code> можно аннотировать с помощью '@Serial'
missorted.modifiers.allowed.place=Аннотации TYPE_USE следуют настройкам генерации
missorted.modifiers.allowed.place.description=Когда эта опция включена, целевые аннотации TYPE_USE отмечаются, если они расположены не в соответствии с опцией <pre>{0}</pre> в <pre>Настройки | Редактор | Стиль кода | Java | Генерация кода.</pre>Когда эта опция отключена, целевые аннотации TYPE_USE разрешены как непосредственно перед типом, так и перед ключевыми словами модификаторов.
missorted.modifiers.display.name=Неправильный порядок модификаторов
missorted.modifiers.problem.descriptor=Неправильный порядок модификаторов <code>{0}</code> \#loc
missorted.modifiers.require.option=Проверять порядок аннотаций
missorted.modifiers.require.option.description=Используйте эту опцию для обнаружения аннотаций в неправильной позиции\: аннотации с <code>ElementType.TYPE_USE</code> <em>не</em> непосредственно перед типом и после ключевых слов модификаторов, или другие аннотации <em>не</em> перед ключевыми словами модификаторов. Когда эта опция отключена, аннотации разрешены как до, так и после ключевых слов модификаторов. Аннотации между ключевыми словами модификаторов всегда будут отмечаться.
missorted.modifiers.sort.quickfix=Отсортировать модификаторы
misspelled.equals.display.name='equal()' вместо 'equals()'
misspelled.equals.problem.descriptor=Метод <code>\#ref()</code> вероятно должен быть 'equals()' \#loc
module.with.too.few.classes.display.name=Модуль с слишком малым количеством классов
module.with.too.few.classes.min.option=Минимальное количество классов\:
module.with.too.few.classes.problem.descriptor=Модуль ''{0}'' содержит слишком мало классов ({1} < {2})
module.with.too.many.classes.display.name=Модуль с слишком большим количеством классов
module.with.too.many.classes.max.option=Максимальное количество классов\:
module.with.too.many.classes.problem.descriptor=Модуль ''{0}'' содержит слишком много классов ({1} > {2})
move.anonymous.to.inner.quickfix=Преобразовать в именованный внутренний класс
move.class.quickfix=Переместить класс
move.exception.to.javadoc.fix.family.name=Переместить в Javadoc '@throws'
move.local.to.inner.quickfix=Преобразовать во внутренний класс
multi.catch.can.be.split.name=Multi-catch можно разделить на отдельные блоки catch
multi.catch.can.be.split.quickfix=Разделить multi-catch на отдельные блоки 'catch'
multiple.declaration.array.only.option=Предупреждать только о разных размерностях массивов в одном объявлении
multiple.declaration.display.name=Несколько переменных в одном объявлении
multiple.declaration.ignore.for.option=Игнорировать объявления в циклах 'for'
multiple.declaration.problem.descriptor=Несколько переменных в одном объявлении \#loc
multiple.loggers.display.name=Класс с несколькими логгерами
multiple.loggers.problem.descriptor=Класс <code>\#ref</code> объявляет несколько логгеров \#loc
multiple.return.points.per.method.display.name=Метод с несколькими точками возврата
multiple.return.points.per.method.problem.descriptor=<code>\#ref</code> имеет {0} точек возврата \#loc
multiple.top.level.classes.in.file.display.name=Несколько классов верхнего уровня в одном файле
multiple.top.level.classes.in.file.problem.descriptor=Несколько классов верхнего уровня в файле
multiple.typed.declaration.problem.descriptor=Переменные с разной размерностью массива в одном объявлении \#loc
multiply.or.divide.by.power.of.two.display.name=Умножение или деление на степень двойки
multiply.or.divide.by.power.of.two.divide.option=Также проверять деление на степень двойки
multiply.or.divide.by.power.of.two.replace.quickfix=Заменить побитовым сдвигом
naked.notify.display.name='notify()' или 'notifyAll()' без соответствующего изменения состояния
naked.notify.problem.descriptor=Вызов <code>\#ref()</code> без соответствующего изменения состояния \#loc
naming.convention.problem.descriptor.long=Имя {0} <code>\#ref</code> слишком длинное ({1} > {2}) \#loc
naming.convention.problem.descriptor.regex.mismatch=Имя {0} <code>\#ref</code> не соответствует регулярному выражению ''{1}'' \#loc
naming.convention.problem.descriptor.short=Имя {0} <code>\#ref</code> слишком короткое ({1} < {2}) \#loc
native.method.display.name=Нативный метод
native.method.naming.convention.element.description='native' метод
native.method.problem.descriptor=Методы, объявленные как <code>\#ref</code>, не являются переносимыми \#loc
negated.conditional.display.name=Условное выражение с отрицательным условием
negated.conditional.expression.display.name=Отрицательное условное выражение
negated.conditional.expression.problem.descriptor=Отрицание условного выражения \#loc
negated.conditional.expression.quickfix=Убрать отрицание
negated.conditional.invert.quickfix=Инвертировать условие
negated.conditional.problem.descriptor=Условное выражение с отрицательным условием \#loc
negated.equality.expression.display.name=Отрицательное выражение равенства
negated.equality.expression.problem.descriptor=Отрицание ''{0}'' \#loc
negated.equality.expression.quickfix=Убрать отрицание
negated.if.else.display.name=Оператор 'if' с отрицательным условием
negated.if.else.ignore.negated.null.option=Игнорировать сравнения '\!\= null'
negated.if.else.ignore.negated.zero.option=Игнорировать сравнения '\!\= 0'
negated.if.else.invert.quickfix=Инвертировать условие 'if'
negated.if.else.problem.descriptor=Оператор <code>\#ref</code> с отрицательным условием \#loc
negative.int.constant.in.long.context.display.name=Отрицательная шестнадцатеричная константа int в контексте long
negative.int.constant.in.long.context.fix.add.suffix=Добавить суффикс 'L' (изменяет семантику)
negative.int.constant.in.long.context.fix.convert=Преобразовать в константу long (сохраняет семантику)
negatively.named.boolean.variable.display.name=Булева переменная с отрицательным именем
negatively.named.boolean.variable.problem.descriptor=Булева переменная <code>\#ref</code> имеет отрицательное имя \#loc
nested.assignment.display.name=Вложенное присваивание
nested.assignment.problem.descriptor=Используется результат выражения присваивания \#loc
nested.conditional.expression.display.name=Вложенное условное выражение
nested.conditional.expression.problem.descriptor=Вложенное условное выражение <code>\#ref</code> \#loc
nested.method.call.display.name=Вложенный вызов метода
nested.method.call.ignore.option=Игнорировать вложенные вызовы методов в инициализаторах полей
nested.method.call.problem.descriptor=Вложенный вызов метода <code>\#ref()</code> \#loc
nested.switch.statement.display.name=Вложенный оператор 'switch'
nested.switch.statement.problem.descriptor=Вложенный <code>\#ref</code> {0} \#loc
nested.synchronized.statement.display.name=Вложенный оператор 'synchronized'
nested.synchronized.statement.problem.descriptor=Вложенный оператор <code>\#ref</code> \#loc
nested.try.statement.display.name=Вложенный оператор 'try'
nested.try.statement.problem.descriptor=Вложенный оператор <code>\#ref</code> \#loc
nesting.depth.display.name=Чрезмерно вложенный метод
nesting.depth.limit.option=Предел глубины вложенности\:
nesting.depth.problem.descriptor=<code>\#ref</code> чрезмерно вложен (максимальная глубина вложенности \= {0}) \#loc
new.exception.without.arguments.display.name=Конструктор исключения вызван без аргументов
new.exception.without.arguments.problem.descriptor=<code>new \#ref()</code> без аргументов \#loc
new.method.naming.convention.display.name=Соглашение об именовании методов
new.string.buffer.replaceable.by.string.problem.descriptor=<code>\#ref</code> можно заменить на 'String' \#loc
new.string.buffer.with.char.argument.display.name=Вызов конструктора StringBuilder с аргументом типа 'char'
new.string.buffer.with.char.argument.problem.descriptor=<code>new \#ref()</code> с аргументом типа 'char' \#loc
new.string.buffer.with.char.argument.quickfix=Заменить символьный аргумент строковым литералом
no.logger.display.name=Класс без логгера
no.logger.problem.descriptor=Класс <code>\#ref</code> не объявляет логгер \#loc
non.atomic.operation.on.volatile.field.display.name=Неатомарная операция с полем 'volatile'
non.atomic.operation.on.volatile.field.problem.descriptor=Неатомарная операция с volatile полем <code>\#ref</code> \#loc
non.boolean.method.name.must.not.start.with.question.display.name=Имя небулевого метода не должно начинаться с вопросительного слова
non.boolean.method.name.must.not.start.with.question.problem.descriptor=Имя небулевого метода <code>\#ref</code> начинается с вопросительного слова \#loc
non.comment.source.statements.display.name=Слишком длинный метод
non.comment.source.statements.limit.option=Предел некомментируемых операторов исходного кода\:
non.comment.source.statements.problem.descriptor=<code>\#ref</code> слишком длинный (количество некомментируемых операторов \= {0}) \#loc
non.constant.logger.display.name=Неконстантный логгер
non.constant.logger.problem.descriptor=Неконстантное поле логгера <code>\#ref</code> \#loc
non.exception.name.ends.with.exception.display.name=Имя класса, не являющегося исключением, заканчивается на 'Exception'
non.exception.name.ends.with.exception.problem.descriptor=Имя класса <code>\#ref</code>, не являющегося исключением, заканчивается на 'Exception' \#loc
non.exception.name.ends.with.exception.quickfix=Сделать ''{0}'' наследником ''java.lang.Exception''
non.final.clone.display.name=Нефинальный метод 'clone()' в защищенном контексте
non.final.clone.problem.descriptor=Нефинальный метод <code>\#ref()</code>, компрометирующий безопасность \#loc
non.final.field.compareto.display.name=Нефинальное поле используется в 'compareTo()'
non.final.field.compareto.problem.descriptor=Нефинальное поле <code>\#ref</code> используется в 'compareTo()' \#loc
non.final.field.in.enum.display.name=Нефинальное поле в 'enum'
non.final.field.in.enum.problem.descriptor=Нефинальное поле <code>\#ref</code> в перечислении ''{0}'' \#loc
non.final.field.in.enum.quickfix.option=Игнорировать поля, которые нельзя сделать 'final'
non.final.field.in.equals.display.name=Нефинальное поле используется в 'equals()'
non.final.field.in.equals.problem.descriptor=Нефинальное поле <code>\#ref</code> используется в 'equals()' \#loc
non.final.field.in.hashcode.display.name=Нефинальное поле используется в 'hashCode()'
non.final.field.in.hashcode.problem.descriptor=Нефинальное поле <code>\#ref</code> используется в 'hashCode()' \#loc
non.final.field.of.exception.display.name=Нефинальное поле класса исключения
non.final.field.of.exception.problem.descriptor=Нефинальное поле <code>\#ref</code> класса исключения \#loc
non.final.static.variable.initialization.display.name=Нефинальное статическое поле используется при инициализации класса
non.final.static.variable.initialization.problem.descriptor=Нефинальное статическое поле <code>\#ref</code> используется при инициализации класса \#loc
non.final.utility.class.display.name=Служебный класс не является 'final'
non.final.utility.class.problem.descriptor=Служебный класс <code>\#ref</code> не является 'final' \#loc
non.protected.constructor.in.abstract.class.display.name=Публичный конструктор в абстрактном классе
non.protected.constructor.in.abstract.class.ignore.option=Игнорировать для непубличных классов
non.protected.constructor.in.abstract.class.problem.descriptor=Конструктор <code>\#ref()</code> абстрактного класса не должен быть объявлен как 'public' \#loc
non.public.clone.display.name=Метод 'clone()' не является 'public'
non.public.clone.problem.descriptor=Метод <code>\#ref()</code> не является 'public' \#loc
non.reproducible.math.call.display.name=Невоспроизводимый вызов 'Math'
non.reproducible.math.call.problem.descriptor=<code>Math.\#ref()</code> может давать невоспроизводимые результаты \#loc
non.reproducible.math.call.replace.quickfix=Заменить на вызов 'StrictMath'
non.serializable.@interface.with.serialversionuid.problem.descriptor=Несериализуемый @interface <code>\#ref</code> определяет поле 'serialVersionUID' \#loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=Несериализуемый анонимный класс, производный от <code>\#ref</code>, определяет поле 'serialVersionUID' \#loc
non.serializable.class.with.readwriteobject.display.name=Несериализуемый класс с 'readObject()' или 'writeObject()'
non.serializable.class.with.readwriteobject.problem.descriptor.both=Несериализуемый {0, choice, 1\#класс|2\#интерфейс|3\#анонимный класс, производный от|4\#тип аннотации|5\#перечисление|6\#запись} <code>\#ref</code> определяет 'readObject()' и 'writeObject()' \#loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=Несериализуемый {0, choice, 1\#класс|2\#интерфейс|3\#анонимный класс, производный от|4\#тип аннотации|5\#перечисление|6\#запись} <code>\#ref</code> определяет 'readObject()' \#loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=Несериализуемый {0, choice, 1\#класс|2\#интерфейс|3\#анонимный класс, производный от|4\#тип аннотации|5\#перечисление|6\#запись} <code>\#ref</code> определяет 'writeObject()' \#loc
non.serializable.class.with.serialversionuid.problem.descriptor=Несериализуемый класс <code>\#ref</code> определяет поле 'serialVersionUID' \#loc
non.serializable.component.in.serializable.record.problem.descriptor=Несериализуемый компонент '\#ref' в сериализуемой записи \#loc
non.serializable.field.in.serializable.class.display.name=Несериализуемое поле в классе 'Serializable'
non.serializable.field.in.serializable.class.problem.descriptor=Несериализуемое поле '\#ref' в сериализуемом классе \#loc
non.serializable.interface.with.serialversionuid.problem.descriptor=Несериализуемый интерфейс <code>\#ref</code> определяет поле 'serialVersionUID' \#loc
non.serializable.object.bound.to.http.session.display.name=Несериализуемый объект привязан к 'HttpSession'
non.serializable.object.bound.to.http.session.problem.descriptor=Несериализуемый объект привязан к HttpSession \#loc
non.serializable.object.passed.to.object.stream.display.name=Несериализуемый объект передан в 'ObjectOutputStream'
non.serializable.object.passed.to.object.stream.problem.descriptor=Несериализуемый объект передан в ObjectOutputStream \#loc
non.serializable.with.serialversionuid.display.name=Несериализуемый класс с 'serialVersionUID'
non.short.circuit.boolean.expression.display.name=Логическое выражение без короткого замыкания
non.short.circuit.boolean.expression.problem.descriptor=Логическое выражение без короткого замыкания <code>\#ref</code> \#loc
non.short.circuit.boolean.expression.replace.quickfix=Заменить на выражение с коротким замыканием
non.synchronized.method.overrides.synchronized.method.display.name=Несинхронизованный метод переопределяет синхронизованный метод
non.synchronized.method.overrides.synchronized.method.problem.descriptor=Несинхронизованный метод <code>\#ref()</code> переопределяет синхронизованный метод \#loc
non.thread.safe.lazy.initialization.display.name=Небезопасная ленивая инициализация статического поля
non.thread.safe.lazy.initialization.problem.descriptor=Ленивая инициализация статического поля <code>\#ref</code> не является потокобезопасной \#loc
none=нет
noop.method.in.abstract.class.display.name=Пустой метод в абстрактном классе
noop.method.in.abstract.class.problem.descriptor=Пустой метод <code>\#ref()</code> следует сделать абстрактным \#loc
normalize.declaration.quickfix=Разделить на отдельные объявления
not.object.equals.can.be.equality.problem.descriptor=<code>\!\#ref()</code> можно заменить на '\!\='
notify.called.on.condition.display.name='notify()' или 'notifyAll()' вызван для объекта 'java.util.concurrent.locks.Condition'
notify.called.on.condition.problem.descriptor=Вызов <code>\#ref()</code> для объекта Condition \#loc
notify.without.corresponding.wait.display.name='notify()' без соответствующего 'wait()'
notify.without.corresponding.wait.problem.descriptor=Вызов <code>\#ref()</code> без соответствующего <code>wait()</code> \#loc
null.argument.to.var.arg.method.display.name=Неоднозначный аргумент метода с переменным числом параметров
null.argument.to.var.arg.method.problem.descriptor=Неоднозначный аргумент <code>\#ref</code>, неясно требуется ли вызов varargs или non-varargs \#loc
null.thrown.display.name=Выброшен 'null'
null.thrown.problem.descriptor=Выброшен <code>\#ref</code> \#loc
number.comparison.display.name=Сравнение чисел через '\=\=' вместо 'equals()'
number.comparison.problem.descriptor=Числовые объекты сравниваются через <code>\#ref</code>, а не 'equals()' \#loc
object.allocation.in.loop.display.name=Выделение объекта в цикле
object.allocation.in.loop.new.descriptor=Выделение объекта <code>new \#ref()</code> в цикле \#loc
object.allocation.in.loop.problem.array.initializer.descriptor=Выделение массива в цикле \#loc
object.allocation.in.loop.problem.call.descriptor=Выделение объекта через вызов <code>\#ref()</code> в цикле \#loc
object.allocation.in.loop.problem.lambda.descriptor=Выделение объекта через захватывающую лямбду в цикле \#loc
object.allocation.in.loop.problem.methodref.descriptor=Выделение объекта через привязанную к экземпляру ссылку на метод <code>\#ref()</code> в цикле \#loc
object.allocation.in.loop.problem.string.concat=Выделение объекта через конкатенацию строк в цикле \#loc
object.comparison.display.name=Сравнение объектов через '\=\=' вместо 'equals()'
object.comparison.enumerated.ignore.option=Игнорировать '\=\=' между переменными перечислений
object.comparison.klass.ignore.option=Игнорировать '\=\=' между типами final-классов без реализации 'equals()'
object.comparison.problem.description=Сравнение объектов выполняется через <code>\#ref</code>, а не 'equals()' \#loc
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=Игнорировать '\=\=' между объектами типа только с 'private' конструкторами
object.equals.can.be.equality.display.name=Вызов 'equals()' может быть заменен на '\=\='
object.equals.can.be.equality.problem.descriptor=<code>\#ref()</code> может быть заменен на '\=\='
object.instantiation.inside.equals.or.hashcode.display.name=Создание объекта внутри 'equals()' или 'hashCode()'
object.instantiation.inside.equals.or.hashcode.problem.descriptor=Создание объекта внутри ''{0}()'' \#loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=Создание объекта внутри ''{0}()'' ({1})\#loc
object.notify.display.name=Вызов 'notify()' вместо 'notifyAll()'
object.notify.problem.descriptor=<code>\#ref</code> вероятно следует заменить на 'notifyAll()' \#loc
objects.hash.fix.family.name=Обернуть в 'Arrays.hashCode()'
objects.hash.problem.descriptor=Массив, переданный в 'Objects.hash()', должен быть обернут в 'Arrays.hashcode()'
octal.and.decimal.integers.in.same.array.display.name=Восьмеричные и десятичные числа в одном массиве
octal.and.decimal.integers.in.same.array.problem.descriptor=Восьмеричные и десятичные числа в одном инициализаторе массива \#loc
octal.literal.display.name=Восьмеричное число
octal.literal.problem.descriptor=Восьмеричное число <code>\#ref</code> \#loc
only.report.public.methods.option=Сообщать только о 'public' методах
only.report.qualified.static.usages.option=Сообщать только о квалифицированном статическом доступе из статического контекста
only.report.static.methods=&Сообщать только о 'static' методах
only.warn.on.protected.clone.methods=Предупреждать только о 'protected' методах clone
only.warn.on.public.clone.methods=Предупреждать только о 'public' методах clone
optional.contains.array.problem.descriptor='Optional' содержит массив <code>\#ref</code>
optional.contains.collection.display.name='Optional' содержит массив или коллекцию
optional.contains.collection.problem.descriptor='Optional' содержит коллекцию <code>\#ref</code>
optional.used.as.field.or.parameter.type.display.name='Optional' используется как тип поля или параметра
optional.used.as.field.type.problem.descriptor=<code>\#ref</code> используется как тип для поля ''{0}''
optional.used.as.parameter.type.problem.descriptor=<code>\#ref</code> используется как тип для параметра ''{0}''
options.label.ignored.classes=Игнорируемые классы\:
options.title.ignored.classes=Игнорируемые классы
overloaded.methods.with.same.number.parameters.display.name=Перегруженные методы с одинаковым числом параметров
overloaded.methods.with.same.number.parameters.option=<html>Игнорировать перегруженные методы с заведомо несовместимыми типами параметров</html>
overloaded.methods.with.same.number.parameters.problem.descriptor=Несколько методов с именем <code>\#ref</code> с одинаковым количеством параметров \#loc
overloaded.vararg.constructor.problem.descriptor=Перегруженный vararg конструктор <code>\#ref()</code> \#loc
overloaded.vararg.method.display.name=Перегруженный vararg метод
overloaded.vararg.method.problem.descriptor=Перегруженный vararg метод <code>\#ref()</code> \#loc
overloaded.vararg.method.problem.option=Игнорировать перегруженные методы с заведомо несовместимыми типами параметров
overly.broad.throws.clause.display.name=Слишком широкая конструкция 'throws'
overly.broad.throws.clause.ignore.thrown.option=&Игнорировать исключения, которые скрывают другие, но сами выбрасываются
overly.broad.throws.clause.problem.descriptor1=<code>throws \#ref</code> слишком широкий, маскирует исключение ''{0}'' \#loc
overly.broad.throws.clause.problem.descriptor2=<code>throws \#ref</code> слишком широкий, маскирует исключения ''{0}'' и ''{1}'' \#loc
overly.broad.throws.clause.quickfix1=Добавить конкретные исключения
overly.broad.throws.clause.quickfix2=Заменить конкретными исключениями
overly.broad.throws.clause.threshold.option=Максимальное количество скрытых исключений для отчёта\:
overly.complex.anonymous.inner.class.display.name=Слишком сложный анонимный класс
overly.complex.anonymous.inner.class.problem.descriptor=Слишком сложный анонимный класс (цикломатическая сложность \= {0}) \#loc
overly.complex.arithmetic.expression.display.name=Слишком сложное арифметическое выражение
overly.complex.arithmetic.expression.max.number.option=Максимальное количество термов\:
overly.complex.arithmetic.expression.problem.descriptor=Слишком сложное арифметическое выражение \#loc
overly.complex.boolean.expression.display.name=Слишком сложное логическое выражение
overly.complex.boolean.expression.ignore.option=Игнорировать чистые конъюнкции и дизъюнкции
overly.complex.boolean.expression.max.terms.option=Максимальное количество термов\:
overly.complex.boolean.expression.problem.descriptor=Слишком сложное логическое выражение ({0} термов) \#loc
overly.complex.class.display.name=Слишком сложный класс
overly.complex.class.problem.descriptor=Слишком сложный класс <code>\#ref</code> (цикломатическая сложность \= {0}) \#loc
overly.coupled.class.class.coupling.limit.option=Лимит связанности класса\:
overly.coupled.class.display.name=Слишком связанный класс
overly.coupled.class.problem.descriptor=<code>\#ref</code> слишком связан (зависимости \= {0}) \#loc
overly.long.lambda.display.name=Слишком длинное лямбда-выражение
overly.long.lambda.problem.descriptor=Лямбда-выражение слишком длинное (\# Не комментариев исходных операторов \= {0}) \#loc
overly.strong.type.cast.display.name=Слишком сильное приведение типа
overly.strong.type.cast.ignore.in.matching.instanceof.option=Игнорировать приведения с соответствующим выражением instanceof
overly.strong.type.cast.problem.descriptor=Приведение к <code>\#ref</code> может быть ослаблено до ''{0}'' \#loc
overly.strong.type.cast.weaken.quickfix=Ослабить слишком сильное приведение
overridable.method.call.in.constructor.display.name=Вызов переопределяемого метода при конструировании объекта
overridable.method.call.in.constructor.problem.descriptor=Вызов переопределяемого метода <code>\#ref()</code> при конструировании объекта \#loc
overridden.method.call.in.constructor.display.name=Вызов переопределённого метода при конструировании объекта
overridden.method.call.in.constructor.problem.descriptor=Вызов переопределённого метода <code>\#ref()</code> при конструировании объекта \#loc
package.dot.html.may.be.package.info.convert.quickfix=Преобразовать в 'package-info.java'
package.dot.html.may.be.package.info.delete.quickfix=Удалить 'package.html'
package.dot.html.may.be.package.info.display.name='package.html' может быть преобразован в 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> игнорируется, так как существует <code>package-info.java</code>
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> может быть преобразован в <code>package-info.java</code>
package.in.multiple.modules.display.name=Пакет с классами в нескольких модулях
package.in.multiple.modules.problem.descriptor.many=Пакет ''{0}'' имеет классы в модулях ''{1}'', ''{2}'' и еще {3} модулях
package.in.multiple.modules.problem.descriptor2=Пакет ''{0}'' имеет классы в модулях ''{1}'' и ''{2}''
package.in.multiple.modules.problem.descriptor3=Пакет ''{0}'' имеет классы в модулях ''{1}'', ''{2}'' и ''{3}''
package.info.java.without.package.display.name='package-info.java' без объявления 'package'
package.info.without.package.family.quickfix=Добавить объявление package
package.info.without.package.problem.descriptor='package-info.java' не содержит объявления 'package'
package.info.without.package.quickfix=Добавить ''package {0};''
package.local.field.not.accessible=Поле ''{0}'' с package-private доступом недоступно отсюда
package.local.private=package-private и private
package.naming.convention.display.name=Соглашение об именовании пакетов
package.naming.convention.problem.descriptor.long=Имя пакета <code>{0}</code> слишком длинное
package.naming.convention.problem.descriptor.regex.mismatch=Имя пакета <code>{0}</code> не соответствует регулярному выражению ''{1}''
package.naming.convention.problem.descriptor.short=Имя пакета <code>{0}</code> слишком короткое
package.visible.field.display.name=Поле с package-видимостью
package.visible.field.problem.descriptor=Поле с package-видимостью <code>\#ref</code> \#loc
package.visible.inner.class.display.name=Вложенный класс с package-видимостью
package.visible.inner.class.ignore.enum.option=Игнорировать внутренние enum с package-видимостью
package.visible.inner.class.ignore.interface.option=Игнорировать внутренние интерфейсы с package-видимостью
package.visible.inner.class.problem.descriptor=Вложенный класс с package-видимостью <code>\#ref</code> \#loc
package.with.too.few.classes.display.name=Пакет с слишком малым количеством классов
package.with.too.few.classes.min.option=Минимальное количество классов\:
package.with.too.few.classes.problem.descriptor=Пакет ''{0}'' содержит слишком мало классов ({1} < {2})
package.with.too.many.classes.display.name=Пакет с слишком большим количеством классов
package.with.too.many.classes.max.option=Максимальное количество классов\:
package.with.too.many.classes.problem.descriptor=Пакет ''{0}'' содержит слишком много классов ({1} > {2})
parameter.hides.member.variable.display.name=Параметр скрывает поле
parameter.hides.member.variable.ignore.abstract.methods.option=Игнорировать для abstract методов
parameter.hides.member.variable.ignore.constructors.option=Игнорировать для конструкторов
parameter.hides.member.variable.ignore.setters.option=Игнорировать для сеттеров свойств
parameter.hides.member.variable.ignore.static.parameters.option=Игнорировать для static методов, параметры которых скрывают поля экземпляра
parameter.hides.member.variable.ignore.superclass.option=Игнорировать поля суперкласса, невидимые из подкласса
parameter.hides.member.variable.problem.descriptor=Параметр <code>\#ref</code> скрывает поле в классе ''{0}'' \#loc
parameter.limit.option=Лимит параметров\:
parameter.name.differs.from.overridden.parameter.display.name=Имя параметра отличается от параметра в переопределённом или перегруженном методе
parameter.name.differs.from.overridden.parameter.ignore.character.option=Игнорировать, если переопределённый параметр содержит только один символ
parameter.name.differs.from.overridden.parameter.ignore.library.option=Игнорировать, если переопределённый параметр из библиотеки
parameter.name.differs.from.overridden.parameter.problem.descriptor=Имя параметра <code>\#ref</code> отличается от параметра ''{0}'' в {1, choice, 1\#методе суперкласса|2\#перегруженном методе|3\#конструкторе суперкласса|4\#перегруженном конструкторе} \#loc
parameter.naming.convention.display.name=Соглашение об именовании параметров метода
parameter.naming.convention.element.description=Параметр
parameter.type.prevents.overriding.display.name=Тип параметра препятствует переопределению
parameter.type.prevents.overriding.family.quickfix=Изменить тип параметра
parameter.type.prevents.overriding.problem.descriptor=Тип параметра <code>\#ref</code> находится в ''{0}'', в то время как тип параметра супер-метода находится в ''{1}'', что препятствует переопределению \#loc
parameter.type.prevents.overriding.quickfix=Изменить тип параметра на ''{0}''
parameters.per.constructor.display.name=Конструктор с слишком большим количеством параметров
parameters.per.constructor.problem.descriptor=<code>\#ref()</code> имеет слишком много параметров (количество параметров \= {0}) \#loc
parameters.per.method.display.name=Метод с слишком большим количеством параметров
parameters.per.method.problem.descriptor=<code>\#ref()</code> имеет слишком много параметров (количество параметров \= {0}) \#loc
pattern.variable.hides.field.display.name=Переменная паттерна скрывает поле
pattern.variable.hides.field.problem.descriptor=Переменная паттерна <code>\#ref</code> скрывает поле в классе ''{0}'' \#loc
pointless.arithmetic.expression.display.name=Бессмысленное арифметическое выражение
pointless.bitwise.expression.display.name=Бессмысленное побитовое выражение
pointless.bitwise.expression.simplify.quickfix=Упростить
pointless.boolean.expression.display.name=Бессмысленное логическое выражение
pointless.boolean.expression.ignore.option=Игнорировать именованные константы при определении бессмысленных выражений
pointless.indexof.comparison.always.false.problem.descriptor=<code>\#ref</code> всегда false \#loc
pointless.indexof.comparison.always.true.problem.descriptor=<code>\#ref</code> всегда true \#loc
pointless.indexof.comparison.display.name=Бессмысленное сравнение 'indexOf()'
pointless.nullcheck.display.name=Ненужная проверка на 'null' перед вызовом метода
pointless.nullcheck.problem.descriptor.call=Ненужная проверка на ''null'' перед вызовом ''{0}()''
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> может быть выброшено внутри блока ''finally'' \#loc
prefer.empty.array.options.mode.always=Всегда
prefer.empty.array.options.mode.always.never=Никогда (предпочитать массив с предустановленным размером)
prefer.empty.array.options.mode.by.level=В соответствии с уровнем языка
prefer.empty.array.options.title=Предпочитать пустой массив\:
prefix.operation.quickfix.family.name=Заменить префиксным оператором
press.escape.to.remove.highlighting.message=Нажмите Escape для удаления подсветки
primitive.array.argument.to.var.arg.method.display.name=Неоднозначный аргумент примитивного массива для varargs метода
primitive.array.argument.to.var.arg.method.problem.descriptor=Неоднозначный аргумент примитивного массива для varargs метода \#loc
primitive.fields.ignore.option=Игнорировать примитивные поля
printstacktrace.call.display.name=Вызов 'printStackTrace()'
printstacktrace.call.problem.descriptor=Вызов <code>\#ref()</code> следует заменить на более надежное логование \#loc
private=private
private.field.not.accessible.problem.descriptor=''private'' поле ''{0}'' недоступно отсюда
private.member.access.between.outer.and.inner.classes.display.name=Вызов синтетического аксессора
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=Сделать конструктор ''{0}'' package-private
private.member.access.between.outer.and.inner.classes.make.local.quickfix=Сделать ''{0}'' package-private
private.member.access.between.outer.and.inner.classes.problem.descriptor=Доступ к ''private'' члену класса ''{0}'' требует синтетического аксессора \#loc
problematic.varargs.method.display.name=Не-varargs метод переопределяет varargs метод
problematic.varargs.method.override.problem.descriptor=Не-varargs метод <code>\#ref()</code> переопределяет varargs метод \#loc
progress.text.analyzing.package.0=Анализ пакета {0}
properties.object.as.hashtable.display.name=Использование объекта 'Properties' как 'Hashtable'
properties.object.as.hashtable.problem.descriptor=Вызов <code>Hashtable.\#ref()</code> на объекте properties \#loc
property.value.set.to.itself.display.name=Значение свойства устанавливается в само себя
protected.field.display.name=Protected поле
protected.field.not.accessible.problem.descriptor=''protected'' поле ''{0}'' недоступно отсюда
protected.field.problem.descriptor=Protected поле <code>\#ref</code> \#loc
protected.inner.class.display.name=Protected вложенный класс
protected.inner.class.ignore.enum.option=Игнорировать 'protected' внутренние enum
protected.inner.class.ignore.interface.option=Игнорировать 'protected' внутренние интерфейсы
protected.inner.class.problem.descriptor=Protected вложенный класс <code>\#ref</code> \#loc
protected.member.in.final.class.display.name='protected' член в 'final' классе
protected.member.in.final.class.problem.descriptor=Член класса объявлен как <code>\#ref</code> в 'final' классе \#loc
protected.package.local.private=protected, package-private и private
public.constructor.display.name='public' конструктор может быть заменен фабричным методом
public.constructor.in.non.public.class.display.name='public' конструктор в не-public классе
public.constructor.in.non.public.class.problem.descriptor=Конструктор объявлен как <code>\#ref</code> в не-public классе ''{0}'' \#loc
public.constructor.in.non.public.class.quickfix=Сделать конструктор private
public.constructor.problem.descriptor=Public конструктор <code>\#ref()</code> \#loc
public.constructor.quickfix=Заменить конструктор фабричным методом
public.default.constructor.problem.descriptor=Класс <code>\#ref</code> имеет 'public' конструктор по умолчанию
public.field.accessed.in.synchronized.context.display.name=Доступ к не-private полю в 'synchronized' контексте
public.field.accessed.in.synchronized.context.problem.descriptor=Доступ к не-private полю <code>\#ref</code> в синхронизованном контексте \#loc
public.field.display.name='public' поле
public.field.ignore.enum.type.fields.option=Игнорировать 'public final' поля типа enum
public.field.problem.descriptor='public' поле <code>\#ref</code> \#loc
public.inner.class.display.name='public' вложенный класс
public.inner.class.ignore.enum.option=Игнорировать 'public' внутренние enum
public.inner.class.ignore.interface.option=Игнорировать 'public' внутренние интерфейсы
public.inner.class.problem.descriptor='public' вложенный класс <code>\#ref</code> \#loc
public.method.not.in.interface.display.name='public' метод не представлен в интерфейсе
public.method.not.in.interface.option=<html>Игнорировать, если содержащий класс не реализует нелибрарный интерфейс</html>
public.method.not.in.interface.problem.descriptor='public' метод <code>\#ref()</code> не представлен через интерфейс \#loc
public.method.without.logging.display.name='public' метод без логования
public.method.without.logging.problem.descriptor='public' метод <code>\#ref()</code> не содержит вызовов логования \#loc
public.static.array.field.display.name='public static' поле массива
public.static.array.field.problem.descriptor='public static' поле массива <code>\#ref</code>, компрометирует безопасность \#loc
public.static.collection.field.display.name='public static' поле коллекции
public.static.collection.field.problem.descriptor='public static' поле коллекции <code>\#ref</code>, компрометирует безопасность \#loc
qualify.call.fix.family.name=Уточнить вызов
query.label=Имена запросов начинаются с\:
questionable.name.display.name=Сомнительное имя
questionable.name.list.label=Отслеживаемые имена\:
questionable.name.problem.descriptor=Сомнительное имя <code>\#ref</code> \#loc
random.double.for.random.integer.display.name=Использование 'Random.nextDouble()' для получения случайного целого числа
random.double.for.random.integer.problem.descriptor=Использование <code>Random.\#ref</code> для создания случайного целого числа \#loc
raw.use.of.parameterized.type.display.name=Сырое использование параметризованного класса
readobject.initialization.display.name=Поле экземпляра может быть не инициализовано методом 'readObject()'
readobject.initialization.problem.descriptor=Поле экземпляра <code>\#ref</code> может быть не инициализовано при вызове 'readObject()' \#loc
readresolve.writereplace.protected.display.name='readResolve()' или 'writeReplace()' не объявлены как 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>\#ref()</code> не объявлен как 'protected' \#loc
readwriteobject.private.display.name='readObject()' или 'writeObject()' не объявлены как 'private'
readwriteobject.private.problem.descriptor=<code>\#ref</code> не объявлен как 'private' \#loc
recordstore.opened.not.safely.closed.display.name='RecordStore' открыт, но не закрыт безопасно
redundant.as.list.for.iteration.fix.name=Развернуть
redundant.as.list.for.iteration.problem=Ненужный вызов 'Arrays.asList()'
redundant.call.problem.descriptor=Избыточный вызов <code>\#ref()</code> \#loc
redundant.else.display.name=Избыточный 'else'
redundant.else.problem.descriptor=Ветвь <code>\#ref</code> может быть развёрнута, так как ветвь 'if' никогда не завершается нормально \#loc
redundant.else.unwrap.quickfix=Удалить избыточный 'else'
redundant.escape.in.regex.replacement.display.name=Избыточное экранирование в строке замены регулярного выражения
redundant.escape.in.regex.replacement.problem.descriptor=Избыточное экранирование ''{0}''
redundant.escape.in.regex.replacement.quickfix=Удалить избыточное экранирование
redundant.explicit.var.type.display.name=Тип локальной переменной может быть опущен
redundant.field.initialization.display.name=Избыточная инициализация поля
redundant.field.initialization.problem.descriptor=Инициализация поля <code>\#ref</code> избыточна \#loc
redundant.field.initialization.remove.quickfix=Удалить инициализатор
redundant.implements.display.name=Избыточное объявление интерфейса
redundant.implements.problem.descriptor=Избыточное объявление интерфейса <code>\#ref</code> \#loc
redundant.implements.remove.quickfix=Удалить избыточное объявление интерфейса
redundant.local.variable.annotation.option=Игнорировать переменные с аннотациями
redundant.local.variable.display.name=Избыточная локальная переменная
redundant.local.variable.ignore.option=Игнорировать переменные, которые сразу возвращаются или выбрасываются
redundant.method.override.delegate.quickfix=Заменить метод делегированием к super
redundant.method.override.delegates.to.super.problem.descriptor=Метод <code>\#ref()</code> только делегирует своему super методу \#loc
redundant.method.override.display.name=Метод идентичен своему super методу
redundant.method.override.option.check.library.methods=Проверять методы, переопределяющие методы библиотек
redundant.method.override.option.ignore.delegates=Игнорировать делегирование к super методам
redundant.method.override.problem.descriptor=Метод <code>\#ref()</code> идентичен своему super методу \#loc
redundant.method.override.quickfix=Удалить избыточный метод
redundant.string.format.call.display.name=Избыточный вызов 'String.format()'
redundant.string.format.call.quickfix=Удалить избыточный вызов 'String.format()'
redundant.string.formatted.call.quickfix=Удалить избыточный вызов 'String.formatted()'
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=Ссылка на подкласс {0} из инициализатора суперкласса {1} может привести к взаимной блокировке при загрузке классов
reflection.for.unavailable.annotation.display.name=Рефлексивный доступ к аннотации, доступной только в исходном коде
reflection.for.unavailable.annotation.problem.descriptor=Аннотация '\#ref' не сохраняется для рефлексивного доступа \#loc
refused.bequest.display.name=Метод не вызывает super метод
refused.bequest.fix.family.name=Вставить вызов super метода
refused.bequest.ignore.default.super.methods.option=Игнорировать 'default' super методы
refused.bequest.ignore.empty.super.methods.option=Игнорировать пустые super методы
refused.bequest.problem.descriptor=Метод <code>\#ref()</code> не вызывает 'super.\#ref()' \#loc
remove.annotation.parameter.0.fix.name=Удалить параметр аннотации ''{0}''
remove.call.fix.family.name=Удалить вызов
remove.cloneable.quickfix=Удалить 'Cloneable' из списка 'implements'
remove.finally.block.quickfix=Удалить блок 'finally'
remove.leading.zero.to.make.decimal.quickfix=Удалить ведущий ноль для десятичного числа
remove.leading.zeroes.to.make.decimals.quickfix=Удалить ведущие нули для десятичных чисел
remove.loop.fix.family.name=Удалить цикл
remove.modifier.fix.family.name=Удалить модификатор
remove.modifier.quickfix=Удалить модификатор ''{0}''
remove.redundant.polyadic.operand.fix.family.name=Удалить ненужное условие
remove.redundant.polyadic.operand.fix.name=Удалить ненужное условие ''{0}''
remove.redundant.string.fix.text=Использовать ''{0}()'' и удалить избыточный вызов ''{1}()''
remove.redundant.substring.fix.family.name=Удалить избыточный вызов 'substring()'
remove.try.finally.block.quickfix=Удалить блок 'try-finally'
remove.unnecessary.0.call.quickfix=Удалить ненужный вызов ''{0}()''
rename.quickfix=Переименовать
renameto.quickfix=Переименовать в ''{0}''
replace.all.dot.display.name=Подозрительное выражение регулярного выражения
replace.all.dot.problem.descriptor=Подозрительное регулярное выражение \#ref в вызове ''{0}()'' \#loc
replace.all.dot.quickfix=Экранировать метасимвол регулярного выражения
replace.all.file.separator.problem.descriptor=File.separator используется как регулярное выражение; не будет работать в Windows
replace.anonymous.with.lambda.body.fix.family.name=Заменить вызов телом метода
replace.case.default.null.with.null.default=Заменить 'case default, null' на 'case null, default'
replace.case.default.with.default=Заменить 'case default' на 'default'
replace.cast.fix.family.name=Заменить тип приведения
replace.casted.literal.with.just.literal.fix.family.name=Заменить на литерал {0}
replace.field.reference.fix.family.name=Заменить ссылку на поле
replace.field.reference.fix.text=Заменить ссылку на поле на ''{0}''
replace.inheritance.with.delegation.quickfix=Заменить наследование делегированием
replace.instanceof.fix.family.name=Заменить тип instanceOf
replace.method.call.fix.family.name=Заменить вызов метода
replace.method.call.fix.text=Заменить вызов метода на ''{0}''
replace.method.ref.with.qualifier.fix.family.name=Заменить на квалификатор
replace.method.ref.with.qualifier.problem.lambda=Лямбда может быть заменена квалификатором вызова
replace.method.ref.with.qualifier.problem.method=Ссылка на метод может быть заменена квалификатором
replace.with.cast.fix.family.name=Заменить на приведение типа
replace.with.catch.clause.for.runtime.exception.quickfix=Заменить на блок 'catch' для 'RuntimeException'
replace.with.comparator.fix.family.name=Упростить компаратор используя статические методы 'Comparator'
replace.with.lambda.body.fix.family.name=Заменить вызов метода по лямбде телом лямбды
replace.with.method.ref.fix.family.name=Заменить лямбду на ссылку на метод
replace.with.method.ref.fix.name.may.change.semantics=Заменить лямбду на ссылку на метод (может изменить семантику)
replace.with.method.reference.fix.family.name=Заменить вызов метода по ссылке на метод соответствующим вызовом метода
replace.with.var.fix.family.name=Заменить явный тип на 'var'
resource.opened.not.closed.problem.descriptor=''{0}'' должен быть открыт перед блоком ''try'' и закрыт в соответствующем блоке ''finally'' \#loc
result.of.method.call.ignored.class.column.title=Имя класса
result.of.method.call.ignored.display.name=Результат вызова метода игнорируется
result.of.method.call.ignored.non.library.option=Сообщать обо всех игнорируемых вызовах не из библиотек
result.of.method.call.ignored.problem.descriptor=Результат <code>{0}.\#ref()</code> игнорируется \#loc
result.of.object.allocation.fix.name=Игнорировать создание объектов типа ''{0}''
result.of.object.allocation.ignored.display.name=Результат создания объекта игнорируется
result.of.object.allocation.ignored.options.chooserTitle=Выберите класс, для которого можно игнорировать создание объектов
result.of.object.allocation.ignored.problem.descriptor=Результат <code>new \#ref()</code> игнорируется \#loc
result.of.object.allocation.ignored.problem.descriptor.methodRef=Объект, созданный внутри <code>\#ref</code>, отбрасывается \#loc
return.from.finally.block.display.name='return' внутри блока 'finally'
return.from.finally.block.problem.descriptor='return' внутри блока 'finally' \#loc
return.of.anonymous.class.problem.descriptor=Возврат экземпляра анонимного класса \#loc
return.of.collection.field.fix.family.name=Сделать возвращаемую коллекцию 'unmodifiable'
return.of.field.with.mutable.type.problem.descriptor=Возврат поля {0} <code>{1}</code> \#loc
return.of.inner.class.display.name=Возврат экземпляра анонимного, локального или внутреннего класса
return.of.inner.class.ignore.non.public.option=Игнорировать возвраты из непубличных методов
return.of.inner.class.problem.descriptor=Возврат экземпляра нестатического внутреннего класса <code>{0}</code> \#loc
return.of.local.class.problem.descriptor=Возврат экземпляра локального класса <code>{0}</code> \#loc
return.of.null.arrays.option=Сообщать о методах, возвращающих массивы
return.of.null.collections.option=Сообщать о методах, возвращающих коллекции
return.of.null.display.name=Возврат 'null'
return.of.null.ignore.private.option=Игнорировать 'private' методы, анонимные классы и лямбды
return.of.null.objects.option=Сообщать о методах, возвращающих объекты
return.of.null.problem.descriptor=Возврат <code>\#ref</code> \#loc
return.point.limit.option=&Лимит точек возврата\:
return.this.display.name=Возврат 'this'
return.this.problem.descriptor=Возврат <code>\#ref</code> \#loc
reuse.of.local.variable.display.name=Повторное использование локальной переменной
reuse.of.local.variable.problem.descriptor=Повторное использование локальной переменной <code>\#ref</code> \#loc
reuse.of.local.variable.split.quickfix=Разделить локальную переменную
runtime.exec.call.display.name=Вызов 'Runtime.exec()'
runtime.exec.call.problem.descriptor=Вызов <code>Runtime.\#ref()</code> не является переносимым \#loc
runtime.exec.with.non.constant.string.display.name=Вызов 'Runtime.exec()' с неконстантной строкой
runtime.exec.with.non.constant.string.problem.descriptor=Вызов <code>Runtime.\#ref()</code> с неконстантным аргументом \#loc
safe.lock.display.name=Блокировка получена, но не освобождена безопасно
safe.lock.problem.descriptor=''{0}'' должен быть заблокирован перед блоком ''try'' и разблокирован в соответствующем блоке ''finally'' \#loc
serial.annotation.used.on.wrong.member.display.name=Аннотация '@Serial' использована на неверном элементе
serial.annotation.used.on.wrong.member.problem.descriptor=Аннотированный элемент не является частью механизма сериализации
serializable.anonymous.class.stores.non.serializable.problem.descriptor=Сериализуемый анонимный класс неявно хранит несериализуемый объект типа ''{0}''
serializable.class.in.secure.context.display.name=Сериализуемый класс в защищенном контексте
serializable.class.in.secure.context.problem.descriptor=Класс <code>\#ref</code> может быть сериализован, что ставит под угрозу безопасность \#loc
serializable.deserializable.class.in.secure.context.problem.descriptor=Класс <code>\#ref</code> может быть сериализован и десериализован, что ставит под угрозу безопасность \#loc
serializable.has.serialization.methods.display.name=Сериализуемый класс без 'readObject()' и 'writeObject()'
serializable.has.serialization.methods.ignore.option=Игнорировать классы, не определяющие поля экземпляра
serializable.has.serialization.methods.problem.descriptor=Сериализуемый класс <code>\#ref</code> не определяет 'readObject()' или 'writeObject()' \#loc
serializable.has.serialization.methods.problem.descriptor1=Сериализуемый класс <code>\#ref</code> не определяет 'writeObject()' \#loc
serializable.has.serialization.methods.problem.descriptor2=Сериализуемый класс <code>\#ref</code> не определяет 'readObject()' \#loc
serializable.inner.class.has.serial.version.uid.field.display.name=Сериализуемый нестатический внутренний класс без 'serialVersionUID'
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=Внутренний класс <code>\#ref</code> не определяет поле 'serialVersionUID' \#loc
serializable.inner.class.with.non.serializable.outer.class.display.name=Сериализуемый не-'static' внутренний класс с несериализуемым внешним классом
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=Внутренний класс <code>\#ref</code> сериализуем, в то время как его внешний класс - нет \#loc
serializable.lambda.stores.non.serializable.problem.descriptor=Сериализуемая лямбда неявно хранит несериализуемый объект типа ''{0}''
serializable.local.class.stores.non.serializable.problem.descriptor=Сериализуемый локальный класс ''{1}'' неявно хранит несериализуемый объект типа ''{0}''
serializable.record.contains.ignored.field.problem.descriptor=<code>\#ref</code> будет проигнорирован при сериализации record
serializable.record.contains.ignored.members.display.name='record' содержит игнорируемые элементы
serializable.record.contains.ignored.method.problem.descriptor=<code>\#ref()</code> будет проигнорирован при сериализации record
serializable.stores.non.serializable.display.name='Serializable' объект неявно хранит не-'Serializable' объект
serializable.with.unconstructable.ancestor.display.name=Сериализуемый класс с неконструируемым предком
serializable.with.unconstructable.ancestor.problem.descriptor=<code>\#ref</code> имеет несериализуемого предка ''{0}'' без конструктора без аргументов \#loc
serialpersistentfields.with.wrong.signature.display.name=Поле 'serialPersistentFields' не объявлено как 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=Поле <code>\#ref</code> сериализуемого класса не объявлено как 'private static final ObjectStreamField[]' \#loc
serialversionuid.private.static.final.long.display.name=Поле 'serialVersionUID' не объявлено как 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=Поле <code>\#ref</code> сериализуемого класса не объявлено как 'private static final long' \#loc
serialversionuid.private.static.final.long.quickfix=Сделать serialVersionUID 'private static final'
set.annotation.parameter.0.1.fix.name=Установить параметр аннотации {0} \= "{1}"
set.replaceable.by.enum.set.display.name='Set' можно заменить на 'EnumSet'
set.replaceable.by.enum.set.problem.descriptor=<code>\#ref</code> можно заменить на 'EnumSet' \#loc
shared.thread.local.random.display.name=Экземпляр 'ThreadLocalRandom' может быть общим
shared.thread.local.random.problem.descriptor=Экземпляр 'ThreadLocalRandom' может быть общим между потоками
shift.operation.by.inappropriate.constant.display.name=Сдвиг на некорректную константу
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Операция сдвига <code>\#ref</code> на отрицательное константное значение {0} \#loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=Операция сдвига <code>\#ref</code> на значение вне допустимого диапазона {0}\#loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Операция сдвига <code>\#ref</code> на слишком большое константное значение {0} \#loc
shift.out.of.range.fix.family.name=Исправить значение сдвига
side.effects.method.ref.to.lambda.fix.family.name={0} (побочные эффекты)
signal.without.corresponding.await.display.name='signal()' без соответствующего 'await()'
signal.without.corresponding.await.problem.descriptor=Вызов <code>\#ref()</code> без соответствующего <code>await()</code> \#loc
simplifiable.annotation.braces.problem.descriptor=Ненужные скобки вокруг <code>{0}</code> в аннотации \#loc
simplifiable.annotation.display.name=Упрощаемая аннотация
simplifiable.annotation.problem.descriptor=Ненужное <code>\#ref</code> в аннотации \#loc
simplifiable.annotation.quickfix=Упростить аннотацию
simplifiable.annotation.whitespace.problem.descriptor=Ненужные пробелы в аннотации \#loc
simplifiable.boolean.expression.display.name=Упрощаемое логическое выражение
simplifiable.conditional.expression.display.name=Упрощаемое условное выражение
simplifiable.conditional.expression.problem.descriptor=<code>{1}</code> можно упростить до ''{0}'' \#loc
simplifiable.equals.expression.display.name=Ненужная проверка на 'null' перед вызовом 'equals()'
simplifiable.equals.expression.option.non.constant=Сообщать о equals с неконстантным ненулевым аргументом
simplifiable.equals.expression.problem.descriptor=Ненужная проверка на ''null'' перед вызовом ''{0}()'' \#loc
simplifiable.equals.expression.quickfix=Инвертировать ''.{0}()'' и удалить ненужную проверку на ''null''
simplifiable.junit.assertion.display.name=Упрощаемое утверждение
simplifiable.junit.assertion.problem.descriptor=<code>\#ref()</code> можно упростить до ''{0}'' \#loc
simplify.junit.assertion.simplify.quickfix=Упростить утверждение
single.character.startswith.display.name=Одиночный символ в 'startsWith()' или 'endsWith()'
single.character.startswith.problem.descriptor=Одиночный символ <code>\#ref()</code> можно заменить выражением 'charAt()' \#loc
single.character.startswith.quickfix=Заменить выражением 'charAt()'
single.class.import.display.name=Импорт одиночного класса
single.class.import.problem.descriptor=Импорт одиночного класса <code>\#ref</code> \#loc
single.element.annotation.family.quickfix=Развернуть аннотацию в нормальную форму
single.element.annotation.name=Ненормализованная аннотация
single.element.annotation.quickfix=Добавить 'value\='
single.statement.in.block.descriptor=''{0}'' содержит единственный оператор
single.statement.in.block.family.quickfix=Удалить фигурные скобки из оператора
single.statement.in.block.name=Блок кода содержит единственный оператор
single.statement.in.block.quickfix=Удалить фигурные скобки из оператора ''{0}''
singleton.display.name=Синглтон
singleton.problem.descriptor=Класс <code>\#ref</code> является синглтоном \#loc
size.replaceable.by.isempty.display.name='size() \=\= 0' можно заменить на 'isEmpty()'
size.replaceable.by.isempty.fix.ignore.calls=Игнорировать вызовы ''.{0}()'' для типа ''{1}''
size.replaceable.by.isempty.negation.ignore.option=Игнорировать выражения, которые будут заменены на '\!isEmpty()'
sleep.while.holding.lock.display.name=Вызов 'Thread.sleep()' в синхронизованном блоке
sleep.while.holding.lock.problem.descriptor=Вызов <code>Thread.\#ref()</code> в синхронизованном блоке \#loc
smth.unnecessary.remove.quickfix=Удалить ненужное ''{0}''
socket.opened.not.closed.display.name=Сокет открыт, но не закрыт безопасно
standard.variable.names.display.name=Стандартные имена переменных
standard.variable.names.ignore.override.option=Игнорировать для имен параметров, идентичных параметрам родительского метода
standard.variable.names.problem.descriptor=Переменная с именем <code>\#ref</code> не имеет тип ''{0}'' \#loc
standard.variable.names.problem.descriptor2=Переменная с именем <code>\#ref</code> не имеет тип ''{0}'' или ''{1}'' \#loc
statement.problem.descriptor=Оператор <code>\#ref</code> \#loc
statement.with.empty.body.display.name=Оператор с пустым телом
statement.with.empty.body.include.option=Включать тела операторов, являющиеся пустыми блоками кода
statement.with.empty.body.problem.descriptor=Оператор <code>\#ref</code> имеет пустое тело \#loc
static.collection.display.name=Статическая коллекция
static.collection.ignore.option=Игнорировать слабые статические коллекции или отображения
static.collection.problem.descriptor=Статическая коллекция <code>\#ref</code> \#loc
static.field.via.subclass.display.name=Статическое поле, используемое через подкласс
static.field.via.subclass.problem.descriptor=Статическое поле <code>\#ref</code> объявлено в классе ''{0}'', но используется через подкласс ''{1}'' \#loc
static.field.via.subclass.rationalize.quickfix=Рационализовать доступ к статическому полю
static.import.display.name=Статический импорт
static.import.fix.ignore.class=Разрешить статические импорты для класса ''{0}''
static.import.options.border.title=Классы, доступные для статического импорта\:
static.import.options.chooserTitle=Выберите класс для статического импорта
static.import.problem.descriptor=Статический импорт <code>\#ref</code> \#loc
static.import.replace.quickfix=Заменить на нестатический импорт
static.inheritance.display.name=Статическое наследование
static.inheritance.fix.family.name=Заменить наследование на квалифицированную ссылку
static.inheritance.problem.descriptor=Интерфейс <code>\#ref</code> реализован только для его статических констант \#loc
static.inheritance.replace.quickfix=Заменить наследование на квалифицированные ссылки в {0}
static.initializer.references.subclass.display.name=Статический инициализатор ссылается на подкласс
static.method.naming.convention.element.description=Статический метод
static.method.only.used.in.one.anonymous.class.problem.descriptor=Статический {0, choice, 1\#метод|2\#поле} <code>\#ref{0, choice, 1\#()|2\#}</code> используется только в анонимном классе, производном от ''{1}'' \#loc
static.method.only.used.in.one.class.display.name=Статический член используется только в одном другом классе
static.method.only.used.in.one.class.ignore.anonymous.option=Игнорировать, если используется только в анонимном классе
static.method.only.used.in.one.class.ignore.on.conflicts=Игнорировать, когда метод нельзя переместить без конфликтов
static.method.only.used.in.one.class.ignore.test.option=Игнорировать, если используется только в тестовом классе
static.method.only.used.in.one.class.ignore.utility.classes=Игнорировать члены, расположенные в служебных классах
static.method.only.used.in.one.class.problem.descriptor=Статический {0, choice, 1\#метод|2\#поле} <code>\#ref{0, choice, 1\#()|2\#}</code> используется только в классе ''{1}'' \#loc
static.method.only.used.in.one.class.quickfix=Переместить {0} в класс использования
static.method.only.used.in.one.class.quickfix.preview=Перемещает статический член в класс, где он используется.
static.method.via.subclass.display.name=Статический метод, вызываемый через подкласс
static.method.via.subclass.problem.descriptor=Статический метод <code>\#ref()</code> объявлен в классе ''{0}'', но вызывается через подкласс ''{1}'' \#loc
static.method.via.subclass.rationalize.quickfix=Рационализовать вызов статического метода
static.non.final.field.display.name=Статическое нефинальное поле
static.non.final.field.option=Сообщать только о 'public' полях
static.non.final.field.problem.descriptor=Статическое нефинальное поле <code>\#ref</code> \#loc
static.variable.may.not.be.initialized.display.name=Статическое поле может быть не инициализовано
static.variable.may.not.be.initialized.problem.descriptor=Статическое поле <code>\#ref</code> может быть не инициализовано при инициализации класса \#loc
static.variable.naming.convention.element.description=Статическое поле
static.variable.of.concrete.class.problem.descriptor=Статическое поле ''{0}'' конкретного класса <code>\#ref</code> \#loc
static.variable.used.before.initialization.display.name=Статическое поле используется до инициализации
static.variable.used.before.initialization.problem.descriptor=Статическое поле <code>\#ref</code> используется до инициализации \#loc
string.buffer.must.have.initial.capacity.display.name='StringBuilder' без начальной емкости
string.buffer.must.have.initial.capacity.problem.descriptor=<code>new \#ref()</code> без начальной емкости \#loc
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' может быть заменен на 'StringBuilder'
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer \#ref</code> может быть объявлен как 'StringBuilder' \#loc
string.buffer.replaceable.by.string.display.name='StringBuilder' может быть заменен на 'String'
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} \#ref</code> может быть заменен на ''String'' \#loc
string.comparison.display.name=Сравнение строк через '\=\=' вместо 'equals()'
string.comparison.problem.descriptor=Строковые значения сравниваются через <code>\#ref</code>, а не через 'equals()' \#loc
string.concatenation.argument.to.log.call.display.name=Неконстантная конкатенация строк в качестве аргумента вызова логования
string.concatenation.argument.to.log.call.problem.descriptor=Неконстантная строка в качестве аргумента вызова логования <code>\#ref()</code> \#loc
string.concatenation.argument.to.log.call.quickfix=Заменить конкатенацию параметризованным сообщением лога
string.concatenation.argument.to.log.message.format.call.quickfix=Заменить 'Message.format()' параметризованным сообщением лога
string.concatenation.argument.to.log.string.format.call.quickfix=Заменить 'String.format()' параметризованным сообщением лога
string.concatenation.display.name=Конкатенация строк
string.concatenation.in.format.call.display.name=Конкатенация строк в качестве аргумента вызова 'format()'
string.concatenation.in.format.call.fix.family.name=Заменить конкатенацию аргументом
string.concatenation.in.format.call.problem.descriptor=Вызов ''{0}()'' содержит аргумент с конкатенацией строк
string.concatenation.in.format.call.quickfix=Заменить конкатенацию отдельным аргументом
string.concatenation.in.loops.display.name=Конкатенация строк в цикле
string.concatenation.in.loops.problem.descriptor=Конкатенация строк <code>\#ref</code> в цикле \#loc
string.concatenation.in.message.format.call.display.name=Конкатенация строк в качестве аргумента вызова 'MessageFormat.format()'
string.concatenation.in.message.format.call.problem.descriptor=Конкатенация строк в качестве аргумента вызова 'MessageFormat.format()' \#loc
string.concatenation.inside.string.buffer.append.display.name=Конкатенация строк в качестве аргумента вызова 'StringBuilder.append()'
string.concatenation.inside.string.buffer.append.problem.descriptor=Конкатенация строк в качестве аргумента вызова <code>{0}.\#ref()</code> \#loc
string.concatenation.inside.string.buffer.append.replace.quickfix=Заменить на цепочку вызовов 'append()'
string.concatenation.introduce.fix=Добавить StringBuilder
string.concatenation.introduce.fix.name=Добавить новый {1} для обновления переменной ''{0}''
string.concatenation.introduce.fix.name.null.safe=Добавить новый {1} для обновления переменной ''{0}'' (с проверкой на null)
string.concatenation.missing.whitespace.display.name=В конкатенации строк может отсутствовать пробел
string.concatenation.missing.whitespace.option=Игнорировать конкатенации со строковыми переменными
string.concatenation.missing.whitespace.problem.descriptor=В конкатенации строк может отсутствовать пробел \#loc
string.concatenation.problem.descriptor=Конкатенация строк <code>\#ref</code> в интернационализованном контексте \#loc
string.concatenation.replace.fix=Заменить на StringBuilder
string.concatenation.replace.fix.name=Преобразовать переменную ''{0}'' из String в {1}
string.concatenation.replace.fix.name.null.safe=Преобразовать переменную ''{0}'' из String в {1} (с проверкой на null)
string.equals.char.sequence.display.name='String.equals()' вызван с аргументом типа 'CharSequence'
string.equals.char.sequence.problem.descriptor=<code>String.equals()</code> вызван с аргументом типа ''{0}'' \#loc
string.equals.empty.string.display.name='String.equals()' может быть заменен на 'String.isEmpty()'
string.equals.empty.string.fix.family.name=Упростить проверку пустой строки
string.equals.empty.string.is.empty.problem.descriptor=<code>\#ref("")</code> может быть заменен на 'isEmpty()' \#loc
string.equals.empty.string.option.do.not.add.null.check=Не сообщать, когда может потребоваться проверка на null
string.equals.empty.string.problem.descriptor=<code>\#ref("")</code> может быть заменен на 'length()\=\=0' \#loc
string.format.choose.class=Выберите класс форматования
string.format.class.label=Дополнительные классы форматования\:
string.format.class.method.label=Дополнительные методы форматования\:
string.indexof.replaceable.by.contains.display.name=Выражение 'String.indexOf()' может быть заменено на 'contains()'
string.replace.quickfix=Удалить пустой строковый операнд
string.replaceable.by.string.buffer.display.name=Неконстантная строка может быть заменена на 'StringBuilder'
string.replaceable.by.string.buffer.in.loop.option=Предупреждать только при добавлении в цикле
string.replaceable.by.string.buffer.problem.descriptor=Неконстантная строка <code>\#ref</code> вероятно должна быть объявлена как 'StringBuilder' \#loc
string.touppercase.tolowercase.without.locale.display.name=Вызов 'String.toUpperCase()' или 'toLowerCase()' без указания локали
string.touppercase.tolowercase.without.locale.problem.descriptor=<code>String.\#ref()</code> вызывается без указания Locale при использовании интернационализованных строк \#loc
stringbuffer.field.display.name=Поле типа 'StringBuilder'
stringbuffer.field.problem.descriptor=Поле ''{0}'' <code>\#ref</code> \#loc
subtraction.in.compareto.display.name=Вычитание в 'compareTo()'
subtraction.in.compareto.problem.descriptor=Вычитание <code>\#ref</code> в 'compareTo()' может привести к переполнению или потере точности \#loc
super.class.logger.option=Игнорировать, когда суперкласс имеет доступный логгер
suppress.for.tests.scope.quickfix=Подавить для области 'Tests'
suspicious.array.cast.display.name=Подозрительное приведение массива
suspicious.array.cast.problem.descriptor=Подозрительное приведение к <code>\#ref</code> \#loc
suspicious.comparator.compare.descriptor.min.value=Возврат Integer.MIN_VALUE из функции сравнения не рекомендуется
suspicious.comparator.compare.descriptor.non.negative=Компаратор никогда не возвращает отрицательные значения
suspicious.comparator.compare.descriptor.non.positive=Компаратор никогда не возвращает положительные значения
suspicious.comparator.compare.descriptor.non.reflexive=Компаратор не возвращает 0 для равных элементов
suspicious.comparator.compare.descriptor.parameter.not.used=Параметр ''{0}()'' <code>\#ref</code> не используется \#loc
suspicious.comparator.compare.display.name=Подозрительная реализация 'Comparator.compare()'
suspicious.getter.problem.descriptor=Getter <code>\#ref()</code> возвращает поле ''{0}'' \#loc
suspicious.getter.setter.display.name=Подозрительный getter/setter
suspicious.indent.after.control.statement.display.name=Подозрительный отступ после управляющей конструкции без фигурных скобок
suspicious.indent.after.control.statement.problem.descriptor=Подозрительный отступ после оператора ''{0}'' \#loc
suspicious.integer.div.assignment.display.name=Подозрительное присваивание целочисленного деления
suspicious.integer.div.assignment.problem.descriptor=Результат деления усекается до целого числа
suspicious.integer.div.assignment.quickfix=Привести к double
suspicious.literal.underscore.display.name=Подозрительное подчеркивание в числовом литерале
suspicious.literal.underscore.problem.descriptor=Группа в числовом литерале с подчеркиваниями не имеет длину 3 \#loc
suspicious.package.private.access.display.name=Подозрительный package-private доступ
suspicious.setter.problem.descriptor=Setter <code>\#ref()</code> присваивает значение полю ''{0}'' \#loc
suspicious.system.arraycopy.display.name=Подозрительный вызов 'System.arraycopy()'
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=Длина всегда больше чем ''dest.length - destPos'' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=Длина всегда больше чем ''src.length - srcPos'' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=Копирование в тот же массив с пересекающимися диапазонами
suspicious.system.arraycopy.problem.descriptor4=<code>\#ref</code> не является типом массива \#loc
suspicious.system.arraycopy.problem.descriptor5=<code>\#ref</code> не является типом массива \#loc
suspicious.system.arraycopy.problem.descriptor6=Тип исходного параметра ''{0}'' не может быть присвоен целевому параметру <code>\#ref</code> типа ''{1}'' \#loc
suspicious.to.array.call.display.name=Подозрительный вызов 'Collection.toArray()'
suspicious.to.array.call.fix.family.name=Заменить правильным массивом
suspicious.to.array.call.problem.descriptor=Ожидался массив типа ''{0}[]'', найден ''{1}[]'' \#loc
swap.equals.fix.family.name=Развернуть вызов метода
switch.expression.with.single.default.message=Выражение 'switch' имеет только ветку 'default'
switch.expression.with.too.few.branches.problem.descriptor=Выражение ''switch'' имеет слишком мало меток case ({0}), и вероятно должно быть заменено оператором ''if'' или условным оператором \#loc
switch.statement.density.display.name=Оператор 'switch' со слишком низкой плотностью веток
switch.statement.density.min.option=Минимальная плотность веток\: %
switch.statement.density.problem.descriptor=Плотность веток <code>\#ref</code> слишком низкая ({0}%) \#loc
switch.statement.display.name=Оператор 'switch'
switch.statement.with.confusing.declaration.display.name=Локальная переменная используется и объявляется в разных ветках 'switch'
switch.statement.with.confusing.declaration.problem.descriptor=Локальная переменная <code>\#ref</code> объявлена в одной ветке 'switch' и используется в другой \#loc
switch.statement.with.single.default.message=Оператор 'switch' имеет только ветку 'default'
switch.statement.with.too.few.branches.display.name=Минимум веток 'switch'
switch.statement.with.too.few.branches.ignore.pattern.option=Не сообщать о pattern switch операторах
switch.statement.with.too.few.branches.min.option=Минимальное количество веток\:
switch.statement.with.too.few.branches.problem.descriptor=Оператор ''switch'' имеет слишком мало меток case ({0}), и вероятно должен быть заменен оператором ''if'' \#loc
switch.statement.with.too.many.branches.display.name=Максимум веток 'switch'
switch.statement.without.default.ignore.option=Игнорировать исчерпывающие switch операторы
switch.statements.without.default.display.name=Оператор 'switch' без ветки 'default'
switch.statements.without.default.problem.descriptor=Оператор <code>\#ref</code> без ветки 'default' \#loc
synchronization.on.get.class.display.name=Синхронизация на 'getClass()'
synchronization.on.get.class.problem.descriptor=Синхронизация на <code>\#ref()</code> \#loc
synchronization.on.local.variable.or.method.parameter.display.name=Синхронизация на локальной переменной или параметре метода
synchronization.on.local.variable.problem.descriptor=Синхронизация на локальной переменной <code>\#ref</code> \#loc
synchronization.on.method.parameter.problem.descriptor=Синхронизация на параметре метода <code>\#ref</code> \#loc
synchronization.on.static.field.display.name=Синхронизация на 'static' поле
synchronization.on.static.field.problem.descriptor=Синхронизация на 'static' поле <code>\#ref</code> \#loc
synchronize.on.class.problem.descriptor=Операции блокировки на классе могут иметь непредвиденные побочные эффекты \#loc
synchronize.on.lock.display.name=Синхронизация на объекте 'Lock'
synchronize.on.lock.problem.descriptor=Синхронизация на объекте ''{0}'' вряд ли является намеренной \#loc
synchronize.on.non.final.field.display.name=Синхронизация на нефинальном поле
synchronize.on.non.final.field.problem.descriptor=Синхронизация на нефинальном поле <code>\#ref</code> \#loc
synchronize.on.this.display.name=Синхронизация на 'this'
synchronize.on.this.problem.descriptor=Операции блокировки на 'this' могут иметь непредвиденные побочные эффекты \#loc
synchronized.method.display.name=Метод 'synchronized'
synchronized.method.ignore.synchronized.super.option=Игнорировать методы, переопределяющие synchronized метод
synchronized.method.include.option=Включать нативные методы
synchronized.method.move.quickfix=Переместить синхронизацию в метод
synchronized.method.problem.descriptor=Метод ''{0}()'' объявлен как <code>\#ref</code> \#loc
synchronized.on.direct.literal.object.problem.descriptor=Синхронизация на литерале {0} <code>\#ref</code> \#loc
synchronized.on.literal.object.name=Синхронизация на объекте, инициализованном литералом
synchronized.on.literal.object.problem.descriptor=Синхронизация на {0} <code>\#ref</code>, инициализованном литералом \#loc
synchronized.on.literal.object.warn.on.all.option=Предупреждать обо всех возможных литералах
synchronized.on.possibly.literal.object.problem.descriptor=Синхронизация на {0} <code>\#ref</code> \#loc
system.exit.call.display.name=Вызов 'System.exit()' или связанных методов
system.exit.call.ignore.option=Игнорировать в методе main
system.exit.call.problem.descriptor=Вызов <code>{0}.\#ref()</code> не является переносимым \#loc
system.getenv.call.display.name=Вызов 'System.getenv()'
system.getenv.call.problem.descriptor=Вызов <code>System.\#ref()</code> не является переносимым \#loc
system.properties.display.name=Доступ к системным свойствам
system.properties.problem.descriptor=Вызов <code>Integer.\#ref()</code> может представлять угрозу безопасности \#loc
system.properties.problem.descriptor1=Вызов <code>Boolean.\#ref()</code> может представлять угрозу безопасности \#loc
system.run.finalizers.on.exit.display.name=Вызов 'System.runFinalizersOnExit()'
system.run.finalizers.on.exit.problem.descriptor=Вызов <code>System.\#ref()</code> \#loc
system.set.problem.descriptor=Вызов <code>System.\#ref()</code> может представлять угрозу безопасности \#loc
system.set.security.manager.display.name=Вызов 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=Вызов <code>System.\#ref()</code> может представлять угрозу безопасности \#loc
tail.recursion.display.name=Хвостовая рекурсия
tail.recursion.problem.descriptor=Хвостовой рекурсивный вызов <code>\#ref()</code> \#loc
tail.recursion.replace.quickfix=Заменить хвостовую рекурсию итерацией
text.label.in.switch.statement.display.name=Текстовая метка в операторе 'switch'
text.label.in.switch.statement.problem.descriptor=Текстовая метка <code>\#ref\:</code> в {0, choice, 1\#операторе|2\#выражении} ''switch'' \#loc
the.whole.project=весь проект
this.class=этот класс
this.reference.escaped.in.construction.display.name=Утечка ссылки 'this' при конструировании объекта
this.reference.escaped.in.construction.problem.descriptor=Утечка <code>\#ref</code> во время конструирования объекта \#loc
thread.death.rethrown.display.name='ThreadDeath' не перевыброшен
thread.death.rethrown.problem.descriptor=ThreadDeath <code>\#ref</code> не перевыброшен \#loc
thread.local.not.static.final.display.name=Поле 'ThreadLocal' не объявлено как 'static final'
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>\#ref</code> не объявлен как 'static final' \#loc
thread.local.set.with.null.display.name='ThreadLocal.set()' с null в качестве аргумента
thread.local.set.with.null.problem.descriptor='ThreadLocal.set()' с null в качестве аргумента может вызвать утечку памяти
thread.local.set.with.null.quickfix=Заменить на вызов 'ThreadLocal.remove()'
thread.priority.display.name=Вызов 'Thread.setPriority()'
thread.priority.problem.descriptor=Вызов <code>Thread.\#ref()</code> \#loc
thread.run.problem.descriptor=Вызовы <code>\#ref()</code> вероятно следует заменить на 'start()' \#loc
thread.start.in.construction.display.name=Вызов 'Thread.start()' во время конструирования объекта
thread.start.in.construction.problem.descriptor=Вызов <code>\#ref()</code> во время конструирования объекта \#loc
thread.stop.suspend.resume.display.name=Вызов 'Thread.stop()', 'suspend()' или 'resume()'
thread.stop.suspend.resume.problem.descriptor=Вызов <code>Thread.\#ref()</code> \#loc
thread.with.default.run.method.display.name=Создание экземпляра 'Thread' с методом 'run()' по умолчанию
thread.with.default.run.method.problem.descriptor=Создание экземпляра <code>\#ref</code> с методом 'run()' по умолчанию \#loc
thread.yield.display.name=Вызов 'Thread.yield()'
thread.yield.problem.descriptor=Вызов <code>Thread.\#ref()</code> \#loc
three.negations.per.method.display.name=Метод с более чем тремя отрицаниями
three.negations.per.method.ignore.assert.option=Игнорировать отрицания в операторах 'assert'
three.negations.per.method.ignore.option=Игнорировать отрицания в методах 'equals()'
three.negations.per.method.problem.descriptor=<code>\#ref</code> содержит {0} отрицаний \#loc
throw,from.finally.block.everywhere.option=Предупреждать везде, где могут быть выброшены объявленные исключения
throw.caught.locally.display.name='throw' перехватывается содержащим блоком 'try'
throw.caught.locally.ignore.option=Игнорировать повторно выбрасываемые исключения
throw.caught.locally.problem.descriptor=<code>\#ref</code> перехватывается содержащим оператором 'try' \#loc
throw.from.finally.block.display.name='throw' внутри блока 'finally'
throw.from.finally.block.problem.descriptor=<code>\#ref</code> внутри блока 'finally' \#loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=Экземпляр проверяемого исключения <code>\#ref</code> не выбрасывается \#loc
throwable.instance.never.thrown.error.problem.descriptor=Экземпляр Error <code>\#ref</code> не выбрасывается \#loc
throwable.instance.never.thrown.problem.descriptor=Экземпляр Throwable <code>\#ref</code> не выбрасывается \#loc
throwable.instance.never.thrown.runtime.exception.problem.descriptor=Экземпляр RuntimeException <code>new \#ref()</code> не выбрасывается \#loc
throwable.not.thrown.display.name='Throwable' не выбрасывается
throwable.printed.to.system.out.display.name='Throwable' выводится в 'System.out'
throwable.printed.to.system.out.problem.descriptor=Аргумент ''Throwable'' <code>\#ref</code> в вызове ''System.{0}.{1}()''
throwable.printed.to.system.out.problem.fix.level.option=Метод логования для исправления\:
throwable.result.of.method.call.ignored.problem.descriptor=Результат <code>\#ref()</code> не выбрасывается \#loc
throwable.supplier.only.throw.exception.name=Поставщик Throwable никогда не возвращает значение
throwable.supplier.only.throw.exception.problem.descriptor=Поставщик Throwable не возвращает никаких исключений
throwable.supplier.only.throw.exception.quickfix=Заменить 'throw' на 'return' в лямбда-выражении
thrown.exceptions.per.method.display.name=Метод с избыточным количеством объявленных исключений
thrown.exceptions.per.method.limit.option=Предел выбрасываемых исключений\:
thrown.exceptions.per.method.problem.descriptor=<code>\#ref</code> имеет слишком много объявленных исключений (количество исключений \= {0}) \#loc
throws.runtime.exception.display.name=Непроверяемое исключение объявлено в блоке 'throws'
throws.runtime.exception.fix.family.name=Удалить из блока 'throws'
throws.runtime.exception.move.quickfix=Переместить ''{0}'' в тег Javadoc ''@throws''
throws.runtime.exception.problem.descriptor=Непроверяемое исключение <code>\#ref</code> объявлено в блоке 'throws' \#loc
throws.runtime.exception.quickfix=Удалить ''{0}'' из блока ''throws''
time.tostring.call.display.name=Вызов 'Time.toString()'
time.tostring.call.problem.descriptor=<code>Time.\#ref()</code> в интернационализованном контексте \#loc
to.array.call.style.display.name=Стиль вызова 'Collection.toArray()'
to.array.call.style.problem.descriptor.presized=Вызов <code>\#ref()</code> с предварительно размеченным массивом в качестве аргумента ''{0}'' \#loc
to.array.call.style.problem.descriptor.zero=Вызов <code>\#ref()</code> с пустым массивом в качестве аргумента ''{0}'' \#loc
to.array.call.style.quickfix.family.name=Исправить размер массива, передаваемого в вызов 'toArray()'
to.array.call.style.quickfix.make.presized=Заменить аргумент на предварительно размеченный массив
to.array.call.style.quickfix.make.zero=Заменить аргумент на пустой массив
too.broad.catch.display.name=Слишком широкий блок 'catch'
too.broad.catch.option=&Предупреждать только о RuntimeException, Exception, Error или Throwable
too.broad.catch.problem.descriptor=''catch'' для <code>\#ref</code> слишком широкий, маскирует исключение ''{0}'' \#loc
too.broad.catch.problem.descriptor1=''catch'' для <code>\#ref</code> слишком широкий, маскирует исключения ''{0}'' и ''{1}'' \#loc
too.broad.catch.quickfix=Добавить блок ''catch'' для ''{0}''
too.broad.scope.allow.option=<html>Сообщать о переменных с new-выражением в качестве инициализатора<br>(потенциально небезопасно)</html>
too.broad.scope.display.name=Слишком широкая область видимости переменной
too.broad.scope.inspection.fix.family.name=Сузить область видимости
too.broad.scope.narrow.quickfix=Переместить объявление ''{0}'' ближе к использованию
too.broad.scope.only.blocks.option=Сообщать только о переменных, которые можно переместить во внутренние блоки
too.broad.scope.problem.descriptor=Область видимости переменной <code>\#ref</code> слишком широкая \#loc
too.many.constructors.count.limit.option=Предельное количество конструкторов\:
too.many.constructors.display.name=Класс с избыточным количеством конструкторов
too.many.constructors.ignore.deprecated.option=Игнорировать устаревшие конструкторы
too.many.constructors.problem.descriptor=<code>\#ref</code> имеет слишком много конструкторов (количество конструкторов \= {0}) \#loc
too.many.fields.count.limit.option=Предельное количество полей\:
too.many.fields.display.name=Класс с избыточным количеством полей
too.many.fields.problem.descriptor=<code>\#ref</code> имеет слишком много полей (количество полей \= {0}) \#loc
too.many.methods.display.name=Класс с избыточным количеством методов
too.many.methods.problem.descriptor=<code>\#ref</code> имеет слишком много методов (количество методов \= {0}) \#loc
trace.level.option=уровень трассировки
transient.field.in.non.serializable.class.display.name=Поле transient в несериализуемом классе
transient.field.in.non.serializable.class.problem.descriptor=Поле ''{0}'' помечено как <code>\#ref</code> в несериализуемом классе \#loc
transient.field.not.initialized.display.name=Поле transient не инициализуется при десериализации
transient.field.not.initialized.problem.descriptor=Поле transient <code>\#ref</code> не инициализуется при десериализации \#loc
trivial.if.display.name=Избыточный оператор 'if'
trivial.if.fix.family.name=Упростить 'if else'
trivial.if.option.ignore.assert.statements=Игнорировать операторы 'if' с тривиальным 'assert'
trivial.if.option.ignore.chained=Игнорировать цепочки операторов 'if'
trivial.if.problem.descriptor=Оператор <code>\#ref</code> можно упростить \#loc
trivial.string.concatenation.display.name=Конкатенация с пустой строкой
trivial.string.concatenation.option.only.necessary=Сообщать только о случаях, где пустые строки можно удалить без других изменений
trivial.string.concatenation.problem.descriptor=Пустая строка в конкатенации
try.finally.can.be.try.with.resources.display.name='try finally' можно заменить на 'try-with-resources'
try.finally.can.be.try.with.resources.problem.descriptor=<code>\#ref</code> может использовать автоматическое управление ресурсами \#loc
try.finally.can.be.try.with.resources.quickfix=Заменить на 'try-with-resources'
try.statement.with.multiple.resources.name=Оператор 'try' с несколькими ресурсами можно разделить
try.statement.with.multiple.resources.quickfix=Разделить оператор 'try' с несколькими ресурсами
try.with.identical.catches.checkbox.different.comments=Не сообщать о блоках catch с разными комментариями
try.with.identical.catches.display.name=Идентичные блоки 'catch' в операторе 'try'
try.with.identical.catches.problem.descriptor=Блок ''catch'' идентичен блоку ''{0}'' \#loc
try.with.identical.catches.quickfix=Объединить блоки 'catch'
type.parameter.extends.enum.type.parameter.problem.descriptor=Параметр типа <code>\#ref</code> неявно расширяет final enum ''{0}'' \#loc
type.parameter.extends.enum.wildcard.problem.descriptor=Аргумент типа-wildcard <code>\#ref</code> неявно расширяет final enum ''{0}'' \#loc
type.parameter.extends.final.class.display.name=Параметр типа расширяет 'final' класс
type.parameter.extends.final.class.quickfix=Заменить параметр типа на фактический класс
type.parameter.extends.final.class.type.parameter.problem.descriptor=Параметр типа <code>\#ref</code> расширяет ''final'' класс ''{0}'' \#loc
type.parameter.extends.final.class.wildcard.problem.descriptor=Аргумент типа с подстановочным знаком <code>\#ref</code> расширяет ''final'' класс ''{0}'' \#loc
type.parameter.extends.object.display.name=Параметр типа явно расширяет 'Object'
type.parameter.extends.object.ignore.annotated=Игнорировать, когда java.lang.Object аннотирован
type.parameter.extends.object.problem.descriptor1=Параметр типа <code>\#ref</code> явно расширяет 'java.lang.Object' \#loc
type.parameter.extends.object.problem.descriptor2=Аргумент типа с подстановочным знаком <code>\#ref</code> явно расширяет 'java.lang.Object' \#loc
type.parameter.hides.type.parameter.problem.descriptor=Параметр типа <code>\#ref</code> скрывает параметр типа ''{0}'' \#loc
type.parameter.hides.visible.type.display.name=Параметр типа скрывает видимый тип
type.parameter.hides.visible.type.problem.descriptor=Параметр типа <code>\#ref</code> скрывает видимый тип ''{0}'' \#loc
type.parameter.naming.convention.element.description=Параметр типа
unary.plus.display.name=Унарный плюс
unary.plus.problem.descriptor=Унарный оператор <code>\#ref</code> \#loc
unary.plus.quickfix=Удалить унарный '+'
unchecked.exception.class.display.name=Непроверяемый класс 'Exception'
unchecked.exception.class.problem.descriptor=Непроверяемый класс исключения <code>\#ref</code> \#loc
unclear.binary.expression.display.name=Несколько операторов с разным приоритетом
unclear.binary.expression.problem.descriptor=Выражение может использовать уточняющие скобки \#loc
unclear.binary.expression.quickfix=Добавить уточняющие скобки
unconditional.wait.display.name=Безусловный вызов 'wait()'
unconditional.wait.problem.descriptor=Безусловный вызов <code>\#ref()</code> \#loc
unnecessarily.qualified.inner.class.access.display.name=Ненужный квалифицированный доступ к внутреннему классу
unnecessarily.qualified.inner.class.access.option=Игнорировать ссылки, для которых нужен импорт
unnecessarily.qualified.inner.class.access.problem.descriptor=''{0}'' ненужным образом квалифицирован с помощью <code>\#ref</code> \#loc
unnecessarily.qualified.inner.class.access.quickfix=Удалить квалификатор
unnecessarily.qualified.static.usage.display.name=Ненужный квалифицированный статический доступ
unnecessarily.qualified.static.usage.ignore.field.option=Игнорировать ненужные квалифицированные обращения к полям
unnecessarily.qualified.static.usage.ignore.method.option=Игнорировать ненужные квалифицированные вызовы методов
unnecessarily.qualified.static.usage.problem.descriptor=Ненужный квалифицированный вызов статического метода <code>{0}()</code> \#loc
unnecessarily.qualified.static.usage.problem.descriptor1=Ненужный квалифицированный доступ к статическому полю <code>{0}</code> \#loc
unnecessarily.qualified.statically.imported.element.display.name=Ненужный квалифицированный статически импортованный элемент
unnecessarily.qualified.statically.imported.element.problem.descriptor=Статически импортованный элемент ''{0}'' ненужным образом квалифицирован с помощью <code>\#ref</code> \#loc
unnecessarily.qualified.statically.imported.element.quickfix=Удалить ненужный квалификатор
unnecessary.block.statement.problem.descriptor=Фигурные скобки вокруг этого оператора не нужны \#loc
unnecessary.boxing.display.name=Ненужная упаковка
unnecessary.boxing.inside.value.of.problem.descriptor=Избыточная упаковка, вместо этого можно использовать вызов <code>{0}.{1}()</code> \#loc
unnecessary.boxing.problem.descriptor=Ненужная упаковка \#loc
unnecessary.boxing.remove.quickfix=Удалить упаковку
unnecessary.boxing.superfluous.option=Сообщать только о действительно избыточных упакованных выражениях
unnecessary.break.display.name=Ненужный оператор 'break'
unnecessary.break.problem.descriptor=Оператор <code>\#ref</code> не нужен \#loc
unnecessary.code.block.display.name=Ненужный блок кода
unnecessary.code.block.unwrap.quickfix=Развернуть блок
unnecessary.constant.array.creation.expression.display.name=Избыточное выражение 'new' при создании константного массива
unnecessary.constant.array.creation.expression.family.quickfix=Удалить спецификацию типа из выражения создания нового массива
unnecessary.constant.array.creation.expression.problem.descriptor=<code>\#ref</code> можно удалить из выражения создания нового массива \#loc
unnecessary.constructor.annotation.option=Игнорировать конструкторы с аннотацией
unnecessary.constructor.display.name=Избыточный конструктор без аргументов
unnecessary.constructor.problem.descriptor=Конструктор без аргументов <code>\#ref()</code> избыточен \#loc
unnecessary.constructor.remove.quickfix=Удалить избыточный конструктор
unnecessary.continue.display.name=Ненужный оператор 'continue'
unnecessary.continue.problem.descriptor=<code>\#ref</code> не нужен как последний оператор в цикле \#loc
unnecessary.conversion.to.string.display.name=Ненужное преобразование в 'String'
unnecessary.default.display.name=Ненужный 'default' для оператора 'switch' с перечислением
unnecessary.default.expressions.option=Сообщать только о выражениях switch
unnecessary.default.problem.descriptor=Ветвь <code>\#ref</code> не нужна \#loc
unnecessary.default.quickfix=Удалить ветвь 'default'
unnecessary.enum.constructor.modifier.problem.descriptor=Модификатор <code>\#ref</code> избыточен для конструкторов перечисления \#loc
unnecessary.explicit.numeric.cast.display.name=Ненужное явное числовое приведение
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' ненужным образом приведено к <code>\#ref</code> \#loc
unnecessary.explicit.numeric.cast.quickfix=Удалить приведение
unnecessary.final.on.local.variable.or.parameter.display.name=Ненужный 'final' для локальной переменной или параметра
unnecessary.final.on.local.variable.problem.descriptor=Ненужный <code>\#ref</code> для переменной ''{0}'' \#loc
unnecessary.final.on.parameter.only.interface.option=Предупреждать только для абстрактных методов или методов интерфейса
unnecessary.final.on.parameter.problem.descriptor=Ненужный <code>\#ref</code> для параметра ''{0}'' \#loc
unnecessary.final.report.local.variables.option=Сообщать о локальных переменных
unnecessary.final.report.parameters.option=Сообщать о параметрах
unnecessary.final.report.pattern.variables.option=Сообщать о переменных шаблона
unnecessary.fully.qualified.name.display.name=Ненужное полное имя
unnecessary.fully.qualified.name.fix.family.name=Заменить полное имя
unnecessary.fully.qualified.name.problem.descriptor1=Квалификатор <code>\#ref</code> не нужен и может быть заменен импортом \#loc
unnecessary.fully.qualified.name.problem.descriptor2=Квалификатор <code>\#ref</code> не нужен и может быть удален \#loc
unnecessary.fully.qualified.name.remove.quickfix=Удалить ненужную квалификацию
unnecessary.fully.qualified.name.replace.quickfix=Заменить полное имя на импорт
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>\#ref</code> недопустим для классов \#loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>\#ref</code> недопустим для конструкторов \#loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=Не найден super метод для наследования Javadoc \#loc
unnecessary.inherit.doc.display.name=Ненужный комментарий '{@inheritDoc}' в Javadoc
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>\#ref</code> недопустим для полей \#loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>\#ref</code> недопустим для объявлений модулей \#loc
unnecessary.inherit.doc.problem.descriptor=Комментарий Javadoc, содержащий только <code>\#ref</code>, не нужен \#loc
unnecessary.inherit.doc.quickfix=Удалить ненужный {@inheritDoc}
unnecessary.initcause.display.name=Ненужный вызов 'Throwable.initCause()'
unnecessary.initcause.problem.descriptor=Ненужный вызов <code>Throwable.\#ref()</code>
unnecessary.initcause.quickfix=Удалить вызов 'Throwable.initCause()'
unnecessary.inner.enum.modifier.problem.descriptor=Модификатор <code>\#ref</code> избыточен для внутренних перечислений \#loc
unnecessary.inner.interface.modifier.problem.descriptor=Модификатор <code>\#ref</code> избыточен для внутренних интерфейсов \#loc
unnecessary.inner.record.modifier.problem.descriptor=Модификатор <code>\#ref</code> избыточен для внутренних записей
unnecessary.interface.field.modifier.problem.descriptor=Модификатор <code>\#ref</code> избыточен для полей интерфейса \#loc
unnecessary.interface.inner.class.modifier.problem.descriptor=Модификатор <code>\#ref</code> избыточен для внутренних классов интерфейсов \#loc
unnecessary.interface.member.modifier.problem.descriptor=Модификатор <code>\#ref</code> избыточен для членов интерфейса \#loc
unnecessary.interface.method.modifier.problem.descriptor=Модификатор <code>\#ref</code> избыточен для методов интерфейса \#loc
unnecessary.interface.modifier.problem.descriptor=Модификатор <code>\#ref</code> избыточен для интерфейсов \#loc
unnecessary.java.doc.link.fix.family.name=Удалить избыточный тег
unnecessary.javadoc.link.display.name=Ненужная ссылка в Javadoc
unnecessary.javadoc.link.option=Игнорировать встроенные ссылки на super методы
unnecessary.javadoc.link.quickfix=Удалить ненужный ''{0}''
unnecessary.javadoc.link.super.method.problem.descriptor=<code>\#ref</code>, указывающий на super метод, не нужен \#loc
unnecessary.javadoc.link.this.class.problem.descriptor=<code>\#ref</code>, указывающий на содержащий класс, не нужен \#loc
unnecessary.javadoc.link.this.method.problem.descriptor=<code>\#ref</code>, указывающий на этот метод, не нужен \#loc
unnecessary.label.on.break.statement.display.name=Ненужная метка в операторе 'break'
unnecessary.label.on.break.statement.problem.descriptor=Лишняя метка <code>\#ref</code> в операторе break \#loc
unnecessary.label.on.continue.statement.display.name=Лишняя метка в операторе 'continue'
unnecessary.label.on.continue.statement.problem.descriptor=Лишняя метка <code>\#ref</code> в операторе continue \#loc
unnecessary.label.remove.quickfix=Удалить метку
unnecessary.local.variable.problem.descriptor=Локальная переменная <code>\#ref</code> избыточна \#loc
unnecessary.modifier.display.name=Лишний модификатор
unnecessary.parentheses.conditional.option=Игнорировать скобки вокруг условия в условных выражениях
unnecessary.parentheses.display.name=Лишние скобки
unnecessary.parentheses.option=Игнорировать поясняющие скобки
unnecessary.parentheses.problem.descriptor=Скобки вокруг <code>\#ref</code> лишние \#loc
unnecessary.parentheses.remove.quickfix=Удалить лишние скобки
unnecessary.qualifier.for.super.problem.descriptor=Квалификатор <code>\#ref</code> для 'super' лишний в данном контексте \#loc
unnecessary.qualifier.for.this.display.name=Избыточный квалификатор для 'this' или 'super'
unnecessary.qualifier.for.this.problem.descriptor=Квалификатор <code>\#ref</code> для 'this' лишний в данном контексте \#loc
unnecessary.qualifier.for.this.remove.quickfix=Удалить лишний квалификатор
unnecessary.record.modifier.problem.descriptor=Модификатор <code>\#ref</code> избыточен для records
unnecessary.return.constructor.problem.descriptor=<code>\#ref</code> лишнее как последний оператор в конструкторе \#loc
unnecessary.return.display.name=Лишний оператор 'return'
unnecessary.return.option=Игнорировать в ветке then оператора 'if' с веткой 'else'
unnecessary.return.problem.descriptor=<code>\#ref</code> лишнее как последний оператор в методе 'void' \#loc
unnecessary.semicolon.display.name=Лишняя точка с запятой
unnecessary.semicolon.ignore.after.enum.constants.option=Игнорировать лишние точки с запятой после констант перечисления
unnecessary.semicolon.problem.descriptor=Лишняя точка с запятой <code>\#ref</code> \#loc
unnecessary.semicolon.remove.quickfix=Удалить лишнюю точку с запятой
unnecessary.strictfp.modifier.problem.descriptor=Модификатор <code>\#ref</code> избыточен в Java 17 и выше
unnecessary.string.escape.display.name=Лишний экранированный символ
unnecessary.string.escape.problem.descriptor=<code>{0}</code> экранирован без необходимости
unnecessary.string.escape.quickfix=Удалить лишнее экранирование
unnecessary.super.constructor.display.name=Лишний вызов 'super()'
unnecessary.super.constructor.problem.descriptor=<code>\#ref</code> лишнее \#loc
unnecessary.super.constructor.remove.quickfix=Удалить лишний 'super()'
unnecessary.super.qualifier.display.name=Лишний квалификатор 'super'
unnecessary.super.qualifier.problem.descriptor=Квалификатор <code>\#ref</code> лишний в данном контексте \#loc
unnecessary.super.qualifier.quickfix=Удалить лишний квалификатор 'super'
unnecessary.temporary.object.fix.family.name=Заменить конкатенацию
unnecessary.temporary.on.conversion.from.string.display.name=Лишний временный объект при преобразовании из 'String'
unnecessary.temporary.on.conversion.to.string.display.name=Лишний временный объект при преобразовании в 'String'
unnecessary.this.display.name=Лишний квалификатор 'this'
unnecessary.this.ignore.assignments.option=Игнорировать присваивания полям
unnecessary.this.problem.descriptor=<code>\#ref</code> лишнее в данном контексте \#loc
unnecessary.this.remove.quickfix=Удалить лишний квалификатор 'this'
unnecessary.tostring.call.display.name=Лишний вызов 'toString()'
unnecessary.tostring.call.option.report.with.empty.string=Сообщать о вызовах, которые могут быть заменены конкатенацией с пустой строкой
unnecessary.tostring.call.problem.descriptor=Лишний вызов <code>\#ref()</code> \#loc
unnecessary.tostring.call.problem.empty.string.descriptor=Может быть заменено конкатенацией с пустой строкой
unnecessary.transient.modifier.problem.descriptor=Модификатор <code>\#ref</code> избыточен для 'static' поля
unnecessary.unary.minus.display.name=Лишний унарный минус
unnecessary.unary.minus.problem.descriptor=Лишний унарный оператор <code>\#ref</code> \#loc
unnecessary.unary.minus.quickfix=Удалить унарный минус и инвертировать знак родительской операции
unnecessary.unary.minus.remove.quickfix=Удалить двойной унарный минус
unnecessary.unboxing.display.name=Лишняя распаковка
unnecessary.unboxing.problem.descriptor=Лишняя распаковка \#loc
unnecessary.unboxing.remove.quickfix=Удалить распаковку
unnecessary.unboxing.superfluous.option=Сообщать только о действительно избыточных распакованных выражениях
unnecessary.unicode.escape.display.name=Лишняя Unicode escape-последовательность
unnecessary.unicode.escape.fix.family.name=Заменить символом
unnecessary.unicode.escape.fix.text=Заменить символом перевода строки
unnecessary.unicode.escape.problem.descriptor=Unicode escape-последовательность <code>\#ref</code> может быть заменена на ''{0}'' \#loc
unnecessary.unicode.escape.problem.newline.descriptor=Unicode escape-последовательность <code>\#ref</code> может быть заменена символом перевода строки \#loc
unpredictable.big.decimal.constructor.call.display.name=Непредсказуемый вызов конструктора 'BigDecimal'
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=Игнорировать вызовы конструктора с несколькими литералами (например, 0.1 + 0.2)
unpredictable.big.decimal.constructor.call.ignore.references.option=Игнорировать вызовы конструктора с аргументами-переменными или вызовами методов
unpredictable.big.decimal.constructor.call.problem.descriptor=Непредсказуемый вызов <code>new \#ref()</code> \#loc
unqualified,static.usage.only.report.static.usages.option=Сообщать только о статическом доступе из нестатического контекста
unqualified.field.access.display.name=Доступ к полю экземпляра без квалификатора 'this'
unqualified.field.access.problem.descriptor=Доступ к полю экземпляра <code>\#ref</code> не квалифицирован с помощью 'this' \#loc
unqualified.inner.class.access.display.name=Неквалифицированный доступ к внутреннему классу
unqualified.inner.class.access.option=Игнорировать ссылки на локальные внутренние классы
unqualified.inner.class.access.problem.descriptor=<code>\#ref</code> не квалифицирован внешним классом \#loc
unqualified.inner.class.access.quickfix=Квалифицировать внешним классом
unqualified.method.access.display.name=Вызов метода экземпляра без квалификатора 'this'
unqualified.method.access.problem.descriptor=Вызов метода экземпляра <code>\#ref()</code> не квалифицирован с помощью 'this' \#loc
unqualified.static.access.fix.family.name=Квалифицировать статический доступ
unqualified.static.usage.display.name=Неквалифицированный статический доступ
unqualified.static.usage.ignore.field.option=Игнорировать неквалифицированный доступ к полям
unqualified.static.usage.ignore.method.option=Игнорировать неквалифицированные вызовы методов
unqualified.static.usage.problem.descriptor=Неквалифицированный вызов статического метода <code>\#ref()</code> \#loc
unqualified.static.usage.problem.descriptor1=Неквалифицированный доступ к статическому полю <code>\#ref</code> \#loc
unqualified.static.usage.qualify.field.quickfix=Квалифицировать доступ к статическому полю
unqualified.static.usage.qualify.method.quickfix=Квалифицировать вызов статического метода
unrunnable.main.method.problem.descriptor=Метод <code>\#ref()</code> не может быть запущен, так как содержащий класс не имеет полного имени
unsecure.random.number.generation.display.name=Небезопасная генерация случайных чисел
unsecure.random.number.generation.problem.descriptor1=В целях безопасности используйте 'java.security.SecureRandom' вместо <code>java.lang.Math.\#ref()</code> \#loc
unsecure.random.number.generation.problem.descriptor2=В целях безопасности используйте 'java.security.SecureRandom' вместо <code>java.util.\#ref</code> \#loc
unsecure.random.number.generation.problem.descriptor3=В целях безопасности используйте 'java.security.SecureRandom' вместо <code>\#ref</code> \#loc
unused.import.problem.descriptor=Неиспользуемый import <code>\#ref</code> \#loc
unused.label.display.name=Неиспользуемая метка
unused.label.problem.descriptor=Неиспользуемая метка <code>\#ref</code> \#loc
unused.label.remove.quickfix=Удалить неиспользуемую метку
update.label=Обновить имена, начинающиеся с\:
upper.case.field.name.not.constant.display.name=Поле не-константа с именем в верхнем регистре
upper.case.field.name.not.constant.problem.descriptor=Поле не-константа <code>\#ref</code> с именем в стиле константы \#loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=Использование индекса '0' в JDBC PreparedStatement \#loc
use.0index.in.jdbc.resultset.display.name=Использование индекса 0 в JDBC ResultSet
use.0index.in.jdbc.resultset.problem.descriptor=Использование индекса '0' в JDBC ResultSet \#loc
use.contentequals=Используйте 'contentEquals()' для сравнения с 'AbstractStringBuilder'
use.equalsignorecase.for.case.insensitive.comparison=Используйте 'equalsIgnoreCase()' для сравнения без учета регистра
use.isblank.to.check.if.string.is.whitespace.or.empty=Используйте 'isBlank()' для проверки, пуста ли строка или содержит только пробельные символы
use.obsolete.collection.type.display.name=Использование устаревшего типа коллекции
use.obsolete.collection.type.ignore.library.arguments.option=Игнорировать устаревшие типы коллекций там, где они необходимы
use.obsolete.collection.type.problem.descriptor=Используется устаревший тип коллекции <code>\#ref</code> \#loc
use.of.awt.peer.class.display.name=Использование AWT peer класса
use.of.awt.peer.class.problem.descriptor=Использование AWT peer класса <code>\#ref</code> не является переносимым \#loc
use.of.clone.call.method.problem.descriptor=Реализация <code>\#ref()</code>
use.of.clone.call.problem.descriptor=Вызов <code>\#ref()</code>
use.of.clone.display.name=Использование 'clone()' или 'Cloneable'
use.of.clone.reference.problem.descriptor=Использование <code>\#ref</code>
use.of.concrete.class.option.ignore.abstract=Игнорировать абстрактные классы
use.of.concrete.class.option.ignore.records=Игнорировать Java records
use.of.concrete.class.option.report.cast=Сообщать о типе, используемом в выражении приведения
use.of.concrete.class.option.report.instance.fields=Сообщать о типе полей экземпляра
use.of.concrete.class.option.report.instanceof=Сообщать о типе, используемом в instanceof, patterns или сравнении getClass()
use.of.concrete.class.option.report.local.variable=Сообщать о типе локальной переменной
use.of.concrete.class.option.report.method.returns=Сообщать о типе возвращаемого значения метода
use.of.concrete.class.option.report.parameter=Сообщать о типе параметра метода
use.of.concrete.class.option.report.static.fields=Сообщать о типе static полей
use.of.concrete.jdbc.driver.class.display.name=Использование конкретного класса JDBC драйвера
use.of.concrete.jdbc.driver.class.problem.descriptor=Использование конкретного класса JDBC драйвера <code>\#ref</code> не является переносимым \#loc
use.of.obsolete.date.time.api.display.name=Использование устаревшего API даты-времени
use.of.obsolete.date.time.api.problem.descriptor=Используется устаревший тип даты-времени <code>\#ref</code> \#loc
use.of.properties.as.hashtable.fix.family.name=Исправить доступ к свойствам
use.processbuilder.class.display.name=Использование класса 'java.lang.ProcessBuilder'
use.processbuilder.class.problem.descriptor=Использование <code>\#ref</code> не является переносимым \#loc
use.stringtokenizer.display.name=Использование 'StringTokenizer'
use.stringtokenizer.problem.descriptor=<code>\#ref</code> в интернационализованном контексте \#loc
use.sun.classes.display.name=Использование классов 'sun.*'
use.sun.classes.problem.descriptor=Использование класса Sun <code>\#ref</code> не является переносимым \#loc
use.system.out.err.display.name=Использование 'System.out' или 'System.err'
use.system.out.err.problem.descriptor=Использование <code>\#ref</code> следует заменить на более надежное логование \#loc
use.system.out.err.problem.fix.err.option=Метод логования для 'System.err'\:
use.system.out.err.problem.fix.out.option=Метод логования для 'System.out'\:
utility.class.can.be.enum.display.name=Утилитный класс может быть 'enum'
utility.class.code.can.be.enum.problem.descriptor=Утилитный класс <code>\#ref</code> может быть 'enum' \#loc
utility.class.code.can.be.enum.quickfix=Преобразовать в 'enum'
utility.class.display.name=Утилитный класс
utility.class.problem.descriptor=Класс <code>\#ref</code> имеет только 'static' члены, что указывает на процедурную конструкцию \#loc
utility.class.with.public.constructor.display.name=Утилитный класс с 'public' конструктором
utility.class.with.public.constructor.fix.family.name=Сделать конструкторы не public
utility.class.with.public.constructor.make.private.quickfix=Сделать {0, choice, 1\#конструктор|2\#конструкторы} 'private'
utility.class.with.public.constructor.make.protected.quickfix=Сделать {0, choice, 1\#конструктор|2\#конструкторы} 'protected'
utility.class.with.public.constructor.problem.descriptor=Класс <code>\#ref</code> имеет только 'static' члены и 'public' конструктор \#loc
utility.class.without.private.constructor.cant.generate.constructor.message=Утилитный класс имеет экземпляры, private конструктор не будет создан
utility.class.without.private.constructor.create.quickfix=Сгенерировать пустой 'private' конструктор
utility.class.without.private.constructor.display.name=Утилитный класс без 'private' конструктора
utility.class.without.private.constructor.make.quickfix=Сделать конструктор 'private'
utility.class.without.private.constructor.option=Игнорировать классы только с методом main
utility.class.without.private.constructor.problem.descriptor=Класс <code>\#ref</code> имеет только 'static' члены и не имеет 'private' конструктора \#loc
value.of.post.decrement.problem.descriptor=Используется значение выражения пост-декремента <code>\#ref</code> \#loc
value.of.post.increment.problem.descriptor=Используется значение выражения пост-инкремента <code>\#ref</code> \#loc
value.of.pre.decrement.problem.descriptor=Используется значение выражения пре-декремента <code>\#ref</code> \#loc
value.of.pre.increment.problem.descriptor=Используется значение выражения пре-инкремента <code>\#ref</code> \#loc
variable.argument.method.display.name=Метод с varargs
variable.argument.method.problem.descriptor=Метод с varargs <code>\#ref()</code> \#loc
variable.argument.method.quickfix=Преобразовать varargs параметр в массив
variable.not.used.inside.conditional.problem.descriptor=<code>\#ref</code>, проверенный на 'null', не используется внутри условия \#loc
variable.not.used.inside.if.display.name=Ссылка, проверенная на 'null', не используется внутри 'if'
variable.not.used.inside.if.problem.descriptor=<code>\#ref</code>, проверенный на 'null', не используется внутри 'if' \#loc
variable.type.can.be.explicit.display.name=Тип переменной может быть явным
volatile.array.field.display.name=Поле массива с модификатором volatile
volatile.field.problem.descriptor=Поле volatile <code>\#ref</code> типа ''{0}'' \#loc
wait.called.on.condition.display.name='wait()' вызван на объекте 'java.util.concurrent.locks.Condition'
wait.called.on.condition.problem.descriptor=Вызов <code>\#ref()</code> на объекте Condition \#loc
wait.not.in.loop.display.name='wait()' не вызывается в цикле
wait.not.in.loop.problem.descriptor=Вызов <code>\#ref()</code> не в цикле \#loc
wait.notify.not.in.synchronized.context.display.name='wait()' или 'notify()' не в синхронизованном контексте
wait.notify.while.not.synchronized.on.problem.descriptor=Вызов <code>\#ref</code> без синхронизации на ''{0}'' \#loc
wait.or.await.without.timeout.display.name='wait()' или 'await()' без таймаута
wait.or.await.without.timeout.problem.descriptor=<code>\#ref</code> без таймаута \#loc
wait.while.holding.two.locks.display.name='wait()' при удержании двух блокировок
wait.while.holding.two.locks.problem.descriptor=Вызов <code>\#ref()</code> выполняется при удержании двух блокировок \#loc
wait.without.corresponding.notify.display.name='wait()' без соответствующего 'notify()'
wait.without.corresponding.notify.problem.descriptor=Вызов <code>\#ref()</code> без соответствующего <code>notify()</code> или <code>notifyAll()</code> \#loc
warn.level.and.lower.option=уровень предупреждения и ниже
warn.on.label=Предупреждать о\:
weaken.visibility.quickfix=Ослабить видимость
while.can.be.foreach.display.name=Цикл 'while' может быть заменен на расширенный цикл 'for'
while.can.be.foreach.problem.descriptor=Цикл <code>\#ref</code> может быть заменен на расширенный 'for' \#loc
while.loop.spins.on.field.display.name=Цикл 'while' спинится на поле
while.loop.spins.on.field.fix.family.name=Исправить спин-цикл
while.loop.spins.on.field.fix.spinwait=Добавить Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile=Сделать ''{0}'' volatile
while.loop.spins.on.field.fix.volatile.spinwait=Сделать ''{0}'' volatile и добавить Thread.onSpinWait()
while.loop.spins.on.field.ignore.non.empty.loops.option=Предупреждать только если цикл пустой
while.loop.spins.on.field.problem.descriptor=Цикл <code>\#ref</code> спинится на поле \#loc
wrap.with.arrays.hash.code.quickfix=Обернуть в ''{0}''
write.only.object.display.name=Объект только для записи
write.only.object.option.ignore.impure.constructors=Игнорировать нечистые конструкторы