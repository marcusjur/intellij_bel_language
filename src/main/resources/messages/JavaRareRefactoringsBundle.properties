action.Generify.description=Преобразовать код для использования generic типов
action.Generify.text=Преобразовать сырые типы в generic…
action.RemoveMiddleman.description=Встроить делегирование для выбранных методов поля
action.RemoveMiddleman.text=Удалить посредника [_M]…
action.ReplaceTempWithQuery.description=Преобразовать выбранную переменную в метод
action.ReplaceTempWithQuery.text=Заменить временную переменную на запрос [_Q]…
action.WrapReturnValue.description=Обернуть возвращаемое значение указанного метода в объект
action.WrapReturnValue.text=Обернуть возвращаемое значение метода [_P]…
cannot.replace.temp.with.query.in.interface=Нельзя заменить временную переменную на запрос в интерфейсе
constructor.returns.can.not.be.wrapped=Возвращаемые значения конструктора не могут быть обернуты
could.not.find.selected.wrapping.class=Не удалось найти выбранный класс-обертку
declaration.s.to.be.generified=Объявления для преобразования в generic {0}
delegating.field=Делегирующее поле
dialog.message.inner.class.with.name.already.exist=Внутренний класс с именем ''{0}'' уже существует
dialog.message.invalid.inner.class.name=''{0}'' - недопустимое имя внутреннего класса
dialog.message.invalid.qualified.wrapper.class.name=''{0}'' - недопустимое полное имя класса-обертки
dialog.message.invalid.wrapper.class.name=''{0}'' - недопустимое имя класса-обертки
dialog.message.invalid.wrapper.class.package.name=''{0}'' - недопустимое имя пакета класса-обертки
dialog.message.wrapper.field.not.found=Поле обертки не найдено
error.wrong.caret.position.local.name=Курсор должен находиться на имени локальной переменной для рефакторинга
exposed.delegation.command.name=Делегирование раскрыто для {0}
field.selected.is.not.used.as.a.delegate=Выбранное поле не используется как делегат
generify.title=Преобразовать сырые типы в generic
method.selected.returns.void=Выбранный метод возвращает 'void'
method.to.wrap.returns.from.label=Метод, возвращаемое значение которого нужно обернуть\:
method.whose.return.are.to.wrapped=Метод, возвращаемое значение которого нужно обернуть
references.to.be.modified.usage.view=Ссылки для изменения{0, choice, 0\#(не найдено)|1\#{0} ссылка|2\#{0} ссылки|3\#{0} ссылок}{1, choice, 0\#|1\# в {1} файле|2\# в {1} файлах}
references.to.expose.usage.view=Ссылки для раскрытия{0, choice, 0\#(не найдено)|1\#{0} ссылка|2\#{0} ссылки|3\#{0} ссылок}{1, choice, 0\#|1\# в {1} файле|2\# в {1} файлах}
remove.middleman=Удалить посредника
remove.middleman.column.header=Удалить
remove.middleman.deleted.hierarchy.conflict={0} будет удален. Иерархия будет нарушена
remove.middleman.field.header=Удалить поле-посредник\:
remove.middleman.methods.to.inline.title=Методы для встраивания [&M]
remove.middleman.title=Удалить посредника
remove.middleman.tooltip.warning=Удаление нарушит иерархию типов
replace.temp.with.query.title=Заменить временную переменную на запрос
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored=Курсор должен находиться на имени поля для рефакторинга
there.already.exists.a.class.with.the.selected.name=Класс с выбранным именем уже существует
type.cook.command=Преобразование в generic
type.cook.drop.obsolete.casts=Удалить устаревшие приведения типов [&D]
type.cook.elements.header=Область действия преобразования в generic
type.cook.generify.objects=Преобразовать объекты в generic [&O]
type.cook.leave.object.parameterized.types.raw=Оставить параметризованные типы объектов сырыми [&L]
type.cook.perform.exhaustive.search=Выполнить полный поиск [&E]
type.cook.preserve.raw.arrays=Сохранить сырые массивы [&A]
type.cook.produce.wildcard.types=Создавать wildcard типы [&W]
type.cook.ratio.generified={0,choice,-1\#не вычислено|0\#{0,number}/{1}}
type.cook.report=Преобразовано элементов\: {0}, удалено приведений типов\: {1}
wrap.return.value=Обернуть возвращаемое значение
wrap.return.value.title=Обернуть возвращаемое значение
wrapped.return.command.name=Обернуть возвращаемое значение {0} для {1}()