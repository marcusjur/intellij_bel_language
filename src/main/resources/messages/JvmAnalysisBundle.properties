action.find.similar.stack.call.methods.not.found=Похожие классы не найдены
advanced.setting.process.console.output.to.find.class.names=Обрабатывать вывод терминала для поиска и подсветки имен классов
allow.suppressions.fix.family.name=Разрешить подавления
allow.suppressions.fix.text=Разрешить эти подавления
assertequals.between.inconvertible.types.display.name='assertEquals()' между объектами несовместимых типов
can.t.build.uast.tree.for.file=Невозможно построить дерево UAST для файла
checkbox.comments.and.javadoc.count.as.content=Считать комментарии и javadoc содержимым
current.version=Текущая версия\:
dialog.title.choose.annotation=Выберите {0}
group.advanced.settings.jvm=Языки JVM
ignored.suppressions=Игнорируемые подавления\:
inspection.empty.method.delete.quickfix=Удалить ненужные методы
inspection.empty.method.display.name=Пустой метод
inspection.empty.method.problem.descriptor=Метод только вызывает свой super
inspection.empty.method.problem.descriptor1=Пустой метод переопределяет пустой метод
inspection.empty.method.problem.descriptor2=Метод пуст
inspection.empty.method.problem.descriptor3=Метод и все его производные пусты
inspection.empty.method.problem.descriptor4=Все реализации этого метода пусты
inspection.message.illegal.dependency.module.doesn.t.export=Недопустимая зависимость\: модуль ''{0}'' не экспортует пакет ''{1}''
inspection.suppression.annotation.display.name=Аннотация подавления проверки
inspection.suppression.annotation.problem.descriptor=Аннотация подавляет {0} \#loc
inspection.suppression.comment.problem.descriptor=Комментарий подавляет {0} \#loc
jvm.class.filter.choose.calls=Похожие вызовы логования\:
jvm.inspection.log.guarded.display.name=Вызовы логования защищены условием логования
jvm.inspection.log.guarded.fix.family.name=Развернуть условие защиты логования
jvm.inspection.log.guarded.problem.descriptor=Вызов логования защищен условием логования \#loc
jvm.inspection.log.guarded.warn.if.fix.possible=Предупреждать только если доступно исправление
jvm.inspection.log.statement.not.guarded.all.levels.option=всех уровнях логования
jvm.inspection.log.statement.not.guarded.debug.level.and.lower.option=уровне debug и ниже
jvm.inspection.log.statement.not.guarded.display.name=Вызов логования не защищен условием логования
jvm.inspection.log.statement.not.guarded.info.level.and.lower.option=уровне info и ниже
jvm.inspection.log.statement.not.guarded.log.fix.family.name=Обернуть условием логования
jvm.inspection.log.statement.not.guarded.log.problem.descriptor=Вызов логования не защищен условием логования \#loc
jvm.inspection.log.statement.not.guarded.trace.level.option=уровне trace
jvm.inspection.log.statement.not.guarded.unguarded.constant.option=Обрабатывать незащищенные вызовы логования с константными сообщениями
jvm.inspection.log.statement.not.guarded.unguarded.constant.option.comment=Обрабатывать все незащищенные вызовы логования, а не только те, что имеют неконстантные аргументы
jvm.inspection.log.statement.not.guarded.warn.level.and.lower.option=уровне warn и ниже
jvm.inspection.log.statement.not.guarded.warn.on.label=Предупреждать о\:
jvm.inspection.logging.condition.disagrees.with.log.statement.display.name=Условие логования не соответствует вызову логования
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.family.name=Изменить уровень логования
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.name=Изменить уровень {0, choice, 0\#условия|1\#вызова}
jvm.inspection.logging.condition.disagrees.with.log.statement.problem.descriptor=Уровень условия ''{0}'' не соответствует уровню вызова логования ''{1}''
jvm.inspection.logging.placeholder.count.matches.argument.count.display.name=Количество плейсхолдеров не соответствует количеству аргументов в вызове логования
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.descriptor=Предоставлено меньше аргументов ({0}), чем указано плейсхолдеров ({1}) \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.partial.descriptor=Предоставлено меньше аргументов ({0}), чем указано плейсхолдеров (минимум {1}) \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.incorrect.problem.descriptor=Недопустимый спецификатор строки формата \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.more.problem.descriptor=Предоставлено больше аргументов ({0}), чем указано плейсхолдеров ({1}) \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option=SLF4J использует Log4j 2 как реализацию
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.auto=Проверять автоматически
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.no=Нет
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.yes=Да
jvm.inspection.logging.similar.message.display.name=Неразличимые вызовы логования
jvm.inspection.logging.similar.message.problem.descriptor=Похожие сообщения лога
jvm.inspection.logging.similar.message.problem.min.similar.length=Минимальная длина похожей последовательности
jvm.inspection.logging.similar.message.problem.skip.on.error=Не сообщать о вызовах с уровнем логования `error`
jvm.inspection.logging.string.template.as.argument.all.levels.option=всех уровнях логования
jvm.inspection.logging.string.template.as.argument.debug.level.and.lower.option=уровне debug и ниже
jvm.inspection.logging.string.template.as.argument.display.name=Строковый шаблон как аргумент вызова логования
jvm.inspection.logging.string.template.as.argument.info.level.and.lower.option=уровне info и ниже
jvm.inspection.logging.string.template.as.argument.problem.descriptor=Строковый шаблон как аргумент вызова логования <code>\#ref()</code> \#loc
jvm.inspection.logging.string.template.as.argument.quickfix.name=Заменить на плейсхолдеры
jvm.inspection.logging.string.template.as.argument.skip.on.only.exception=Не предупреждать, когда вызов только с исключением как аргументом после аргумента сообщения.
jvm.inspection.logging.string.template.as.argument.skip.on.primitives=Не предупреждать, когда включены только выражения с примитивными типами, их обертками или String
jvm.inspection.logging.string.template.as.argument.trace.level.option=уровне trace
jvm.inspection.logging.string.template.as.argument.warn.level.and.lower.option=уровне warn и ниже
jvm.inspection.logging.string.template.as.argument.warn.on.label=Предупреждать о\:
jvm.inspection.test.failed.line.display.name=Неудачная строка в тесте
jvm.inspections.1.5.problem.descriptor=Использование API, документированного как @since {0}+
jvm.inspections.1.7.problem.descriptor=Использование обобщенного после 1.6 API, которое может вызвать проблемы компиляции с JDK {0}
jvm.inspections.1.8.problem.descriptor=Дефолтный {0, choice, 0\#|1\#метод|2\#методы} не переопределен. Это вызовет проблемы компиляции с JDK {1}
jvm.inspections.1.8.problem.single.descriptor=Дефолтный метод ''{0}'' не переопределен. Это вызовет проблемы компиляции с JDK {1}
jvm.inspections.api.display.name=Использование API, недоступного на настроенном уровне языка
jvm.inspections.api.no.extension.class.description=Класс ''{0}'' не должен быть расширен
jvm.inspections.api.no.extension.display.name=Класс, интерфейс или метод не должен быть расширен
jvm.inspections.api.no.extension.interface.extend.description=Интерфейс ''{0}'' не должен быть расширен
jvm.inspections.api.no.extension.interface.implement.description=Интерфейс ''{0}'' не должен быть реализован
jvm.inspections.api.no.extension.method.overriding.description=Метод ''{0}'' не должен быть переопределен
jvm.inspections.api.override.only.description=Метод ''{0}'' может быть только переопределен
jvm.inspections.api.override.only.display.name=Метод может быть только переопределен
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>\#ref()</code> между объектами несовместимых типов ''{0}'' и ''{1}'' \#loc
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=Возможно избыточное утверждение\: сравниваются несовместимые типы ''{0}'' и ''{1}''
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=Избыточное утверждение\: сравниваются несовместимые типы ''{0}'' и ''{1}''
jvm.inspections.blocking.method.annotation.blocking=Блокирующие аннотации\:
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Добавить блокирующую аннотацию
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Добавить неблокирующую аннотацию
jvm.inspections.blocking.method.annotation.non-blocking=Неблокирующие аннотации\:
jvm.inspections.blocking.method.consider.suspend.context.non.blocking=Считать контекст Kotlin suspend неблокирующим
jvm.inspections.blocking.method.consider.unknown.context.blocking=Считать неизвестные контексты блокирующими
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=Считать неизвестные контексты неблокирующими
jvm.inspections.blocking.method.display.name=Возможно блокирующий вызов в неблокирующем контексте
jvm.inspections.blocking.method.in.implicit.ctr.problem.descriptor=Возможно блокирующий вызов из неявного вызова конструктора в неблокирующем контексте может привести к истощению потоков
jvm.inspections.blocking.method.in.implicit.ctr.problem.wildcard.descriptor=Возможно блокирующий вызов из неявного вызова конструктора в {0} может привести к истощению потоков
jvm.inspections.blocking.method.intention.text=Включает опцию проверки ''{0}''.
jvm.inspections.blocking.method.problem.descriptor=Возможно блокирующий вызов в неблокирующем контексте может привести к истощению потоков
jvm.inspections.blocking.method.problem.wildcard.descriptor=Возможно блокирующий вызов в {0} может привести к истощению потоков
jvm.inspections.collection.contains.url.problem.descriptor=''{0}'' может содержать объекты URL \#loc
jvm.inspections.dependency.display.name=Недопустимые зависимости пакетов
jvm.inspections.dependency.edit.rules.family=Редактировать правила зависимостей
jvm.inspections.dependency.edit.rules.text=Редактировать правило зависимости "{0}"
jvm.inspections.dependency.intention.description=Открывает диалог для настройки правил зависимостей между областями видимости.
jvm.inspections.dependency.on.internal.display.name=Недопустимая зависимость от внутреннего пакета
jvm.inspections.dependency.violator.problem.descriptor=Нарушено правило зависимости ''{0}.''
jvm.inspections.equals.hashcode.called.on.url.display.name=Вызов 'equals()' или 'hashCode()' на объекте 'URL'
jvm.inspections.equals.hashcode.called.on.url.problem.descriptor=Вызов ''{0}'' на объекте URL
jvm.inspections.group.name=Языки JVM
jvm.inspections.logging.frameworks.group.name=Логирование
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=API, запланованный к удалению, должен быть также помечен аннотацией '@Deprecated'
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Отсутствует аннотация '@Deprecated' на API, запланованном к удалению
jvm.inspections.must.already.be.removed.api.current.version.description=API должен быть удален в текущей версии {0}
jvm.inspections.must.already.be.removed.api.display.name=API должен быть уже удален
jvm.inspections.must.already.be.removed.api.earlier.version.description=API должен был быть удален в версии {0}, но текущая версия {1}
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' объявлен в {1} ''{2}'', запланованном к удалению в {3}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' запланован к удалению в {1}
jvm.inspections.scheduled.for.removal.future.version=будущей версии
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=Переопределённый метод ''{0}'' объявлен в {1} ''{2}'', запланованном к удалению в {3}
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=Переопределённый метод ''{0}'' запланован к удалению в {1}
jvm.inspections.scheduled.for.removal.predefined.version=версии {0}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' запланован к удалению, так как его сигнатура ссылается на {1} ''{2}'', запланованный к удалению в {3}
jvm.inspections.serializable.class.without.serialversionuid.display.name=Сериализуемый класс без 'serialVersionUID'
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>\#ref</code> не определяет поле 'serialVersionUID' \#loc
jvm.inspections.source.to.sink.flow.assigned.unknown=Неизвестная строка присваивается безопасной переменной
jvm.inspections.source.to.sink.flow.assigned.unsafe=Небезопасная строка присваивается безопасной переменной
jvm.inspections.source.to.sink.flow.common.unknown=Неизвестная строка используется в безопасном контексте
jvm.inspections.source.to.sink.flow.common.unsafe=Небезопасная строка используется в безопасном контексте
jvm.inspections.source.to.sink.flow.display.name=Небезопасная строка передается в безопасный метод
jvm.inspections.source.to.sink.flow.passed.unknown=Неизвестная строка используется как безопасный параметр
jvm.inspections.source.to.sink.flow.passed.unsafe=Небезопасная строка используется как безопасный параметр
jvm.inspections.source.to.sink.flow.returned.unknown=Неизвестная строка возвращается из безопасного метода
jvm.inspections.source.to.sink.flow.returned.unsafe=Небезопасная строка возвращается из безопасного метода
jvm.inspections.source.to.sink.flow.too.complex=Слишком сложно проверить безопасность строки в безопасном контексте
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods=Считать параметры private методов безопасными
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods.comment=Если включено, то параметры private методов считаются безопасными, иначе они будут считаться неизвестными
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex=Сообщать, если случай слишком сложен для проверки
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex.comment=Сообщать об объектах, которые невозможно проверить из-за их сложности
jvm.inspections.source.unsafe.to.sink.flow.checked.types=Проверяемые типы\:
jvm.inspections.source.unsafe.to.sink.flow.config=Аннотация Untainted будет добавлена в настройки проверки для элемента ''{0}''
jvm.inspections.source.unsafe.to.sink.flow.depth.inside=Глубина анализа внутри метода\:
jvm.inspections.source.unsafe.to.sink.flow.impossible=Аннотация Untainted не поддерживается для элемента ''{0}''. Элемент будет пропущен
jvm.inspections.source.unsafe.to.sink.flow.index.parameter=Индекс параметра
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=Отметить как требующее валидации
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=Отметить как требующее валидации
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=Отметить элементы как требующие валидации
jvm.inspections.source.unsafe.to.sink.flow.not.number=Не число
jvm.inspections.source.unsafe.to.sink.flow.place.class.column.title=Имя класса контекста
jvm.inspections.source.unsafe.to.sink.flow.place.method.column.title=Регулярное выражение имени метода контекста
jvm.inspections.source.unsafe.to.sink.flow.preview=Добавить аннотацию '@Untainted'
jvm.inspections.source.unsafe.to.sink.flow.preview.propagate=Показать дерево распространения
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=Дерево распространения
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=Открывает окно инструмента для проверки распространения безопасной аннотации
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=Показать дерево распространения отсюда
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=Аннотировать все кроме исключенных
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=Небезопасные члены
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=Небезопасный поток
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.arguments=Аргументы
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.classes=Классы
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.comment=Эти методы помечают квалификаторы как 'untainted' (Аргументы должны разделяться запятыми)
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.methods=Методы
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.table=Методы для очистки квалификаторов\:
jvm.inspections.source.unsafe.to.sink.flow.safe.class=Безопасные классы\:
jvm.inspections.source.unsafe.to.sink.flow.safe.class.comment=Эти классы не могут содержать небезопасные данные
jvm.inspections.source.unsafe.to.sink.flow.show.unknown.object=Сообщать о неизвестном объекте
jvm.inspections.source.unsafe.to.sink.flow.show.unsafe.object=Сообщать о небезопасном объекте
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations=Помеченные аннотации\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations.comment=Эти аннотации будут использоваться как аннотации '@Tainted' во время анализа
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods=Помеченные методы\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods.comment=Считается, что эти методы возвращают только небезопасные объекты
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters=Помеченные параметры\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters.comment=Эти параметры считаются имеющими аннотацию '@Tainted'
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations=Непомеченные аннотации\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations.comment=Эти аннотации будут использоваться как аннотации '@Untainted' во время анализа. Первая аннотация из этого списка будет использована для распространения, если она существует в classpath.
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields=Непомеченные поля\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.comment=Считается, что эти поля содержат только безопасные объекты
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.name=Имя поля
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods=Непомеченные методы\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods.comment=Считается, что эти методы возвращают только безопасные объекты
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters=Непомеченные параметры\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters.comment=Эти параметры считаются имеющими аннотацию '@Untainted'
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments=Считать внешние методы непомеченными, если получатели и аргументы непомечены
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments.comment=Если включено, то внешние методы вне текущего класса будут считаться безопасными, если их получатели и аргументы безопасны. В некоторых случаях это неприменимо, но может быть полезно для stateless-классов. В противном случае все внешние методы будут считаться небезопасными
jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code>String.{0}()</code> вызван без указания Locale при использовании интернационализованных строк \#loc
jvm.inspections.system.get.property.display.name=Вызов 'System.getProperty(str)' можно упростить
jvm.inspections.system.get.property.problem.descriptor=Вызов <code>\#ref</code> можно упростить для ''{0}''
jvm.inspections.test.case.in.product.source.display.name=Тест в production-исходниках
jvm.inspections.test.case.in.product.source.problem.descriptor=Тестовый случай <code>\#ref</code> должен быть размещен в дереве тестовых исходников \#loc
jvm.inspections.test.case.with.constructor.display.name=TestCase с нетривиальными конструкторами
jvm.inspections.test.case.with.constructor.problem.descriptor=Логика инициализации в конструкторе <code>\#ref()</code> вместо метода жизненного цикла 'setup()' \#loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=Логика инициализации в инициализаторе вместо метода жизненного цикла 'setup()'
jvm.inspections.test.case.without.test.methods.display.name=Тестовый класс без тестов
jvm.inspections.test.case.without.test.methods.option=Игнорировать тестовые случаи с суперклассами, содержащими тестовые методы
jvm.inspections.test.case.without.test.methods.problem.descriptor=Тестовый класс <code>\#ref</code> не содержит тестов \#loc
jvm.inspections.test.frameworks.group.name=Тестовые фреймворки
jvm.inspections.test.method.in.product.source.problem.descriptor=Тестовый метод <code>\#ref()</code> должен быть размещен в дереве тестовых исходников \#loc
jvm.inspections.test.method.without.assertion.display.name=Тестовый метод без assertions
jvm.inspections.test.method.without.assertion.problem.descriptor=Тестовый метод <code>\#ref()</code> не содержит assertions \#loc
jvm.inspections.testonly.class.reference=Класс только для тестов используется в production-коде
jvm.inspections.testonly.display.name=Использование test-only кода в production-коде
jvm.inspections.testonly.field.reference=Поле только для тестов используется в production-коде
jvm.inspections.testonly.method.call=Метод только для тестов вызывается в production-коде
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting имеет мало смысла для кода с @TestOnly
jvm.inspections.thread.run.display.name=Вызов 'Thread.run()'
jvm.inspections.unstable.api.usage.annotations.list=Аннотации нестабильного API\:
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' объявлен в нестабильном {1} ''{2}'', помеченном с помощью @{3}
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' помечен как нестабильный с помощью @{1}
jvm.inspections.unstable.api.usage.display.name=Использование нестабильного API
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=Игнорировать API, объявленный в этом проекте
jvm.inspections.unstable.api.usage.ignore.inside.imports=Игнорировать внутри импортов
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=Переопределённый метод ''{0}'' объявлен в нестабильном {1} ''{2}'', помеченном с помощью @{3}
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=Переопределённый метод ''{0}'' помечен как нестабильный с помощью @{1}
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' нестабилен, так как его сигнатура ссылается на нестабильный {1} ''{2}'', помеченный с помощью @{3}
jvm.inspections.unstable.type.used.in.class.signature.description=Класс должен быть помечен аннотацией ''@{0}'', так как его объявление ссылается на нестабильный тип ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=Поле должно быть помечено аннотацией ''@{0}'', так как его тип ссылается на нестабильный тип ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=Метод должен быть помечен аннотацией ''@{0}'', так как его сигнатура ссылается на нестабильный тип ''{1}''
jvm.inspections.unstable.type.used.in.signature.display.name=В сигнатуре используется нестабильный тип
jvm.inspections.usages.of.obsolete.api.description=Используется устаревший API
jvm.inspections.usages.of.obsolete.api.display.name=Использование ApiStatus.@Obsolete
jvm.options.general.color.descriptor.logging.string.placeholder=Строка лога//Плейсхолдер
propagated.from=Причина распространения\:
propagated.to=Цель распространения\:
remove.suppress.comment.fix.family.name=Удалить //{0}
title.uast=UAST