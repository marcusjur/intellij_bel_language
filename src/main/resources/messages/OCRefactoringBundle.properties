0.was.not.initialized={0} не инициализован
button.cancel=Отмена [&C]
button.extract=Извлечь
button.inline=Встроить [&I]
button.inline.all.usages.file=Встроить все использования{0, choice, 0\# в файле|1\#} [&A]
button.inline.current.usage=Встроить текущее использование [&U]
button.rename=Переименовать [&R]
button.rename.all=Переименовать все использования [&R]
button.rename.code=Переименовать только использования в коде [&C]
button.view.usages=Показать использования [&S]
can.t.extract.type.of.0.definition=Невозможно извлечь тип определения {0}
can.t.inline.definition=Невозможно встроить определение {0}
can.t.introduce.parameter.to.a.function.with.default.parameter.values=Невозможно добавить параметр в функцию со значениями параметров по умолчанию
can.t.refactor.the.compound.initializer=Невозможно рефакторить составной инициализатор
cannot.determine.type.of.the.selected.expression=Невозможно определить тип выбранного выражения
cannot.find.the.method.function=Не удаётся найти метод/функцию
cannot.inline.constructor.expression=Невозможно встроить выражение конструктора
cannot.inline.function.reference.in.non.call.expression=Невозможно встроить ссылку на функцию в невызывающем выражении
cannot.inline.function.type=Невозможно встроить тип функции
cannot.inline.method.reference.in.property.attribute=Невозможно встроить ссылку на метод в атрибуте свойства
cannot.inline.method.reference.in.selector.expression=Невозможно встроить ссылку на метод в выражении '@selector'
cannot.inline.method.reference.in.xml.file=Невозможно встроить ссылку на метод в XML-файле
cannot.inline.recursive=Невозможно встроить рекурсивный вызов {0}
cannot.inline.the.macro.inside.another.macro.definition=Невозможно встроить макрос внутри другого определения макроса
cannot.inline.usage.in.swift.code=Невозможно встроить использование в код Swift
cannot.inline.usages.inside.the.macro.substitutions=Невозможно встроить использования внутри подстановок макроса
cannot.perform.refactoring.selected.expression.has.void.type=Невозможно выполнить рефакторинг, так как выбранное выражение имеет тип void.
declaration.must.have.one.declarator.to.introduce.the.type=Объявление должно иметь один декларатор для введения типа
dialog.message.accessed.for.address={0} используется для получения адреса
dialog.message.accessed.for.writing={0} доступен для записи
dialog.message.can.t.copy.to.itself=Невозможно скопировать ''{0}'' в себя
dialog.message.can.t.move.to.itself=Невозможно переместить ''{0}'' в себя
dialog.message.can.t.refactor.with.variable.arguments=Невозможно рефакторить {0} с переменным числом аргументов
dialog.message.cannot.extract.there.are.multiple.exit.points.in.selected.code.fragment=Невозможно извлечь {0}.\nВ выбранном фрагменте кода несколько точек выхода.
dialog.message.cannot.find.method.function=Не удаётся найти метод/функцию
dialog.message.cannot.inline.blocks=Невозможно встроить блоки
dialog.message.cannot.inline.methods.with.return.statements.interrupting.execution.flow=Невозможно встроить методы с операторами return, прерывающими поток выполнения
dialog.message.cannot.inline.parameters.blocks=Невозможно встроить параметры блоков
dialog.message.cannot.inline.parameters.lambdas=Невозможно встроить параметры лямбд
dialog.message.cannot.inline.protocol.method=Невозможно встроить метод протокола
dialog.message.cannot.inline.with.empty.body=Невозможно встроить {0} с пустым телом
dialog.message.cant.refactor.operators=Невозможно рефакторить операторные функции C++
dialog.message.containing.class.invalid=Содержащий класс "{0}" недопустим
dialog.message.containing.class.outside.project=Содержащий класс "{0}" находится вне проекта
dialog.message.directory.already.exists.at=Директория уже существует в ''{0}''
dialog.message.do.you.want.to.proceed.refactoring=Продолжить рефакторинг?
dialog.message.do.you.want.to.refactor.base.s=Рефакторить базовый {0}?
dialog.message.elements.to=элементы для {0}
dialog.message.file.already.exists=Файл уже существует
dialog.message.file.already.exists.at=Файл уже существует в ''{0}''
dialog.message.interface.was.not.implemented=Интерфейс {0} не реализован
dialog.message.lambdas.cant.extract.dependent.types=Невозможно извлечь выражения с зависимыми типами в параметр лямбды
dialog.message.lambdas.cant.extract.functional.type=Невозможно извлечь выражения функционального типа в параметр лямбды
dialog.message.lambdas.cant.extract.initializer.list=Невозможно извлечь список инициализаторов в параметр лямбды
dialog.message.lambdas.not.supported=Лямбды не поддерживаются текущим стандартом языка
dialog.message.must.have.initializer={0} должен иметь инициализатор
dialog.message.name.invalid=Недопустимое имя для {0}
dialog.message.no.inheritors.are.selected=Наследники не выбраны
dialog.message.no.selector.parts.for=Нет частей селектора для {0}
dialog.message.overrides.in.choice.which.out.project={0} переопределяет {1} в {2}{3, choice, 0\#, который находится вне проекта|1\#}.
dialog.message.paramer.default.value.invalid=''{0}'' не является выражением
dialog.message.parameter.name.invalid=Имя параметра ''{0}'' недопустимо
dialog.message.return.type.invalid=Недопустимый тип возвращаемого значения для {0}
dialog.message.selected.statements.should.be.inside.function.choice.or.method=Выбранные операторы должны находиться внутри функции{0, choice, 0\# или метода|1\#}
dialog.message.selector.part.invalid=Часть селектора ''{0}'' недопустима
dialog.message.several.call.sites.with.different.parameter.initializers=Существует несколько точек вызова с разными инициализаторами параметров
dialog.message.there.are.no.calls.in.project=В проекте нету вызовов {0}
dialog.message.there.are.no.usages=Нету использований {0}
dialog.message.variable.must.be.const=Переменная "{0}" должна быть константой
dialog.title.choose.containing.class=Выберите содержащий класс
dialog.title.extract.block.parameter=Извлечь параметр блока
dialog.title.extract.function=Извлечь функцию
dialog.title.extract.lambda.parameter=Извлечь параметр лямбды
dialog.title.extract.method=Извлечь метод
dialog.title.inline=Встроить {0}
element.has.inheritor={0} имеет наследуемые {1, choice, 0\#методы|1\#функции}
element.inherits.method={0} наследует метод из {1}
element.is.accessed.for.writing={0} доступен для записи
element.is.written.in.the.block={0} записывается в блоке
escalate.visibility.current.visibility.column=Текущая видимость
escalate.visibility.member.column=Член
escalate.visibility.required.visibility.column=Требуемая видимость
extract.dialog.button.extract=Извлечь [&R]
extract.invalid.name.for.class.type.error=Недопустимое имя для {0}
file.0.already.exists.in.the.project=Файл ''{0}'' уже существует в проекте
label.declaration.place=Место объявления\:
message.never.used={0} никогда не используется
namespace.qualifier.should.be.resolved.to.the.class=Квалификатор пространства имён должен разрешаться в класс
progress.title.inplace.rename.appending.additional.elements=Добавление дополнительных элементов
progress.title.inplace.rename.preparing=Подготовка переименования
property.inplace.introducer.label.semantics=Семантика
push.down.inheritor.column=Наследник
question.inline.usage=Встроить {0} использовани{1, choice, 0\#е|1\#я} {2}?
refactoring.change.signature.target.symbols.panel=Цели\:
refactoring.extract.category.title=Извлечь категорию
refactoring.extract.subclass.title=Извлечь подкласс
refactoring.extract.super.protocol.title=Извлечь суперпротокол
refactoring.introduce.block.expression.represent.error=Выбранный блок должен представлять {0}
refactoring.introduce.constant.auto.declaration=Объявить auto [&A]
refactoring.introduce.constant.constexpr.declaration=Объявить constexpr [&C]
refactoring.introduce.constant.name=Создать константу
refactoring.introduce.constant.static.declaration=Объявить static [&S]
refactoring.introduce.define.name=Создать Define
refactoring.introduce.expressions.choose.dialog.title=Выражения
refactoring.introduce.instance.variable.name=Создать переменную экземпляра
refactoring.introduce.ivar.name=Создать Ivar
refactoring.introduce.parameter.name=Создать параметр
refactoring.introduce.property.name=Создать свойство
refactoring.introduce.put.to.header=Поместить в заголовок [&H]
refactoring.introduce.typedef.name=Создать Typedef
refactoring.introduce.variable.name=Создать переменную
refactoring.introducer.declare.auto=Объявить auto [&A]
refactoring.introducer.declare.const=Объявить const [&C]
refactoring.ivar.inplace.introducer.declare.interface=Объявить в интерфейсе [&I]
refactoring.ivar.inplace.introducer.generate.property=Создать свойство [&P]
refactoring.move.cant.find.symbol=Не удаётся найти символ для выбранного класса
refactoring.move.caret.position=Курсор должен находиться внутри класса
refactoring.move.escalate.visibility.declare.in.interface=объявить в интерфейсе
refactoring.move.file.has.no.members=В файле "{0}" нет элементов для перемещения
refactoring.move.members.error.class.name.invalid=Недопустимое имя класса
refactoring.move.members.error.no.target.class.selected=Не выбран целевой класс
refactoring.move.members.error.not.in.project.sources={0} не находится внутри проекта
refactoring.move.members.error.the.same.source.and.target=Исходный и целевой классы должны различаться
refactoring.move.members.message.target.does.not.exist=Целевой класс "{0}" еще не существует.
refactoring.move.members.ok.button.text=Переместить [&M]
refactoring.move.namespace.has.no.members=В пространстве имён "{0}" нет элементов для перемещения
refactoring.move.no.members.are.selected.error=Не выбраны элементы
refactoring.move.pull.up.ok.button.text=Pull [&U]
refactoring.move.push.down.ok.button.text=Push [&U]
refactoring.parameter.introducer.refactor.super.method=Рефакторинг super {0} [&S]
refactoring.property.introducer.generate.instance.variable=Создать переменную экземпляра [&I]
refactoring.property.introducer.generate.synthesize=Создать @synthesize [&S]
refactoring.property.introducer.make.readonly=Сделать readonly [&R]
refactoring.property.introducer.put.to.private.category=Поместить в приватную категорию [&P]
refactoring.rename=Переименовать {0} [&R]
refactoring.rename.0.already.exists.in.1={0} уже существует в {1}
refactoring.rename.0.already.exists.in.the.scope={0} уже существует в области видимости
refactoring.rename.associated.file=Переименовать связанный файл
refactoring.rename.class.aliases=Переименовать псевдонимы класса [&R]
refactoring.rename.command.name=Переименовать
refactoring.symbol.has.no.members.to.move=В {0} нет элементов для перемещения
rename.multiple.macro.usages.message={0} имеет несколько использований с разными привязками для "{1}". Переименование может нарушить код. Продолжить?
rename.non.code.usages.message=Найдено {0} {0, choice, 1\#использование|2\#использования|5\#использований} в комментариях и некодовых файлах.\nХотите {0, choice, 1\#его|2\#их} переименовать?
rename.reference.command.name=Переименовать ссылку
rename.reference.invalid.dialog.button.yes=Продолжить редактирование
rename.reference.invalid.dialog.title=Недопустимый идентификатор
selected.expression.cannot.be.a.constant.initializer=Выбранное выражение не может быть инициализатором константы
selected.expression.should.be.inside.a.block.statement=Выбранное выражение должно находиться внутри блока
selected.expression.should.be.inside.a.function.or.method=Выбранное выражение должно находиться внутри функции или метода
selected.expression.should.be.inside.an.instance.method=Выбранное выражение должно находиться внутри метода экземпляра
selected.expression.should.be.inside.an.instance.method1=Выбранное выражение должно находиться внутри метода экземпляра
several.definitions.of.0=Существует несколько определений {0}
text.parameter.initializer.not.available.in=Инициализатор параметра недоступен в {0}\: {1}.
the.address.of.is.taken=Адрес {0} занят
the.type.is.empty=Тип пуст
there.are.several.definitions.of=Существует несколько определений {0}
there.are.usages.in.other.blocks=Есть использования в других блоках
top.level.namespace.placeholder=пространство имён верхнего уровня
trying.to.rename.0.to.existing.file.name.1=Попытка переименовать {0} в существующее имя файла {1}