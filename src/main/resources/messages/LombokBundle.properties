action.defaultLombokData.description=Заменить методы getter/setter/equals/hashcode/toString аннотацией lombok @Data
action.defaultLombokData.text=Добавить @Data
action.defaultLombokEqualsAndHashcode.description=Заменить методы equals и hashcode аннотацией lombok @EqualsAndHashcode
action.defaultLombokEqualsAndHashcode.text=Добавить @EqualsAndHashcode
action.defaultLombokGetter.description=Заменить все методы getter аннотацией lombok @Getter
action.defaultLombokGetter.text=Добавить @Getter
action.defaultLombokLogger.description=Заменить логгер аннотацией lombok @Log
action.defaultLombokLogger.text=@Log (и другие)
action.defaultLombokSetter.description=Заменить все методы setter аннотацией lombok @Setter
action.defaultLombokSetter.text=Добавить @Setter
action.defaultLombokToString.description=Заменить метод toString аннотацией lombok @ToString
action.defaultLombokToString.text=Добавить @ToString
action.delombokAny.description=Заменить все аннотации lombok на обычные java методы
action.delombokAny.text=Все аннотации Lombok
action.delombokBuilder.description=Заменить аннотацию lombok @Builder на обычные java методы
action.delombokBuilder.text=@Builder
action.delombokConstructor.description=Заменить аннотации lombok @NoArgsConstructor, @RequiredArgsConstructor и @AllArgsConstructor на обычные java методы
action.delombokConstructor.text=@Constructors
action.delombokData.description=Заменить аннотацию lombok @Data на обычные java методы
action.delombokData.text=@Data
action.delombokDelegate.description=Заменить аннотацию lombok @Delegate на обычные java методы
action.delombokDelegate.text=@Delegate
action.delombokEqualsAndHashCode.description=Заменить аннотацию lombok @EqualsAndHashCode на обычные java методы
action.delombokEqualsAndHashCode.text=@EqualsAndHashCode
action.delombokFieldNameCostants.description=Заменить аннотацию lombok @FieldNameConstants на обычные java поля
action.delombokFieldNameCostants.text=@FieldNameConstants
action.delombokGetter.description=Заменить аннотацию lombok @Getter на обычные методы getter
action.delombokGetter.text=@Getter
action.delombokLogger.description=Заменить аннотацию lombok @Log (и другие) на обычное поле логгера
action.delombokLogger.text=@Log (и другие)
action.delombokSetter.description=Заменить аннотацию lombok @Setter на обычные методы setter
action.delombokSetter.text=@Setter
action.delombokStandardException.description=Заменить аннотацию lombok @StandardException на обычные java методы
action.delombokStandardException.text=@StandardException
action.delombokSuperBuilder.description=Заменить аннотацию lombok @SuperBuilder на обычные java методы
action.delombokSuperBuilder.text=@SuperBuilder
action.delombokToString.description=Заменить аннотацию lombok @ToString на обычные java методы
action.delombokToString.text=@ToString
action.delombokUtilityClass.description=Заменить аннотацию lombok @UtilityClass на обычные java поля
action.delombokUtilityClass.text=@UtilityClass
action.delombokValue.description=Заменить аннотацию lombok @Value на обычные java методы
action.delombokValue.text=@Value
action.delombokWither.description=Заменить аннотацию lombok @Wither на обычные java методы
action.delombokWither.text=@Wither
checkbox.settings.jps.fix=Автоматически добавлять опцию компиляции '-Djps.track.ap.dependencies\=false' для старых (<1.18.16) версий Lombok
checkbox.settings.version.warning=Включить предупреждение о версии для старых версий Lombok
color.settings.clear=Очистить
color.settings.comment=Комментарий
color.settings.key=Ключ
color.settings.separator=Разделитель
color.settings.value=Значение
config.warn.annotation-processing.disabled.title=Lombok требует включенной обработки аннотаций
config.warn.dependency.outdated.message=<br>Похоже, в проекте "{0}" используется устаревшая версия Lombok.<br>Текущая версия "{1}", но уже доступна версия "{2}"<br><a href\="https\://projectlombok.org/download">Возможно, стоит обновить?</a> <br>
config.warn.dependency.outdated.title=Возможно, зависимость Lombok устарела
configurable.name.lombok.config=Конфигурация Lombok
dialog.message.logger.field.s.not.private.sfinal.field.named.s.refactor.anyway=Поле логгера\: "{0}" не является private {1, choice, 0\#|1\#static }final полем с именем "{2}". Продолжить рефакторинг?
dialog.message.this.element.cannot.be.renamed=Этот элемент нельзя переименовать.
dialog.title.attention=Внимание\!
filetype.lombok.config.description=Файл конфигурации Lombok
group.DelombokActionGroup.description=Рефакторинг кода с удалением аннотаций lombok
group.DelombokActionGroup.text=Delombok
group.LombokActionGroup.description=Рефакторинг кода с аннотациями lombok
group.LombokActionGroup.text=Lombok
inspection.builder.static.import.name=Использование static import для методов, сгенерированных Lombok
inspection.deprecated.lombok.display.name=Устаревшие аннотации Lombok
inspection.lombok.display.name=Аннотации Lombok
inspection.lombok.getter.may.be.used.display.class.message=Класс ''{0}'' может использовать Lombok @Getter
inspection.lombok.getter.may.be.used.display.field.message=Поле ''{0}'' может иметь Lombok @Getter
inspection.lombok.getter.may.be.used.display.fix.family.name=Заменить явный метод getter на Lombok @Getter
inspection.lombok.getter.may.be.used.display.fix.name=Использовать Lombok @Getter для ''{0}''
inspection.lombok.getter.may.be.used.display.name=Можно использовать Lombok @Getter
inspection.lombok.group.name.lombok=Lombok
inspection.lombok.group.name.redundant.definitions=Избыточные определения
inspection.lombok.group.name.redundant.modifiers=Избыточные модификаторы
inspection.lombok.setter.may.be.used.display.class.message=Класс ''{0}'' может использовать Lombok @Setter
inspection.lombok.setter.may.be.used.display.field.message=Поле ''{0}'' может иметь Lombok @Setter
inspection.lombok.setter.may.be.used.display.fix.family.name=Заменить явный метод setter на Lombok @Setter
inspection.lombok.setter.may.be.used.display.fix.name=Использовать Lombok @Setter для ''{0}''
inspection.lombok.setter.may.be.used.display.name=Можно использовать Lombok @Setter
inspection.message.annotation.copy.duplicate=Аннотация ''{0}'' уже присутствует в поле и будет продублирована конфигурацией onX
inspection.message.annotation.not.lombok.copyable=Lombok не копирует аннотацию ''{0}'' в конструктор
inspection.message.annotation.only.supported.on.class.or.enum.type={0} поддерживается только для класса или enum.
inspection.message.builder.can.be.used.only=@Builder поддерживается только для классов, records, конструкторов и методов.
inspection.message.builder.default.requires.builder.annotation=@Builder.Default требует наличия @Builder или @SuperBuilder в классе.
inspection.message.builder.default.requires.initializing.expression=@Builder.Default требует выражения инициализации (' \= something;').
inspection.message.builder.default.singular.cannot.be.mixed=@Builder.Default и @Singular нельзя использовать вместе.
inspection.message.can.t.singularize.this.name=Невозможно привести к единственному числу\: ''{0}''; укажите форму единственного числа явно (например, @Singular("sheep"))
inspection.message.cleanup.legal.only.on.local.variable.declaration.inside.block=@Cleanup\: допустимо только для объявления локальной переменной внутри блока
inspection.message.cleanup.legal.only.on.local.variable.declarations=@Cleanup допустимо только для объявлений локальных переменных
inspection.message.cleanup.method.s.not.found.on.target.class=@Cleanup\: метод ''{0}()'' не найден в целевом классе
inspection.message.cleanup.value.cannot.be.empty.string=@Cleanup\: значение не может быть пустой строкой
inspection.message.cleanup.variable.declarations.need.to.be.initialized=Переменные с @Cleanup должны быть инициализованы.
inspection.message.constructor.noargs.needs.to.be.forced=Класс содержит обязательные поля, необходимо форсировать NoArgsConstructor.
inspection.message.constructor.with.d.parameters.already.defined=Конструктор с ''{0}'' параметрами уже определен
inspection.message.constructor.without.parameters.already.defined=Конструктор без параметров уже определен
inspection.message.custom.log.does.not.allow.topic=@CustomLog не поддерживает topic.
inspection.message.custom.log.not.configured.correctly=@CustomLog настроен неправильно; установите log.custom.declaration в lombok.config.
inspection.message.custom.log.requires.topic=@CustomLog требует указания topic.
inspection.message.data.only.supported.on.class.type=@Data поддерживается только для типа класса
inspection.message.default.constructor.doesn.t.exist=Конструктор по умолчанию не существует
inspection.message.delegate.can.only.use.concrete.class.types=@Delegate может использовать только конкретные типы классов, но не wildcards, массивы, переменные типа или примитивы. ''{0}'' является неверным типом класса
inspection.message.delegate.does.not.support.recursion.delegating=@Delegate не поддерживает рекурсию (делегирование типу, который сам имеет члены @Delegate). Член ''{0}'' является @Delegate в типе ''{1}''
inspection.message.delegate.legal.only.on.instance.fields=@Delegate допустим только для полей экземпляра или методов экземпляра без аргументов.
inspection.message.delegate.legal.only.on.no.argument.methods=@Delegate допустим только для методов без аргументов.
inspection.message.delegate.unknown.type.method=Не удаётся найти метод ''{0}''
inspection.message.equals.and.hashcode.only.supported.on.class.type=@EqualsAndHashCode поддерживается только для типа class
inspection.message.exclude.are.mutually.exclusive.exclude.parameter.will.be.ignored=Параметры 'exclude' и 'of' являются взаимоисключающими; параметр 'exclude' будет проигнорирован
inspection.message.existing.builder.must.be.abstract.static.inner.class=Существующий Builder должен быть абстрактным статическим внутренним классом.
inspection.message.field.name.constants.inner.type=Внутренний тип @FieldNameConstants уже существует, но asEnum\={0} не соответствует существующему типу
inspection.message.field.name.constants.only.supported.on.class.enum.or.field.type=@FieldNameConstants поддерживается только для типа class, enum, record или field
inspection.message.field.name.constants.only.supported.on.class.or.enum=@FieldNameConstants поддерживается только для class, enum или record.
inspection.message.field.s.does.not.exist=Поле ''{0}'' не существует.
inspection.message.field.s.does.not.exist.exclude=Поле ''{0}'' не существует
inspection.message.field.s.does.not.exist.field=Поле ''{0}'' не существует
inspection.message.field.s.would.have.been.excluded.anyway=Поле ''{0}'' в любом случае было бы исключено
inspection.message.generating.equals.hashcode.implementation=Генерируется реализация equals/hashCode без вызова суперкласса, хотя этот класс не наследуется от java.lang.Object. Если это сделано намеренно, добавьте '(callSuper\=false)' к вашему типу.
inspection.message.generating.equals.hashcode.with.super.call=Генерация equals/hashCode с вызовом super для java.lang.Object бессмысленна.
inspection.message.getter.only.supported.on.class.enum.or.field.type=@Getter поддерживается только для типа class, enum или field
inspection.message.jacksonized.builder.on.abstract.classes=Builder'ы в абстрактных классах не могут быть @Jacksonized (builder никогда не будет использован).
inspection.message.jacksonized.cannot.process.both.builder.superbuilder=@Jacksonized не может обрабатывать одновременно @Builder и @SuperBuilder в одном классе.
inspection.message.jacksonized.jsondeserialize.already.exists=@JsonDeserialize уже существует в классе. Либо удалите @JsonDeserialize, либо удалите @Jacksonized и настройте Jackson вручную.
inspection.message.jacksonized.requires.builder.superbuilder=@Jacksonized требует @Builder или @SuperBuilder для осмысленного использования.
inspection.message.lazy.does.not.work.with.access.level.none='lazy' не работает с AccessLevel.NONE.
inspection.message.lazy.not.supported.for.getter.on.type='lazy' не поддерживается для @Getter на уровне типа
inspection.message.lazy.requires.field.initialization='lazy' требует инициализации поля.
inspection.message.lazy.requires.field.to.be.private.final='lazy' требует, чтобы поле было private и final
inspection.message.lombok.annotation.deprecated.not.supported=Аннотация Lombok ''{0}'' устарела и больше не поддерживается плагином Lombok. Используйте ''{1}'' вместо нее.
inspection.message.lombok.annotations.are.not.allowed.on.builder.class=Аннотации Lombok не разрешены в builder-классе.
inspection.message.lombok.builder.needs.proper.constructor.for.this.class=Lombok @Builder требует подходящий конструктор для этого класса
inspection.message.lombok.does.not.know=Lombok не может сгенерировать builder-методы в единственном числе для типа ''{0}''
inspection.message.lombok.needs.default.constructor.in.base.class=Lombok требует конструктор по умолчанию в базовом классе
inspection.message.method.s.matched.static.constructor.name.already.defined=Метод ''{0}'', соответствующий staticConstructorName, уже определен
inspection.message.method.s.with.d.parameters.matched.static.constructor.name.already.defined=Метод ''{0}'' с ''{1}'' параметрами, соответствующий staticConstructorName, уже определен
inspection.message.not.allowed.in.old.style.for.loops=''{0}'' не разрешено использовать в циклах for старого стиля
inspection.message.not.allowed.with.lambda.expressions=''{0}'' не разрешено использовать с лямбда-выражениями.
inspection.message.not.compatible.with.array.initializer.expressions=''{0}'' несовместим с инициализаторами массивов. Используйте полную форму (new int[] '{' ... '}' вместо просто '{' ... '}')
inspection.message.not.generated.s.method.with.same.name.already.exists=Не сгенерирован ''{0}()''\: Метод с таким именем уже существует
inspection.message.not.generated.s.method.with.similar.name.s.already.exists=Не сгенерирован ''{0}()''\: Метод с похожим именем ''{0}'' уже существует
inspection.message.not.generating.constant=Константа для этого поля не генерируется\: Имя константы совпало бы с именем поля.
inspection.message.not.generating.equals.hashcode=Не генерируются equals и hashCode\: Метод с одним из этих имен уже существует. (Будут сгенерированы либо оба метода, либо ни один).
inspection.message.not.generating.field.s.field.with.same.name.already.exists=Поле ''{0}'' не генерируется\: Поле с таким именем уже существует
inspection.message.not.generating.getter.for.this.field=Геттер для этого поля не генерируется\: Оно не соответствует списку префиксов @Accessors.
inspection.message.not.generating.s.method.with.that.name.already.exists=Не сгенерирован ''{0}()''\: Метод с таким именем уже существует
inspection.message.not.generating.setter.for.this.field.it=Сеттер для этого поля не генерируется\: Оно не соответствует списку префиксов @Accessors.
inspection.message.not.generating.setter.for.this.field.setters=Сеттер для этого поля не генерируется\: Сеттеры не могут быть сгенерированы для final полей.
inspection.message.not.generating.wither=Wither для этого поля не генерируется\: Wither'ы не могут быть сгенерированы для static полей.
inspection.message.not.generating.wither.for.this.field.withers=Wither для этого поля не генерируется\: Wither'ы не могут быть сгенерированы для полей, начинающихся с $.
inspection.message.not.generating.wither.for.this.field.withers.cannot.be.generated=Wither для этого поля не генерируется\: Wither'ы не могут быть сгенерированы для инициализованных final полей.
inspection.message.obtain.via.is.static.true.not.valid.unless.method.has.been.set=@ObtainVia(isStatic \= true) недействителен, если не установлен 'method'.
inspection.message.on.local.variable.requires.initializer.expression=''{0}'' для локальной переменной требует выражение инициализации
inspection.message.s.legal.only.on.classes.enums=''@{0}'' допустим только для классов и перечислений
inspection.message.s.not.valid.identifier=''{0}'' не является допустимым идентификатором
inspection.message.setter.only.supported.on.class.or.field.type=@Setter поддерживается только для класса или поля
inspection.message.slf4j.logger.defined.explicitly=Slf4j Logger определен явно. Используйте аннотацию Lombok @Slf4j.
inspection.message.sneakythrows.calls.to.sibling.super.constructors.excluded=Вызовы родственных/супер конструкторов всегда исключаются из @SneakyThrows; @SneakyThrows был проигнорирован, так как в этом конструкторе нет другого кода.
inspection.message.standardexception.accesslevel.none.not.valid=AccessLevel.NONE здесь недопустим
inspection.message.standardexception.class.only.supported.on.class=@StandardException поддерживается только для класса
inspection.message.standardexception.should.extend.throwable=@StandardException требует наследования от типа Throwable
inspection.message.superbuilder.can.be.used.on.classes.only=@SuperBuilder поддерживается только для классов.
inspection.message.superbuilder.can.be.used.on.static.inner.classes.only=@SuperBuilder не поддерживается для нестатических вложенных классов.
inspection.message.synchronized.field.is.not.static=Поле ''{0}'' не является static и не может использоваться в этом статическом методе
inspection.message.synchronized.legal.only.on.concrete.methods=@Synchronized допустима только для конкретных методов.
inspection.message.synchronized.legal.only.on.methods.in.classes.enums=@Synchronized допустима только для методов в классах и перечислениях.
inspection.message.syntax.either.obtain.via.field=Синтаксис\: @ObtainVia(field \= "fieldName") или @ObtainVia(method \= "methodName").
inspection.message.to.string.only.supported.on.class.or.enum.type=@ToString поддерживается только для класса или перечисления
inspection.message.utility.class.already.marks.class.final=@UtilityClass уже помечает класс как final.
inspection.message.utility.class.already.marks.fields.static=@UtilityClass уже помечает поля как static.
inspection.message.utility.class.already.marks.inner.classes.static=@UtilityClass уже помечает внутренние классы как static.
inspection.message.utility.class.already.marks.methods.static=@UtilityClass уже помечает методы как static.
inspection.message.utility.class.automatically.makes.class.static=@UtilityClass автоматически делает класс статическим, однако этот класс не может быть static.
inspection.message.utility.class.cannot.be.placed=@UtilityClass нельзя размещать в локальном классе метода, анонимном внутреннем классе или любом вложенном в такой класс.
inspection.message.utility.class.only.supported.on.class=@UtilityClass поддерживается только для класса (не может быть интерфейсом, перечислением или аннотацией).
inspection.message.utility.classes.cannot.have.declared.constructors=@UtilityClasses не могут иметь объявленных конструкторов.
inspection.message.val.already.marks.variables.final='val' уже помечает переменные как final.
inspection.message.val.works.only.on.local.variables='val' работает только с локальными переменными и циклами foreach
inspection.message.value.already.marks.class.final=@Value уже помечает класс как final.
inspection.message.value.already.marks.non.static.fields.final=@Value уже помечает нестатические поля как final.
inspection.message.value.already.marks.non.static.package.local.fields.private=@Value уже помечает нестатические package-local поля как private.
inspection.message.value.only.supported.on.class.type=@Value поддерживается только для типа класса
inspection.message.var.works.only.on.local.variables.on.for.foreach.loops='var' работает только с локальными переменными и циклами for/foreach
inspection.message.wither.needs.constructor.for.all.fields.d.parameters=@Wither требует конструктор для всех полей (''{0}'' параметров)
inspection.message.wither.only.supported.on.class.or.field=@Wither поддерживается только для класса или поля.
inspection.redundant.modifiers.utility.class.lombok.display.name=Модификаторы @UtilityClass
inspection.redundant.modifiers.val.lombok.display.name=Лишний модификатор final перед 'val'
inspection.redundant.modifiers.value.lombok.display.name=Модификаторы @Value
inspection.redundant.slf.4.j.definition.display.name=@Slf4j
inspection.springqualifiercopyable.lombok.display.name=@Qualifier не может быть скопирован через Lombok
inspection.static.method.import.error=Static import методов, сгенерированных Lombok, не работает с javac
intention.category.lombok=Java/Lombok
intention.family.name.slf4j.annotation=Заменить поле logger аннотацией @Slf4j
intention.name.create.new.field.s=Создать новое поле ''{0}''
intention.name.replace.with.lombok=Заменить на Lombok
make.abstract.and.static.modifier.quickfix=Сделать ''{0}'' abstract и static
make.abstract.and.static.modifier.quickfix.family.name=Изменить модификатор
notification.enable.annotation.processing=Включить обработку аннотаций
notification.group.lombok=Проблема интеграции Lombok
plugin.settings.title=Lombok
popup.content.java.annotation.processing.has.been.enabled=Обработка Java-аннотаций включена
replace.0.with.explicit.type.lombok=Заменить ''{0}'' на явный тип (Lombok)
replace.explicit.type.with.0.lombok=Заменить явный тип на ''{0}'' (Lombok)
replace.synchronized.lombok.intention=Заменить на Lombok @Synchronized
replace.with.annotations.lombok=Заменить на аннотации (Lombok)