0.field.is.always.initialized.not.null=Поле @{0} всегда инициализуется ненулевым значением
access.can.be.0=Доступ может быть ''{0}''
access.can.be.package.private=Доступ может быть package-private
access.to.field.code.ref.code.outside.of.declared.guards.loc=Доступ к полю <code>\#ref</code> вне объявленных охранных условий \#loc
add.explicit.type.arguments=Добавить явные аргументы типа
annotate.as.safevarargs=Аннотировать как '@SafeVarargs'
annotate.overridden.methods.parameters=Аннотировать параметры переопределяющего метода как ''@{0}''
annotate.overridden.methods.parameters.family.name=Аннотировать параметры переопределяющего метода
annotation.target.ANNOTATION_TYPE=тип аннотации
annotation.target.CONSTRUCTOR=конструктор
annotation.target.FIELD=поле
annotation.target.LOCAL_VARIABLE=локальная переменная
annotation.target.METHOD=метод
annotation.target.MODULE=модуль
annotation.target.PACKAGE=пакет
annotation.target.PARAMETER=параметр
annotation.target.RECORD_COMPONENT=компонент записи
annotation.target.TYPE=тип
annotation.target.TYPE_PARAMETER=параметр типа
annotation.target.TYPE_USE=использование типа
anonymous.ref.loc.can.be.replaced.with.0=Анонимный \#ref \#loc может быть заменен на {0}
anonymous.ref.loc.can.be.replaced.with.lambda=Анонимный \#ref \#loc может быть заменен лямбда-выражением
arguments.count.mismatch=Ожидалось {0, choice, 0\#без аргументов|1\#1 аргумент|1<{0} аргументов}, но найдено {1}
assigning.a.collection.of.nullable.elements=Присваивание коллекции обнуляемых элементов коллекции ненулевых элементов
call.to.method.code.ref.code.outside.of.declared.guards.loc=Вызов метода <code>\#ref()</code> вне объявленных охранных условий \#loc
change.type.arguments=Изменить аргументы типа
change.type.arguments.to.0=Изменить аргументы типа на <{0}>
change.visibility.level=Сделать {0} {1}
chooser.popup.title.select.class.to.move.members.to=Выберите целевой класс
comparision.between.object.and.primitive=Сравнение между объектом и примитивом недопустимо и поддерживается только в Java 7
contract.return.validator.incompatible.return.parameter.type=тип возвращаемого значения ''{0}'' должен быть конвертируемым из типа параметра ''{1}''
contract.return.validator.method.return.incompatible.with.method.containing.class=тип возвращаемого значения метода должен быть совместим с классом, содержащим метод
contract.return.validator.not.applicable.for.constructor=не применимо для конструктора
contract.return.validator.not.applicable.primitive=не применимо для примитивного типа возвращаемого значения ''{0}''
contract.return.validator.not.applicable.static=не применимо для статического метода
contract.return.validator.return.type.must.be.boolean=тип возвращаемого значения метода должен быть 'boolean'
contract.return.validator.too.few.parameters=не применимо для метода, который имеет {0, choice, 0\#нет параметров|1\#один параметр|2\#{0} параметров}
contract.return.value.validation.prefix=Возвращаемое значение контракта ''{0}''\:
custom.exception.class.should.have.a.constructor=Пользовательский класс исключения должен иметь конструктор с одним строковым параметром сообщения
dataflow.message.array.index.out.of.bounds=Индекс массива выходит за границы
dataflow.message.arraystore=Сохранение элемента типа <code>{0}</code> в массив элементов <code>{1}</code> вызовет <code>ArrayStoreException</code>
dataflow.message.assigning.null=<code>null</code> присваивается переменной с аннотацией @NotNull
dataflow.message.assigning.null.notannotated=Присваивание значения <code>null</code> полю без аннотации
dataflow.message.assigning.nullable=Выражение <code>\#ref</code> может вернуть null, но присваивается переменной с аннотацией @NotNull
dataflow.message.assigning.nullable.notannotated=Выражение <code>\#ref</code> \#loc может быть null, но присваивается полю без аннотации
dataflow.message.cce=Приведение <code>{0}</code> к <code>\#ref</code> \#loc может вызвать <code>ClassCastException</code>
dataflow.message.cce.always=Приведение <code>{0}</code> к <code>\#ref</code> \#loc вызовет <code>ClassCastException</code> для любого ненулевого значения
dataflow.message.constant.condition=Условие <code>\#ref</code> \#loc всегда <code>{0, choice, 0\#false|1\#true}</code>
dataflow.message.constant.condition.when.reached=Условие <code>\#ref</code> \#loc всегда <code>{0, choice, 0\#false|1\#true}</code> при достижении
dataflow.message.constant.expression=Результат <code>\#ref</code> \#loc всегда ''{0}''
dataflow.message.constant.method.reference=Результат ссылки на метод всегда ''{0}''
dataflow.message.constant.no.ref=Условие всегда {0, choice, 0\#false|1\#true}
dataflow.message.constant.value=Значение <code>\#ref</code> \#loc всегда ''{0}''
dataflow.message.contract.fail=Вызов '\#ref' всегда завершается ошибкой согласно контрактам метода
dataflow.message.contract.fail.index=Вызов '\#ref' всегда завершается ошибкой, так как аргумент выходит за границы
dataflow.message.fail=Вызов '\#ref' всегда завершается исключением
dataflow.message.immutable.modified=Изменяется неизменяемый объект
dataflow.message.immutable.passed=Неизменяемый объект передается там, где ожидается изменяемый
dataflow.message.negative.array.size=Отрицательный размер массива
dataflow.message.npe.array.access=Доступ к массиву <code>\#ref</code> \#loc может вызвать <code>NullPointerException</code>
dataflow.message.npe.array.access.sure=Доступ к массиву <code>\#ref</code> \#loc вызовет <code>NullPointerException</code>
dataflow.message.npe.field.access=Разыменование <code>\#ref</code> \#loc может вызвать <code>NullPointerException</code>
dataflow.message.npe.field.access.sure=Разыменование <code>\#ref</code> \#loc вызовет <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction=Создание внутреннего класса может вызвать <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction.sure=Создание внутреннего класса вызовет <code>NullPointerException</code>
dataflow.message.npe.method.invocation=Вызов метода <code>\#ref</code> \#loc может вызвать <code>NullPointerException</code>
dataflow.message.npe.method.invocation.sure=Вызов метода <code>\#ref</code> \#loc вызовет <code>NullPointerException</code>
dataflow.message.npe.methodref.invocation=Вызов ссылки на метод <code>\#ref</code> \#loc может вызвать <code>NullPointerException</code>
dataflow.message.npe.template.invocation=Вызов обработчика шаблона может вызвать <code>NullPointerException</code>
dataflow.message.npe.template.invocation.sure=Вызов обработчика шаблона вызовет <code>NullPointerException</code>
dataflow.message.only.switch.label=Метка switch <code>\#ref</code> \#loc является единственной достижимой во всем switch
dataflow.message.passing.non.null.argument.to.optional='Optional.ofNullable()' с ненулевым аргументом следует заменить на 'Optional.of()'
dataflow.message.passing.null.argument=Передача аргумента <code>null</code> параметру с аннотацией @NotNull
dataflow.message.passing.null.argument.nonannotated=Передача аргумента <code>null</code> параметру без аннотации
dataflow.message.passing.null.argument.to.optional='Optional.ofNullable()' с null аргументом следует заменить на 'Optional.empty()'
dataflow.message.passing.nullable.argument=Аргумент <code>\#ref</code> \#loc может быть null
dataflow.message.passing.nullable.argument.methodref=Аргумент ссылки на метод может быть null
dataflow.message.passing.nullable.argument.methodref.nonannotated=Аргумент ссылки на метод может быть null, но передается параметру без аннотации
dataflow.message.passing.nullable.argument.nonannotated=Аргумент <code>\#ref</code> \#loc может быть null, но передается параметру без аннотации
dataflow.message.pointless.assignment.expression=Условие <code>\#ref</code> \#loc в левой части выражения присваивания всегда <code>{0}</code>. Можно упростить
dataflow.message.pointless.same.argument.and.result=Результат ''\#ref'' совпадает с {0,choice,1\#первым|2\#вторым} аргументом, что делает вызов бессмысленным
dataflow.message.pointless.same.arguments=Аргументы '\#ref' одинаковы. Вызов этого метода с одинаковыми аргументами бессмыслен
dataflow.message.redundant.assignment=Переменной уже присвоено это значение
dataflow.message.redundant.instanceof=Условие <code>\#ref</code> \#loc избыточно и может быть заменено проверкой на null
dataflow.message.redundant.update=Обновление переменной ничего не делает
dataflow.message.return.notnull.from.nullable=Метод @{0} ''{1}'' всегда возвращает ненулевое значение
dataflow.message.return.null.from.notnull=<code>null</code> возвращается методом, объявленным как @{0}
dataflow.message.return.null.from.notnullable=<code>null</code> возвращается методом, не объявленным как @{0}
dataflow.message.return.nullable.from.notnull=Выражение <code>\#ref</code> может вернуть null, но возвращается методом, объявленным как @{0}
dataflow.message.return.nullable.from.notnull.function=Функция может вернуть null, но здесь это не разрешено
dataflow.message.return.nullable.from.notnullable=Выражение <code>\#ref</code> может вернуть null, но возвращается методом, не объявленным как @{0}
dataflow.message.storing.array.null=<code>null</code> сохраняется в массив элементов @NotNull
dataflow.message.storing.array.nullable=Выражение <code>\#ref</code> может вернуть null, но сохраняется в массив элементов @NotNull
dataflow.message.stream.consumed=Поток возможно уже был связан или использован
dataflow.message.stream.consumed.always=Поток уже был связан или использован
dataflow.message.unboxing=Распаковка <code>\#ref</code> \#loc может вызвать <code>NullPointerException</code>
dataflow.message.unboxing.method.reference=Использование <code>\#ref</code> \#loc потребует распаковки, которая может вызвать <code>NullPointerException</code>
dataflow.message.unboxing.nullable.argument.methodref=Передача аргумента в ссылку на метод требует распаковки, которая может вызвать <code>NullPointerException</code>
dataflow.message.unknown.nullability=\ (неизвестная обнуляемость)
dataflow.message.unreachable.switch.label=Метка switch <code>\#ref</code> \#loc недостижима
dataflow.method.fails.with.null.argument=Метод выбросит исключение, если параметр равен null
dataflow.not.precise={0} сложный\: результаты анализа потока данных могут быть неточными
dataflow.too.complex={0} слишком сложный для анализа алгоритмом потока данных
delete.repeated.0=Удалить повторяющийся ''{0}''
delete.repeated.interface=Удалить повторяющийся интерфейс
delimiters.argument.contains.duplicated.characters=Аргумент 'delimiters' класса StringTokenizer содержит повторяющиеся символы
deprecated.class.usage.group.xml=XML
deprecated.member.0.is.still.used=Устаревший член ''{0}'' все еще используется
detach.library.quickfix.name=Отсоединить библиотеку
detach.library.roots.quickfix.name=Отсоединить неиспользуемые корни библиотеки
dfa.find.cause.an.execution.might.exist.where=может существовать выполнение, где\:
dfa.find.cause.and.another=и {0}
dfa.find.cause.array.length.is.always.non.negative=длина массива всегда неотрицательна
dfa.find.cause.call.always.fails=вызов всегда завершается неудачей
dfa.find.cause.cast.may.fail=приведение типов может не сработать
dfa.find.cause.collection.size.is.always.non.negative=размер коллекции всегда неотрицателен
dfa.find.cause.comparison.arguments.are.different.constants=аргументы сравнения - разные константы
dfa.find.cause.comparison.arguments.are.the.same=аргументы сравнения одинаковы
dfa.find.cause.compile.time.constant=это константа времени компиляции со значением ''{0}''
dfa.find.cause.condition.is.known.from.place=известно, что ''{0}'' из ___PLACE___
dfa.find.cause.condition.was.checked.before=условие ''{0}'' было проверено ранее
dfa.find.cause.condition.was.deduced=условие ''{0}'' было выведено
dfa.find.cause.contract.kind.explicit=контракт
dfa.find.cause.contract.kind.hard.coded=жестко закодованный контракт
dfa.find.cause.contract.kind.inferred=выведенный контракт
dfa.find.cause.contract.returns.on.condition=согласно {0}, {1} ''{2}'' возвращает ''{3}'' когда {4}
dfa.find.cause.contract.throws.on.condition=согласно {0}, {1} ''{2}'' выбрасывает исключение когда {3}
dfa.find.cause.contract.trivial=согласно {0}, {1} ''{2}'' всегда возвращает значение ''{3}''
dfa.find.cause.equality.established.from.condition=''{0}'' установлено из условия
dfa.find.cause.field.assigned.nullability=известно, что поле ''{0}'' всегда инициализуется значением ''{1}''
dfa.find.cause.field.initializer.nullability=поле ''{0}'' инициализовано значением ''{1}''
dfa.find.cause.instanceof.implies.non.nullity=проверка 'instanceof' подразумевает не-null
dfa.find.cause.left.operand.range.template=левый операнд равен %s
dfa.find.cause.may.be.null=может быть null
dfa.find.cause.nonnull.expression.kind.concatenation=конкатенация
dfa.find.cause.nonnull.expression.kind.literal=литерал
dfa.find.cause.nonnull.expression.kind.newly.created.object=новый созданный объект
dfa.find.cause.nonnull.expression.kind.primitive.type=значение примитивного типа ''{0}''
dfa.find.cause.nonnull.expression.kind.this.object=объект 'this'
dfa.find.cause.nullability.explicitly.annotated={0} ''{1}'' аннотировано как ''{2}''
dfa.find.cause.nullability.externally.annotated={0} ''{1}'' внешне аннотировано как ''{2}''
dfa.find.cause.nullability.inferred={0} ''{1}'' выведено как ''{2}''
dfa.find.cause.nullability.inherited.from.class={0} ''{1}'' наследует аннотацию из класса {2}, поэтому ''{3}''
dfa.find.cause.nullability.inherited.from.container={0} ''{1}'' наследует аннотацию контейнера, поэтому ''{2}''
dfa.find.cause.nullability.inherited.from.named.element={0} ''{1}'' наследует от {2}, поэтому ''{3}''
dfa.find.cause.nullability.inherited.from.package={0} ''{1}'' наследует аннотацию из пакета {2}, поэтому ''{3}''
dfa.find.cause.numeric.cast.operand.template=операнд приведения равен %s
dfa.find.cause.numeric.range.generic.template=значение равно %s
dfa.find.cause.object.kind.expression=выражение
dfa.find.cause.object.kind.generic=объект
dfa.find.cause.object.kind.method.return=возвращаемое значение метода
dfa.find.cause.obviously.non.null.expression=выражение не может быть null, так как это {0}
dfa.find.cause.one.of.the.following.happens=происходит одно из следующего\:
dfa.find.cause.operand.of.boolean.expression.is.the.same=операнд \#{0} {1, choice, 0\#and|1\#or}-цепочки равен {2}
dfa.find.cause.or.another=или {0}
dfa.find.cause.place.here=здесь
dfa.find.cause.place.line.number=строка \#{0}
dfa.find.cause.primitive.boxed=примитивное значение было упаковано
dfa.find.cause.range.is.known.from.place=диапазон известен из ___PLACE___
dfa.find.cause.range.is.specified.by.annotation=диапазон ''{0}'' задан аннотацией как {1}
dfa.find.cause.result.of.numeric.operation.template=результат ''{0}'' равен %s
dfa.find.cause.result.of.primitive.cast.template=результат приведения ''({0})'' равен %s
dfa.find.cause.right.operand.range.template=правый операнд равен %s
dfa.find.cause.size.is.always.zero=размер всегда равен 0
dfa.find.cause.special.field.of.something={0}/{1}
dfa.find.cause.string.length.is.always.non.negative=длина строки всегда неотрицательна
dfa.find.cause.type.is.known.from.place=тип ''{0}'' известен из ___PLACE___
dfa.find.cause.type.known={0} имеет тип {1}
dfa.find.cause.unable=Не удаётся найти причину
dfa.find.cause.value.is.always.the.same=значение всегда {0}
dfa.find.cause.value.is.known.from.place=известно, что ''{0}'' равно ''{1}'' из ___PLACE___
dfa.find.cause.value.x.is.always.the.same=значение ''{0}'' всегда равно ''{1}''
dfa.find.cause.values.cannot.be.equal.because=значения не могут быть равны, потому что {0}
dfa.find.cause.variable.is.initialized={0} ''{1}'' инициализован значением {2}
dfa.find.cause.was.assigned=''{0}'' было присвоено
dfa.find.cause.was.assigned.to=''{0}'' было присвоено ''{1}''
dfa.find.cause.was.dereferenced=''{0}'' было разыменовано
dfa.find.cause.was.passed.as.non.null.parameter=''{0}'' было передано как аргумент методу, принимающему не-null параметр
dftype.presentation.empty.optional=пустой Optional
dftype.presentation.present.optional=существующий Optional
don.t.report.unused.jars.inside.used.library=Не сообщать о неиспользуемых jar-файлах внутри используемой библиотеки
duplication.policy.ask=Спросить
duplication.policy.generate.duplicate=Сгенерировать дублирующий метод
duplication.policy.replace=Заменить существующий
element.kind.keys=ключи
element.kind.objects=объекты
element.kind.values=значения
error.class.not.found=Класс {0} не найден
error.message.invalid.java.type=Недопустимый тип Java
error.unnamed.field.not.allowed=Безымянное поле не допускается
error.unnamed.method.parameter.not.allowed=Безымянный параметр метода не допускается
error.unnamed.variable.brackets=Скобки не допускаются после объявления безымянной переменной
error.unnamed.variable.not.allowed.in.this.context=Объявление безымянной переменной не допускается в этом контексте
error.unnamed.variable.without.initializer=Объявление безымянной переменной должно иметь инициализатор
exception.handler.will.become.unreachable=Секция catch станет недостижимой
explicit.type.argument.ref.loc.can.be.replaced.with=Явный аргумент типа \#ref \#loc можно заменить на <>
exports.to.itself.delete.module.ref.fix=Удалить ссылку на модуль ''{0}''
exports.to.itself.delete.statement.fix=Удалить директиву
find.searching.for.references.to.class.progress=Поиск ссылок на класс {0}…
find.usages.panel.title.base.methods=использования базового метода
find.usages.panel.title.base.methods.cap=использования базового метода
find.usages.panel.title.derived.classes=производные классы
find.usages.panel.title.derived.classes.cap=Производные классы
find.usages.panel.title.derived.interfaces=производные интерфейсы
find.usages.panel.title.derived.interfaces.cap=Производные интерфейсы
find.usages.panel.title.implementing.classes=реализующие классы
find.usages.panel.title.implementing.classes.cap=Реализующие классы
find.usages.panel.title.implementing.methods=реализующие методы
find.usages.panel.title.implementing.methods.cap=Реализующие методы
find.usages.panel.title.overloaded.methods.usages=перегруженные методы
find.usages.panel.title.overloaded.methods.usages.cap=Перегруженные методы
find.usages.panel.title.overriding.methods=переопределяющие методы
find.usages.panel.title.overriding.methods.cap=Переопределяющие методы
generate.members.position.after.equals.and.hashcode=После equals() и hashCode()
generate.members.position.at.caret=На позиции курсора
generate.members.position.at.the.end.of.class=В конце класса
highlighting.try.blocks=Подсветка try-блоков…
html.classes.exposed.with.code.module.info.code.html=<html>Классы, экспортуемые через <code>module-info</code></html>
html.ignore.overrides.of.deprecated.abstract.methods=<html>Игнорировать переопределения устаревших абстрактных методов из неустаревших суперклассов</html>
ignore.casts.in.suspicious.collections.method.calls=Игнорировать уточняющие приведения типов
ignore.exceptions.thrown.by.entry.points.methods=Игнорировать исключения, выбрасываемые методами точек входа
ignore.in.the.same.outermost.class=Игнорировать в том же внешнем классе
ignore.in.the.same.project=Игнорировать API, объявленный в этом проекте
ignore.inside.deprecated.members=Игнорировать внутри устаревших членов
ignore.inside.non.static.imports=Игнорировать внутри нестатических импортов
ignore.members.of.deprecated.classes=Игнорировать члены устаревших классов
ignore.operation.which.results.in.negative.value=Игнорировать операцию '<<', приводящую к отрицательному значению
inspection.annotate.method.quickfix.family.name=Аннотировать метод
inspection.annotate.method.quickfix.name=Аннотировать метод ''@{0}''
inspection.annotate.overridden.method.and.self.quickfix.family.name=Аннотировать переопределяющие методы и текущий
inspection.annotate.overridden.method.and.self.quickfix.name=Аннотировать переопределяющие методы и текущий с помощью ''@{0}''
inspection.annotate.overridden.method.nullable.quickfix.name=Аннотировать переопределяющие методы как ''@{0}''
inspection.annotate.overridden.method.quickfix.family.name=Аннотировать переопределяющие методы
inspection.annotate.overridden.method.quickfix.name=Аннотировать переопределяющие методы с помощью ''@{0}''
inspection.anonymous.has.lambda.alternative.display.name=Анонимный тип имеет более короткую лямбда-альтернативу
inspection.block.marker.comments.display.name=Комментарий-маркер блока
inspection.c.style.array.declarations.option=Игнорировать объявления в стиле C в переменных
inspection.can.be.final.accept.quickfix=Сделать final
inspection.can.be.final.display.name=Объявление может иметь модификатор 'final'
inspection.can.be.final.option=Сообщать о классах
inspection.can.be.final.option1=Сообщать о методах
inspection.can.be.final.option2=Сообщать о полях
inspection.can.be.local.parameter.problem.descriptor=Параметр <code>\#ref</code> может иметь модификатор <code>final</code>
inspection.can.be.local.variable.problem.descriptor=Переменная <code>\#ref</code> может иметь модификатор <code>final</code>
inspection.can.be.replaced.with.message=Может быть заменено на ''{0}''
inspection.class.getclass.display.name=Подозрительный вызов 'Class.getClass()'
inspection.class.getclass.fix.remove.name=Удалить вызов 'getClass()'
inspection.class.getclass.fix.replace.name=Заменить на 'Class.class'
inspection.class.getclass.message='getClass()' вызывается для экземпляра Class
inspection.class.has.no.to.string.method.description=Класс ''{0}'' не переопределяет метод ''toString()''
inspection.class.has.no.to.string.method.display.name=Класс не переопределяет метод 'toString()'
inspection.class.has.no.to.string.method.exclude.classes.reg.exp.option=Исключить классы (рег. выр.)\:
inspection.class.has.no.to.string.method.ignore.abstract.classes.option=Игнорировать абстрактные классы
inspection.class.has.no.to.string.method.ignore.deprecated.classes.option=Игнорировать устаревшие классы
inspection.class.has.no.to.string.method.ignore.enum.classes.option=Игнорировать классы перечислений
inspection.class.has.no.to.string.method.ignore.exception.classes.option=Игнорировать классы исключений
inspection.class.has.no.to.string.method.ignore.inner.classes.option=Игнорировать внутренние классы
inspection.class.has.no.to.string.method.ignore.records.option=Игнорировать записи
inspection.class.has.no.to.string.method.ignore.test.classes.option=Игнорировать тестовые классы
inspection.common.if.parts.disable.highlight.tail.call=Не подсвечивать общие части, если последний оператор - вызов
inspection.common.if.parts.family=Извлечь общие части оператора 'if'
inspection.common.if.parts.family.else.if=Объединить оператор 'else if'
inspection.common.if.parts.family.else.if.description='else if' можно объединить
inspection.common.if.parts.family.else.if.invert=Объединить оператор 'else if' с инвертированием второго условия
inspection.common.if.parts.settings.highlight.else.if=Подсвечивать цепочки else-if, которые можно упростить
inspection.common.if.parts.settings.highlight.when.tail.call=Подсвечивать, когда последний общий оператор - вызов
inspection.compiler.javac.quirks.anno.array.comma.fix=Удалить замыкающую запятую
inspection.compiler.javac.quirks.anno.array.comma.problem=Замыкающая запятая в инициализаторах массивов аннотаций может вызвать ошибки компиляции при использовании старых версий javac (например, JDK 5 и JDK 6)
inspection.compiler.javac.quirks.illegal.forward.reference=Прямые ссылки могут вызвать ошибки компиляции при использовании старых версий javac (например, JDK 5 и JDK 6)
inspection.compiler.javac.quirks.name=Особенности Javac
inspection.compiler.javac.quirks.qualifier.type.args.fix=Удалить параметр обобщения
inspection.compiler.javac.quirks.qualifier.type.args.problem=Обобщения в ссылках на квалификаторы могут вызвать ошибки компиляции при использовании старых версий javac (например, JDK 5 и JDK 6)
inspection.constant.on.wrong.side.of.a.comparison.side.option=Константа должна быть на|стороне сравнения
inspection.contract.checker.boolean.condition.for.nonboolean.parameter=Параметр ''{0}'' имеет тип ''{1}'' (ожидается boolean)
inspection.contract.checker.clause.syntax=Пункт контракта должен иметь форму arg1, …, argN -> возвращаемое-значение
inspection.contract.checker.contract.clause.never.satisfied=Пункт контракта ''{0}'' никогда не выполняется, так как его условия покрыты предыдущими контрактами
inspection.contract.checker.contract.violated=Нарушен пункт контракта ''{0}''
inspection.contract.checker.empty.constraint=Ограничение не должно быть пустым
inspection.contract.checker.inferred.notnull.parameter.notnull=Параметр ''{0}'' выведен как не-null, поэтому ''\!null'' всегда выполняется
inspection.contract.checker.inferred.notnull.parameter.null=Параметр ''{0}'' выведен как не-null, поэтому ''null'' не применим
inspection.contract.checker.method.always.fails.nontrivial=Возвращаемое значение пункта ''{0}'' можно заменить на ''fail'', так как метод всегда завершается неудачей в этом случае
inspection.contract.checker.method.always.fails.trivial=Возвращаемое значение пункта ''{0}'' можно заменить на ''fail'', так как метод всегда завершается неудачей
inspection.contract.checker.no.exception.thrown=Нарушен пункт контракта ''{0}''\: исключение не выброшено
inspection.contract.checker.notnull.parameter.notnull=Параметр ''{0}'' аннотирован как не-null, поэтому ''\!null'' всегда выполняется
inspection.contract.checker.notnull.parameter.null=Параметр ''{0}'' аннотирован как не-null, поэтому ''null'' не применим
inspection.contract.checker.parameter.count.mismatch=Метод принимает {0} параметров, тогда как пункт контракта ''{1}'' ожидает {2}
inspection.contract.checker.primitive.parameter.nullability=Параметр ''{0}'' имеет примитивный тип ''{1}'', поэтому ''{2}'' не применим
inspection.contract.checker.pure.method.mutation.contract=Чистый метод не может иметь контракт мутации
inspection.contract.checker.unknown.constraint=Ограничение должно быть одним из\: {0}. Найдено\: {1}
inspection.contract.checker.unknown.return.value=Возвращаемое значение должно быть одним из\: {0}. Найдено\: {1}
inspection.contract.checker.unreachable.contract.clause=Пункт контракта ''{0}'' недостижим\: предыдущие контракты покрывают все возможные случаи
inspection.contract.display.name=Проблемы с контрактами
inspection.convert.2.diamond.display.name=Явный тип можно заменить на '<>'
inspection.convert.2.lambda.display.name=Анонимный тип можно заменить на лямбда-выражение
inspection.data.flow.redundant.instanceof.quickfix=Заменить на проверку на null
inspection.data.flow.simplify.boolean.expression.quickfix=Упростить логическое выражение
inspection.data.flow.simplify.to.assignment.quickfix.name=Упростить до обычного присваивания
inspection.data.flow.turn.off.constant.references.quickfix=Не сообщать о значениях, которые гарантированно являются константами
inspection.data.flow.turn.off.nullable.returning.notnull.quickfix=Не сообщать о nullable методах, которые всегда возвращают не-null значение
inspection.data.flow.turn.off.true.asserts.quickfix=Не сообщать о всегда истинных утверждениях
inspection.data.flow.warn.when.reading.a.value.guaranteed.to.be.constant=Предупреждать, когда константа сохраняется в переменной
inspection.depends.on.the.java.feature=Эта проверка зависит от функции Java ''{0}'', которая доступна начиная с Java {1}.
inspection.depends.on.the.java.features=Эта проверка зависит от следующих функций Java\:
inspection.depends.on.the.java.features.minimal.version=Эти функции доступны начиная с Java {0}.
inspection.deprecated.class.usage.inspection.display.name=Использование устаревшего API в XML
inspection.deprecated.is.still.used.display.name=Устаревший член все еще используется
inspection.duplicate.throws.display.name=Дублирующиеся throws
inspection.duplicate.throws.ignore.subclassing.option=Игнорировать исключения, наследующие другие
inspection.duplicate.throws.more.general.problem=В списке throws уже есть более общее исключение ''{0}''.
inspection.duplicate.throws.problem=Дублирующиеся throws
inspection.equals.hashcode.only.one.defined.problem.descriptor=В классе определен {0}, но не определен {1}
inspection.export.results.can.be.final.description=Объявление может иметь модификатор final
inspection.expression.can.be.replaced.with.message=Выражение может быть заменено на ''{0}''
inspection.extract.method.dont.suggest.length=Не предлагать извлечение таких коротких методов
inspection.extract.method.dont.suggest.parameters=Не предлагать извлечение метода с {0} или более параметрами
inspection.extract.method.inspection.name=Метод может быть извлечен
inspection.extract.method.message=Возможно извлечь метод, возвращающий ''{0}'', из длинного окружающего метода
inspection.extract.method.nothing=ничего
inspection.extract.method.option.max.parameters=Максимальное количество параметров\:
inspection.extract.method.option.min.length=Минимальная длина кода для извлечения\:|символов
inspection.extract.method.preview.html=Извлечь {0} операторов в метод, который принимает {1} и возвращает <b>{2}</b>
inspection.field.access.not.guarded.display.name=Незащищенный доступ к полю или вызов метода
inspection.field.not.used.in.to.string.description=Метод ''{0}'' не используется в методе ''toString()''
inspection.field.not.used.in.to.string.description2=Поле ''{0}'' не используется в методе ''toString()''
inspection.field.not.used.in.to.string.display.name=Поле не используется в методе 'toString()'
inspection.fix.name.remove.scheduled.for.removal.annotation.by.attribute=Заменить @ScheduledForRemoval атрибутом 'forRemoval' в аннотации @Deprecated
inspection.i18n.quickfix.annotate=Аннотировать…
inspection.i18n.quickfix.annotate.as=Аннотировать как ''@{0}''
inspection.i18n.quickfix.annotate.element=Аннотировать {0} ''{1}''…
inspection.i18n.quickfix.annotate.element.as=Аннотировать {0} ''{1}'' как ''@{2}''
inspection.implicit.subclass.display.forClass=Класс ''{0}'' может быть неявно унаследован и не должен быть final
inspection.implicit.subclass.display.name=Final-объявление не может быть переопределено во время выполнения
inspection.implicit.subclass.extendable=Сделать ''{0}'' переопределяемым
inspection.implicit.subclass.make.class.extendable=Сделать класс ''{0}'' {1,choice,0\#|1\#и метод {2} |1<и {1} требуемых методов }расширяемым
inspection.inconsistent.language.level.display.name=Несогласованные настройки уровня языка
inspection.infinite.loop.option=Игнорировать при размещении в Thread.run
inspection.instance.guarded.by.static.display.name=Член экземпляра защищен статическим полем
inspection.invalid.comparator.method.reference.display.name=Недопустимая ссылка на метод для 'Comparator'
inspection.java.8.list.sort.display.name='Collections.sort()' можно заменить на 'List.sort()'
inspection.java.9.redundant.requires.statement.display.name=Избыточная директива 'requires' в module-info
inspection.java.module.naming=Имя модуля Java противоречит соглашению
inspection.java.module.naming.terminal.digits=Компонент имени модуля ''{0}'' не должен заканчиваться цифрами
inspection.local.can.be.final.display.name=Локальная переменная или параметр могут быть 'final'
inspection.local.can.be.final.option=Сообщать о локальных переменных
inspection.local.can.be.final.option1=Сообщать о параметрах метода
inspection.local.can.be.final.option2=Сообщать о параметрах catch
inspection.local.can.be.final.option3=Сообщать о параметрах foreach
inspection.local.can.be.final.option4=<html>Сообщать о переменных, которые неявно final<br/>(параметры multi-catch или try-with-resources)</html>
inspection.local.can.be.final.option5=Сообщать о переменных шаблона
inspection.message.code.generation.different.nullability.annotation.will.be.used=Сгенерированный код будет использовать ''@{1}'' вместо ''@{0}''
inspection.message.expression.compared.to.itself.description=Выражение сравнивается с самим собой
inspection.message.javac.quick.intersection.type.problem=Пересекающийся тип ''{0}'' не может быть инстанцирован, так как ''{1}'' является final
inspection.message.non.annotated.method.implements.non.null.method=Неаннотированный метод ''{0}'' из ''{1}'' реализует non-null метод из ''{2}''
inspection.message.non.annotated.parameter.should.not.override.non.null.parameter=Неаннотированный параметр ''{0}'' в методе ''{1}'' из ''{2}'' не должен переопределять non-null параметр из ''{3}''
inspection.message.non.null.parameter.should.not.override.non.annotated.parameter=Non-null параметр ''{0}'' в методе ''{1}'' из ''{2}'' не должен переопределять неаннотированный параметр из ''{3}''
inspection.message.non.null.parameter.should.not.override.nullable.parameter=Non-null параметр ''{0}'' в методе ''{1}'' из ''{2}'' не должен переопределять nullable параметр из ''{3}''
inspection.message.nullable.method.implements.non.null.method=Nullable метод ''{0}'' из ''{1}'' реализует non-null метод из ''{2}''
inspection.message.scheduled.for.removal.annotation.can.be.removed=Аннотация @ScheduledForRemoval может быть удалена
inspection.message.scheduled.for.removal.annotation.can.be.replaced.by.attribute=Аннотация @ScheduledForRemoval может быть заменена атрибутом 'forRemoval' в аннотации @Deprecated
inspection.module.exports.package.to.itself=Модуль экспортует/открывает пакет самому себе
inspection.name.can.be.replaced.with.long.hashcode=Можно использовать стандартный метод 'hashCode()'
inspection.name.redundant.scheduled.for.removal.annotation=Избыточная аннотация @ScheduledForRemoval
inspection.non.final.field.in.immutable.display.name=Не final поле в классе '@Immutable'
inspection.non.final.guard.display.name=Не final поле '@GuardedBy'
inspection.nullable.problems.NotNull.parameter.overrides.Nullable=Параметр с аннотацией @{0} не должен переопределять параметр с @{1}
inspection.nullable.problems.NotNull.parameter.overrides.not.annotated=Параметр с аннотацией @{0} не должен переопределять неаннотированный параметр
inspection.nullable.problems.NotNull.parameter.receives.null.literal=Параметр с аннотацией @{0} не должен получать ''null'' в качестве аргумента
inspection.nullable.problems.Nullable.NotNull.conflict=Нельзя использовать одновременно аннотации @{0} и @{1}
inspection.nullable.problems.Nullable.method.overrides.NotNull=Метод с аннотацией @{0} не должен переопределять метод с @{1}
inspection.nullable.problems.annotated.field.constructor.parameter.not.annotated=Параметр конструктора для поля с @{0} может быть аннотирован @{0}
inspection.nullable.problems.annotated.field.getter.conflict=Геттер для поля с @{0} аннотирован @{1}
inspection.nullable.problems.annotated.field.getter.not.annotated=Геттер для поля с @{0} может быть аннотирован @{0}
inspection.nullable.problems.annotated.field.setter.parameter.conflict=Параметр сеттера для поля с @{0} аннотирован @{1}
inspection.nullable.problems.annotated.field.setter.parameter.not.annotated=Параметр сеттера для поля с @{0} может быть аннотирован @{0}
inspection.nullable.problems.applied.to.package=Аннотация полного имени должна быть размещена перед последним компонентом
inspection.nullable.problems.at.class=Аннотация nullability не применима к классам
inspection.nullable.problems.at.constructor=Аннотация nullability не применима к конструкторам
inspection.nullable.problems.at.enum.constant=Аннотация nullability не применима к константам перечисления
inspection.nullable.problems.at.local.variable=Аннотация nullability не применима к локальным переменным
inspection.nullable.problems.at.reference.list=Аннотация nullability не применима к конструкциям extends/implements
inspection.nullable.problems.at.type.parameter=Аннотация nullability не применима к параметрам типа
inspection.nullable.problems.at.wildcard=Аннотация nullability не применима к типу wildcard
inspection.nullable.problems.method.overrides.NotNull=Неаннотированный метод переопределяет метод с аннотацией @{0}
inspection.nullable.problems.outer.type=Внешний тип по своей природе не может быть null
inspection.nullable.problems.parameter.overrides.NotNull=Неаннотированный параметр переопределяет параметр с @{0}
inspection.nullable.problems.primitive.type.annotation=Примитивные типы не могут быть аннотированы
inspection.nullable.problems.receiver.annotation=Параметр receiver по своей природе не может быть null
inspection.numeric.overflow.display.name=Числовое переполнение
inspection.objects.equals.can.be.simplified.display.name='Objects.equals()' можно заменить на 'equals()'
inspection.quirk.method.reference.return.type.message=Возвращаемый тип целевого метода содержит недоступный класс {0}, это вызовет IllegalAccessError во время выполнения
inspection.redundant.cast.display.name=Избыточное приведение типа
inspection.redundant.cast.methodref.descriptor=Приведение избыточно
inspection.redundant.cast.problem.descriptor=Приведение <code>{0}</code> к <code>\#ref</code> \#loc избыточно
inspection.redundant.cast.remove.quickfix=Удалить избыточное приведение типа
inspection.redundant.field.initialization.option=Предупреждать только при инициализации null
inspection.redundant.requires.statement.description=Избыточная директива ''requires {0}''.
inspection.redundant.requires.statement.fix.family=Удалить избыточную директиву 'requires'
inspection.redundant.requires.statement.fix.name=Удалить директиву ''requires {0}''
inspection.redundant.requires.statement.message.java.base.implicitly.required='java.base' требуется неявно.
inspection.redundant.requires.statement.message.module.unused=Использование пакетов модуля не найдено.
inspection.redundant.requires.statement.message.transitive.dependencies.on.can.be.used.directly=Транзитивные зависимости от ''{0}'' могут использоваться напрямую.
inspection.redundant.throws.display.name=Избыточное объявление 'throws'
inspection.redundant.throws.problem.descriptor=Объявленное исключение <code>\#ref</code> никогда не выбрасывается ни в одной реализации метода
inspection.redundant.throws.problem.descriptor1=Объявленное исключение <code>\#ref</code> никогда не выбрасывается в этом методе или его переопределяющих методах
inspection.redundant.throws.problem.descriptor2=Объявленное исключение <code>\#ref</code> никогда не выбрасывается
inspection.redundant.throws.remove.quickfix=Удалить ненужные объявления 'throws'
inspection.redundant.tostring.option.notnull.qualifier=Сообщать только когда известно, что квалификатор не null
inspection.redundant.type.display.name=Избыточные аргументы типа
inspection.redundant.type.no.generics.method.reference.problem.descriptor=Аргументы типа избыточны для ссылки на негенерический метод
inspection.redundant.type.no.generics.problem.descriptor=Аргументы типа избыточны для вызова негенерического метода
inspection.redundant.type.problem.descriptor=Явные аргументы типа могут быть выведены
inspection.redundant.type.remove.quickfix=Удалить аргументы типа
inspection.reference.anonymous.class=анонимный класс
inspection.reference.anonymous.name=анонимный ({0})
inspection.reference.default.lambda.name=лямбда
inspection.reference.default.method.reference.name=ссылка на метод
inspection.reference.default.package=<по умолчанию>
inspection.reference.implicit.class=неявный класс в файле ''{0}''
inspection.reference.implicit.constructor.name=неявный конструктор {0}
inspection.reference.jsp.holder.method.anonymous.name=<% содержимое страницы %>
inspection.reference.lambda.name=лямбда ({0})
inspection.reference.method.reference.name=ссылка на метод ({0})
inspection.requires.auto.module=Зависимости от автоматических модулей
inspection.requires.auto.module.message=Директива 'requires' для автоматического модуля
inspection.requires.auto.module.option=Подсвечивать только транзитивные зависимости
inspection.requires.auto.module.transitive=Директива 'requires transitive' для автоматического модуля
inspection.safe.varargs.detector.display.name=Возможно загрязнение кучи из параметризованного vararg типа
inspection.same.return.value.display.name=Метод всегда возвращает одно и то же значение
inspection.same.return.value.problem.descriptor=Метод <code>\#ref()</code> всегда возвращает <code>{0}</code>
inspection.same.return.value.problem.descriptor1=Метод <code>\#ref()</code> и все его переопределяющие методы всегда возвращают <code>{0}</code>
inspection.same.return.value.problem.descriptor2=Все реализации метода <code>\#ref()</code> всегда возвращают <code>{0}</code>
inspection.static.guarded.by.instance.display.name=Статический член защищен полем экземпляра или this
inspection.string.tokenizer.delimiter.display.name=Повторяющиеся разделители в 'StringTokenizer'
inspection.surround.requirenonnull.quickfix=Заменить на ''Objects.requireNonNull({0})''
inspection.suspicious.array.method.call.display.name=Подозрительный вызов метода 'Arrays'
inspection.suspicious.array.method.call.problem.arrays=Типы массивов несовместимы\: массивы всегда различны
inspection.suspicious.array.method.call.problem.element=Тип элемента несовместим с типом массива
inspection.suspicious.collections.method.calls.display.name=Подозрительный вызов метода коллекции
inspection.suspicious.collections.method.calls.problem.descriptor=''{0}'' может не содержать {2} типа ''{1}''
inspection.suspicious.collections.method.calls.problem.descriptor1=Подозрительный вызов ''{0}''
inspection.suspicious.getter.setter.field.option=Предупреждать только при наличии поля, соответствующего имени getter/setter
inspection.suspicious.integer.div.assignment.option=Сообщать о подозрительных, но возможно точных делениях
inspection.unary.plus.unary.binary.option=Сообщать только в контексте неоднозначных бинарных или унарных выражений
inspection.unknown.guard.display.name=Неизвестное поле '@GuardedBy'
inspection.unnecessary.super.qualifier.option=Игнорировать уточняющий квалификатор 'super'
inspection.unsatisfied.range.display.name=Возвращаемое значение вне объявленного диапазона
inspection.unsatisfied.range.message=Диапазон возвращаемого значения ''{0}'' находится вне объявленного диапазона ''{1}''
inspection.unsatisfied.range.message.value=Возвращаемое значение ''{0}'' находится вне объявленного диапазона ''{1}''
inspection.use.compare.method.display.name=Для сравнения чисел можно использовать метод 'compare()'
inspection.use.compare.method.fix.family.name=Заменить на единый метод сравнения
inspection.use.compare.method.option.double=Предлагать 'Double.compare()' и 'Float.compare()'
inspection.use.compare.method.turn.off.double=Не предлагать методы Double.compare() и Float.compare()
inspection.visibility.accept.quickfix=Принять предложенный уровень доступа
inspection.visibility.compose.suggestion=Может быть {0}
inspection.visibility.option.constants=Предлагать более слабую видимость для констант
inspection.visibility.option.package.private.members=Предлагать уровень видимости package-private для членов класса
inspection.visibility.package.private.top.level.classes=Предлагать уровень видимости package-private для классов верхнего уровня
inspection.visibility.private.inner.members=Предлагать 'private' для членов внутреннего класса только при обращении из внешнего класса
inspection.weaker.access.display.name=Доступ к объявлению может быть ослаблен
instance.member.guarded.by.static.0.loc=Член экземпляра защищен статическим "{0}" \#loc
instance.member.guarded.by.static.ref.loc=Член экземпляра защищен статическим \#ref \#loc
intention.add.annotation.family=Добавить аннотацию
intention.add.type.annotation.family=Добавить аннотацию типа
intention.family.name.move.annotation.to.array=Переместить аннотацию в массив
intention.family.name.move.annotation.to.upper.bound=Переместить аннотацию к верхней границе
intention.family.name.move.members.into.class=Переместить члены в класс
intention.family.name.move.members.to=Переместить члены в {0}
intention.family.name.remove.new.family.name=Удалить 'new'
intention.family.name.remove.repeating.call=Удалить повторяющийся вызов
intention.family.name.replace.with.expression=Заменить выражением
intention.family.name.replace.with.unnamed.pattern=Заменить безымянным шаблоном
intention.name.do.not.report.conditions.with.possible.side.effect=Не сообщать об условиях с возможными побочными эффектами
intention.name.ignore.exception=Игнорировать исключение ''{0}''
intention.name.make.variable.effectively.final=Сделать переменную effectively final
intention.name.move.members.into.class=Переместить {0, choice, 1\#член|2\#члена|3\#члена|4\#члена|5\#членов} в класс
intention.name.qualify.expression=Уточнить выражение {0} с помощью ''{1}''
intention.name.remove.repeating.call=Удалить повторяющийся вызов ''{0}()''
intention.text.remove.annotation=Удалить
make.0.default.annotation=Сделать "{0}" аннотацией по умолчанию
make.default.the.last.case.family.name=Сделать 'default' последним case
make.final.and.annotate.as.safevarargs=Сделать final и аннотировать как '@SafeVarargs'
message.class.inaccessible=Класс ''{0}'' недоступен здесь
message.class.inaccessible.from.module=Класс ''{0}'' недоступен из модуля ''{1}''
method.reference.mapped.to.comparator=Ссылка на метод, сопоставленная с интерфейсом 'Comparator', не выполняет контракт 'Comparator'
missorted.imports.inspection.display.name=Неправильно отсортированные импорты
module.0.with.language.level.1.depends.on.module.2.with.language.level.3=Модуль {0} с уровнем языка {1} зависит от модуля {2} с уровнем языка {3}
move.0.to.the.beginning=Переместить ''{0}'' в начало
move.annotations.to.package.info.file.family.name=Переместить аннотации в 'package-info.java'
move.to.front=Переместить вперед
mutability.modifiable=изменяемый
mutability.must.not.modify=входной параметр, который не должен изменяться
mutability.unknown=неизвестно
mutability.unmodifiable=неизменяемый
mutability.unmodifiable.view=неизменяемое представление
mutation.signature.problem.invalid.token=Недопустимый токен\: {0}; поддерживаются ''this'', ''io'', ''param1'', ''param2'' и т.д.
mutation.signature.problem.parameter.has.immutable.type=Параметр \#{0} имеет неизменяемый тип ''{1}''
mutation.signature.problem.reference.to.parameter.invalid=Ссылка на параметр \#{0} недействительна
mutation.signature.problem.static.method.cannot.mutate.this=Статический метод не может изменять 'this'
navigate.to.overridden.methods.title=Переопределяющие методы {0}
non.final.field.code.ref.code.in.immutable.class.loc=Не final поле <code>\#ref</code> в классе @Immutable \#loc
non.final.guarded.by.field.0.loc=Не final поле с @GuardedBy "{0}" \#loc
non.final.guarded.by.field.ref.loc=Не final поле с @GuardedBy \#ref \#loc
non.null.type.argument.is.expected=Ожидается non-null аргумент типа
notification.content.cannot.move.file=Невозможно переместить ''{0}'' в ''{1}''\: {2}
notification.file.system.issue=Проблема с файловой операцией
nullability.non.null=non-null
nullability.null=null
nullability.nullable=nullable
nullable.stuff.error.overriding.notnull.with.nullable=Переопределение коллекции non-null элементов коллекцией nullable элементов
nullable.stuff.error.overriding.nullable.with.notnull=Переопределение коллекции nullable элементов коллекцией non-null элементов
nullable.stuff.problems.overridden.method.parameters.are.not.annotated=Параметры переопределяющего метода не аннотированы
nullable.stuff.problems.overridden.methods.are.not.annotated=Переопределяющие методы не аннотированы
parameter.can.be.null=Параметр может быть null
parameter.is.always.not.null=Параметр всегда non-null
possible.heap.pollution.from.parameterized.vararg.type.loc=Возможно загрязнение кучи из параметризованного vararg типа \#loc
processing.method.usages=Обработка использований метода…
progress.title.searching.for.overridden.methods=Поиск переопределённых методов
provided.type=Предоставленный
qualify.0=Уточнить {0}
qualify.with.0.this=Уточнить с помощью {0}.this
reassign.variable.display.name=Переприсвоенная переменная
redundant.block.marker=Избыточный маркер блока
remove.annotation=Удалить аннотацию
remove.block.marker.comments=Удалить комментарий маркера блока
remove.dependency=Удалить зависимость
remove.left.side.of.assignment=Удалить левую часть присваивания
remove.switch.branch.0=Удалить ветвь switch ''{0}''
remove.switch.label=Удалить метку switch
remove.switch.label.0=Удалить метку switch ''{0}''
replace.0.with=Заменить ''{0}'' на '\='
replace.anonymous.class.with.lambda.alternative=Заменить анонимный класс на лямбда-выражение
replace.get.class.with.class.literal=Заменить getClass() на литерал .class
replace.operator.assignment.with.assignment=Заменить присваивание с оператором на простое присваивание
replace.stringtokenizer.delimiters.parameter.with.unique.symbols=Удалить дубликаты из аргумента 'delimiters'
replace.var.with.explicit.type=Заменить 'var' на явный тип
replace.with.0=Заменить на {0}
replace.with.boolean.equals=Заменить на Boolean.equals
replace.with.comparator=Заменить на компаратор
replace.with.constant.value=Заменить константным значением
replace.with.constant.value.title=Заменить константным значением
replace.with.expression.lambda=Заменить лямбда-выражением
replace.with.lambda=Заменить на лямбда
replace.with.stream.api.fix=Свернуть цикл с помощью stream ''{0}()''
report.suspicious.but.possibly.correct.method.calls=Сообщать о подозрительных, но возможно правильных вызовах методов  [&R]
report.when.interface.is.not.annotated.with.functional.interface=Сообщать, когда интерфейс не аннотирован @FunctionalInterface
required.type=Требуемый тип
scope.package=Пакет {0}
searching.for.overriding.methods=Поиск переопределяющих методов
service.click.to.navigate=Нажмите для перехода
service.provides=Предоставляет сервис
service.uses=Использует сервис
special.field.array.length=Длина массива
special.field.collection.size=Размер
special.field.consumed.stream=Связанный или использованный поток
special.field.enum.ordinal=Порядковый номер enum
special.field.instantiable.class=Инстанцируемый класс
special.field.optional.value=Опциональное значение
special.field.string.length=Длина строки
special.field.unboxed.value=Распакованное значение
statement.lambda.can.be.replaced.with.expression.lambda=Лямбда-выражение с блоком можно заменить на лямбда-выражение с выражением
static.inheritrance.fix.replace.progress=Замена использований {0}
static.member.guarded.by.instance.0.loc=Статический член, защищенный экземпляром "{0}" \#loc
static.member.guarded.by.instance.ref.loc=Статический член, защищенный экземпляром \#ref \#loc
subclasses.search.progress.title=Поиск переопределённых методов
suggest.package.private.visibility.level.for.classes.in.exported.packages.java.9=Предлагать уровень видимости package-private для классов в экспортуемых пакетах (Java 9+)
suppress.all.for.class=Подавить все инспекции для класса
suppress.for.parameter=Подавить для параметра
suppress.for.statement.with.comment=Подавить для оператора с комментарием
suppress.inspection.class=Подавить для класса
suppress.inspection.field=Подавить для поля
suppress.inspection.member=Подавить для члена
suppress.inspection.method=Подавить для метода
suppress.inspection.module=Подавить для объявления модуля
suspected.module.dependency.problem.descriptor=Модуль ''{0}'' не зависит от модуля ''{1}''. При этом ''{1}'' не проверялся на экспортуемые зависимости, необходимые для области ''{2}''
suspicious.invocation.handler.implementation.display.name=Подозрительная реализация 'InvocationHandler'
suspicious.invocation.handler.implementation.method.unused.message=Метод никогда не используется в 'invoke()'\: маловероятно, что 'hashCode()', 'equals()' и 'toString()' реализованы правильно
suspicious.invocation.handler.implementation.null.returned.for.toString.message=При проксировании метода 'toString()' может быть возвращен null\: это не рекомендуется
suspicious.invocation.handler.implementation.null.returned.message=При проксировании метода ''{0}()'' может быть возвращен null\: это может вызвать NullPointerException
suspicious.invocation.handler.implementation.type.mismatch.message=При проксировании метода ''{0}()'' может быть возвращен несовместимый тип\: требуется\: {1}; получено\: {2}
text.raw.ctor.reference.with.type.parameters=Сырая ссылка на конструктор с явными параметрами типа
text.shebang.mechanism.in.java.files.not.permitted=Механизм shebang в .java файлах не разрешен
text.unused.import.in.template=Неиспользуемый импорт (указан в шаблоне)
type.constraint.assignability.explanation.definitely.inconvertible=Известно, что {0} является {1}, что точно несовместимо с {2}
type.constraint.assignability.explanation.exact={0} уже известен как {1}
type.constraint.assignability.explanation.exact.not.subtype=Тип {0} в точности {1}, который не является подтипом {2}
type.constraint.assignability.explanation.exact.subtype=Тип {0} в точности {1}, который является подтипом {2}
type.constraint.assignability.explanation.not.instance.of=Известно, что {0} не является {1}
type.constraint.assignability.explanation.not.instance.of.supertype=Известно, что {0} не является {1}, который является супертипом {2}
type.constraint.assignability.explanation.subtype.of.subtype={0} уже известен как {1}, который является подтипом {2}
type.mismatch.reason=причина\: {0}
uast.language.display.name=JVM языки
unknown.guardedby.reference.0.loc=Неизвестная ссылка @GuardedBy "{0}" \#loc
unknown.guardedby.reference.ref.loc=Неизвестная ссылка @GuardedBy \#ref \#loc
unnecessary.module.dependency.display.name=Ненужная зависимость модуля
unnecessary.module.dependency.problem.descriptor=Исходный код модуля ''{0}'' не зависит от исходного кода модуля ''{1}''
unused.import.display.name=Неиспользуемый импорт
unused.import.statement=Неиспользуемый оператор import
unused.library.display.name=Неиспользуемая библиотека
unused.library.problem.descriptor=Неиспользуемая библиотека ''{0}''
unused.library.roots.problem.descriptor=Неиспользуемые корни {0} из библиотеки ''{1}''
var.can.be.replaced.with.explicit.type='var' можно заменить явным типом
vararg.method.call.with.50.poly.arguments=Вызов vararg-метода с более чем 50 полиморфными аргументами может замедлить компиляцию и анализ