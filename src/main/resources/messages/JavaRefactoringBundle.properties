0.already.contains.field.1={0} уже содержит поле {1}
0.already.contains.inner.class.named.1={0} уже содержит внутренний класс с именем {1}
0.already.has.parameter.named.1.use.this.name.anyway={0} уже имеет параметр с именем ''{1}''.\nИспользовать это имя anyway?
0.contains.call.with.null.argument.for.parameter.1={0} содержит вызов с null-аргументом для параметра {1}
0.implements.1={0} реализует {1}.
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0} является {1} и не будет доступен из {2}.
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0} является частью иерархии методов. Удалить несколько параметров?
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0} является частью иерархии методов. Удалить несколько параметров типа?
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0} является интерфейсом.\nРеализация метода будет добавлена во все классы, напрямую реализующие интерфейс.\nПродолжить?
0.is.an.interface.that.has.no.implementing.classes={0} является интерфейсом без реализующих классов
0.is.not.a.legal.java.identifier=''{0}'' не является допустимым идентификатором Java
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0} недоступен из {1}. Значение введенного параметра в этом вызове метода будет некорректным.
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0} не инициализовано в объявлении. Такие поля не допускаются в интерфейсах.
0.is.not.static.it.cannot.be.moved.to.the.interface={0} не является статическим. Его нельзя переместить в интерфейс
0.is.not.visible.to.members.of.1={0} не видим для членов {1}
0.is.used.for.writing.in.1={0} используется для записи в {1}
0.refactoring.is.supported.only.for.final.fields=Рефакторинг {0} поддерживается только для final полей
0.upcasts.an.instance.of.1.to.2={0} выполняет upcast экземпляра {1} к {2}
0.uses.1.of.an.instance.of.a.2={0} использует {1} экземпляра {2}
0.uses.1.which.needs.class.instance={0} использует {1}, которому требуется экземпляр класса
0.uses.a.package.local.1={0} использует package-private {1}
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0} использует нестатический {1}, который не передается как параметр
0.will.be.inaccessible.from.1={0} станет недоступным из {1}
0.will.become.inaccessible.from.1={0} станет недоступным из {1}
0.will.hide.renamed.1={0} скроет переименованный {1}
0.will.no.longer.be.canonical.constructor=Конструктор больше не будет каноническим
0.will.no.longer.be.record.component.accessor={0} больше не будет геттером {1}
0.will.no.longer.override.1={0} больше не будет переопределять {1}
0.will.not.be.accessible.from.1.after.inlining={0} станет недоступным из {1} после встраивания
0.will.override.renamed.1={0} переопределит переименованный {1}
a.package.local.class.0.will.no.longer.be.accessible.from.1=Package-local класс {0} больше не будет доступен из {1}
accept.signature.change=Принять изменение сигнатуры
add.object.as.a.parameter.to.constructors.with.name=Добавить &объект как параметр в конструкторы с именем\:
add.parameters.for.fields=Добавить параметры для &полей\:
add.parameters.for.fields.to.constructors=Добавить параметры для &полей в конструкторы\:
all.candidate.variables.have.types.not.in.project=Все переменные-кандидаты (параметры метода и поля содержащего класса) имеют типы, отсутствующие в проекте
all.candidate.variables.have.unknown.types=Все переменные-кандидаты (параметры метода и поля содержащего класса) имеют неизвестные типы
all.invocations.and.remove.the.method=Встроить &все использования, удалить метод
all.invocations.in.project=Встроить &все использования в проекте
all.invocations.keep.the.method=Встроить все использования, &сохранить метод
all.references.and.remove.super.class=Встроить &все ссылки и удалить класс
all.references.and.remove.the.class=Встроить &все ссылки и удалить класс
all.references.and.remove.the.field=Встроить &все использования, удалить поле
all.references.keep.field=Встроить все использования, &сохранить поле
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=Все эти каталоги будут перемещены, и все ссылки на {0}\nбудут изменены.
analyze.and.replace.usages=Анализовать и заменить использования
analyze.module.conflicts=Анализовать конфликты модулей…
annotate.field.as.nonnls.checkbox=Аннотировать &поле как @NonNls
anonymous.class.description=анонимный класс, производный от {0}
anonymous.class.text=Анонимный класс
anonymous.to.inner.enum.constant.cannot.refactor.message=Константу перечисления нельзя преобразовать во внутренний класс
anonymousToInner.class.name.label.text=Имя класса\:
anonymousToInner.make.class.static.checkbox.text=Сделать класс &статическим
anonymousToInner.no.inner.class.name=Необходимо указать имя класса
anonymousToInner.parameters.panel.border.title=Параметры конструктора
anonymousToInner.refactoring.name=Преобразовать анонимный в внутренний
auto.rename.module.dialog.description=Переименовать Java модули со следующими именами в\:
auto.rename.module.dialog.title=Переименовать Java модули
auto.rename.module.entity=Java модуль
automatic.overload.renamer.entity.name=Перегрузка
automatic.parameter.renamer.entity.name=Параметр
boolean.method.result=результат логического метода
can.t.restore.context.for.method.extraction=Невозможно восстановить контекст для извлечения метода
cannot.find.or.create.destination.directory=Невозможно найти или создать целевой каталог
cannot.introduce.field.in.interface=Неконстантные поля не допускаются в интерфейсе.
cannot.move=Невозможно переместить
cannot.move.inner.class.0.into.itself=Невозможно переместить внутренний класс {0} в самого себя
cannot.move.package.into.itself=Невозможно переместить пакет в самого себя
caret.position.warning.message=Курсор должен быть установлен на тип поля, переменной, метода или параметра метода для рефакторинга
change.method.signature.action.name=Изменить сигнатуру метода
change.signature.default.value.missing.warning.message=Отсутствует значение по умолчанию. Вызовы метода будут содержать пустые значения вместо нового значения параметра.
change.signature.use.any.checkbox=&Использовать любую переменную
changeClassSignature.Type.parameter.can.not.be.primitive=Параметр типа не может быть примитивным
changeClassSignature.already.contains.type.parameter=''{0}'' уже содержит параметр типа ''{1}''
changeClassSignature.bad.value=Неверное значение {0}\: ''{1}'' для параметра ''{2}''
changeClassSignature.class.label.text=Изменить сигнатуру <code>{0}</code>.
changeClassSignature.no.type.parameters=Класс не может иметь параметры типа
changeClassSignature.parameters.panel.border.title=Параметры\:
changeClassSignature.refactoring.name=Изменить сигнатуру класса
changeSignature.bound.value.column=Связанное значение
changeSignature.cannot.resolve.return.type=Невозможно разрешить тип возвращаемого значения ''{0}''.\nПродолжить?
changeSignature.contract.converter.can.not.update.annotation=Аннотация @Contract не может быть обновлена автоматически\: {0}
changeSignature.contract.converter.definition.error=Ошибка в определении контракта\: {0}
changeSignature.contract.converter.external.annotations=Автоматическое обновление внешних аннотаций не поддерживается
changeSignature.contract.converter.inherited.annotation=Аннотация унаследована от базового метода
changeSignature.contract.converter.invalid.clause=Недопустимое условие контракта ''{0}''
changeSignature.contract.converter.invalid.return.reference=Недопустимая ссылка в возвращаемом значении\: {0}
changeSignature.contract.converter.mutation.contract=Аннотация содержит контракт мутации
changeSignature.contract.converter.parameter.removed=Параметр ''{0}'' был удален, но условие контракта ''{1}'' зависит от него
changeSignature.contract.converter.return.parameter.removed=Параметр ''{0}'' был удален, но условие контракта ''{1}'' возвращает его
changeSignature.default.value.column=Значение по умолчанию
changeSignature.empty.callee.method.text=Здесь будет показан текст вызываемого метода
changeSignature.empty.caller.method.text=Здесь будет показан текст вызывающего метода с подсвеченным вызовом вызываемого метода
changeSignature.exception.caller.chooser=Выберите методы для распространения новых исключений
changeSignature.exceptions.panel.border.title=Исключения
changeSignature.exceptions.wont.propagate=Рекурсивное распространение изменений исключений не будет выполнено
changeSignature.no.return.type=Не указан тип возвращаемого значения
changeSignature.no.type.for.exception=Укажите тип для исключения
changeSignature.no.type.for.parameter=Укажите тип {0} для параметра ''{1}''
changeSignature.not.throwable.type=Неверный тип ''{0}'' для исключения, должен расширять java.lang.Throwable
changeSignature.processing.changes.title=Обработка изменений…
changeSignature.propagate.exceptions.title=Распространить исключения [&X]…
changeSignature.use.any.var=Использовать любую переменную.
changeSignature.validating.title=Проверка…
changeSignature.vararg.not.last=Vararg параметр должен быть последним в сигнатуре метода
changeSignature.wrong.return.type=Неверный тип возвращаемого значения\: ''{0}''
changeSignature.wrong.type.for.exception=Неверный тип\: ''{0}'' для исключения
changeSignature.wrong.type.for.parameter=Неверный тип\: ''{0}'' для параметра ''{1}''
checking.conflicts=Проверка конфликтов…
choose.the.ones.you.want.to.be.deleted=Выберите методы, которые нужно удалить
class.0.already.exists=Класс {0} уже существует
class.0.is.not.accessible.from.target.1=Класс {0} недоступен из целевого {1}
class.0.not.found=Класс {0} не найден.
class.body.description=тело класса {0}
class.description={1, choice, 0\#|1\#локальный }класс {0}
class.does.not.exist.in.the.project=Класс не существует в проекте. Создать его?
class.does.not.have.base.classes.or.interfaces=Класс {0} не имеет базовых классов или интерфейсов
class.does.not.have.implicit.default.constructor=Класс {0} не имеет неявного конструктора по умолчанию
class.has.been.successfully.created=Класс {0} успешно создан.
class.initializer.description={0, choice, 0\#статический |1\#}инициализатор
class.is.abstract={0} является абстрактным.
class.is.anonymous.warning.message=Рефакторинг невозможен, так как анонимные классы не могут иметь подклассов
class.is.final.warning.message=Рефакторинг невозможен, так как класс является final
class.is.interface={0} является интерфейсом.
class.is.never.used=Класс никогда не используется
class.name.prompt=Имя класса [&N]\:
collect.overloads=Сбор перегрузок…
comments.elements.header=Найдены вхождения в комментариях, строках и некодовых файлах {0}
constructor.being.refactored.is.used.in.initializer.of.0=Рефакторируемый конструктор используется в инициализаторе {0}. Нестатическая фабрика внутреннего класса {1} не может быть использована в этом контексте. Результирующий код не скомпилируется.
constructor.description=конструктор {0}
constructor.with.builder.new.setter.prefix.dialog.message=Новый префикс сеттера\:
constructor.with.builder.parameters.to.pass.to.the.builder.title=Параметры для передачи в билдер
constructor.with.builder.rename.setters.prefix.action.name=Переименовать префикс сеттеров
convert.anonymous.or.local.to.inner.fix.name=Преобразовать анонимный или локальный класс во внутренний
convert.anonymous.to.inner.action.name=Преобразовать анонимный в внутренний…
convert.anonymous.to.inner.fix.name=Преобразовать анонимный класс во внутренний
convert.local.to.field.title=Преобразовать локальную переменную в поле
convert.local.to.inner.action.name=Преобразовать локальный во внутренний…
convert.local.to.inner.fix.name=Преобразовать локальный класс во внутренний
convert.to.instance.method.title=Преобразовать в метод экземпляра
convert.to.record.accessor.more.accessible={0} является {1}. Преобразование в record сделает соответствующий неявный метод доступа {2}.
convert.to.record.ctor.more.accessible={0} является {1}. Преобразование в record сделает соответствующий неявный канонический конструктор record {2}.
convert.to.record.title=Преобразовать в Record класс
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=Не найден целевой класс для метода экземпляра\: не найден параметр метода с типом, ссылающимся на класс в проекте.
convertToInstanceMethod.all.reference.type.parameters.have.unknown.types=Не найден целевой класс для метода экземпляра\: неизвестные типы параметров метода.
convertToInstanceMethod.method.is.not.static=Метод {0} не является статическим
convertToInstanceMethod.no.default.ctor=Кроме того, содержащий класс не имеет конструктора по умолчанию.
convertToInstanceMethod.no.parameters.with.reference.type=Нет параметров ссылочного типа.
copy.class.clone.0.1=Клоновать {0} {1}
copy.class.copy.0.1=Копировать {0} {1}
copy.handler.clone.class=Клоновать класс
copy.handler.copy.class=Копировать класс
copy.handler.copy.class.with.dialog=Копировать класс…
copy.handler.copy.classes.with.dialog=Копировать классы…
current.class=текущий класс
dataflow.to.here.expand.progress=Разворачиваются все узлы… {0}
dataflow.to.here.group.by.leaf.action.description=Определить, может ли null попасть в это выражение
dataflow.to.here.group.by.leaf.action.text=Группировать по null-значению листового выражения{0, choice, 1\#|2\# (Выполняется анализ)}
dataflow.to.here.variable.dereferenced.tooltip=Переменная разыменована
declare.final=Объявить final [&F]
declare.generated.annotations=Сгенерировать аннотации [&G]
declare.static.checkbox=Объявить static [&S]
declare.static.pass.fields.checkbox=Объявить static (передавать поля как параметры) [&S]
declare.var.type=Объявить тип переменной [&V]
declare.varargs.checkbox=Объявить varargs [&A]
default.visibility.border.title=Видимость по умолчанию
delete.variable.declaration=Удалить объявление переменной [&D]
destination.directory.does.not.correspond.to.any.package=Целевая директория не соответствует никакому пакету
destination.package=Целевой пакет [&P]\:
dialog.message.0.would.hide.which.1.used.by.moved.2={0} скроет {1}, который используется перемещенным {2}.
dialog.message.caret.should.be.inside.method.or.constant=Курсор должен находиться внутри метода или константы
dialog.message.confirmation.to.process.only.implementation=Найдена реализация абстрактного метода\:<br><br><b>{0}</b><br><br>Выполнить встраивание этой реализации?
dialog.message.enum.constant.0.won.t.be.compilable.in.1={0} не будет компилироваться после перемещения в {1}.
dialog.message.field.doesnt.have.initializer=Поле {0} не имеет инициализатора
dialog.message.moving.directories.to=Перемещение директорий в ''{0}''
dialog.message.non.constant.will.not.be.compilable.in.interface=Непостоянное {0} не будет компилироваться после перемещения в интерфейс.
dialog.message.overriding.methods.with.weaken.visibility=Понизить также видимость переопределяющих методов до ''{0}''?
dialog.message.replace.duplicates.works.with.constants.only=Замена дубликатов работает только с константами
dialog.message.static.class.initializers.are.not.allowed.in.interfaces=Статические инициализаторы класса не разрешены в интерфейсах.
dialog.title.analyze.code.fragment.to.extract=Анализ кода для извлечения…
dialog.title.confirm.move=Подтвердить перемещение
dialog.title.move.directory.to.source.root=Переместить директорию в корень исходников
dialog.title.resolving.method.implementation=Определение реализации метода
different.name.expected=Ожидается другое имя
directory.0.already.contains.1.named.2=Директория {0}\nуже содержит {1} с именем ''{2}''
directory.0.already.contains.a.file.named.1=Директория {0}\nуже содержит файл с именем ''{1}''
do.not.replace=Не заменять [&N]
do.not.show.this.message.in.the.future=Больше не показывать это сообщение [&D]
do.you.want.to.process.overriding.methods.with.covariant.return.type=Обработать переопределяющие методы\nс ковариантным типом возвращаемого значения?
edit.migration.entry.title=Редактировать правило миграции класса/пакета
edit.migration.map.ok.button=Сохранить
edit.migration.map.title.existing=Редактировать карту миграции
edit.migration.map.title.new=Новая карта миграции
element.will.no.longer.be.accessible={0} больше не будет доступен из {1}
encapsulate.fields..encapsulated.fields.visibility.border.title=Видимость инкапсулированных полей
encapsulate.fields..package.local.radio=Package local [&C]
encapsulate.fields.accessors.visibility.border.title=Видимость методов доступа
encapsulate.fields.command.name=Инкапсуляция полей в {0}
encapsulate.fields.encapsulate.border.title=Инкапсуляция
encapsulate.fields.existed.accessor.hidden=Уже существует {0}, который будет скрыт сгенерированным методом доступа
encapsulate.fields.existed.accessor.hides.generated=Уже существует {0}, который скроет сгенерированный аксессор для {1}
encapsulate.fields.expression.type.is.used=Невозможно продолжить с постфиксным/префиксным выражением, когда используется его результирующий тип
encapsulate.fields.field.column.name=Поле
encapsulate.fields.fields.to.be.encapsulated=Поля для инкапсуляции
encapsulate.fields.fields.to.encapsulate.border.title=Поля для инкапсуляции
encapsulate.fields.get.access.checkbox=Доступ на чтение  [&G]
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.getter.exists=Уже существует метод {0}, который отличается от геттера {1} только возвращаемым типом
encapsulate.fields.no.target=Не найдено элементов для инкапсуляции
encapsulate.fields.nothing.todo.warning.message=В классе нет полей для инкапсуляции
encapsulate.fields.private.radio=Приватный [&I]
encapsulate.fields.protected.radio=Protected [&T]
encapsulate.fields.refactoring.cannot.be.applied.to.interface=Рефакторинг инкапсуляции полей нельзя применить к интерфейсу
encapsulate.fields.set.access.checkbox=Доступ на запись  [&S]
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.setter.exists=Уже существует метод {0}, который отличается от сеттера {1} только возвращаемым типом
encapsulate.fields.title=Инкапсуляция полей
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=Использовать аксессоры, даже если поле доступно
entity.name.accessor=Аксессор
entity.name.constructor.parameter=Параметр
entity.name.inheritor=Наследник
entity.name.test=Тест
entity.name.variable=Переменная
enum.constant.description=константа перечисления {0}
enum.description={1, choice, 0\#|1\#локальное }перечисление {0}
error.cannot.resolve=Не удаётся разрешить {0}
error.incorrect.data=Некорректные данные
error.not.supported.for.jsp=Рефакторинг {0} не поддерживается для JSP
error.not.supported.for.local=Класс, расширяющий локальный класс, нельзя преобразовать во внутренний класс
error.not.supported.for.package.info=Рефакторинг {0} не поддерживается для package-info.java
error.wrong.caret.position.anonymous=Курсор должен находиться внутри анонимного или локального класса для рефакторинга
error.wrong.caret.position.constructor=Курсор должен находиться внутри конструктора для рефакторинга
error.wrong.caret.position.local.or.expression.name=Курсор должен находиться на имени локальной переменной или выражения для рефакторинга
error.wrong.caret.position.method=Курсор должен находиться внутри метода для рефакторинга
error.wrong.name.input=Неверное имя\: {0}
expand.method.reference.warning=Метод используется в одной или нескольких ссылках на метод. Продолжение преобразует эти ссылки в лямбда-выражения.
expression.result=результат выражения
extract.chained.constructor.checkbox=Извлечь цепочку конструкторов  [&C]
extract.delegate.as.enum.checkbox=Извлечь как enum
extract.delegate.create.nested.checkbox=Создать вложенный класс
extract.delegate.generate.accessors.checkbox=Сгенерировать аксессоры [&G]
extract.delegate.unable.create.warning.message=Невозможно создать класс с указанным именем
extract.method.checkbox.annotate=Аннотировать
extract.method.checkbox.make.static=Сделать статическим
extract.method.checkbox.make.static.and.pass.fields=Сделать статическим и передать поля
extract.method.conflict.parameter=Конфликтующее имя параметра\: {0}
extract.method.conflict.variable=Переменная с именем {0} уже определена в выбранной области
extract.method.control.flow.analysis.failed=Код содержит синтаксические ошибки. Невозможно выполнить необходимый анализ.
extract.method.dialog.separator.parameters=Параметры [&P]
extract.method.error.annotation.value=Невозможно извлечь метод из значения аннотации
extract.method.error.class.not.found=Выбранный блок должен быть частью java-класса.
extract.method.error.class.outside.defined=Локальный класс определен вне выбранного блока.
extract.method.error.class.outside.used=Локальный класс используется вне выбранного блока.
extract.method.error.local.class.defined.outside=Невозможно извлечь метод, так как выбранный фрагмент кода использует локальные классы, определённые вне фрагмента
extract.method.error.local.class.used.outside=Невозможно извлечь метод, так как выбранный фрагмент кода определяет локальные классы, используемые вне фрагмента
extract.method.error.local.class.variable.used.outside=Невозможно извлечь метод, так как выбранный фрагмент кода определяет переменную типа локального класса, используемую вне фрагмента
extract.method.error.make.static=Не удалось сделать статическим
extract.method.error.many.exits=Имеется несколько точек выхода.
extract.method.error.many.finals=Присутствует присваивание final-полю.
extract.method.error.many.outputs=Имеется несколько переменных для возврата.
extract.method.error.method.conflict=Метод с такой же сигнатурой уже существует
extract.method.error.prefix=Невозможно извлечь метод.
extract.method.error.variable.in.expression=Внутри выбранного выражения есть переменная для возврата.
extract.method.error.wrap.many.outputs=В выбранном блоке кода несколько выходных переменных.\nМетод можно извлечь, если объединить их в {0}.
extract.method.error.wrap.many.outputs.class=единый объект
extract.method.error.wrap.many.outputs.record=новую запись
extract.method.gotit.navigation.header=Хотите изменить сигнатуру метода?
extract.method.gotit.navigation.message=Перейдите к объявлению метода\: <br/>{0} имя метода или нажмите {1}.
extract.method.gotit.signature.header=Изменить сигнатуру метода
extract.method.gotit.signature.message=<html><p style\=''margin-bottom\:3px;''>1. Отредактируйте сигнатуру</p><p style\=''margin-bottom\:3px;''>2. Обновите использования\: нажмите на значок на полях или нажмите {0}</p><p><font color\=gray>Для изменения порядка параметров используйте {1} или {2}.</font></p></html>
extract.method.link.label.more.options=Дополнительные опции
extract.method.object=Извлечь объект метода
extract.method.object.anonymous.make.varargs.option=Сделать varargs [&V]
extract.method.object.class.name=Имя класса [&C]\:
extract.method.object.create.anonymous.class=Создать анонимный класс [&A]
extract.method.object.create.inner.class=Создать внутренний класс [&I]
extract.method.object.inner.class.visibility=Видимость\:
extract.method.object.inner.make.static.option=Сделать статическим [&S]
extract.method.object.inner.make.varargs.option=Сделать varargs [&V]
extract.method.object.inner.visibility.package.local=package local [&K]
extract.method.object.inner.visibility.private=private [&V]
extract.method.object.inner.visibility.protected=protected [&O]
extract.method.object.inner.visibility.public=public [&B]
extract.method.object.method.name=Имя метода [&M]\:
extract.method.object.parameters=Параметры
extract.method.object.signature.preview=Предпросмотр сигнатуры
extract.method.object.suggestion=Хотите извлечь объект метода?
extract.method.preview.node.invalid.prefix=Недопустимый 
extract.method.progress.replace.duplicates=Замена дубликатов
extract.method.progress.search.duplicates=Поиск дубликатов
extract.parameters.to.replace.duplicates=Извлечь параметры для замены дубликатов
extract.subclass.command=Извлечь подкласс
extractSuper.rename.original.class.to=Переименовать исходный класс в\:  [&R]
extractSuperInterface.javadoc=JavaDoc
factory.method.name.label=Имя фабричного метода\:
failed.to.re.run.refactoring=Не удалось повторно запустить рефакторинг
field.0.is.already.defined.in.the.1=Поле {0} уже определено в {1}
field.0.is.never.used=Поле {0} никогда не используется
field.0.is.not.accessible=Поле {0} недоступно из {1}
field.0.will.hide.field.1.of.the.base.class=Поле {0} скроет \nполе {1} базового {2}
field.0.won.t.be.initialized.already.in.class.initializer=Поле ''{0}'' не будет инициализовано внутри инициализатора класса
field.declaration.radio=Объявление поля  [&D]
field.description=поле {0}
field.name=Имя поля  [&F]\:
fields.to.be.refactored.should.belong.to.the.same.class=Рефакторируемые поля должны принадлежать одному классу
functional.interface.broken=Функциональное выражение требует, чтобы функциональный интерфейс имел ровно один метод
generate.getter.for.delegated.component=Сгенерировать getter для делегированного компонента  [&G]
generate.module.descriptors.analysing.message=Анализ зависимостей
generate.module.descriptors.build.required.message=Невозможно сгенерировать дескрипторы модулей, так как проект еще не собран
generate.module.descriptors.collecting.message=Сбор зависимостей
generate.module.descriptors.command.title=Сгенерировать дескрипторы module-info
generate.module.descriptors.io.exceptions.message=Проблема при чтении файлов модуля {0}
generate.module.descriptors.no.suitable.modules.message=Не найдено модулей, которые могут содержать module-info
generate.module.descriptors.preparing.message=Подготовка кода
generate.module.descriptors.rebuild.message=Для более точного расчета зависимостей необходимо собрать проект.\nНачать сборку перед генерацией дескрипторов module-info?
generate.module.descriptors.scanning.message=Сканирование результатов компиляции
generate.module.descriptors.title=Сгенерировать дескрипторы модулей
getter.and.setter.methods.found.for.the.field.0=Для поля {0} найдены методы getter и setter.\nТакже {1} их?
getter.method.found.for.the.field.0=Для поля {0} найден метод getter. Также {1} getter?
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0} не нашла дубликатов
ignore.button=Игнорировать
implicit.last.parameter.warning=Неявный последний параметр не должен быть удален
infer.class.type.args.warning=Невозможно вывести аргументы типа класса. При продолжении будет создан сырой {0}
information.title=Информация
initializer.for.variable.cannot.be.a.constant.initializer=Инициализатор для переменной {0} не может быть константным
inline.action.name=Встроить
inline.anonymous.conflict.progress=Поиск наследников класса "{0}"…
inline.class.elements.header=Встраиваемый класс
inline.conflicts.progress=Проверка возможности встраивания…
inline.constant.field.not.supported.for.enum.constants={0} не поддерживается для констант перечисления
inline.element.unknown.header=Неизвестный элемент
inline.field.action.name=Встроить поле…
inline.field.command=Встроить поле {0}
inline.field.elements.header=Встраиваемое поле
inline.field.field.name.label=Встроить поле ''{0}''\:
inline.field.field.occurrences=Встроить поле ''{0}'' с {1} {1, choice, 1\#использованием|2\#использованиями}\:
inline.field.initializer.is.not.accessible=Инициализатор поля ссылается на {0}, который недоступен в {1}
inline.field.title=Встраивание поля
inline.field.used.in.javadoc=Встраиваемое поле используется в javadoc
inline.field.used.in.reflection=Встраиваемое поле используется рефлексивно
inline.local.unable.try.catch.warning.message=Невозможно встроить за пределами блока try/catch
inline.local.used.as.resource.cannot.refactor.message=Переменная используется как ссылка на ресурс
inline.local.variable.declared.outside.cannot.refactor.message=Переменная объявлена вне блока кода
inline.method.calls.not.accessible.in=Встраиваемый метод вызывает {0}, который будет недоступен в {1}
inline.method.calls.not.accessible.on.qualifier=Встраиваемый метод вызывает {0}, который будет недоступен для квалификатора {1}
inline.method.checking.tail.calls.progress=Проверка хвостовых вызовов
inline.method.elements.header=Встраиваемый метод
inline.method.method.label=Встроить метод ''{0}''\:
inline.method.method.occurrences=Встроить метод ''{0}'' с {1} {1, choice, 1\#использованием|2\#использованиями}\:
inline.method.multiline.method.in.ctor.call=Встраивание не может быть применено к многострочному методу в вызове конструктора
inline.method.multiline.method.in.loop.condition=Встраивание не может быть применено к многострочному методу в условии цикла
inline.method.object.action.name=Встроить объект
inline.method.object.suggestion.message=Хотите встроить объект и последующий вызов?
inline.method.qualifier.usage.side.effect=Встраиваемый метод используется в ссылке на метод с побочными эффектами в квалификаторе
inline.method.used.in.javadoc=Встраиваемый метод используется в javadoc
inline.method.used.in.reflection=Встраиваемый метод используется рефлексивно
inline.object.command.name=Встроить объект
inline.parameter.action.name=Встроить параметр…
inline.parameter.cannot.find.initializer.warning.message=Не удаётся найти константный инициализатор для параметра
inline.parameter.confirmation=Встроить параметр ''{0}'' с инициализатором ''{1}''?
inline.parameter.dependency.unavailable.in.static.method=Инициализатор параметра зависит от {0}, который недоступен внутри статического метода
inline.parameter.depends.on.caller.parameter=Инициализатор параметра зависит от параметра вызывающего метода
inline.parameter.depends.on.non.static=Инициализатор параметра зависит от нестатического члена другого класса
inline.parameter.depends.on.non.static.class=Инициализатор параметра зависит от нестатического класса, недоступного внутри статического метода
inline.parameter.depends.on.this.inside.static.method=Инициализатор параметра зависит от this, который недоступен внутри статического метода
inline.parameter.depends.on.unavailable.element.inside.method=Инициализатор параметра зависит от {0}, который недоступен внутри метода и не может быть встроен
inline.parameter.depends.on.unavailable.value=Инициализатор параметра зависит от значения, недоступного внутри метода
inline.parameter.error.hierarchy=Встраивание параметра не поддерживается, когда метод является частью иерархии наследования
inline.parameter.error.non.project.method=Встраивание не поддерживается для методов вне проекта
inline.parameter.error.varargs=Встраивание varargs параметров не поддерживается
inline.parameter.initializer.depends.on.inaccessible.value=Инициализатор параметра зависит от значения, которое недоступно внутри метода и не может быть встроено
inline.parameter.method.usages.progress=Поиск использований метода
inline.parameter.no.usages.warning.message=Метод не имеет использований
inline.parameter.not.accessible.warning.message=Константный инициализатор недоступен в теле метода
inline.parameter.refactoring=Встраивание параметра
inline.parameter.replace.with.local.checkbox=Заменить локальной переменной  [&E]
inline.parameter.write.usages.warning.message=Встраивание параметра с записью использований не поддерживается
inline.pattern.variable.title=Встроить переменную шаблона
inline.popup.highlight=Подсветить {0} конфликтных {0, choice, 1\#запись|2\#записи}
inline.popup.ignore.conflicts=Игнорировать записи и продолжить
inline.super.class=Встроить суперкласс
inline.super.class.action.name=Встроить суперкласс…
inline.super.class.label=Класс {0}
inline.super.ctor.can.be.replaced=Конструктор {0} может быть заменен любым из {1}
inline.super.doc.panel.title=JavaDoc для встраиваемых членов
inline.super.expr.can.be.replaced={0} может быть заменен любым из {1}
inline.super.no.anonymous.class=Невозможно встроить в анонимный класс.
inline.super.no.ctor=Не найден конструктор, соответствующий super
inline.super.no.inheritors.warning.message=Невозможно встроить класс без наследников
inline.super.no.inner.class=Невозможно встроить во внутренний класс. Переместите ''{0}'' на верхний уровень
inline.super.no.return.in.super.ctor=Рефакторинг не поддерживается, когда оператор return прерывает поток выполнения конструктора суперкласса
inline.super.no.substitution=Не найдена согласованная замена для {0}. Ожидалось ''{1}'', но найдено ''{2}''.
inline.super.non.project.class.warning.message=Невозможно встроить класс не из проекта
inline.super.static.import.can.be.replaced=Статический импорт может быть заменен любым из {0}
inline.super.target.instead.of.super.class=Экземпляр целевого типа передается в место, где ожидается суперкласс.
inline.super.type.element.can.be.replaced={0} может быть заменен любым из {1}
inline.super.type.params.differ=Параметры типа не согласуются в {0}. Ожидалось {1}, но найдено {2}
inline.super.unknown.type=Тип неизвестен
inline.superclass.foreign.language.conflict.message=Невозможно встроить в {0}
inline.to.anonymous.border.title=Встраивание
inline.to.anonymous.command.name=Встроить класс {0}
inline.to.anonymous.name.label=Класс {0}
inline.to.anonymous.no.abstract=Абстрактные классы не могут быть встроены
inline.to.anonymous.no.ctor.calls=Класс не может быть встроен, так как он вызывает собственный конструктор
inline.to.anonymous.no.get.class.calls=Результат вызова getClass() будет изменен
inline.to.anonymous.no.method.calls=Класс не может быть встроен, так как он обращается к своим членам в другом экземпляре
inline.to.anonymous.no.multiple.interfaces=Классы, реализующие несколько интерфейсов, не могут быть встроены
inline.to.anonymous.no.superclass.and.interface=Классы, имеющие суперкласс и реализующие интерфейс, не могут быть встроены
inline.to.anonymous.refactoring=Встроить в анонимный класс
inline.vars.elements.header=Переменная для встраивания
inline.warning.variables.used.in.initializer.are.updated=Небезопасное встраивание\: переменные, используемые в инициализаторе, обновляются
inlined.method.implements.method.from.0=Встраиваемый метод реализует метод из {0}
inlined.method.overrides.method.from.0=Встраиваемый метод переопределяет метод из {0}
inlined.method.will.be.transformed.to.single.return.form=Встраиваемый метод будет преобразован в форму с единственным return
inner.class.0.is.already.defined.in.class.1=Внутренний класс {0} уже определен в классе {1}.\nПродолжить?
inner.class.0.is.not.static=Внутренний класс {0} не является статическим.\nРефакторинг {1} поддерживается только для статических членов.
inner.class.exists=Внутренний класс с именем ''{0}'' уже определен\nв классе ''{1}''
inner.class.name=&Имя внутреннего класса\: [&I]
instance.initializer.description=инициализатор экземпляра {0}
instances.casted.to.java.lang.object=Экземпляры, приведенные к java.lang.Object
instances.of.0.upcasted.to.1.were.found=Найдены экземпляры {0}, приведенные к типу {1}. При продолжении они будут показаны в отдельной вкладке поиска.
instances.upcasted.to.java.lang.object.found=Найдены экземпляры, приведенные к java.lang.Object
instances.upcasted.to.object=Экземпляры, приведенные к Object
interface.0.does.not.have.inheritors=Интерфейс {0} не имеет наследников
interface.description={1, choice, 0\#|1\#локальный }интерфейс {0}
interface.does.not.have.base.interfaces=Интерфейс {0} не имеет базовых интерфейсов
interface.has.been.successfully.created=Интерфейс {0} успешно создан
introduce.constant.enum.cb=Извлечь как константу перечисления [&E]
introduce.constant.field.of.type=Константа (static final поле) типа [&T]\:
introduce.constant.introduce.to.class=Извлечь в класс (полное имя) [&C]\:
introduce.constant.move.to.another.class.checkbox=Переместить в другой класс [&M]
introduce.field.field.of.type=Поле типа [&T]\:
introduce.field.static.field.of.type=Статическое поле типа [&T]\:
introduce.functional.variable.pass.fields.checkbox=Передавать поля как параметры [&F]
introduce.local.variable.to.reassign.title=Выберите переменную для переназначения
introduce.parameter.command=Извлечение параметра в {0}
introduce.parameter.convert.lambda=Преобразовать в функциональное выражение [&C]
introduce.parameter.duplicates.progress=Поиск дубликатов метода…
introduce.parameter.elements.header=Добавление параметра в метод
introduce.parameter.object.create.inner.class=Создать внутренний класс [&I]
introduce.parameter.object.create.new.class=Создать новый класс [&C]
introduce.parameter.object.error.class.does.not.exist=''{0}'' не существует
introduce.parameter.object.error.created.class.wont.be.accessible=Созданный класс будет недоступен
introduce.parameter.object.error.existing.class.misses.compatible.constructor=В существующем классе нет совместимого конструктора
introduce.parameter.object.error.file.already.exits=Файл уже существует\: {0}
introduce.parameter.object.error.inner.class.already.exist=Внутренний класс с именем ''{0}'' уже существует
introduce.parameter.object.error.invalid.inner.class.name=''{0}'' является недопустимым именем внутреннего класса
introduce.parameter.object.error.invalid.parameter.class.name=''{0}'' является недопустимым именем класса параметра
introduce.parameter.object.error.invalid.parameter.class.package.name=''{0}'' является недопустимым именем пакета для класса параметра
introduce.parameter.object.error.invalid.qualified.parameter.class.name=''{0}'' является недопустимым полным именем класса параметра
introduce.parameter.object.error.no.field.associated.found=Не найдено поле, связанное с {0}
introduce.parameter.object.escalate.visibility.option=Повысить видимость [&E]
introduce.parameter.object.existing.class.name=Имя [&N]
introduce.parameter.object.generate.accessors.option=Сгенерировать методы доступа [&G]
introduce.parameter.object.inner.class.name=Имя [&N]
introduce.parameter.object.new.class.name=Имя [&N]
introduce.parameter.object.new.class.package.name=Имя пакета [&P]
introduce.parameter.object.use.existing.class=Использовать существующий класс [&U]
introduce.parameter.super.method.checkbox=Рефакторинг метода super [&U]
introduce.variable.message.cannot.extract.in.implicit.class=Невозможно выполнить извлечение в неявно объявленном классе
introduce.variable.message.expression.refers.to.pattern.variable.declared.outside=Выражение ссылается на переменную шаблона ''{0}'', объявленную снаружи
introduce.variable.no.matching.occurrences=Нет совпадающих вхождений
introduced.variable.will.conflict.with.0=Введенная переменная будет конфликтовать с {0}
introducing.variable.may.break.code.logic=Введение переменной может нарушить логику кода
invalid.expression.context=Недопустимый контекст выражения.
invalid.package.name=Недопустимое имя пакета\: {0}
invalid.target.package.name.specified=Указано недопустимое имя целевого пакета
invert.boolean.foreach=Инициализатор параметра foreach не может быть инвертирован
invert.boolean.wrong.type=Тип возвращаемого значения метода или тип рефакторируемой переменной должен быть boolean
invocations.to.be.inlined=Вызовы для встраивания {0}
is.modified.in.loop.body={0} изменяется в теле цикла
java.safe.delete.caller.text=Здесь будет показан текст вызывающего метода с подсветкой вызываемого
java.safe.delete.empty.callee.text=Здесь будет показан текст вызываемого метода
javadoc.for.abstracts=JavaDoc для абстрактных элементов
keep.original.signature=Сохранить исходную сигнатуру
lambda.to.reference.side.effect.warning.message=В квалификаторе ссылки на метод обнаружены возможные побочные эффекты.\nВвести локальную переменную?
local.variable.description=локальная переменная {0}
local.will.be.hidden.renamed.description=Переименованное поле скроет {0}
localToInner.refactoring.name=Преобразовать локальный класс во внутренний
locate.caret.inside.a.method=Поместите курсор внутрь члена класса
locate.duplicates.action.name=Найти дубликаты
make.0.static=Сделать {0} статическим
make.method.static.title=Сделать метод статическим
make.static.command=Преобразование {0} в статический
make.static.description.label=Сделать {0} {1} статическим
make.static.elements.header={0} для преобразования в статический
make.static.method.references.progress=Поиск ссылок на метод
make.static.methods.to.propagate.dialog.title=Выберите методы для распространения static
members.to.form.interface.title=Члены для формирования интерфейса
members.to.form.superclass.title=Члены для формирования суперкласса
method.0.is.overridden.by.1=Метод {0} переопределен в {1}
method.0.will.hide.method.of.the.base.class=Метод {0} скроет \nметод базового класса {1}
method.0.will.implement.method.of.the.base.class=Метод {0} будет реализовывать \nметод базового класса {1}
method.0.will.override.a.method.of.the.base.class=Метод {0} переопределит \nметод базового класса {1}
method.call.would.be.linked.to.0.after.rename=После переименования вызов метода будет связан с "{0}"
method.column=Метод
method.description=метод {0}
method.does.not.have.a.body=Метод {0} не имеет тела
method.duplicates.found.message=Найдено {0, choice, 1\#1 фрагмент кода|2\#{0,number} фрагмента кода|3\#{0,number} фрагментов кода}
method.has.an.empty.body=Метод {0} имеет пустое тело.
method.is.not.a.constructor=Метод не является конструктором
migration.class=Класс
migration.dialog.alert.delete=Удалить
migration.dialog.alert.name=Удалить карту миграции
migration.dialog.alert.text=Удалить миграцию ''{0}''?
migration.dialog.link.delete=Удалить
migration.dialog.link.duplicate=Дублировать и редактировать…
migration.dialog.link.edit=Редактировать…
migration.dialog.ok.button.text=Выполнить
migration.dialog.scope.label=Область\:
migration.dialog.scope.whole.project=Весь проект
migration.dialog.title=Миграция пакетов и классов
migration.edit.copy.existing=Копировать существующую
migration.edit.duplicated.migration.name=Копия {0}
migration.edit.empty.name=Имя миграции не может быть пустым.
migration.edit.empty.table=Таблица миграции не может быть пустой.
migration.edit.existing.name=Миграция с таким именем уже существует.
migration.entry.class=Класс
migration.entry.new.name=Новое имя\:
migration.entry.old.name=Старое имя\:
migration.entry.package=Пакет
migration.map.description.label=Описание карты\:
migration.map.name.prompt=Имя карты\:
migration.new.name.column.header=Новое имя
migration.no.usages.found.in.the.project=Использования не найдены в проекте
migration.old.name.column.header=Старое имя
migration.package=Пакет
migration.package.with.subpackages=Пакет с подпакетами
migration.title=Миграция
migration.type.column.header=Тип
move.class=Переместить класс…
move.class.or.package.build.directories=Построение списка директорий
move.class.refactoring.cannot.be.applied.to.anonymous.classes=Перемещение класса не может быть применено к анонимным классам
move.class.to.inner.command.name=Переместить {0, choice, 1\#класс|2\#классы} {1} в {2}
move.class.to.inner.find.target.class.progress=Поиск целевого класса…
move.class.to.inner.move.to.self.error=Нельзя переместить класс в самого себя
move.class.to.inner.nonstatic.error=Нельзя переместить класс в нестатический внутренний класс
move.class.to.new.file.or.make.inner.class.preview=Переместить класс ''{0}'' в новый файл в выбранном пакете или преобразовать его во внутренний класс существующего.
move.classes=Переместить классы…
move.classes.and.packages=Переместить классы и пакеты…
move.classes.command=Перемещение {0} в пакет {1}
move.classes.destination.make.inner=Сделать внутренним классом [&M]
move.classes.destination.package.prompt=В пакет\:
move.classes.destination.to.package=В пакет [&G]
move.classes.invalid.package.name.warning.message=Недопустимое имя пакета
move.classes.or.packages.different.modules.exports.conflict=Перемещение {0} из модуля {1} в модуль {2} может скрыть доступ к нему
move.classes.or.packages.new.module.exports.conflict=Изменение операторов exports/opens пакета {0} предоставит доступ к другим типам и их членам в том же пакете
move.classes.or.packages.title=Переместить
move.classes.or.packages.unused.exports.action.name=Удалить неиспользуемые exports/opens
move.classes.or.packages.unused.exports.command.name=Удаление неиспользуемых exports/opens
move.classes.or.packages.unused.exports.notification.title=Найдены неиспользуемые exports/opens<br>\nв {0,choice, 1\#дескрипторе|2\#дескрипторах} модуля
move.enum.constant.cb=По возможности переместить как константы перечисления [&E]
move.files.regrouping.command.name=Перегруппировка…
move.files.to.new.directory.prompt=В директорию\:
move.inner.class.action.name=Переместить внутренний класс…
move.inner.class.command=Перемещение внутреннего класса {0}
move.inner.class.to.another.class=Переместить внутренний класс {0} в другой класс [&M]
move.inner.class.to.be.moved=Перемещаемый класс
move.inner.class.to.upper.level=Переместить внутренний класс {0} на верхний уровень
move.inner.class.to.upper.level.action.name=Переместить внутренний класс на верхний уровень…
move.inner.class.to.upper.level.or.another.class.preview=Переместить внутренний класс ''{0}'' на верхний уровень выбранного пакета или в другой класс.
move.inner.class.to.upper.level.preview=Переместить внутренний класс ''{0}'' на верхний уровень выбранного пакета.
move.instance.method.delegate.title=Переместить метод экземпляра…
move.instance.method.elements.header=Переместить метод экземпляра
move.instance.method.handler.make.method.static=Хотите сделать метод ''{0}'' статическим и затем переместить?
move.label.text=Переместить\:
move.member.write.access.in.interface.conflict=Производится запись в {0}, но интерфейс может содержать только константы.
move.members.action.name=Переместить члены…
move.method.enter.a.valid.name.for.parameter=Введите корректное имя параметра
move.method.is.not.supported.for.0=Перемещение метода экземпляра не поддерживается для {0}
move.method.is.not.supported.for.constructors=Перемещение метода не поддерживается для конструкторов
move.method.is.not.supported.for.generic.classes=Перемещение метода не поддерживается для обобщенных классов
move.method.is.not.supported.for.non.project.methods=Перемещение метода не поддерживается для методов вне проекта
move.method.this.parameter.label=Выберите имя для параметра ''{0}.this''
move.methods.panel.title=Методы для перемещения в извлеченный класс [&M]
move.methods.used.in.extracted.block.only=Переместить методы, используемые только в извлеченном блоке
move.nonstatic.class.from.jsp.not.supported=Перемещение нестатических классов из JSP страницы не поддерживается
move.package.or.directory=Переместить пакет или директорию…
move.package.refactoring.cannot.be.applied.to.default.package=Перемещение пакета не может быть применено к пакету по умолчанию
move.packages.or.directories=Переместить пакеты или директории…
move.single.class.or.package.name.label=Переместить {0} {1}
move.specified.classes=Переместить указанные классы
move.specified.packages=Переместить указанные пакеты
move.to.inner.duplicate.inner.class=Класс {0} уже содержит внутренний класс с именем {1}
moving.local.classes.is.not.supported=Перемещение локальных классов не поддерживается
no.class.name.specified=Имя класса не указано
no.exact.method.duplicates.were.found=<html><b>Найдено {0,choice, 0\#0|1\#1|2\#{0}} точных {0,choice, 0\#дубликатов|1\#дубликат|2\#дубликатов} метода</b>, хотя измененный метод, как показано ниже, имеет еще {1} {1,choice, 1\#дубликат|2\#дубликатов}</html>
no.initializer.present.for.the.field=Отсутствует инициализатор поля
no.parameter.name.specified=Имя параметра не указано
no.usages.can.be.replaced=Использования {0} \nне могут быть заменены использованиями {1}
occurrences.to.be.migrated=Вхождения для миграции {0}
ok.button=OK
only.fields.variables.of.methods.of.valid.type.can.be.considered=Могут рассматриваться только поля, переменные, параметры методов или методы допустимого типа.
package.description=пакет {0}
package.does.not.exist=Пакет {0} не существует.\nСоздать его?
package.does.not.exist.preview=Пакет {0} не существует.\nРефакторинг создаст его позже.
package.name.prompt=Имя пакета [&G]\:
parameter.description=параметр {0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=Инициализатор параметра содержит {0}, но не все вызовы метода находятся в его классе
parameter.name.prompt=Имя параметра [&M]\:
parameter.of.type=Параметр &типа\:
parameter.type.table.column.title=Тип
parameter.used.in.method.body.warning={0} используется в теле метода
pass.outer.class.instance.as.parameter=Передать экземпляр внешнего класса как параметр [&U]
pattern.variable.description=паттерн-переменная {0}
please.enter.a.valid.target.package.name=Введите корректное имя целевого пакета
popup.title.choose.class.to.introduce.constant=Выберите класс для добавления константы
popup.title.choose.class.to.introduce.field=Выберите класс для добавления поля
press.the.do.migrate.button=Нажмите кнопку "Выполнить миграцию" внизу панели результатов поиска\nдля миграции с использованием карты миграции "{0}"\n
preview.usages.to.be.changed=Предпросмотр изменяемых использований  [&P]
process.duplicates.change.signature.promt=Для замены всех вхождений сигнатура метода будет изменена. Продолжить?
process.duplicates.title=Обработка дубликатов
process.methods.duplicates.title=Обработка дубликата метода {2} ({0} из {1})
processing.progress.text=Обработка {0}
progress.title.collect.hierarchy=Сбор иерархии ''{0}''
project.files.have.been.changed=Файлы проекта были изменены.\nХотите повторно запустить рефакторинг?
push.down.delete.warning.text={0}Перемещение членов вниз приведет к их удалению. Хотите продолжить?
push.down.enum.no.constants.warning.text=Enum {0} не имеет констант для встраивания.
push.down.no.inheritors.class.warning.text=Класс {0} не имеет наследников.
push.down.no.inheritors.final.class.warning.text=Final класс {0} не имеет наследников.
push.down.unrelated.defaults.conflict={0} унаследует несвязанные значения по умолчанию из {1} и {2}
push.up.abstract.accessibility.in.subclass.conflict={0} использует {1}, который будет недоступен из подкласса.
push.up.abstract.accessible.from.the.subclass.conflict=Невозможно сделать {0} абстрактным, так как он будет недоступен из подкласса.
push.up.super.class.signature.conflict={0} в суперклассе будет конфликтовать с методом {2} из {1}
re.run.refactoring=Повторить рефакторинг
record.description={1, choice, 0\#|1\#локальный }record {0}
refactor.base.method.choice=Рефакторинг базов{0, choice, 0\#ых методов|1\#ого метода}
refactor.only.current.method.choice=Рефакторинг только текущего метода
refactoring.cannot.be.applied.no.sources.attached=Рефакторинг "{0}" не может быть применен\: не прикреплены исходники
refactoring.cannot.be.applied.to.abstract.methods=Рефакторинг {0} не может быть применен к абстрактным методам
refactoring.cannot.be.applied.to.inline.non.chaining.constructors=Рефакторинг {0} не может быть применен к встраиванию нецепочечных конструкторов
refactoring.cannot.be.applied.to.native.methods=Рефакторинг {0} не может быть применен к нативным методам
refactoring.cannot.be.applied.to.vararg.constructors=Рефакторинг {0} не может быть применен к vararg конструкторам
refactoring.extract.method.dialog.duplicates.count={0,choice, 1\#Один|2\#{0,number}} дубликат{0,choice, 1\# кода|2\#а кода} может быть заменен вызовом извлеченного метода
refactoring.extract.method.dialog.duplicates.pending=Поиск дубликатов…
refactoring.extract.method.dialog.duplicates.progress=Поиск дубликатов
refactoring.extract.method.inner.class.defined=Внутренний класс {0} уже определен в классе {1}.
refactoring.extract.method.preview.button.refactor=&Рефакторинг
refactoring.extract.method.preview.button.rerun=Повторить р&ефакторинг
refactoring.extract.method.preview.failed=Не удалось извлечь метод
refactoring.extract.method.preview.group.duplicates=Дубликаты кода
refactoring.extract.method.preview.group.method=Метод для извлечения
refactoring.extract.method.preview.group.original=Исходный фрагмент кода
refactoring.extract.method.preview.preparing=Подготовка сравнения
refactoring.extract.method.preview.updating=Обновление сравнения
refactoring.extract.method.reference.to.change=Ссылки для изменения
refactoring.introduce.variable.enum.in.label.message=Невозможно извлечь константу enum в метке switch
refactoring.is.not.supported.for.jsp.classes=Рефакторинг не поддерживается для JSP классов
refactoring.is.not.supported.in.the.current.context=Рефакторинг {0} не поддерживается в текущем контексте
references.in.code.to.elements.from.migration.map=Ссылки в коде на элементы из карты миграции "{0}" {1}
references.to.0.to.be.replaced.with.references.to.1=Ссылки на ''{0}'' будут заменены ссылками на ''{1}''{2}
remove.parameter.0.no.longer.used=Удалить неиспользуемый параметр ''{0}''
removing.redundant.imports.progress.title=Удаление неиспользуемых импортов
rename.accessors=Переименовать &аксессоры
rename.accessors.title=Переименование геттеров/сеттеров
rename.accessors.with.the.following.names.to=Переименовать аксессоры со следующими именами в\:
rename.constructor.parameters.title=Переименование параметров конструктора
rename.constructor.parameters.with.the.following.names.to=Переименовать параметры со следующими именами в\:
rename.inheritors.with.the.following.names.to.title=Переименовать наследников со следующими именами в\:
rename.module.already.exists=Модуль ''{0}'' уже существует в проекте
rename.module.directory.command=Переименовать модуль и директорию в ''{0}''
rename.module.directory.title=Переименовать модуль и &директорию
rename.overloads=Переименовать перегрузки  [&O]
rename.overloads.dialog.title=Переименование перегрузок
rename.overloads.to.dialog.description=Переименовать перегрузки в\:
rename.parameter.in.hierarchy.to.dialog.description=Переименовать параметр в иерархии в\:
rename.parameters.dialog.title=Переименование параметров
rename.test.method=Переименовать тестовый метод
rename.test.method.description=Переименовать тестовые методы со следующими именами в\:
rename.test.method.entity.name=Тестовый метод
rename.test.method.title=Переименование тестовых методов
rename.tests=Переименовать т&есты
rename.tests.title=Переименование тестов
rename.tests.with.the.following.names.to=Переименовать тесты со следующими именами в\:
rename.variables=Переименовать переменные  [&V]
rename.variables.title=Переименование переменных
renamed.class.will.hide.0.in.1=Переименованный класс скроет {0} в {1}
renaming.method.will.override.final.0=Переименование метода переопределит final "{0}"
replace.all.and.extract=Заменить все {0} вхождения и извлечь как операцию ''{1}''
replace.all.fields=&Заменить все поля
replace.all.occurrences.changes.semantics=Заменить все {0} вхождения (изменит семантику\!)
replace.all.occurrences.of.expression.0.occurrences=Заменить &все вхождения ({0})
replace.all.read.and.write=Заменить вхождения чтения и записи (изменит семантику\!)
replace.as.separate.operation=Извлечь как операцию ''{0}''
replace.constructor.0.with.a.factory.method=Заменить конструктор {0} фабричным методом
replace.constructor.builder.create.new=&Создать новый
replace.constructor.builder.default.value.table.title=Значение по умолчанию
replace.constructor.builder.error.builder.class.cannot.be.the.same=Класс {0} не может быть своим собственным классом builder.
replace.constructor.builder.error.caret.position=Курсор должен находиться внутри класса, конструкторы которого нужно заменить на builder.
replace.constructor.builder.error.class.with.chosen.name.already.exist=Класс {0} уже существует в пакете {1}.
replace.constructor.builder.error.identifier.invalid=Идентификатор ''{0}'' некорректен
replace.constructor.builder.error.invalid.builder.class.name=''{0}'' не является корректным именем класса
replace.constructor.builder.error.invalid.builder.package.name=''{0}'' не является корректным именем пакета
replace.constructor.builder.error.invalid.builder.qualified.class.name=''{0}'' не является корректным полным именем класса
replace.constructor.builder.error.invalid.field.name=''{0}'' не является корректным именем поля
replace.constructor.builder.error.invalid.setter.name=''{0}'' не является корректным именем сеттера
replace.constructor.builder.error.no.constructor.chain=Конструкторы {0} не образуют простую цепочку.
replace.constructor.builder.error.no.constructors=Текущий класс не имеет конструкторов для замены на builder.
replace.constructor.builder.error.selected.class.was.not.found=Существующий класс builder {0} не найден.
replace.constructor.builder.field.name.table.title=Имя поля
replace.constructor.builder.optional.setter.table.title=Опциональный setter
replace.constructor.builder.parameter.table.title=Параметр
replace.constructor.builder.select.builder.class.chooser.title=Выберите класс builder
replace.constructor.builder.setter.name.table.title=Имя setter
replace.constructor.builder.use.existing=Использовать существующий [&U]
replace.constructor.existing.builder.fqn=Имя класса builder (полное имя) [&B]
replace.constructor.factory.error.factory.method.already.exists=Фабричный метод {0} уже существует и будет использован вместо вновь созданного.
replace.constructor.factory.error.invalid.factory.method.name=''{0}'' не является допустимым именем фабричного метода
replace.constructor.new.builder.class.name=Имя класса builder [&N]
replace.constructor.new.builder.package=Пакет для нового builder [&P]
replace.constructor.with.builder=Заменить конструктор на builder
replace.constructor.with.builder.text=Заменить конструктор на builder
replace.constructor.with.factory.method=Заменить конструктор на фабричный метод
replace.constructor.with.factory.method.title=Заменить конструктор на фабричный метод
replace.constructor.with.factory.target.fq.name=В (полное имя)\:
replace.default.constructor.of.0.with.a.factory.method=Заменить конструктор по умолчанию {0} на фабричный метод
replace.default.constructor.with.factory.method=Заменить конструктор по умолчанию на фабричный метод
replace.fields.inaccessible.in.usage.context=Заменить недоступные в контексте использования поля [&I]
replace.fields.used.in.expressions.with.their.getters=Заменить используемые в выражениях поля на их геттеры [&U]
replace.inheritance.from=Заменить наследование делегированием от [&R]\:
replace.inheritance.with.delegation.command=Замена наследования делегированием в {0}
replace.inheritance.with.delegation.delegate.members.title=Делегировать члены
replace.inheritance.with.delegation.elements.header=Заменить наследование делегированием
replace.inheritance.with.delegation.invalid.field=''{0}'' - недопустимое имя поля для делегирования
replace.inheritance.with.delegation.invalid.inner.class=''{0}'' - недопустимое имя поля для делегирования
replace.inheritance.with.delegation.title=Заменить наследование делегированием
replace.inside.current.lambda=Создать переменную внутри текущей lambda
replace.instance.qualifiers.with.class.references=Заменить квалификаторы экземпляра на ссылки на класс
replace.lambda.chain.detected=Обнаружена цепочка lambda
replace.method.code.duplicates.title=Заменить дубликаты кода
replace.method.duplicates.scope.chooser.message=Область анализа
replace.method.duplicates.scope.chooser.title=Укажите область {0}
replace.occurrences.inside.statement=Заменить {0} вхождений в {2, choice, 1\#|2\#внешнем} блоке ''{1}''
replace.this.code.fragment.and.change.signature=Сигнатура метода будет изменена на {0}
replace.this.code.fragment.and.make.method.static=(Метод будет сделан статическим)
replace.this.code.fragment.and.make.method.static.visible=(Метод будет сделан статическим и {0})
replace.this.code.fragment.and.make.method.visible=(Метод будет {0})
replace.with.method.call.does.not.work.for.constructors=Замена на вызов метода не работает для конструкторов
replace.write.access.occurrences=Заменить вхождения с записью [&L]
replacing.inheritance.with.delegation=Замена наследования делегированием
safe.delete.parameter.usage.warning={0} имеет использование на стороне вызова, которое нельзя безопасно удалить.
safe.delete.search.for.caller.method.usages.progress=Поиск использований вызывающего метода…
safe.delete.select.members.to.propagate.dialog.title=Выберите члены для распространения безопасного удаления
safe.delete.select.methods.to.propagate.delete.parameters.dialog.title=Выберите методы для распространения удаления параметров
select.source.root.chooser.title=Выберите корневой каталог исходников
selected.block.contains.invocation.of.another.class.constructor=Выбранный блок содержит вызов конструктора другого класса
selected.block.contains.statement.outside.of.class=Выбранный блок содержит оператор вне класса
selected.block.should.represent.an.expression=Выбранный блок должен представлять выражение
selected.expression.cannot.be.a.constant.initializer=Выбранное выражение не может быть инициализатором константы
selected.expression.cannot.be.extracted=Выбранное выражение не может быть извлечено
selected.expression.has.void.type=Выбранное выражение имеет тип 'void'
selected.expression.introduces.pattern.variable=Выбранное выражение вводит переменную шаблона ''{0}''
setter.method.found.for.the.field.0=Найден метод setter для поля {0}. {1} setter тоже?
side.effects.detected.title=Обнаружены побочные эффекты
source.folder.0.has.package.prefix.1=Исходная папка {0} имеет префикс пакета ''{1}''\nПакет ''{2}'' не может быть создан там.
static.initializer.description=статический инициализатор {0}
suggest.signature.preview.after.title=После
suggest.signature.preview.method.call.prefix=вызов метода\:
suggest.signature.preview.title.before=До
superclass.cannot.be.accessed.in.subclass=Суперкласс будет недоступен в подклассе
superclass.cannot.be.extracted.from.a.record=Суперкласс не может быть извлечен из record
superclass.cannot.be.extracted.from.an.enum=Суперкласс не может быть извлечен из enum
synthetic.jsp.class.is.referenced.in.the.method=В методе есть ссылка на синтетический jsp класс
target.0.is.not.accessible.from.1=Цель {0} недоступна из {1}
template.error.class.already.defined=Класс с именем ''{0}'' уже определен в области видимости
template.error.invalid.identifier.name=Недопустимое имя идентификатора
template.error.variable.already.defined=Переменная с таким именем уже определена
there.are.going.to.be.multiple.destination.files.with.the.same.name=Будет несколько целевых файлов с одинаковым именем
there.are.multiple.exit.points.in.the.selected.code.fragment=В выбранном фрагменте кода несколько точек выхода
there.are.multiple.output.values.for.the.selected.code.fragment=Для выбранного фрагмента кода существует несколько выходных значений
there.are.no.variables.that.have.reference.type=Нет параметров метода или полей содержащего класса ссылочного типа
there.are.unused.methods.that.override.methods.you.delete=Существуют неиспользуемые методы, которые переопределяют удаляемые методы
there.is.already.a.0.in.1=В {1} уже существует {0}
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=Уже существует {0}. Это вызовет конфликт с добавляемым параметром
there.is.already.a.0.it.will.conflict.with.the.renamed.1=Существующий {0} имеет такое же имя
there.is.already.type.parameter.in.0.with.name.1=В {0} уже существует параметр типа с именем {1}
this.invocation.only.and.keep.the.method=Встроить только это использование и сохранить метод [&K]
this.method=Этот метод
this.reference.only.and.keep.super.class=Встроить только эту ссылку и сохранить суперкласс [&K]
this.reference.only.and.keep.the.class=Встроить только эту ссылку и сохранить класс [&K]
this.reference.only.and.keep.the.field=Встроить только это использование и сохранить поле [&K]
title.rename.variables.with.the.following.names.to=Переименовать переменные со следующими именами в\:
tooltip.cannot.inline.pattern.variable=Невозможно встроить переменную шаблона
turn.refs.to.super.command=Замена использований {0} на {1}
turnRefsToSuper.change.usages.to=Изменить использования {0} на\:  [&C]
turnRefsToSuper.use.superclass.in.instanceof=Использовать интерфейс/суперкласс в instanceof  [&U]
type.migration.action.name=Миграция типов
type.migration.choose.scope.title=Выберите область, где может произойти изменение сигнатуры
type.migration.class.type.argument.label=Мигрировать аргумент типа класса {0} в
type.migration.conflicts.found=Найдены конфликты миграции
type.migration.error.hint.title=Миграция типов
type.migration.exclude.action.text=Исключить  [&E]
type.migration.include.action.text=Включить [&I]
type.migration.migrate.button.text=Мигрировать  [&M]
type.migration.no.conflicts.found=Конфликтов миграции не найдено
type.migration.no.scope.warning.message=Область не выбрана
type.migration.reasons.to.migrate=Найдены причины для миграции
type.migration.rerun.button.text=Перезапустить миграцию типов [&R]
type.migration.return.type.of.method.label=Мигрировать возвращаемый тип {0} метода {1} в
type.migration.select.suggestion=Выберите корень для поиска причин миграции
type.migration.type.of.field.label=Мигрировать тип {0} поля {1} в
type.migration.type.of.parameter.label=Мигрировать тип {0} параметра {1} в
type.migration.type.of.pattern.variable.label=Мигрировать тип {0} переменной шаблона {1} в
type.migration.type.of.record.component.label=Мигрировать тип {0} компонента записи {1} в
type.migration.type.of.variable.label=Мигрировать тип {0} переменной {1} в
type.of.the.selected.expression.cannot.be.determined=Невозможно определить тип выбранного выражения
unable.to.start.type.migration=Невозможно начать миграцию типов
unknown.expression.type=Неизвестный тип выражения
unused.overriding.methods.title=Неиспользуемые переопределяющие методы
use.interface.where.possible.title=Использовать интерфейс где возможно
use.super.references.prompt=На этом этапе {0} может проанализовать использования {1} \nи заменить их использованиями {2}, где это возможно.\nПродолжить?
use.variable.initializer.to.initialize.parameter=Использовать инициализатор переменной для инициализации параметра [&I]
variable.0.is.changed.before.last.access=Переменная ''{0}'' изменяется перед последним обращением к переменной ''{1}''
variable.does.not.have.an.initializer=Переменная {0} не имеет инициализатора
variable.is.accessed.for.writing=Переменная ''{0}'' используется для записи
variable.is.never.used.before.modification=Переменная {0} никогда не используется перед модификацией
variable.of.type=Переменная типа [&T]\:
would.you.like.to.replace.default.constructor.of.0.with.factory.method=Хотите заменить конструктор по умолчанию {0} на фабричный метод?
wrap.return.value.create.inner.class=Создать внутренний класс [&I]
wrap.return.value.create.new.class=Создать новый класс [&C]
wrap.return.value.existing.class.name=Имя
wrap.return.value.inner.class.name=Имя [&M]
wrap.return.value.new.class.name=Имя [&N]
wrap.return.value.new.class.package.name=Имя пакета [&P]
wrap.return.value.use.existing.class=Использовать существующий класс [&U]
wrap.return.value.wrapper.field=Поле обертки [&F]