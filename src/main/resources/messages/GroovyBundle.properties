0.expressions.on.trait.fields.properties.are.not.supported.in.traits=Выражения {0} для полей/свойств трейта не поддерживаются в трейтах
0.is.deprecated=''{0}'' устарел
Cannot.perform.undo.operation=Невозможно выполнить операцию отмены
Constructor=Конструктор
Equals=Equals
Getter=Getter
Inner.methods.are.not.supported=Внутренние методы не поддерживаются
Setter=Setter
Undo.disable=Отмена отключена
abstract.methods.must.not.have.body=Абстрактные методы не должны иметь тело
abstract.visibility.presentation=abstract
action.ConvertGroovyToJava.description=Преобразовать файлы Groovy в Java
action.ConvertGroovyToJava.text=Преобразовать в Java
action.ConvertToCompileStatic.description=Преобразовать файлы Groovy в @CompileStatic
action.ConvertToCompileStatic.text=Преобразовать в @CompileStatic
action.DumpGroovyControlFlowAction.text=Дамп потока управления Groovy
action.ExcludeFromStubGeneration.description=Не генерировать Java-заглушки для этого файла Groovy при компиляции
action.ExcludeFromStubGeneration.text=Исключить из генерации заглушек
action.Gant.NewScript.description=Создать новый скрипт Gant
action.Gant.NewScript.text=Скрипт Gant
action.Groovy.CheckResources.Make.description=Запустить инкрементальный компилятор для файлов Groovy в корневых каталогах ресурсов для проверки проблем компиляции
action.Groovy.CheckResources.Make.text=Собрать ресурсы [_B]
action.Groovy.CheckResources.Rebuild.description=Запустить компилятор для всех файлов Groovy в корневых каталогах ресурсов для проверки проблем компиляции
action.Groovy.CheckResources.Rebuild.text=Пересобрать ресурсы  [_R]
action.Groovy.Console.description=Запустить консоль Groovy
action.Groovy.Console.text=Консоль Groovy
action.Groovy.NewClass.description=Создать новый класс Groovy
action.Groovy.NewClass.text=Класс Groovy
action.Groovy.NewScript.description=Создать новый скрипт Groovy
action.Groovy.NewScript.text=Скрипт Groovy
action.build.module.restart.description=Собрать модуль ''{0}'' и перезапустить
action.build.restart.text=Собрать и перезапустить
action.collapse.all.description=Свернуть все
action.collapse.all.text=Свернуть все
action.convert.lambda.to.closure=Преобразовать лямбду в замыкание
action.expand.all.description=Развернуть все
action.expand.all.text=Развернуть все
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=Генерирует getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=Генерирует getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=getter и setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=Генерирует setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=Генерирует конструктор
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=Конструктор
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=Действие генерирует equals и hashCode
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=equals() и hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=Действие генерирует propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=Действие генерирует propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=Генерирует метод toString()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=to_String()
action.remove.dynamic.member.description=Удалить динамический член
action.remove.dynamic.member.text=Удалить
add.class.to.extends.family.name=Реализовать
add.compilestatic=Добавить @CompileStatic
add.dynamic.element=Добавить динамический элемент
add.dynamic.method=Добавить динамический метод
add.dynamic.method.0=Добавить динамический метод ''{0}''
add.dynamic.property=Добавить динамическое свойство ''{0}''
add.method=Добавить метод ''{0}()'' в класс ''{1}''
add.method.family=Добавить метод
add.modifier.sealed=Добавить модификатор 'sealed'
add.parenthesis.to.lambda.parameter.list=Добавить круглые скобки к списку параметров
add.return.type=Добавить тип возвращаемого значения
add.return.type.to.method.declaration=Добавить тип возвращаемого значения в объявление метода
add.to.resources=Добавить в ресурсы
add.type.customizer.to.resources=Добавить скрипт настройки типа в ресурсы
ambiguous.code.block=Неоднозначный блок кода
annotation.collector.cannot.have.attributes=Тип аннотации с @AnnotationCollector не может иметь атрибуты
annotation.field.can.only.be.used.within.a.script=Аннотация @Field может использоваться только внутри скрипта
annotation.field.can.only.be.used.within.a.script.body=Аннотация @Field может использоваться только внутри тела скрипта
annotation.field.should.have.type.declaration=Поле в аннотации должно иметь объявление типа
annotation.type.cannot.be.inner=Тип аннотации не может быть внутренним
annotation.types.may.not.have.extends.clause=Типы аннотаций не могут иметь выражение 'extends'
annotation.types.may.not.have.implements.clause=Типы аннотаций не могут иметь выражение 'implements'
anonymous.class=анонимный класс
anonymous.class.cannot.have.abstract.method=Анонимный класс не может иметь абстрактный метод
anonymous.class.derived.from.0=анонимный класс, производный от {0}
anonymous.classes.cannot.be.created.from.traits=Анонимные классы из трейтов доступны начиная с Groovy 2.5.2
are.you.sure.to.delete.dynamic.property=Вы уверены, что хотите удалить ''{0}''?
are.you.sure.to.delete.elements=Вы уверены, что хотите удалить ''{0}'' элементов?
at.interface.0.does.not.contain.attribute=@interface ''{0}'' не содержит атрибут ''{1}''
attribute.descriptor.abstract.class=Абстрактный класс
attribute.descriptor.annotation.attribute.name=Имя атрибута аннотации
attribute.descriptor.annotation.name=Имя аннотации
attribute.descriptor.annotations=Аннотации
attribute.descriptor.anonymous.class=Анонимный класс
attribute.descriptor.bad.character=Некорректный символ
attribute.descriptor.block.comment=Блочный комментарий
attribute.descriptor.braces=Фигурные скобки
attribute.descriptor.braces.and.operators=Фигурные скобки и операторы
attribute.descriptor.brackets=Квадратные скобки
attribute.descriptor.class=Класс
attribute.descriptor.classes.and.interfaces=Классы и интерфейсы
attribute.descriptor.closure.expression.braces.and.arrow=Фигурные скобки и стрелка выражения замыкания
attribute.descriptor.comments=Комментарии
attribute.descriptor.constructor.call=Вызов конструктора
attribute.descriptor.constructor.declaration=Объявление конструктора
attribute.descriptor.enum=Перечисление
attribute.descriptor.fields=Поля
attribute.descriptor.groovydoc=Groovydoc
attribute.descriptor.groovydoc.tag=Тег
attribute.descriptor.groovydoc.text=Текст
attribute.descriptor.gstring=GString
attribute.descriptor.instance.field=Поле экземпляра
attribute.descriptor.instance.method.call=Вызов метода экземпляра
attribute.descriptor.instance.property.reference=Ссылка на свойство экземпляра
attribute.descriptor.interface=Интерфейс
attribute.descriptor.invalid.string.escape=Некорректная строковая escape-последовательность
attribute.descriptor.keyword=Ключевое слово
attribute.descriptor.label=Метка
attribute.descriptor.lambda.expression.braces.and.arrow=Фигурные скобки и стрелка лямбда-выражения
attribute.descriptor.line.comment=Однострочный комментарий
attribute.descriptor.list.map.to.object.conversion=Преобразование списка/карты в объект
attribute.descriptor.local.variable=Локальная переменная
attribute.descriptor.map.key.named.argument=Ключ карты/именованный аргумент
attribute.descriptor.method.declaration=Объявление метода
attribute.descriptor.methods=Методы
attribute.descriptor.number=Число
attribute.descriptor.operator.sign=Знак оператора
attribute.descriptor.parameter=Параметр
attribute.descriptor.parentheses=Круглые скобки
attribute.descriptor.reassigned.local.variable=Переприсвоенная локальная переменная
attribute.descriptor.reassigned.parameter=Переприсвоенный параметр
attribute.descriptor.references=Ссылки
attribute.descriptor.static.field=Статическое поле
attribute.descriptor.static.method.call=Вызов статического метода
attribute.descriptor.static.property.reference=Ссылка на статическое свойство
attribute.descriptor.string=Строка
attribute.descriptor.strings=Строки
attribute.descriptor.trait=Трейт
attribute.descriptor.type.parameter=Параметр типа
attribute.descriptor.unresolved.reference=Неразрешённая ссылка
attribute.descriptor.valid.string.escape=Корректная строковая escape-последовательность
attribute.descriptor.variables.and.parameters=Переменные и параметры
attribute.name.expected=Ожидается имя атрибута
base.script.annotation.is.allowed.only.inside.scripts=Аннотация @BaseScript может использоваться только внутри скриптов
break.outside.loop=Оператор break с именованными метками разрешен только внутри циклов
break.outside.loop.or.switch=Оператор 'break' разрешен только внутри циклов или switch-выражений с двоеточием
builder.annotation.not.support.super.for.simple.strategy=Атрибут аннотации 'includeSuperProperties' не поддерживается groovy.transform.builder.SimpleStrategy
call.can.throw.npe=Цепочка вызовов может вызвать NullPointerException
call.without.parentheses.are.supported.since.groovy.3=Вызовы без скобок в списке аргументов поддерживаются начиная с Groovy 3.0
cannot.access=Доступ к ''{0}'' превышает права доступа
cannot.apply.constructor=Конструктор ''{0}'' в ''{1}'' не может быть применен к ''{2}''
cannot.apply.default.constructor=Невозможно применить конструктор по умолчанию для класса ''{0}''
cannot.apply.method.or.closure=''{0}'' не может быть применен к ''{1}''
cannot.apply.method1=''{0}'' в ''{1}'' не может быть применен к ''{2}''
cannot.assign=Невозможно присвоить ''{0}'' значению ''{1}''
cannot.assign.a.value.to.final.field.0=Невозможно присвоить значение final полю ''{0}''
cannot.assign.a.value.to.final.parameter.0=Невозможно присвоить значение final параметру ''{0}''
cannot.assign.string.to.enum.0=Невозможно присвоить строку перечислению ''{0}''
cannot.cast=Невозможно привести ''{0}'' к типу ''{1}''
cannot.create.class=Невозможно создать класс
cannot.create.class.error.text=Невозможно создать класс ''{0}''\: {1}
cannot.create.class.error.title=Невозможно создать класс
cannot.find.enum.constant.0.in.enum.1=Невозможно найти константу ''{0}'' в перечислении ''{1}''
cannot.infer.argument.types=Невозможно вывести типы аргументов
cannot.instantiate.abstract.class=Невозможно создать экземпляр абстрактного класса ''{0}''
cannot.instantiate.interface=Невозможно создать экземпляр интерфейса ''{0}''
cannot.reference.non.static=Невозможно обратиться к нестатическому символу ''{0}'' из статического контекста
cannot.resolve=Не удаётся разрешить символ ''{0}''
cannot.return.from.constructor=Невозможно вернуть объект из конструктора
cannot.return.from.void.method=Невозможно вернуть объект из метода, возвращающего 'void'
cannot.return.type=Невозможно вернуть ''{0}'' из метода, возвращающего ''{1}''
catch.statement.parameter.type.should.be.a.subclass.of.throwable=Тип параметра catch должен быть подклассом Throwable
change.base.method.label=Изменить базовый метод
change.implements.and.extends.classes=Нормализовать списки extends и implements
change.lvalue.type=Изменить тип переменной ''{0}'' на ''{1}''
change.modifier=Сделать ''{0}'' {1}
change.modifier.family.name=Изменить модификаторы
change.modifier.not=Сделать ''{0}'' не {1}
change.signature.default.initializer.column=Инициализатор по умолчанию
change.signature.type.column=Тип
change.usages.label=Изменить использования
checkbox.delegate.via.overloading.method=Делегировать через перегруженный метод
checkbox.ignore.conditional.operators=Игнорировать условные операторы
checkbox.ignore.double.checked.locking.on.volatile.fields=Игнорировать двойную проверку блокировки для volatile полей
checkbox.ignore.obscure.operators=Игнорировать неявные операторы
checkbox.inspect.anonymous.closures=Проверять анонимные замыкания
checkbox.inspect.gradle.files=Проверять файлы Gradle
checkbox.only.warn.if.loop.empty=Предупреждать только если цикл пуст
checkbox.report.unmatched.null=Сообщать о несоответствующих 'null'
class.definition.is.not.expected.here=Определение класса здесь не ожидается
class.is.not.annotation=''{0}'' не является аннотацией
closure=замыкание
closure.is.accessed.outside.of.groovy=Поле <b>{0}</b> доступно вне Groovy
closure.is.too.complex.to.analyze=Замыкание слишком сложное для анализа.\nТипы локальных переменных не выведены.
closure.used.as.variable=Замыкание передается как аргумент. Рефакторинг может нарушить семантику.
code.style.groovydoc.enable=Включить форматование GroovyDoc
code.style.groovydoc.tab.name=GroovyDoc
code.style.group.list.map.literals=Литералы списков и карт
code.style.option.after.assert.separator=После разделителя 'assert'
code.style.option.align.multiline.named.arguments=Выравнивать многострочные именованные аргументы
code.style.option.align.when.multiple=Выравнивать при множественных
code.style.option.before.assert.separator=Перед разделителем 'assert'
code.style.option.before.record.parameter.list=Перед списком параметров record
code.style.option.closure.left.brace.in.method.calls=Левая фигурная скобка замыкания в вызовах методов
code.style.option.gstring.injection.braces=Фигурные скобки для внедрения GString
code.style.option.import.annotations=Импортовать аннотации
code.style.option.in.named.argument.after.colon=В именованном аргументе после '\:'
code.style.option.in.named.argument.before.colon=В именованном аргументе перед '\:'
code.style.option.list.maps.literals=Литералы списков и мап
code.style.option.regexp.expression=Регулярное выражение (\=\=~, \=~)
code.style.option.relational.operators=Операторы отношения (<, >, <\=, >\=, <\=>)
code.style.option.simple.lambdas.closures.in.one.line=Простые лямбды/замыкания в одну строку
code.style.option.tuple.assignment.expression=Выражение присваивания кортежа
code.style.option.unary.operators=Унарные операторы (\!, -, +, ++, --, *)
code.style.option.use.flying.geese.braces=Использовать фигурные скобки в стиле "летящих гусей"
code.style.option.wrap.after.dot=Переносить после точки
collection.literal.contains.named.argument.and.expression.items=Литерал коллекции содержит одновременно именованные аргументы и выражения
command.name.add.dynamic.member=Добавить динамический член
comments.count.as.content=Считать комментарии содержимым
configurable.GantConfigurable.display.name=Gant
configurable.GroovyCompilerConfigurable.display.name=Компилятор Groovy
configurable.greclipse.border.title=Параметры Groovy-Eclipse
configurable.greclipse.command.java.agent.class.workaround='-javaAgentClass' предотвращает использование предопределённых параметров VM
configurable.greclipse.command.line.params.label=Параметры командной строки\:
configurable.greclipse.debug.checkbox=Генерировать отладочную информацию
configurable.greclipse.path.chooser.description=Выберите путь к groovy-eclipse-batch-*.jar с версией, соответствующей вашему дистрибутиву Groovy
configurable.greclipse.path.label=Путь к groovy-eclipse-batch jar\:
configurable.greclipse.vm.options.comment=Если указано, переопределяет общие и пользовательские параметры VM процесса сборки
configurable.greclipse.vm.options.label=Параметры VM\:
configurable.hotswap.checkbox=Включить агент hot-swap для кода Groovy
configurable.hotswap.checkbox.description=Может вызвать проблемы сериализации в отлаживаемом приложении
configure.groovy.library=Настроить Groovy SDK…
constructor.cannot.have.static.modifier=Конструктор не может быть static
constructors.are.not.allowed.in.anonymous.class=Конструкторы не разрешены в анонимном классе
constructors.are.not.allowed.in.interface=Конструкторы не разрешены в интерфейсе
constructors.cannot.have.return.type=Элемент возвращаемого типа не разрешен в конструкторе
continue.outside.loop=Оператор continue разрешен только внутри циклов
conversion.closure.not.allowed.in.non.groovy.files=Рефакторинг не разрешен для замыканий, имеющих вхождения в не-Groovy файлах\:
conversion.method.not.allowed.in.non.groovy.files=Рефакторинг не разрешен для методов, имеющих вхождения в не-Groovy файлах\:
convert.cannot.itself=Рефакторинг недоступен для самого параметра мапы
convert.param.to.map.entry=Преобразовать параметр в элемент мапы
convert.parameter.to.map.entry.title=Преобразовать параметр в элемент мапы
create.annotation.text=Создать аннотацию ''{0}''
create.class.family.name=Создать класс
create.class.text=Создать класс ''{0}''
create.directory.command=Создать директорию
create.enum=Создать enum ''{0}''
create.field.from.usage=Создать поле ''{0}''
create.field.from.usage.family.name=Создать поле из использования
create.instance.of.built-in.type=Создание экземпляра встроенного типа
create.interface.text=Создать интерфейс ''{0}''
create.method.from.usage=Создать метод ''{0}''
create.method.from.usage.family.name=Создать метод из использования
create.parameter.from.usage=Создать параметр ''{0}''
create.parameter.from.usage.family.name=Создать параметр из использования
create.record.text=Создать запись ''{0}''
create.trait=Создать трейт ''{0}''
create.variable.from.usage=Создать переменную ''{0}''
create.variable.from.usage.family.name=Создать переменную из использования
cyclic.inheritance.involving.0=Циклическое наследование с участием ''{0}''
debug.option=Включить отладочный стек-трейс [&D]
declare.explicit.implementations.of.trait=Объявить явные реализации трейта
declared.type.0.extends.1.which.is.circular.inheritance=Объявленный тип ''{0}'' расширяет ''{1}'', что создает циклическое наследование
declared.type.0.have.to.extend.script=Объявленный тип ''{0}'' не расширяет класс ''groovy.lang.Script''
def.visibility.presentation=def
default.initializers.are.not.allowed.in.abstract.method=Инициализаторы по умолчанию не разрешены в абстрактных методах
default.modifier.in.old.versions=Модификатор 'default' доступен в Groovy 3.0 или более поздней версии
delegate.annotation.is.only.for.methods.without.arguments=Аннотация @Delegate не может быть применена к методу с аргументами
destination.package=Целевой пакет\:
dialog.create.class.package.chooser.title=Выберите целевой пакет
dialog.message.gant.not.configured=Gant не настроен
dialog.title.no.jdk.specified.error=Groovy SDK не указан
dialog.title.no.jdk.specified.prompt=Хотите создать проект без назначенного SDK?
dialog.title.no.jdk.specified.title=Groovy SDK не указан
dialog.title.refactoring.unavailable.in.current.scope=Рефакторинг недоступен в текущей области
dialog.title.select.groovy.sdk=Выберите Groovy SDK
dialog.title.specify.groovy.sdk=Укажите домашнюю директорию Groovy SDK
dialog.title.validation.directory.you.specified.does.not.contain.groovy.sdk.do.you.want.to.create.project.with.this.configuration=Указанная директория не содержит Groovy SDK. Хотите создать проект с этой конфигурацией?
dialog.title.validation.invalid.sdk.specified.error=Указан недействительный Groovy SDK
dialog.title.validation.invalid.sdk.specified.title=Указан недействительный Groovy SDK
dialog.title.validation.path.does.not.contain.groovy.sdk=Путь не содержит Groovy SDK
dialog.title.validation.path.should.not.be.empty=Путь не должен быть пустым
do.you.want.to.change.method.return.type=Хотите изменить возвращаемый тип метода ''{0}''
do.you.want.to.change.type.of.parameter.in.method=Хотите изменить тип параметра ''{0}'' в методе ''{1}''
do.you.want.to.change.variable.type=Хотите изменить тип ''{0}''
doc.end.expected=Ожидается '*/'
documentation.cannot.infer.type.label=Невозможно вывести тип
documentation.gdk.label=GDK
documentation.inferred.type.label=Выведенный тип
duplicate.attribute=Повторяющийся атрибут
duplicate.class=Класс ''{0}'' уже существует в ''{1}''
duplicate.element.in.the.map=Повторяющийся элемент ''{0}'' в мапе
duplicate.inner.class=Повторяющийся класс\: ''{0}''
duplicate.modifier=Повторяющийся модификатор ''{0}''
duplicated.named.parameter=Найден повторяющийся именованный параметр ''{0}''
duplicating.named.parameter=Повторяющийся именованный параметр ''{0}'' в параметрах\: {1}
dynamic.dialog.class.label=Класс [&C]\:
dynamic.dialog.static.checkbox=static [&S]
dynamic.dialog.type.label=Тип [&T]\:
dynamic.element=Динамический элемент
dynamic.element.deletion=Удаление динамического элемента
dynamic.members.column.name.element=Динамический элемент
dynamic.members.column.name.type=Тип
dynamic.method.property.type=Тип свойства [&T]\:
dynamic.method.return.type=Возвращаемый тип [&T]\:
dynamic.name=Имя
dynamic.properties.table.name=Аргументы метода
dynamic.property.deletion=Удаление динамического свойства
dynamic.tool.window.id=Динамические члены
dynamic.type=Тип
ellipsis.type.is.not.allowed.here=Тип многоточия здесь не разрешен
enums.may.not.have.extends.clause=Перечисления не могут иметь оператор 'extends'
equals.between.inconvertible.types.tooltip=<code>{0}</code> между объектами несовместимых типов ''{1}'' и ''{2}''
exception.0.has.already.been.caught=Исключение ''{0}'' уже было перехвачено
expected.0.to.be.inline.constant=Ожидалось, что ''{0}'' будет встроенной константой
expected.type.0=Ожидался ''{0}'', найден ''{1}''
explicit.constructors.are.not.allowed.in.immutable.class=Явные конструкторы не разрешены для класса @Immutable
explicit.includes.and.excludes=Должно быть указано только одно из 'includes' или 'excludes'
expression.expected=Ожидается выражение
expression.type.no.expression=Выражение не найдено
expression.type.unknown=<unknown>
extract.closure.command.name=Извлечь замыкание
field.already.defined=Поле ''{0}'' уже определено
field.already.exists=Поле <b>{0}</b> уже существует
field.is.used.in.argument.label=Поле <b>{0}</b> используется в метке аргумента
field.should.be.immutable=Поле ''{0}'' должно иметь неизменяемый тип или быть объявлено с помощью @ImmutableOptions
file.exists=Файл ''{0}'' уже существует в директории ''{1}''
file.template.group.title.groovy=Groovy
filetype.dgm.description=Файл дескриптора модуля расширения Groovy
filetype.dgm.display.name=DGM
filetype.gdsl.description=Конфигурация IntelliJ Groovy DSL
filetype.gdsl.display.name=Groovy DSL
filetype.logback.description=Конфигурация Groovy Logback DSL
filetype.logback.display.name=Groovy Logback DSL
final.class.cannot.be.extended=Класс final не может быть расширен
final.visibility.presentation=final
find.method.ro.closure.usages=Поиск использований включающего замыкания в файлах проекта
find.method.ro.method.usages=Поиск использований включающего метода в файлах проекта
find.usages.method.0.of.class.1={0} класса {1}
fix.class=Исправить класс {0}
fix.package.name=Исправить имя пакета
framework.0.home.label=Домашняя директория {0}\:
framework.0.library=Библиотека {0}
framework.0.library.version.1=Библиотека {0} версии {1}
framework.0.sdk.chooser.description=Выберите директорию, содержащую дистрибутив {0}
framework.0.sdk.chooser.error.message=Похоже, что дистрибутив {0} в указанном пути поврежден. Невозможно определить версию.
framework.0.sdk.chooser.error.title=Не удалось создать библиотеку
framework.0.sdk.chooser.title=SDK {0}
framework.gant=Gant
gdsl.error.notification.title=Ошибка выполнения DSL скрипта
gdsl.investigate.link.label=Нажмите здесь для исследования
generate.equals.and.hashcode.already.defined.title=equals() и hashCode() уже определены
generate.equals.and.hashcode.already.defined.warning=equals() и hashCode() уже определены
generate.equals.and.hashcode.already.defined.warning.anonymous=equals() и hashCode() уже определены
generate.equals.compare.arrays.comment=// Возможно некорректно - сравнение массивов Object[] с помощью Arrays.equals
generate.equals.compare.nested.arrays.comment=// Сравнить вложенные массивы - значения {0} здесь
generate.method.missing.already.defined.title=methodMissing() уже определен
generate.method.missing.already.defined.warning=methodMissing() уже определен
generate.property.missing.already.defined.title=propertyMissing() уже определен
generate.property.missing.already.defined.warning=propertyMissing() уже определен
generated.stub.exclude.link.label=Исключить из генерации стабов
generated.stub.message=Этот стаб создан для класса Groovy для обеспечения кросс-компиляции Groovy-Java
generated.stub.navigate.link.label=Перейти к классу Groovy
getter.0.clashes.with.getter.1=Произошел конфликт\: ''{0}'' с ''{1}''
getter.kind.gdk.method.0=GDK метод {0}
getter.kind.getter.0=Геттер {0}
getter.kind.method.0=Метод {0}
ginq.code.style.group.ginq.clauses=Операторы GINQ
ginq.code.style.option.indent.having.clauses=Отступ для оператора 'having'
ginq.code.style.option.indent.on.clauses=Отступ для оператора 'on'
ginq.code.style.option.space.after.keyword=Ставить пробел после ключевых слов
ginq.code.style.option.wrap.having.clauses=Переносить оператор 'having'
ginq.code.style.option.wrap.on.clauses=Переносить оператор 'on'
ginq.error.message.0.must.be.after.1=''{0}'' должно быть после ''{1}''
ginq.error.message.0.must.be.before.1=''{0}'' должно быть перед ''{1}''
ginq.error.message.boolean.condition.expected=Ожидается логическое условие
ginq.error.message.container.expected=Ожидается GINQ, Iterable, Stream или массив
ginq.error.message.expected.a.boolean.expression=Ожидается логическое выражение
ginq.error.message.expected.alias=Ожидается имя псевдонима
ginq.error.message.expected.data.source=Ожидается источник данных
ginq.error.message.expected.in.operator=Ожидается '… in …'
ginq.error.message.expected.one.or.two.arguments.for.limit=Для 'limit' ожидается один или два аргумента
ginq.error.message.from.must.be.in.the.start.of.a.query='from' должно быть в начале запроса
ginq.error.message.groupby.expected.a.list.of.expressions=Ожидается список выражений
ginq.error.message.on.is.expected.after.join=После оператора типа 'join' ожидается 'on'
ginq.error.message.on.should.not.be.provided.after.crossjoin='on' не ожидается после 'crossjoin'
ginq.error.message.orderby.expected.a.list.of.ordering.fields=Ожидается список полей сортировки
ginq.error.message.query.should.end.with.select=Запрос должен заканчиваться на 'select'
ginq.error.message.query.should.start.from.from=Запрос должен начинаться с 'from'
ginq.error.message.unrecognized.query=Нераспознанный запрос
gr.package.inspection.check.scripts=Проверять скрипты
grab.error.0.title=Невозможно выполнить @Grab\: {0}
grab.error.ivy.missing.message=Извините, но ИСРA не может выполнить @Grab зависимостей без Apache Ivy. Пожалуйста, добавьте Apache Ivy в зависимости вашего модуля и повторите действие.
grab.error.ivy.missing.title=Отсутствует Ivy
grab.family.name=Grab
grab.intention.name=Получить артефакты
grab.jar.count=<b>{0}</b>\: {1} {1, choice, 0\#jar|1\#jar|2\#jar}
grab.progress.title=Обработка аннотаций @Grab
grab.result.title=Добавлено {0} Grape зависимостей {0, choice, 0\#jar|1\#jar|2\#jar}
groovy.complex.argument.label.annotator.message=Сложное выражение метки перед двоеточием должно быть заключено в скобки
groovy.complex.argument.label.quick.fix.message=Заключить выражение в скобки
groovy.consoles.type=Консоли Groovy
groovy.debug.caption=Groovy
groovy.debug.disable.specific.methods=Не заходить в определённые классы Groovy [&I]
groovy.does.not.support.constructor.type.arguments=Groovy не поддерживает аргументы типа конструктора
groovy.file.0=Groovy файл ''{0}''
groovy.file.extension.is.not.mapped.to.groovy.file.type=Файлы *.groovy сопоставлены с ''{0}''.\nВы можете сопоставить их с Groovy в Настройки | Типы файлов
groovy.library.is.not.configured.for.module=Groovy SDK не настроен для модуля ''{0}''
groovy.library.label=Библиотека Groovy\:
groovy.term.annotation=аннотация
groovy.term.binding=переменная привязки скрипта
groovy.term.class=класс
groovy.term.closure=замыкание
groovy.term.enum=enum
groovy.term.expression=выражение
groovy.term.field=поле
groovy.term.interface=интерфейс
groovy.term.label=метка
groovy.term.method=метод
groovy.term.parameter=параметр
groovy.term.property=свойство
groovy.term.record=record
groovy.term.trait=trait
groovy.term.type.parameter=параметр типа
groovy.term.variable=локальная переменная
groovy.version.0=Groovy {0}
groovy.version.bundled.0=Встроенный Groovy {0}
group.Groovy.CheckResources.description=Запустить компилятор для Groovy файлов в корневых ресурсах для проверки проблем компиляции
group.Groovy.CheckResources.text=Groovy ресурсы [_O]
header.extract.closure=Извлечь замыкание
highlight.if.groovy.object.methods.overridden=Подсвечивать ссылки из класса, переопределяющего invokeMethod(), getProperty() или setProperty()
highlight.if.missing.methods.declared=Подсвечивать ссылки из класса, объявляющего missingMethod() или missingProperty()
identifier.expected=Ожидается идентификатор
identifier.or.block.expected=Ожидается идентификатор или блок кода
ignore.boolean.expressions=Игнорировать неприсвоенные переменные в логических проверках
ignore.when.catch.parameter.is.named.ignore.or.ignored=Игнорировать, когда параметр catch назван ignore или ignored
illegal.combination.of.modifiers=Недопустимая комбинация модификаторов
illegal.combination.of.modifiers.abstract.and.final=Недопустимая комбинация модификаторов 'abstract' и 'final'
illegal.combination.of.modifiers.volatile.and.final=Недопустимая комбинация модификаторов 'volatile' и 'final'
illegal.default.modifier=Модификатор 'default' имеет смысл только в методах интерфейса
illegal.default.modifier.fix=Удалить модификатор 'default'
illegal.escape.character.in.string.literal=Недопустимый escape-символ в строковом литерале
illegal.method.name=Имя метода содержит недопустимые символы\: {0}
illegal.nonsealed.modifier.fix=Удалить модификатор 'non-sealed'
illegal.sealed.modifier.fix=Удалить модификатор 'sealed'
illegal.single.argument.lambda=Форма lambda с одним аргументом доступна только в правой части выражения присваивания или как аргумент внутри вызова метода
illegal.type.void=Недопустимый тип\: 'void'
immutable.options.property.not.exist=Свойство ''{0}'' не существует
implement.class=Реализовать {0}
import.statement.cannot.have.modifiers=Оператор import не может иметь модификаторов
incorrect.number.of.values=Неверное количество значений. Ожидалось\: {0}, Получено\: {1}
incorrect.variable.name=Неверное имя переменной
indexed.property.is.applicable.to.properties.only=@IndexedProperty применим только к свойствам
infer.method.parameters.types=Добавить явные типы для параметров
infer.method.parameters.types.for.method.declaration=Добавить явные типы для всех параметров в объявлении метода
initializer.cannot.be.0=Инициализатор не может быть {0}
initializer.cannot.have.annotations=Инициализаторы не могут иметь аннотации
initializers.are.forbidden.with.defaults=Значения по умолчанию запрещены при отключенном параметре 'defaults' в @TupleConstructor
initializers.are.not.allowed.in.interface=Инициализаторы не разрешены в интерфейсе
injection.should.not.contain.line.feeds=GString-инъекция не должна содержать переводы строк
inspection.annotations=Аннотации
inspection.assignments=Проблемы присваивания
inspection.bugs=Возможные ошибки
inspection.confusing=Потенциально запутанные конструкции кода
inspection.control.flow=Проблемы потока управления
inspection.data.flow=Поток данных
inspection.display.name.access.to.inaccessible.element=Недоступный элемент
inspection.display.name.access.to.static.field.locked.on.instance=Доступ к статическому полю заблокирован на данных экземпляра
inspection.display.name.annotation.references.unknown.identifier=@TupleConstructor и @MapConstructor
inspection.display.name.assignability.check=Несовместимые присваивания типов
inspection.display.name.assignment.can.be.operator.assignment=Присваивание может быть заменено на присваивание с оператором
inspection.display.name.assignment.to.for.loop.parameter=Присваивание параметру цикла 'for'
inspection.display.name.assignment.to.method.parameter=Присваивание параметру метода
inspection.display.name.break=Оператор 'break'
inspection.display.name.busy.wait=Активное ожидание
inspection.display.name.change.to.method=Вызов оператора может быть заменен вызовом метода
inspection.display.name.change.to.operator=Вызов метода может быть заменен вызовом оператора
inspection.display.name.check.labeled.statement=Проверка помеченных операторов
inspection.display.name.clashing.getters=Конфликтующие геттеры
inspection.display.name.clashing.trait.methods=Конфликтующие методы trait
inspection.display.name.class.naming.convention=Соглашение об именовании классов
inspection.display.name.conditional=Тернарное выражение
inspection.display.name.conditional.can.be.conditional.call=Тернарное выражение может быть заменено безопасным вызовом
inspection.display.name.conditional.can.be.elvis=Тернарное выражение может быть заменено elvis-выражением
inspection.display.name.conditional.with.identical.branches=Тернарное выражение с идентичными ветвями
inspection.display.name.constant.conditional=Константное условное выражение
inspection.display.name.constant.if.statement=Константное условие if
inspection.display.name.constant.naming.convention=Соглашение об именовании констант
inspection.display.name.constructor.named.arguments=Именованные аргументы вызова конструктора
inspection.display.name.continue=Оператор 'continue'
inspection.display.name.continue.or.break.from.finally.block='continue' или 'break' из блока 'finally'
inspection.display.name.delegates.to=@DelegatesTo
inspection.display.name.deprecated.api.usage=Использование устаревшего API
inspection.display.name.divide.by.zero=Деление на ноль
inspection.display.name.double.checked.locking=Double-checked блокировка
inspection.display.name.double.negation=Двойное отрицание
inspection.display.name.duplicate.switch.branch=Дублирующийся case в switch
inspection.display.name.empty.catch.block=Пустой блок 'catch'
inspection.display.name.empty.finally.block=Пустой блок 'finally'
inspection.display.name.empty.statement.body=Оператор с пустым телом
inspection.display.name.empty.sync.block=Пустой блок 'synchronized'
inspection.display.name.empty.try.block=Пустой блок 'try'
inspection.display.name.equals.between.inconvertible.types='equals()' между объектами несовместимых типов
inspection.display.name.fallthrough=Проваливание в операторе 'switch'
inspection.display.name.final.variable.access=Доступ к final переменной
inspection.display.name.groovydoc.check=Неразрешённая ссылка GroovyDoc
inspection.display.name.gstring.key=GString ключ в Map
inspection.display.name.if.statement.with.identical.branches=Оператор if с идентичными ветками
inspection.display.name.if.statement.with.too.many.branches=Оператор if с слишком большим количеством веток
inspection.display.name.implicit.null.argument=Неявный null аргумент
inspection.display.name.in.argument.check=Несовместимые типы аргументов 'in'
inspection.display.name.incorrect.range.argument=Некорректные аргументы диапазона
inspection.display.name.infinite.loop.statement=Бесконечный цикл
inspection.display.name.infinite.recursion=Бесконечная рекурсия
inspection.display.name.instance.method.naming.convention=Соглашение об именовании методов экземпляра
inspection.display.name.instance.variable.naming.convention=Соглашение об именовании переменных экземпляра
inspection.display.name.java.style.properties.invocation=Java-стиль доступа к свойствам
inspection.display.name.list.get.can.be.keyed.access=Вызов List.get может быть заменен на доступ по ключу
inspection.display.name.list.set.can.be.keyed.access=Вызов List.set может быть заменен на доступ по ключу
inspection.display.name.local.variable.naming.convention=Соглашение об именовании локальных переменных
inspection.display.name.loop.statement.that.doesnt.loop=Оператор цикла, который не выполняет итерации
inspection.display.name.map.get.can.be.keyed.access=Вызов Map.get может быть заменен на доступ по ключу
inspection.display.name.map.put.can.be.keyed.access=Вызов Map.put может быть заменен на доступ по ключу
inspection.display.name.method.may.be.static=Метод может быть объявлен как 'static'
inspection.display.name.method.parameter.count=Метод с слишком большим количеством параметров
inspection.display.name.method.with.more.than.three.negations=Метод с более чем тремя отрицаниями
inspection.display.name.multiple.return.points.per.method=Метод с несколькими точками возврата
inspection.display.name.negated.conditional=Отрицательное условное выражение
inspection.display.name.negated.if=Отрицательное условное выражение if
inspection.display.name.nested.assignment=Вложенное присваивание
inspection.display.name.nested.conditional=Вложенное условное выражение
inspection.display.name.nested.switch=Вложенный оператор switch
inspection.display.name.nested.synchronized.statement=Вложенный оператор 'synchronized'
inspection.display.name.new.instance.of.singleton=Новый экземпляр класса с аннотацией @groovy.lang.Singleton
inspection.display.name.no.return=Отсутствует оператор return
inspection.display.name.non.extending.permitted.subclasses=Неразрешённые подклассы без расширения
inspection.display.name.non.short.circuit.boolean=Не короткозамкнутое логическое выражение
inspection.display.name.notify.while.not.synchronized='notify()' или 'notifyAll()' без синхронизации
inspection.display.name.octal.integer=Восьмеричное целое число
inspection.display.name.overly.complex.arithmetic.expression=Чрезмерно сложное арифметическое выражение
inspection.display.name.overly.complex.boolean.expression=Чрезмерно сложное логическое выражение
inspection.display.name.overly.complex.method=Чрезмерно сложный метод
inspection.display.name.overly.long.method=Чрезмерно длинный метод
inspection.display.name.overly.nested.method=Чрезмерно вложенный метод
inspection.display.name.package.mismatch=Несоответствие пакета
inspection.display.name.parameter.naming.convention=Соглашение об именовании параметров метода
inspection.display.name.pointless.arithmetic=Бессмысленное арифметическое выражение
inspection.display.name.pointless.boolean=Бессмысленное логическое выражение
inspection.display.name.pojo.without.compile.static=@POJO без @CompileStatic
inspection.display.name.public.field.accessed.in.synchronized.context=Доступ к не private полю в синхронизованном контексте
inspection.display.name.reassigned.in.closure.local.var=Локальная переменная переназначается в замыкании или анонимном классе
inspection.display.name.result.of.assignment.used=Используется результат присваивания
inspection.display.name.result.of.increment.or.decrement.used=Используется результат инкремента или декремента
inspection.display.name.result.of.object.allocation.ignored=Игнорируется результат создания объекта
inspection.display.name.return.from.closure.can.be.implicit=Оператор 'return' может быть неявным
inspection.display.name.return.from.finally.block='return' внутри блока 'finally'
inspection.display.name.second.unsafe.call=Второй небезопасный вызов
inspection.display.name.silly.assignment=Бессмысленное присваивание
inspection.display.name.singleton.constructor=Конструкторы @Singleton
inspection.display.name.static.method.naming.convention=Соглашение об именовании static методов
inspection.display.name.static.variable.naming.convention=Соглашение об именовании static переменных
inspection.display.name.string.style.violation=Нарушение стиля строки
inspection.display.name.switch.exhaustiveness.check=Проверка исчерпываемости для выражений switch
inspection.display.name.switch.statement.with.no.default=Оператор switch без default case
inspection.display.name.synchronization.on.non.final.field=Синхронизация на не final поле
inspection.display.name.synchronization.on.this=Синхронизация на 'this'
inspection.display.name.synchronization.on.variable.initialized.with.literal=Синхронизация на переменной, инициализованной литералом
inspection.display.name.synchronized.method=Synchronized метод
inspection.display.name.system.run.finalizers.on.exit=Вызов System.runFinalizersOnExit()
inspection.display.name.thread.stop.suspend.resume=Вызов Thread.stop(), Thread.suspend() или Thread.resume()
inspection.display.name.throw.from.finally.block='throw' внутри блока 'finally'
inspection.display.name.trivial.conditional=Избыточное условное выражение
inspection.display.name.trivial.if=Избыточный оператор 'if'
inspection.display.name.type.customizer=Проверка настройщика типов
inspection.display.name.unassigned.access=Переменная не присвоена
inspection.display.name.unchecked.assignment.of.member.of.raw.type=Непроверенное присваивание из членов сырого типа
inspection.display.name.unconditional.wait=Безусловный вызов 'wait'
inspection.display.name.unnecessary.alias=Ненужный псевдоним импорта
inspection.display.name.unnecessary.continue=Ненужный оператор 'continue'
inspection.display.name.unnecessary.def.modifier=Ненужный модификатор 'def'
inspection.display.name.unnecessary.final.modifier=Ненужный модификатор 'final'
inspection.display.name.unnecessary.non.sealed.modifier=Ненужный модификатор 'non-sealed'
inspection.display.name.unnecessary.public.modifier=Ненужный модификатор 'public'
inspection.display.name.unnecessary.qualified.reference=Ненужная квалифицированная ссылка
inspection.display.name.unnecessary.return=Ненужный оператор 'return'
inspection.display.name.unnecessary.sealed.modifier=Ненужный модификатор 'sealed'
inspection.display.name.unnecessary.semicolon=Ненужная точка с запятой
inspection.display.name.unreachable.statement=Недостижимый оператор
inspection.display.name.unresolved.access=Неразрешённое ссылочное выражение
inspection.display.name.unresolved.labels.in.named.variant=Неразрешённая метка @NamedVariant/@NamedParam/@NamedDelegate
inspection.display.name.unsynchronized.method.overrides.synchronized.method=Несинхронизованный метод переопределяет synchronized метод
inspection.display.name.untyped.access=Нетипизованное ссылочное выражение
inspection.display.name.unused.assignment=Неиспользуемое присваивание
inspection.display.name.unused.catch.parameter=Неиспользуемый параметр 'catch'
inspection.display.name.unused.declaration=Неиспользуемое объявление
inspection.display.name.unused.inc.dec=Неиспользуемое увеличение или уменьшение
inspection.display.name.variable.can.be.final=Переменная может быть final
inspection.display.name.wait.call.not.in.loop='wait()' не в цикле
inspection.display.name.wait.while.not.synchronized='wait()' без синхронизации
inspection.display.name.while.loop.spins.on.field=Цикл while крутится на поле
inspection.error.handling=Обработка ошибок
inspection.gpath=GPath
inspection.message.0.not.allowed.for.record=''{0}'' не разрешено для record
inspection.message.access.to.static.field.locked.on.instance.data=Доступ к static полю <code>\#ref</code> заблокирован на данных экземпляра \#loc
inspection.message.annotation.non.sealed.cannot.be.applied.to.enum.class=Аннотация '@NonSealed' не может быть применена к enum-классу
inspection.message.annotation.sealed.cannot.be.applied.to.enum.class=Аннотация '@Sealed' не может быть применена к enum классу
inspection.message.arrows.in.case.expressions.are.available.with.groovy.4.or.later=Стрелки в выражениях case доступны в Groovy 4.0 или более поздней версии
inspection.message.assignment.replaceable.with.operator.assignment=<code>\#ref</code> можно упростить до ''{0}'' \#loc
inspection.message.assignment.to.for.loop.parameter=Присваивание параметру цикла for '\#ref' \#loc
inspection.message.assignment.to.method.parameter=Присваивание параметру метода '\#ref' \#loc
inspection.message.both.open.ranges.are.available.in.groovy.4.or.later=Открытые с обеих сторон диапазоны доступны в Groovy 4.0 или более поздней версии
inspection.message.call.to.ref.can.be.keyed.access=Вызов '\#ref' может быть заменен на доступ по ключу \#loc
inspection.message.call.to.ref.outside.of.loop=Вызов '\#ref' вне цикла \#loc
inspection.message.call.to.ref.outside.of.synchronized.context=Вызов '\#ref' вне synchronized контекста \#loc
inspection.message.call.to.ref.outside.synchronized.context=Вызов '\#ref' вне synchronized контекста \#loc
inspection.message.call.to.system.ref=Вызов 'System.\#ref' \#loc
inspection.message.call.to.thread.ref=Вызов 'Thread.\#ref' \#loc
inspection.message.call.to.thread.ref.in.a.loop=Вызов <code>Thread.\#ref()</code> в цикле, возможно активное ожидание \#loc
inspection.message.cannot.determine.type.ref=Не удаётся определить тип '\#ref'
inspection.message.cannot.resolve.method.call=Не удаётся разрешить метод 'call'
inspection.message.case.or.default.branches.are.expected=Ожидаются ветви 'case' или 'default'
inspection.message.class.cannot.be.non.sealed.without.sealed.parent=Класс ''{0}'' не может быть non-sealed без sealed родителя
inspection.message.class.has.no.explicit.or.implicit.subclasses=Класс ''{0}'' не имеет явных или неявных разрешённых подклассов
inspection.message.code.ref.code.recurses.infinitely.can.only.complete.by.throwing.exception=<code>\#ref</code> рекурсивно вызывает себя бесконечно и может завершиться только выбросом исключения \#loc
inspection.message.code.ref.code.statement.doesnt.loop=Оператор <code>\#ref</code> не создает цикл \#loc
inspection.message.compact.constructor.should.have.explicit.visibility.modifier=Компактный конструктор должен иметь явный модификатор видимости
inspection.message.conditional.expression=Условное выражение \#loc
inspection.message.conditional.expression.can.be.call=Условное выражение может быть вызовом \#loc
inspection.message.conditional.expression.can.be.elvis=Условное выражение может использовать оператор elvis \#loc
inspection.message.conditional.expression.with.identical.branches=Условное выражение с идентичными ветвями \#loc
inspection.message.constant.name.ref.doesnt.match.regex=Имя константы ''\#ref'' не соответствует регулярному выражению ''{0}'' \#loc
inspection.message.constant.name.ref.too.long=Имя константы '\#ref' слишком длинное
inspection.message.constant.name.ref.too.short=Имя константы '\#ref' слишком короткое
inspection.message.couldnt.find.property.field.with.this.name=Не удалось найти свойство или поле с таким именем \#loc
inspection.message.divide.by.zero=Деление на ноль \#loc
inspection.message.double.checked.locking=Double-checked locking \#loc
inspection.message.double.negation.ref=Двойное отрицание \#ref \#loc
inspection.message.dsl.descriptor.file.has.been.changed.and.isnt.currently.executed=DSL-дескриптор был изменен и в данный момент не выполняется
inspection.message.dsl.descriptor.file.has.been.disabled.due.to.processing.error=DSL-дескриптор был отключен из-за ошибки обработки
inspection.message.duplicate.switch.case.ref=Дублирующийся case '\#ref' в switch \#loc
inspection.message.empty.ref.block=Пустой блок '\#ref' \#loc
inspection.message.fallthrough.in.switch.statement=Проваливание в операторе 'switch' \#loc
inspection.message.fraction.literals.without.leading.zero.are.available.in.groovy.or.later=Дробные литералы без ведущего нуля доступны в Groovy 4.0 или более поздней версии
inspection.message.gstring.used.as.maps.key=GString используется как ключ map \#loc
inspection.message.instance.method.name.ref.doesnt.match.regex=Имя метода экземпляра ''\#ref'' не соответствует регулярному выражению ''{0}'' \#loc
inspection.message.instance.method.name.ref.too.long=Имя метода экземпляра '\#ref' слишком длинное
inspection.message.instance.method.name.ref.too.short=Имя метода экземпляра '\#ref' слишком короткое
inspection.message.instance.variable.name.ref.doesn.t.match.regex=Имя переменной экземпляра ''\#ref'' не соответствует регулярному выражению ''{0}'' \#loc
inspection.message.instance.variable.name.ref.too.long=Имя переменной экземпляра '\#ref' слишком длинное
inspection.message.instance.variable.name.ref.too.short=Имя переменной экземпляра '\#ref' слишком короткое
inspection.message.interface.cannot.be.non.sealed.without.sealed.parent=Интерфейс ''{0}'' не может быть non-sealed без sealed родителя
inspection.message.interface.has.no.explicit.or.implicit.implementors=Интерфейс ''{0}'' не имеет явных или неявных разрешённых реализаций
inspection.message.interpolated.string.should.be.dollar.slashy.quoted=Строка с интерполяцией должна использовать доллар-слэш-кавычки
inspection.message.interpolated.string.should.be.double.quoted=Строка с интерполяцией должна быть в двойных кавычках
inspection.message.interpolated.string.should.be.quoted.with.triple.double.quotes=Строка с интерполяцией должна быть в тройных двойных кавычках
inspection.message.interpolated.string.should.be.slashy.quoted=Строка с интерполяцией должна использовать слэш-кавычки
inspection.message.invalid.permits.clause.must.be.sealed=Неверное выражение ''permits''\: ''{0}'' должен быть ''sealed''
inspection.message.invalid.permits.clause.must.directly.extend=Неверное выражение ''permits''\: ''{0}'' должен напрямую расширять ''{1}''
inspection.message.keyword.yield.available.with.groovy.4.or.later=Ключевое слово 'yield' доступно в Groovy 4.0 или более поздней версии
inspection.message.label.name.ref.not.supported.by.0=Имя метки ''\#ref'' не поддерживается {0}
inspection.message.left.open.ranges.are.available.in.groovy.4.or.later=Левооткрытые диапазоны доступны в Groovy 4.0 или более поздней версии
inspection.message.local.variable.name.ref.doesnt.match.regex=Имя локальной переменной ''\#ref'' не соответствует регулярному выражению ''{0}'' \#loc
inspection.message.local.variable.name.ref.too.long=Имя локальной переменной '\#ref' слишком длинное
inspection.message.local.variable.name.ref.too.short=Имя локальной переменной '\#ref' слишком короткое
inspection.message.method.called.with.implicit.null.argument=Метод вызывается с неявным null аргументом
inspection.message.method.parameter.name.ref.doesnt.match.regex=Имя параметра метода ''\#ref'' не соответствует регулярному выражению ''{0}'' \#loc
inspection.message.method.parameter.name.ref.too.long=Имя параметра метода '\#ref' слишком длинное
inspection.message.method.parameter.name.ref.too.short=Имя параметра метода '\#ref' слишком короткое
inspection.message.method.ref.contains.too.many.parameters.0.1=Метод ''\#ref'' содержит слишком много параметров ({0}>{1})
inspection.message.method.ref.has.too.many.negations=Метод ''\#ref'' содержит слишком много отрицаний ({0} > 3)
inspection.message.method.ref.overly.complex.cyclomatic.complexity=Метод ''\#ref'' чрезмерно сложный (цикломатическая сложность \= {0}>{1})
inspection.message.method.ref.overly.nested.nesting.depth=Метод ''\#ref'' имеет чрезмерную вложенность (глубина вложенности \= {0}>{1})
inspection.message.method.ref.too.long.statement.count=Метод ''\#ref'' слишком длинный (количество операторов \= {0}>{1})
inspection.message.mixing.arrows.colons.not.allowed=Смешивание стрелок и двоеточий не допускается
inspection.message.modifier.non.sealed.cannot.be.applied.to.enum.class=Модификатор 'non-sealed' не может быть применен к enum классу
inspection.message.modifier.nonsealed.available.with.groovy.or.later=Модификатор 'non-sealed' доступен в Groovy 4.0 или более поздней версии
inspection.message.modifier.sealed.available.with.groovy.or.later=Модификатор 'sealed' доступен в Groovy 4.0 или более поздней версии
inspection.message.modifier.sealed.cannot.be.applied.to.enum.class=Модификатор 'sealed' не может быть применен к enum классу
inspection.message.multiline.string.should.be.dollar.slashy.quoted=Многострочная строка должна использовать доллар-слэш-кавычки
inspection.message.multiline.string.should.be.quoted.with.triple.double.quotes=Многострочная строка должна быть в тройных двойных кавычках
inspection.message.multiline.string.should.be.quoted.with.triple.quotes=Многострочная строка должна быть в тройных одинарных кавычках
inspection.message.multiline.string.should.be.slashy.quoted=Многострочная строка должна использовать слэш-кавычки
inspection.message.multiple.expressions.in.case.section.are.available.with.groovy.4.or.later=Множественные выражения в метках case доступны в Groovy 4.0 или более поздней версии
inspection.message.negated.conditional.expression=Отрицательное условное выражение \#loc
inspection.message.negated.if.condition.expression=Отрицательное условие в if \#loc
inspection.message.nested.assignment=Использование результата выражения присваивания \#loc
inspection.message.nested.assignment.expression=Вложенное выражение присваивания \#loc
inspection.message.nested.conditional.expression=Вложенное условное выражение \#loc
inspection.message.nested.ref.statement=Вложенный оператор '\#ref' \#loc
inspection.message.non.private.field.accessed.in.synchronized.context=Доступ к не-private полю '\#ref' в synchronized контексте \#loc
inspection.message.non.short.circuit.boolean.expression=Логическое выражение без короткого замыкания \#loc
inspection.message.not.allowed.in.sealed.hierarchy=''{0}'' не разрешен в sealed иерархии
inspection.message.octal.integer.ref=Восьмеричное число \#ref \#loc
inspection.message.only.one.final.sealed.non.sealed.should.be.applied.to.class=К классу должен применяться только один из модификаторов\: 'final', 'sealed', 'non-sealed', @Sealed или @NonSealed
inspection.message.overly.complex.arithmetic.expression=Чрезмерно сложное арифметическое выражение \#loc
inspection.message.overly.complex.boolean.expression=Чрезмерно сложное логическое выражение \#loc
inspection.message.package.name.mismatch=Несоответствие имени пакета
inspection.message.package.name.mismatch.actual.0.expected.1=Несоответствие имени пакета. Текущее\: ''{0}'', ожидаемое\: ''{1}''
inspection.message.permits.available.with.groovy.4.or.later='permits' доступен в Groovy 4.0 или более поздней версии
inspection.message.plain.string.should.be.dollar.slashy.quoted=Обычная строка должна использовать доллар-слэш-кавычки
inspection.message.plain.string.should.be.double.quoted=Обычная строка должна быть в двойных кавычках
inspection.message.plain.string.should.be.quoted.with.triple.double.quotes=Обычная строка должна быть в тройных двойных кавычках
inspection.message.plain.string.should.be.quoted.with.triple.quotes=Обычная строка должна быть в тройных одинарных кавычках
inspection.message.plain.string.should.be.single.quoted=Обычная строка должна быть в одинарных кавычках
inspection.message.plain.string.should.be.slashy.quoted=Обычная строка должна использовать слэш-кавычки
inspection.message.pojo.has.effect.only.with.compilestatic=@POJO действует только с @CompileStatic
inspection.message.property.0.is.final=Свойство ''{0}'' является final \#loc
inspection.message.property.0.is.ignored.by.map.constructor=Свойство ''{0}'' игнорируется @MapConstructor \#loc
inspection.message.property.not.indexable.type.must.be.array.or.list.but.found.0=Свойство не индексируемо. Тип должен быть массивом или списком, но найден {0}
inspection.message.record.parameter.should.be.immutable=Параметр record ''{0}'' должен иметь неизменяемый тип или быть объявлен таковым с помощью @ImmutableOptions
inspection.message.records.are.available.in.groovy.4.or.later=Records доступны в Groovy 4.0.0-beta-2 или выше
inspection.message.ref.can.be.simplified='\#ref' можно упростить \#loc
inspection.message.ref.has.0.return.points=<code>\#ref</code> имеет {0} точек возврата \#loc
inspection.message.ref.inside.finally.block='\#ref' внутри блока 'finally' \#loc
inspection.message.ref.is.unnecessary.as.last.statement.in.loop=\#ref не нужен как последний оператор в цикле \#loc
inspection.message.ref.is.unnecessary.as.last.statement.in.method.with.no.return.value=\#ref не нужен как последний оператор в методе без возвращаемого значения \#loc
inspection.message.ref.loop.spins.on.field=Цикл <code>\#ref</code> крутится на поле \#loc
inspection.message.ref.statement=\#ref оператор \#loc
inspection.message.ref.statement.at.end.closure.can.be.made.implicit=Явный return в конце замыкания \#loc
inspection.message.ref.statement.can.be.simplified=Оператор \#ref можно упростить \#loc
inspection.message.ref.statement.cannot.complete.without.throwing.exception=Оператор <code>\#ref</code> не может завершиться без выброса исключения \#loc
inspection.message.ref.statement.has.empty.body=Оператор '\#ref' имеет пустое тело
inspection.message.ref.statement.has.empty.branch=Оператор '\#ref' имеет пустую ветку
inspection.message.ref.statement.with.identical.branches=Оператор '\#ref' с идентичными ветками \#loc
inspection.message.ref.statement.with.no.default.branch=Оператор \#ref без ветки 'default'\#loc
inspection.message.ref.statement.with.too.many.branches=Оператор ''\#ref'' имеет слишком много веток ({0}) \#loc
inspection.message.result.increment.or.decrement.expression.used=Использование результатов инкремента или декремента \#loc
inspection.message.result.of.new.ref.is.ignored=Результат ''new \#ref{0}'' игнорируется \#loc
inspection.message.silly.assignment=Бессмысленное присваивание \#loc
inspection.message.static.interface.methods.must.be.qualified.in.groovy.4=Начиная с Groovy 4, 'static' методы интерфейса должны быть квалифицированы
inspection.message.static.method.name.ref.doesnt.match.regex=Имя static метода ''\#ref'' не соответствует регулярному выражению ''{0}'' \#loc
inspection.message.static.method.name.ref.too.long=Имя static метода ''\#ref'' слишком длинное
inspection.message.static.method.name.ref.too.short=Имя static метода ''\#ref'' слишком короткое
inspection.message.static.variable.name.ref.doesnt.match.regex=Имя static переменной ''\#ref'' не соответствует регулярному выражению ''{0}'' \#loc
inspection.message.static.variable.name.ref.too.long=Имя static переменной '\#ref' слишком длинное
inspection.message.static.variable.name.ref.too.short=Имя static переменной '\#ref' слишком короткое
inspection.message.string.escaping.could.be.minimized=Экранирование можно минимизовать
inspection.message.switch.expression.does.not.cover.all.possible.outcomes=Выражение switch не охватывает все возможные результаты
inspection.message.switch.expressions.are.available.with.groovy.4.or.later=Выражения switch доступны в Groovy 4.0 или выше
inspection.message.switch.expressions.do.not.support.return=Выражения switch не поддерживают 'return'
inspection.message.synchronization.on.non.final.field.ref=Синхронизация на нефинальном поле ''\#ref'' \#loc
inspection.message.synchronization.on.ref=Синхронизация на '\#ref' \#loc
inspection.message.synchronization.on.variable.ref.which.was.initialized.with.literal=Синхронизация на '\#ref', который был инициализован литералом \#loc
inspection.message.synchronized.method.ref=Synchronized метод '\#ref' \#loc
inspection.message.traits.0.contain.clashing.methods.with.signature.1=Трейты {0} содержат конфликтующие методы с сигнатурой {1}
inspection.message.trivial.conditional.expression=Тривиальное условное выражение \#loc
inspection.message.type.argument.0.can.not.be.1=Тип аргумента ''{0}'' не может быть ''{1}''
inspection.message.unconditional.call.to.ref=Безусловный вызов <code>\#ref()</code> \#loc
inspection.message.unreachable.statement=Недостижимый оператор \#loc
inspection.message.unsynchronized.method.ref.overrides.synchronized.method=Несинхронизованный метод '\#ref' переопределяет synchronized метод \#loc
inspection.message.unused.catch.parameter.ref=Неиспользуемый параметр catch '\#ref' \#loc
inspection.message.yield.or.throw.expected.in.case.section='yield' или 'throw' ожидается в секции case
inspection.method.metrics=Метрики методов
inspection.naming=Соглашения об именовании
inspection.other=Прочее
inspection.redundancy=Избыточность объявлений
inspection.separator.disable.in.file.types=Включить для типов файлов\:
inspection.style=Стиль
inspection.threading=Проблемы многопоточности
inspection.validity=Проблемы валидности
intention.category.closures=Groovy/Замыкания
intention.category.comments=Groovy/Комментарии
intention.category.control.flow=Groovy/Поток управления
intention.category.conversions=Groovy/Преобразования выражений
intention.category.groovy=Groovy
intention.category.groovy.declaration=Groovy/Объявления
intention.category.groovy.other=Groovy/Прочее
intention.category.groovy.style=Groovy/Стиль Groovy
intention.family.name.activate.dsl.descriptor=Активировать DSL дескриптор
intention.family.name.add.attributes.to.annotation=Добавить атрибуты к аннотации
intention.family.name.add.cast=Добавить приведение типа
intention.family.name.add.class.to.clause=Добавить класс в условие
intention.family.name.add.missing.case.branches=Добавить отсутствующие ветки case
intention.family.name.add.parameter.cast=Добавить приведение параметра
intention.family.name.change.variable.type=Изменить тип переменной
intention.family.name.collapse.conditional.expressions=Свернуть условное выражение
intention.family.name.collapse.if.statement=Свернуть оператор 'if'
intention.family.name.convert.conditional.expression.to.elvis=Преобразовать условное выражение в Elvis
intention.family.name.create.field=Создать поле
intention.family.name.fix.quotation=Исправить кавычки
intention.family.name.fix.range.class=Исправить класс диапазона
intention.family.name.make.return.implicit=Сделать return неявным
intention.family.name.remove.double.negation=Удалить двойное отрицание
intention.family.name.remove.unnecessary.continue=Удалить ненужный continue
intention.family.name.remove.unnecessary.return=Удалить ненужный return
intention.family.name.rename=Переименовать
intention.family.name.replace.for.each.operator=Заменить оператор 'for-each'
intention.family.name.replace.keywords=Заменить элементы
intention.family.name.replace.modifiers=Заменить модификаторы
intention.family.name.replace.something.with=Заменить ''{0}'' на ''{1}''
intention.family.name.replace.with.conditional.call=Заменить на условный вызов
intention.family.name.replace.with.keyed.access=Заменить на доступ по ключу
intention.family.name.replace.with.short.circuit.expression=Заменить на выражение с коротким замыканием
intention.family.name.simplify=Упростить
intention.name.activate.back=Активировать обратно
intention.name.add.required.attributes.to.map.constructor=Добавить необходимые атрибуты к '@MapConstructor'
intention.name.add.to.clause=Добавить ''{0}'' в {1} условие ''{2}''
intention.name.cast.operand.to.0=Привести операнд к {0}
intention.name.cast.to.0=Привести к {0}
intention.name.change.quotes.to.triple.double.quotes=Изменить кавычки на """
intention.name.change.quotes.to.triple.single.quotes=Изменить кавычки на '''
intention.name.convert.to.dollar.slashy.string=Преобразовать в dollar-slashy строку
intention.name.convert.to.double.quoted.string=Преобразовать в строку с двойными кавычками
intention.name.convert.to.single.quoted.string=Преобразовать в строку с одинарными кавычками
intention.name.convert.to.slashy.string=Преобразовать в slashy строку
intention.name.create.abstract.method.in.class=Создать abstract метод ''{0}'' в ''{1}''
intention.name.create.constant.field.in.class=Создать константное поле ''{0}'' в ''{1}''
intention.name.create.enum.constant.0=Создать константу enum ''{0}''
intention.name.create.field.in.class=Создать поле ''{0}'' в ''{1}''
intention.name.create.method.in.class=Создать метод ''{0}'' в ''{1}''
intention.name.insert.case.0=Вставить ''case {0}''
intention.name.insert.case.0.case.1=Вставить ''case {0}'', ''case {1}''
intention.name.insert.default.branch=Вставить ветку 'default'
intention.name.insert.missing.branches=Вставить отсутствующие ветки
intention.name.make.compact.constructor.public=Сделать компактный конструктор 'public'
intention.name.remove.wrong.modifiers.for.record=Удалить неправильные модификаторы для record
intention.name.replace=Заменить ''{0}'' на ''{1}''
intention.name.replace.eq.with.0.eq=Заменить ''\='' на ''{0}\=''
intention.name.replace.with.in=Заменить '\:' на 'in'
intention.name.replace.with.qualified.expression=Заменить на полное имя
interface.cannot.have.modifier.final=Интерфейс не может иметь модификатор 'final'
interface.members.are.not.allowed.to.be=Члены интерфейса не могут быть {0}
interface.must.have.no.static.method=Интерфейс не может иметь static метод
introduce.constant.title=Создать константу
introduce.parameter.delegate.via.overload=Делегировать через перегруженный метод [&L]
introduce.parameter.delegating.unavailable.tooltip=Делегирование не разрешено в контексте замыкания
introduce.parameter.do.not.replace.option.label=Не заменять [&O]
introduce.parameter.explicit.return.statement.option.label=Использовать явный оператор return [&X]
introduce.parameter.replace.all.fields.option.label=Заменить все поля [&R]
introduce.parameter.replace.fields.border.title=Заменить используемые в выражении поля на их геттеры
introduce.parameter.replace.inaccessible.fields.option.label=Заменить недоступные в контексте использования поля [&I]
introduce.variable.change.type.advertisement=Нажмите {0} для изменения типа
introduce.variable.declare.final.label=Объявить final [&F]
introduce.variable.name.label=Имя [&N]\:
introduce.variable.replace.all.0.occurrences=Заменить все вхождения ({0} вхождений) [&A]
introduce.variable.replace.all.occurrences=Заменить все вхождения [&A]
introduce.variable.type.label=Тип [&T]\:
invalid.lvalue=Недопустимое значение для присваивания
invalid.qualified.name=Некорректное полное имя Groovy
investigate.gdsl.error.family.name=Исследовать ошибку обработки DSL-дескриптора
investigate.gdsl.error.intention.name=Просмотреть подробности
invoke.completion.second.time.to.show.skipped.methods=Вызовите автодополнение повторно для отображения пропущенных методов
is.not.enclosing.class=''{0}'' не является внешним классом
java.style.for.each.statement.requires.a.type.declaration=For-each в стиле Java требует объявления типа
java.style.properties.invocation.intention.family.name=Изменить вызов аксессора в стиле Java на ссылку на свойство в стиле Groovy
java.style.properties.invocation.intention.name=Изменить на ссылку на свойство в стиле Groovy
java.style.property.access=Вызов аксессора в стиле Java
label.already.used=Метка ''{0}'' уже используется
label.groovy.sdk=Groovy SDK\:
language.groovy=Groovy
leave.only.modifier.or.annotation.0=Оставить только ''{0}''
listener.list.field.must.have.a.generic.collection.type=Поле @ListenerList должно иметь обобщенный тип Collection
listener.list.field.with.generic.wildcards.not.supported=Поле @ListenerList с обобщенными wildcard-типами не поддерживается
live.template.context.declaration=Объявление
live.template.context.expression=Выражение
live.template.context.statement=Оператор
local.var.0.is.reassigned=Локальной переменной ''{0}'' присваивается новое значение
lock.field.0.must.be.static=Поле блокировки ''{0}'' должно быть static
lock.field.0.must.not.be.static=Поле блокировки ''{0}'' не должно быть static
lock.field.0.not.found=Поле блокировки ''{0}'' не найдено
loss.of.precision=Возможна потеря точности при преобразовании из ''{0}'' в ''{1}''
map.param.name=Имя Map-параметра [&N]\:
map.parameter.dialog.create.new.checkbox=Создать новый параметр для именованных аргументов [&C]
map.parameter.dialog.explicit.type.checkbox=Явно указать тип
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=Метод ''{0}'' не может иметь более слабые права доступа (''{1}'') чем ''{2}'' в ''{3}'' (''{4}'')
method.0.cannot.override.method.1.in.2.overridden.method.is.final=Метод ''{0}'' не может переопределить метод ''{1}'' в ''{2}''; переопределяемый метод является final
method.0.is.too.complex.too.analyze=Метод ''{0}'' слишком сложен для анализа.\nТипы локальных переменных не выведены.
method.call.is.ambiguous=Неоднозначный вызов метода
method.does.not.override.super=Метод не переопределяет метод суперкласса
method.duplicate=Метод с сигнатурой {0} уже определен в классе ''{1}''
method.has.incorrect.modifier.volatile=Метод имеет некорректный модификатор 'volatile'
method.is.not.implemented=Метод ''{0}'' не реализован
method.is.used.outside.of.groovy=Метод используется вне Groovy
method.may.be.static=Метод может быть static
method.may.be.static.ignore.empty.method.option=Игнорировать пустые методы
method.may.be.static.only.private.or.final.option=Проверять только final или private методы
method.may.be.static.option.ignore.trait.methods=Игнорировать методы trait
method.parameters.count.max.parameters.option=Максимальное количество параметров\:
method.returns.max.returns.option=Лимит точек возврата\:
method.with.signature.already.exists=Метод с сигнатурой {0} уже существует
method.with.type.parameters.should.have.return.type=Метод с параметрами типа должен иметь возвращаемый тип
missed.attributes=Пропущенные атрибуты\: {0}
missing.required.named.parameter=Отсутствует обязательный именованный параметр ''{0}''
mixing.private.and.public.protected.methods.of.the.same.name=Смешивание private и public/protected методов с одинаковым именем
modifier.0.not.allowed=Модификатор ''{0}'' здесь не допускается
modifier.transient.not.allowed.here=Модификатор 'transient' здесь не допускается
modifier.volatile.not.allowed.here=Модификатор 'volatile' здесь не допускается
module.name.0.and.groovy.version.1={0} ({1})
module.with.groovy=Простой модуль с подключенной библиотекой Groovy
move.class.0.from.method=Переместить ''{0}'' в правильное место
move.class.from.method.family.name=Быстрое исправление "Переместить в правильное место"
move.to.correct.dir=Переместить в пакет ''{0}''
move.to.correct.dir.family.name=Переместить файл в правильный пакет
multiple.assignments.without.list.expr=Множественные присваивания без списковых выражений справа не поддерживаются в режиме статической проверки типов
named.arguments.are.not.allowed.inside.index.operations=Именованные аргументы не допускаются внутри индексных операций
native.methods.cannot.have.body=Нативные методы не могут иметь тело
native.visibility.presentation=native
new.class.action.description=Создает новый класс Groovy
new.class.action.text=Класс Groovy
new.class.dialog.title=Новый класс Groovy
new.class.list.item.annotation=Аннотация
new.class.list.item.class=Класс
new.class.list.item.enum=Enum
new.class.list.item.interface=Интерфейс
new.class.list.item.record=Record
new.class.list.item.trait=Трейт
new.gant.script.dialog.message=Введите имя для нового Gant скрипта
new.gant.script.dialog.title=Новый Gant скрипт
new.instance.of.singleton=Новый экземпляр класса с аннотацией @groovy.lang.Singleton
new.project.wizard.groovy.creating.main.file=Создание главного файла Groovy…
new.project.wizard.groovy.retrieving.has.failed=Не удалось получить версии Groovy
new.script.action.description=Создает новый Groovy скрипт
new.script.action.text=Groovy скрипт
new.script.dialog.title=Введите имя нового Groovy скрипта
new.script.list.item.script=Groovy скрипт
new.script.list.item.script.dsl=GroovyDSL скрипт
newlines.here.are.available.since.groovy.3=Символы новой строки в списке аргументов доступны начиная с Groovy 3.0
no.applicable.signature.found=Не найдена подходящая сигнатура
no.class.expected.here=Здесь не ожидается класс
no.class.in.file.template=Класс не найден в шаблоне файла
no.implements.clause.allowed.for.interface=Интерфейсы не могут иметь оператор 'implements'
no.interface.expected.here=Здесь не ожидается интерфейс
no.return.message=Не все пути выполнения возвращают значение
no.such.property=Свойство ''{0}'' не существует
no.super.classes.found=Суперклассы не найдены
no.super.method.found=Методы super не найдены
no.type.specified=Тип не указан
non.sealed.visibility.presentation=non-sealed
non.static.classes.not.allowed=Нестатические внутренние классы не разрешены в трейтах
not.abstract.method.should.have.body=Неабстрактный метод должен иметь тело
not.allowed.modifier.in.for.in=Модификатор ''{0}'' здесь не разрешен
notification.group.grape=Обработана аннотация Groovy @Grab
notification.group.groovy.dsl=Ошибки Groovy DSL
only.abstract.class.can.have.abstract.method=Только абстрактный класс может иметь абстрактный метод
only.traits.expected.here=Здесь ожидаются только трейты
operator.call.is.ambiguous=Неоднозначный вызов оператора
operator.is.not.supported.in=Оператор ''{0}'' не поддерживается в текущей версии
optimize.all.imports=Оптимизовать неиспользуемые операторы import
optimize.imports=Оптимизовать импорты
optimize.imports.progress.title=Оптимизация импортов в файлах Groovy…
other.scope=Другая область видимости
overly.complex.method.complexity.limit.option=Предел сложности метода\:
overly.long.method.statements.limit.option=Максимальное количество операторов на метод\:
overly.nested.method.nesting.limit.option=Максимальная глубина вложенности\:
overriding.methods.of.0=Переопределяющие методы ''{0}''
package.definition.cannot.have.modifiers=Определение пакета не может иметь модификаторов
packageLocal.visibility.presentation=default видимость
parameter.can.be.final.tooltip=Параметр ''{0}'' может быть final
parameter.cast.fix=Привести {0,number,ordinal} параметр к типу {1}
parameter.hint.number.of.arguments={0, choice, 0\#|1\#{0} аргумент|2\#{0} аргумента|3\#{0} аргументов}
parameter.list.owner.chooser.title=Добавить параметр в
pointless.arithmetic.error.message=Избыточные арифметические операции \#loc
pointless.boolean.problem.descriptor=Избыточные логические операции \#loc
pointless.boolean.quickfix=Упростить
popup.content.navigation.to.overriding.classes.unavailable=Навигация к переопределяющим классам невозможна во время обновления индекса
postfix.template.provider.name=Groovy
primitive.bound.types.are.not.allowed=Примитивные ограничивающие типы не разрешены
primitive.type.parameters.are.not.allowed=Примитивные типы параметров не разрешены в списке параметров типа
private.visibility.presentation=private
property.missing=propertyMissing
property.name.expected=Ожидается имя свойства
protected.visibility.presentation=protected
public.visibility.presentation=public
pull.up.abstract.wont.be.accessible.from=Невозможно сделать {0} абстрактным, так как он не будет доступен из подкласса
pull.up.wont.be.accessible.from={0} не будет доступен из {1}
pull.up.wont.be.accessible.from.the.subclass={0} использует {1}, который не будет доступен из подкласса
qualified.0.is.allowed.only.in.nested.or.inner.classes=Квалифицированный {0} разрешен только во вложенных/внутренних классах
recursive.constructor.invocation=Рекурсивный вызов конструктора
remove.0=Удалить ''{0}''
remove.catch.block=Удалить блок catch
remove.exception=Удалить исключение
remove.modifier=Удалить ''{0}''
remove.parameter.0=Удалить параметр ''{0}''
remove.unused.parameter=Удалить неиспользуемый параметр
rename.file.to.0=Переименовать файл в ''{0}''
repetitive.method.name.0=Повторяющееся имя метода ''{0}''
replace.0.with.1=Заменить ''{0}'' на бинарный ''{1}''
replace.all.occurrences.and.remove.variable.0=Заменить все вхождения и удалить переменную ''{0}''
replace.new.expression.with.instance.access=Заменить на доступ к экземпляру
replace.postfix.0.with.prefix.0=Заменить постфиксный ''{0}'' на префиксный ''{0}''
replace.primitive.type.with.wrapper=Заменить примитивный тип на обертку
replace.qualified.name.with.import=Заменить полное имя на импорт
replace.with.get.at=Заменить на доступ по индексу
replace.with.list.literal=Заменить на литерал списка
replace.with.method.fix=Заменить методом ''{0}''
replace.with.method.message=Можно заменить вызовом метода ''{0}''
replace.with.operator.compareTo.equality.option=Заменить равенство 'compareTo' на equals (т.е. \=\=)
replace.with.operator.double.negation.option=Использовать двойное отрицание (т.е. \!\!)
replace.with.operator.fix=Заменить ''{0}'' оператором
replace.with.operator.message=''{0}'' можно заменить оператором
replace.with.operator.parentheses=Не предлагать замену на оператор, если это требует дополнительных скобок
replace.with.wrapper=Заменить на ''{0}''
require.closure.as.attribute.value=Ожидается замыкание в качестве значения атрибута
return.type.is.incompatible=Возвращаемый тип {0} в {1} несовместим с {2} в {3}
rtype.cannot.contain.ltype=''{1}'' не может содержать ''{0}''
run.configuration.module.chooser.label=&Модуль\:
run.configuration.module.classpath.checkbox=Добавить &classpath модуля в runner
run.configuration.script.path.label=Путь к скрипту\:
script.cannot.have.modifier.native=Скрипт не может иметь модификатор 'native'
script.generated.with.same.name=Для кода скрипта сгенерирован синтетический класс ''{0}''
script.method.cannot.have.modifier.abstract=Метод скрипта не может иметь модификатор 'abstract'
script.runner.cant.find.script=Не удаётся найти скрипт ''{0}''
script.runner.chooser.description=Укажите путь к скрипту
script.runner.chooser.title=Путь к скрипту
script.runner.class.cannot.be.executed=Класс не может быть выполнен
script.runner.class.does.not.exist=Класс не существует
script.runner.description=Класс или скрипт Groovy
script.runner.display.name=Groovy
script.runner.file.is.not.groovy.file=Файл скрипта не является файлом Groovy
script.runner.module.not.specified.message=Модуль не указан
script.runner.no.groovy.for.module=Groovy не настроен для модуля ''{0}''
script.runner.unknown.script.type=Неизвестный тип скрипта ''{0}''
sealed.visibility.presentation=sealed
second.unsafe.call=Второй небезопасный вызов
select.framework.0.home.title=Выберите домашний каталог {0}
select.module.action.description=Выбрать модуль для использования его classpath
select.module.action.text=Выбрать модуль…
select.module.popup.title=Использовать Classpath модуля
selfType.class.does.not.inherit=@SelfType\: Класс ''{0}'' не наследует ''{1}''
separator.domain.of.inspection.usage=Область применения
separator.preferable.string.kind=Предпочтительный вид
settings.code.style.absolute=Абсолютный
settings.code.style.indent.labels=Отступ для меток
settings.code.style.indent.statements.after.label=Отступ для операторов после метки
settings.code.style.label.indent.size=размер отступа метки
settings.code.style.label.indent.style=Стиль отступа меток\:
settings.compiler.alternative=Также вы можете указать компилятор Groovy-Eclipse на странице <a>компилятора Java</a>
settings.compiler.exclude.from.stub.generation=Исключить из генерации заглушек\:
settings.compiler.invoke.dynamic.support=Поддержка invoke dynamic [&D]
settings.compiler.path.to.configscript=Путь к конфигурационному скрипту [&C]\:
settings.compiler.select.path.to.groovy.compiler.configscript=Выберите путь к конфигурационному скрипту компилятора Groovy
settings.inlay.groovy.implicit.null.argument.provider.description=Если метод принимает только один параметр, Groovy позволяет вызывать его без аргументов. В этом случае Groovy неявно передает один 'null' в качестве аргумента.
settings.inlay.groovy.implicit.null.argument.provider.name=Неявный 'null'
settings.inlay.groovy.lambda.parameter.provider.description=Отображает типы параметров в лямбда-выражениях\:
settings.inlay.groovy.lambda.parameter.provider.name=Параметр лямбды
settings.inlay.groovy.local.variable.implicit.types.description=Отображает типы в месте объявления локальных переменных, объявленных с помощью 'def' или 'var'.
settings.inlay.groovy.local.variable.implicit.types.name=Подсказки типов локальных переменных
shows.parameter.names.at.function.call.sites=Показывает имена параметров в местах вызова функций.
singleton.constructor.found=Класс с аннотацией @Singleton не должен иметь конструкторов
singleton.constructor.makeNonStrict=Сделать @Singleton нестрогим
singleton.constructor.remove=Удалить конструктор
spread.operator.is.not.available=Оператор распространения (spread operator) не может использоваться как аргумент при статической проверке типов
static.import.method.0.fix=Static импорт метода ''{0}''
static.import.method.fix=Static импорт метода…
static.visibility.presentation=static
strictfp.visibility.presentation=strictfp
string.end.expected=Ожидается конец строки
string.option.do.not.handle.specifically=Не обрабатывать специально
string.option.dollar.slashy.string=Строка с $/ 
string.option.double.quoted.string=Строка в двойных кавычках
string.option.single.quoted.string=Строка в одинарных кавычках
string.option.slashy.string=Строка со слэшем
string.option.triple.double.quoted.string=Строка в тройных двойных кавычках
string.option.triple.quoted.string=Строка в тройных кавычках
string.sort.default=По умолчанию
string.sort.multiline.string=Многострочная строка
string.sort.strings.with.escaping=Строки с экранированием
string.sort.strings.with.interpolation=Строки с интерполяцией
super.cannot.be.used.in.static.context='super' нельзя использовать в статическом контексте
super.is.not.allowed.in.pre.with.call.super=Вызов super не разрешен в 'pre' при включенном 'callSuper'
surround.with.cast=((Type) expr)
surround.with.closure={ -> ... }.call()
surround.with.for=for
surround.with.if=if
surround.with.if.else=if / else
surround.with.if.else.expr=if (expr) / else
surround.with.if.expr=if (expr)
surround.with.parentheses=(expr)
surround.with.shouldFail=shouldFail () {...}
surround.with.try=try
surround.with.try.catch=try / catch
surround.with.try.catch.finally=try / catch / finally
surround.with.try.finally=try / finally
surround.with.while=while
surround.with.while.expr=while (expr)
surround.with.with=with () {...}
surround.with.with.expr=with (expr)
synchronized.not.allowed.on.abstract.method=@Synchronized не разрешен для абстрактного метода
synchronized.visibility.presentation=synchronized
target.0.does.not.exist=Цель ''{0}'' не существует
target.annotation.is.unused=@Target не используется
text.class.0.is.unused=Класс {0} не используется
text.constructor.0.is.unused=Конструктор {0} не используется
text.method.0.is.unused=Метод {0} не используется
text.parameter.0.is.unused=Параметр {0} не используется
text.property.0.is.unused=Свойство {0} не используется
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=Использование выражения map entry для инициализации Enum в настоящее время не поддерживается
there.is.no.default.constructor.available.in.class.0=В классе ''{0}'' нет доступного конструктора по умолчанию
this.super.completion.advertisement=Двойное нажатие {0} без квалификатора класса покажет все доступные статические методы
throws.clause.is.not.allowed.in.at.interface=Конструкция 'throws' не разрешена в членах @interface
top.level.class.may.not.have.private.modifier=Класс верхнего уровня не может иметь модификатор 'private'
top.level.class.may.not.have.protected.modifier=Класс верхнего уровня не может иметь модификатор 'protected'
trait.method.cannot.be.protected=Методы трейта не могут быть protected
transient.visibility.presentation=transient
try.catch.fix=Исправление try-catch
try.without.catch.finally='try' без 'catch' или 'finally'
tuple.cant.be.placed.in.class=Множественное присваивание не разрешено для полей
tuple.declaration.should.end.with.def.modifier=Объявление кортежа должно заканчиваться модификатором 'def'
type.argument.0.is.not.in.its.bound.should.extend.1=Параметр типа ''{0}'' вне своих границ; должен расширять ''{1}''
type.argument.list.is.not.allowed.here=Список аргументов типа здесь не разрешен
type.customizer.is.not.marked.as.a.resource.file=Скрипт настройки типа не помечен как ресурс компилятора
type.doesnt.contain.method=Тип ''{0}'' не может быть итерирован в диапазоне, так как не имеет метода ''{1}''
type.doesnt.implement.comparable=Тип ''{0}'' не реализует Comparable
type.parameters.are.unexpected=Неожиданные параметры типа
unassigned.access.tooltip=Переменной ''{0}'' может быть не присвоено значение
undefined.label=Неопределённая метка ''{0}''
undefined.library.version=не определено
unexpected.attribute.type.0=Неожиданный тип атрибута\: ''{0}''
unnecessary.alias.description=Псевдоним не нужен
unnecessary.alias.fix=Удалить ненужный псевдоним
unnecessary.def.explicitly.typed.only=Сообщать только в явно типизованных объявлениях
unnecessary.modifier.description=Модификатор ''{0}'' не нужен
unnecessary.modifier.remove=Удалить ненужный ''{0}''
unnecessary.semicolon.description=Точка с запятой не нужна
unnecessary.semicolon.fix=Удалить точку с запятой
unnecessary.type=Лишнее исключение ''{0}''. ''{1}'' уже объявлено
unresolved.type.status=Тип ''{0}'' не разрешен
unsupported.anonymous.class.0=Анонимные классы не поддерживаются в Groovy {0}
unsupported.array.initializers=Инициализаторы массивов не поддерживаются в текущей версии
unsupported.command.syntax.0=Синтаксис командных выражений не поддерживается в Groovy {0}
unsupported.diamonds.0=Ромбовидный синтаксис не поддерживается в Groovy {0}
unsupported.do.while.statement='do while' не поддерживается в текущей версии
unsupported.dollar.slashy.string.0=Строки типа $/ не поддерживаются в Groovy {0}
unsupported.elvis.assignment=Elvis-присваивание не поддерживается в текущей версии
unsupported.expression.list.in.for.update=Множественные выражения в обновлении 'for' не поддерживаются в текущей версии
unsupported.inner.class.0=Внутренние классы не поддерживаются в Groovy {0}
unsupported.lambda=Лямбды не поддерживаются в текущей версии
unsupported.multiline.slashy.string.0=Многострочные строки типа / не поддерживаются в Groovy {0}
unsupported.multiple.variables.in.for=Множественные переменные в инициализации 'for' не поддерживаются в текущей версии
unsupported.negated.in=Отрицание 'in' не поддерживается в текущей версии
unsupported.negated.instanceof=Отрицание 'instanceof' не поддерживается в текущей версии
unsupported.resource.list='try-with-resources' не поддерживается в текущей версии
unsupported.safe.index.access=Безопасный доступ по индексу не поддерживается в текущей версии
unsupported.traits.0=Трейты не поддерживаются в Groovy {0}
unsupported.tuple.application.initializer=Инициализатор приложения не поддерживается в текущей версии
unsupported.tuple.declaration.in.for=Объявление кортежа в инициализации 'for' не поддерживается в текущей версии
unsupported.type.annotations=Аннотации типов не поддерживаются в текущей версии
unused.0=Неиспользуемый ''{0}''
unused.assignment.tooltip=Присваивание не используется
unused.default.parameter.fix=Удалить инициализатор
unused.default.parameter.message=Параметр по умолчанию не используется
unused.import=Неиспользуемый import
unused.variable=Переменная не используется
variable.0.might.not.have.been.initialized=Переменная ''{0}'' может быть не инициализована
variable.already.defined=Переменная ''{0}'' уже определена
variable.can.be.final.tooltip=Переменная ''{0}'' может быть final
variable.cannot.be=Переменная не может иметь модификатор ''{0}''
volatile.visibility.presentation=volatile
wildcards.are.not.allowed.in.extends.list=Супертип не может содержать wildcard-тип
write.access.to.closure.variable=Доступ на запись к полю <b>{0}</b>
wrong.closure.first.parameter.type=Замыкание ''{0}'' используется с именованными аргументами, но его первый параметр ''{1}'' не соответствует типу Map
wrong.method.first.parameter.type=Метод ''{0}'' используется с именованными аргументами, но его первый параметр ''{1}'' не соответствует типу Map
wrong.number.of.type.arguments=Неверное количество аргументов типа\: {0}; требуется\: {1}