0.1.be.lifted.out.of.2=''{0}'' можно вынести из ''{1}''
0.1.could.be.private={0} ''{1}'' может быть private
0.1.is.never.used={0} ''{1}'' никогда не используется
0.already.exists={0} уже существует
0.always.returns.non.null.type=''{0}'' всегда возвращает non-null тип
0.call.could.be.simplified.to.1=Вызов {0} можно упростить до {1}
0.call.should.be.replaced.with.array.literal=Вызов ''{0}'' следует заменить литералом массива [...]
0.from.1={0} из {1}
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} обнаружил {1} код {1,choice,1\#фрагмент|2\#фрагмента} в {2}, которые можно заменить на {3}. Хотите просмотреть и заменить {1,choice,1\#его|2\#их}?
0.has.empty.body=''{0}'' имеет пустое тело
0.in.1.will.require.class.instance=''{0}'' в {1} потребует экземпляр класса
0.interface.1={0} интерфейс ''{1}''
0.is.always.non.null.type=''{0}'' всегда non-null тип
0.is.expected.to.be.used.since.kotlin.1.3=''{0}'' ожидается к использованию начиная с Kotlin 1.3
0.is.missing.documentation=Отсутствует документация для {0}
0.is.overridden.by.declaration.s.in.a.subclass={0} переопределяется объявлением(ями) в подклассе
0.may.break.code={0} (может нарушить код)
0.on.a.readonly.1.creates.a.new.1.under.the.hood=''{0}'' на read-only {1} создает новый {1} под капотом
0.references.type.parameters.of.the.containing.class={0} ссылается на параметры типа содержащего класса
0.should.return.unit={0} должен возвращать Unit
0.try.1.with.2.fails.and.3.verifications={0} [Попытка {1} с {2} неудачами и {3} проверками]
0.will.become.invisible.after.extraction={0} станет невидимым после извлечения
0.will.no.longer.be.accessible.after.extraction={0} станет недоступным после извлечения
a.constructor.call.is.not.yet.supported=Вызов конструктора пока не поддерживается
a.field.without.an.initializer.is.not.yet.supported=Поле без инициализатора пока не поддерживается
accessing.non.final.property.0.in.constructor=Доступ к не-final свойству {0} в конструкторе
action.CacheResetOnProcessCanceledToggleAction.text=Сбросить кэш при ProcessCanceledException
action.CheckComponentsUsageSearchAction.text=Проверить поиск использования функций компонентов
action.ConfigureKotlinInProject.text=Настроить Kotlin в проекте
action.ConvertJavaToKotlin.text=Конвертировать Java файл в Kotlin файл
action.CopyAsDiagnosticTest.text=Копировать текущий файл как диагностический тест
action.CopyKotlinProjectInformation.text=Копировать обзор проекта Kotlin в буфер обмена
action.DecompileKotlinToJava.text=Декомпилировать Kotlin в Java
action.DumbModeTremble.text=Режим тремора Dumb Mode
action.ExtractFunction.text=Извлечь функцию [_F]…
action.ExtractFunctionToScope.text=Извлечь функцию в область видимости [_S]…
action.FindImplicitNothingAction.text=Найти неявные вызовы Nothing
action.GotoSuperClass.MainMenu.text=Суперкласс [_U]
action.GotoSuperClass.text=Перейти к суперклассу [_U]
action.GotoSuperInterface.MainMenu.text=Super-интерфейс [_U]
action.GotoSuperInterface.text=Перейти к super-интерфейсу [_U]
action.GotoSuperProperty.MainMenu.text=Super-свойство [_U]
action.GotoSuperProperty.description=Перейти к объявлению свойства, которое текущее свойство переопределяет или реализует
action.GotoSuperProperty.text=Перейти к super-свойству [_U]
action.HighlightingBenchmarkAction.text=Тест производительности подсветки
action.InspectBreakpointApplicability.text=Проверить применимость точки останова
action.IntroduceProperty.text=Создать свойство [_P]…
action.IntroduceTypeAlias.text=Создать псевдоним типа [_A]…
action.IntroduceTypeParameter.text=Создать параметр типа [_Y]…
action.Kotlin.ClearScratch.description=Очистить Kotlin скретч
action.Kotlin.ClearScratch.text=Очистить Kotlin скретч
action.Kotlin.Gradle.ShowDslLogs.text=Показать логи Kotlin Gradle DSL
action.Kotlin.NewFile.description=Создает новый класс или файл Kotlin
action.Kotlin.NewFile.text=Kotlin класс/файл
action.Kotlin.NewScript.description=Создает новый скрипт или рабочий лист Kotlin
action.Kotlin.NewScript.text=Kotlin скрипт
action.Kotlin.RunScratch.description=Запустить Kotlin скретч
action.Kotlin.RunScratch.text=Запустить Kotlin скретч
action.Kotlin.StopScratch.description=Остановить выполнение скретча
action.Kotlin.StopScratch.text=Остановить выполнение скретча
action.Kotlin.XDebugger.CoroutinesDump.text=Получить дамп корутин
action.Kotlin.XDebugger.ToggleKotlinVariableView.text=Показывать только переменные Kotlin
action.KotlinCodeMigration.text=Запустить миграции кода
action.KotlinCodeMigrationToggle.text=Включить обнаружение миграций
action.KotlinConfigurePlugin.text=Настроить плагин Kotlin
action.KotlinConsoleREPL.text=Kotlin REPL (Экспериментально)
action.KotlinFormattingSettingsStatusAction.text=Информация о настройках форматования
action.KotlinGenerateDataMethod.text=Функция параметров
action.KotlinGenerateEqualsAndHashCode.text=equals() и hashCode()
action.KotlinGenerateMavenCompileExecutionAction.text=Выполнение компиляции Kotlin
action.KotlinGenerateMavenPluginAction.text=Плагин Kotlin
action.KotlinGenerateMavenTestCompileExecutionAction.text=Выполнение test-compile Kotlin
action.KotlinGenerateSecondaryConstructor.text=Вторичный конструктор
action.KotlinGenerateSetUpMethod.text=Функция SetUp
action.KotlinGenerateTearDownMethod.text=Функция TearDown
action.KotlinGenerateTestMethod.text=Тестовая функция
action.KotlinGenerateToString.text=toString()
action.KotlinShellExecute.description=Выполнить код Kotlin в консоли
action.KotlinShellExecute.text=Выполнить код Kotlin
action.KotlinThrowException.text=Сбросить ошибку из плагина Kotlin
action.LibraryToSourceDependencySupportToggleAction.text=Переключить поддержку зависимостей библиотеки на исходный код
action.LocalCompletionBenchmarkAction.text=Локальный сценарий
action.PrintOutNotPropertyMatches.text=Поиск не-свойств кандидатов
action.ShowKotlinBytecode.text=Показать байткод Kotlin
action.StoredExceptionsThrowToggleAction.text=Бросить кэшированный PCE
action.TestMoveRefactiringAction.text=Тестовать рефакторинг перемещения в открытом проекте
action.TopLevelCompletionBenchmarkAction.text=Сценарий верхнего уровня
action.add.import.chooser.title=Импорты
action.generate.equals.choose.equals=Выберите свойства для включения в 'equals()'
action.generate.equals.choose.hashcode=Выберите свойства для включения в 'hashCode()'
action.generate.functions.already.defined=Функции {0} уже определены для класса {1}. Хотите удалить их и продолжить?
action.generate.secondary.constructor.choose.properties=Выберите свойства для инициализации конструктором
action.generate.secondary.constructor.error.already.exists=Конструктор уже существует
action.generate.super.type=Явно указать super-тип
action.generate.test.support.choose.framework=Выберите фреймворк
action.generate.test.support.choose.test.name=Выберите имя теста\:
action.generate.test.support.edit.template=Редактировать шаблон
action.generate.test.support.error.cant.convert.java.template=Не удалось конвертировать Java-шаблон в Kotlin
action.generate.test.support.error.cant.generate.method=Не удалось сгенерировать метод\: {0}
action.generate.test.support.error.no.template.found=Шаблон не найден для {0}\: {1}
action.generate.tostring.choose.implementation=Выберите реализацию\:
action.generate.tostring.choose.implementation.mnemonic=i
action.generate.tostring.generate.super.call=Сгенерировать вызов super.toString()
action.generate.tostring.generate.super.call.mnemonic=s
action.generate.tostring.name=Сгенерировать 'toString()'
action.generate.tostring.template.multiple=Несколько шаблонов с конкатенацией
action.generate.tostring.template.multiple.with.super=Несколько шаблонов с конкатенацией и вызовом super
action.generate.tostring.template.single=Единый шаблон
action.generate.tostring.template.single.with.super=Единый шаблон с вызовом super
action.hints.settings.text=Настройки подсказок…
action.j2k.correction.errors.multiple=''{0}'' и {1} других Java файлов содержат синтаксические ошибки, результат конвертации может быть неверным
action.j2k.correction.errors.single=''{0}'' содержит синтаксические ошибки, результат конвертации может быть неверным
action.j2k.correction.investigate=Исследовать ошибки
action.j2k.correction.proceed=Продолжить конвертацию
action.j2k.correction.required=После выполнения этой конвертации некоторый код в остальной части проекта может потребовать исправлений. Хотите найти и исправить такой код?
action.j2k.error.cant.find.document=не удалось найти документ для ''{0}''
action.j2k.error.cant.save.result=Не удалось сохранить результат конвертации\: {0}
action.j2k.error.nothing.to.convert=Нечего конвертировать\:<br>Не найдено доступных для записи Java файлов
action.j2k.error.read.only=файл ''{0}'' доступен только для чтения
action.j2k.name=Конвертировать Java в Kotlin
action.j2k.task.name=Конвертировать файлы из Java в Kotlin
action.move.method=Переместить метод…
action.new.file.dialog.annotation.title=Аннотация
action.new.file.dialog.class.title=Класс
action.new.file.dialog.data.class.title=Data класс
action.new.file.dialog.enum.title=Enum класс
action.new.file.dialog.file.title=Файл
action.new.file.dialog.interface.title=Интерфейс
action.new.file.dialog.object.title=Объект
action.new.file.dialog.sealed.class.title=Sealed класс
action.new.file.dialog.sealed.interface.title=Sealed интерфейс
action.new.file.dialog.title=Новый Kotlin класс/файл
action.new.file.error.empty.name=Имя не может быть пустым
action.new.file.error.empty.name.part=Имя не может содержать пустые части
action.new.script.dialog.title=Новый Kotlin файл
action.new.script.name=Kotlin скрипт
action.text.append=Добавить
action.text.cancel=Отмена
action.text.install=Установить
action.text.overwrite=Перезаписать
action.usage.update.command=Обновление использования
add.0.constructor.to.1=Добавить конструктор {0} в ''{1}''
add.0.library=Добавить библиотеку ''{0}''
add.0.to.argument=Добавить ''{0} \='' к аргументу
add.an.opt.in.requirement.marker.compiler.argument=Добавить маркер opt-in в аргументы компилятора
add.braces=Добавить фигурные скобки
add.braces.to.0.statement=Добавить фигурные скобки в оператор ''{0}''
add.braces.to.all.branches=Добавить фигурные скобки во все ветви
add.braces.to.if.all.statements=Добавить фигурные скобки во все операторы 'if'
add.braces.to.when.all.entries=Добавить фигурные скобки во все элементы 'when'
add.braces.to.when.entry=Добавить фигурные скобки в элемент 'when'
add.call.or.unwrap.type.fix.text=Добавить ''.{0}()'' к результату функции (нарушит использование\!)
add.call.or.unwrap.type.fix.text1=Развернуть возвращаемый тип ''{0}'' (нарушит использование\!)
add.constructor.keyword=Добавить ключевое слово 'constructor'
add.constructor.parameters.from.0.1=Добавить параметры конструктора из {0}{1}
add.constructor.parameters.from.superclass=Добавить параметры конструктора из суперкласса
add.documentation.fix.text=Добавить документацию
add.empty.argument.list=Добавить пустой список аргументов
add.empty.brackets.after.primary.constructor=Добавить пустые скобки после первичного конструктора
add.explicit.parameter.to.outer.lambda.fix.text=Добавить явное имя параметра во внешнюю лямбду
add.explicit.type.arguments=Добавить явные аргументы типа
add.external.keyword=Добавить ключевое слово external
add.full.qualifier=Добавить полный квалификатор
add.fun.modifier.to.0=Добавить модификатор ''fun'' к ''{0}''
add.import.for.0=Добавить import для ''{0}''
add.import.for.member=Добавить import для члена
add.indices.to.for.loop=Добавить индексы в цикл 'for'
add.initializer=Добавить инициализатор
add.jvminline.annotation=Добавить аннотацию '@JvmInline'
add.jvmoverloads.annotation=Добавить аннотацию '@JvmOverloads'
add.jvmoverloads.annotation.to.0=Добавить аннотацию ''@JvmOverloads'' к {0}
add.jvmstatic.annotation=Добавить аннотацию '@JvmStatic'
add.kotlin.coroutines=Добавить библиотеку Kotlin корутин
add.kotlin.coroutines.description=Добавить библиотеку Kotlin корутин
add.labeled.return.to.last.expression.in.a.lambda=Добавить помеченный return к последнему выражению в лямбде
add.method=Добавить метод
add.method.0.to.1=Добавить метод ''{0}'' в ''{1}''
add.missing.class.keyword=Добавить отсутствующее ключевое слово 'class'
add.missing.component=Добавить отсутствующий компонент деструктуризации
add.modifier=Добавить модификатор
add.name.to.argument=Добавить имя к аргументу
add.names.in.comment.to.call.arguments=Добавить имена в комментарии к аргументам вызова
add.names.to.call.arguments=Добавить имена к аргументам вызова
add.names.to.this.argument.and.following.arguments=Добавить имена к этому и всем последующим аргументам
add.operator.modifier=Добавить модификатор 'operator'
add.remaining.branches=Добавить оставшиеся ветви
add.replacewith.argument.to.specify.replacement.pattern=Добавить аргумент 'replaceWith' для указания шаблона замены
add.return.at.0=Добавить ''return@{0}''
add.return.expression=Добавить выражение 'return'
add.source.retention=Добавить SOURCE retention
add.throws.annotation=Добавить аннотацию '@Throws'
add.underscores=Добавить подчеркивания
add.use.site.target=Добавить use-site target
add.val.to.parameter.0=Добавить ''val'' к параметру ''{0}''
add.val.var.to.parameter.0=Добавить ''val'' или ''var'' к параметру ''{0}''
add.val.var.to.primary.constructor.parameter=Добавить 'val' или 'var' к параметру первичного конструктора
add.variance.fix.family.name=Добавить вариантность
add.variance.fix.text=Добавить вариантность ''{0}''
advanced.setting.kotlin.mpp.experimental=Включить экспериментальные функции Multiplatform ИСР
advanced.setting.kotlin.mpp.experimental.description=Требуется перезапуск ИСР
all.expected.and.actual.classes.must.be.sealed.classes=Все expected и actual классы должны быть sealed классами.\n
all.inheritors.must.be.nested.objects.of.the.class.itself.and.may.not.inherit.from.other.classes.or.interfaces=Все наследники должны быть вложенными объектами самого класса и не могут наследоваться от других классов или интерфейсов.\n
ambiguous.coroutinecontext.due.to.coroutinescope.receiver.of.suspend.function=Неоднозначный coroutineContext из-за CoroutineScope-получателя suspend-функции
ambiguous.non.local.break.or.continue=Неоднозначный нелокальный ''{0}'' (''{1}'' и ''{2}''). Используйте уточняющие метки или добавьте контракт ''callsInPlace''.
ambiguous.non.local.break.or.continue.display.name=Неоднозначный нелокальный 'break' или 'continue'
analyzed.0.classes.no.difference.found=Проанализовано классов\: {0}. Различий не найдено.
analyzing.functions=Анализ функций…
analyzing.members=Анализ членов…
and.delete.initializer=\ и удалить инициализатор
apply.also.to.internal.members=Применить также к internal членам
apply.also.to.private.members=Применить также к private членам
apply.in.the.project.0=Применить в проекте\: {0}
apply.only.to.public.or.protected.members=Применить только к public или protected членам
applying.0=Применение ''{0}''
array.property.in.data.class.it.s.recommended.to.override.equals.hashcode=Свойство типа 'Array' в 'data' классе\: рекомендуется переопределить 'equals()' и 'hashCode()'
assert.should.be.replaced.with.operator=assert следует заменить оператором
assign.backing.field.fix.text=Присвоить backing field
base.property.0=базовое свойство {0}
block.body=тело блока
boolean.literal.argument.without.parameter.name=Булев литерал без имени параметра
boolean.property.in.external.interface.should.be.nullable=Булево свойство в external интерфейсе должно быть nullable
breadcrumbs.tooltip.indexing=Индексация…
button.add.package=Добавить пакет
button.rename.base=Переименовать базовый
button.rename.current=Переименовать текущий
button.text.move.nested.class.0.to.another.class=Переместить вложенный класс {0} в другой класс [&M]
button.text.move.nested.class.0.to.upper.level=Переместить вложенный класс {0} на верхний уровень [&N]
call.chain.length.to.transform=Длина цепочки вызовов для преобразования\:
call.chain.on.collection.could.be.converted.into.sequence.to.improve.performance=Цепочку вызовов коллекции можно преобразовать в 'Sequence' для улучшения производительности
call.chain.on.collection.type.may.be.simplified=Цепочка вызовов коллекции может быть упрощена
call.is.replaceable.with.another.scope.function=Вызов может быть заменен другой функцией области видимости
call.of.inline.function.with.nullable.extension.receiver.can.cause.npe.in.kotlin.1.2=Вызов 'inline fun' с nullable-получателем может вызвать 'NPE' до Kotlin 1.2
call.of.java.mutator.0.on.immutable.kotlin.collection.1=Вызов Java-мутатора ''{0}'' на неизменяемой Kotlin-коллекции ''{1}''
call.on.collection.type.may.be.reduced=Вызов на коллекции может быть упрощен
call.on.not.null.type.may.be.reduced=Вызов на not-null типе может быть упрощен
call.replaceable.with.binary.operator=Вызов может быть заменен бинарным оператором
call.with.arguments.will.be.skipped.0=Вызов с аргументами будет пропущен\: {0}
callable.reference.fix.family.name=Добавить явный ''{0}''
callable.reference.transformation.is.not.supported.0=Преобразование callable reference не поддерживается\: {0}
calling.non.final.function.0.in.constructor=Вызов не-final функции {0} в конструкторе
calls.with.explicit.extension.receiver.won.t.be.processed.0=Вызовы с явным extension-получателем не будут обработаны\: {0}
can.be.converted.to.to=Явная инициализация 'Pair' может быть заменена инфиксным вызовом 'to()'
can.be.joined.with.assignment=Может быть объединено с присваиванием
can.convert.argument.to.set=Аргумент может быть преобразован в 'Set' для улучшения производительности
can.t.finish.while.indexing.is.in.progress=Невозможно завершить во время индексации
can.t.modify.0=Невозможно изменить {0}
can.t.replace.foreign.reference.with.call.expression.0=Невозможно заменить внешнюю ссылку на выражение вызова\: {0}
can.t.replace.non.kotlin.reference.with.call.expression.0=Невозможно заменить не-Kotlin ссылку на выражение вызова\: {0}
cannot.extract.super.call=Невозможно извлечь super-вызов
cannot.get.or.create.results.file=Невозможно получить или создать файл результатов
cannot.get.project.root.directory=Невозможно получить корневую директорию проекта
cannot.infer.type.for.this.declaration=Невозможно вывести тип для этого объявления
cannot.inline.property.with.accessor.s.and.backing.field=Невозможно встроить свойство с аксессором(ами) и backing field
cannot.introduce.parameter.of.0.type=Невозможно добавить параметр типа ''{0}''
cannot.refactor.expression.has.unit.type=Невозможно добавить выражение типа Unit
cannot.refactor.no.container=Невозможно выполнить рефакторинг в этом месте
cannot.refactor.no.expression=Невозможно выполнить рефакторинг без выражения
cannot.refactor.no.type=Невозможно выполнить рефакторинг без типа
cannot.refactor.not.expression=Не найдено выражение для добавления
cannot.refactor.package.expression=Невозможно добавить ссылку на пакет
cannot.refactor.syntax.errors=Невозможно выполнить рефакторинг из-за ошибок в коде
cannot.refactor.synthesized.function=Невозможно выполнить рефакторинг синтезированной функции
cascade.if.should.be.replaced.with.when=Каскадный 'if' следует заменить на 'when'
cast.explicitly.fix.text=Привести явно
category.class=Kotlin/На основе классов
category.comments=Kotlin/Комментарии, KDoc и метаданные
category.declaration=Kotlin/Объявления
category.expressions=Kotlin/Выражения
category.interesting=Kotlin/Интересное
category.operators=Kotlin/Операторы
change.all.usages.of.0.in.this.file.to.1=Изменить все использования ''{0}'' в этом файле на ''{1}''
change.all.usages.of.0.in.this.file.to.a.kotlin.class=Изменить все использования ''{0}'' в этом файле на класс Kotlin
change.existent.retention.to.source=Изменить существующее retention на SOURCE
change.main.function.return.type.to.unit.fix.text=Добавить явный возвращаемый тип Unit
change.main.function.return.type.to.unit.fix.text2=Изменить возвращаемый тип на Unit
change.signature.conflict.text.kotlin.default.parameter.in.non.kotlin.files=Параметр по умолчанию может не поддерживаться в других языках
change.signature.conflict.text.kotlin.default.value.in.non.kotlin.files=Значение по умолчанию Kotlin может привести к некорректному коду в других языках
change.to.0=Изменить на ''{0}''
change.to.constructor.invocation=Изменить на вызов конструктора
change.to.correct.long.suffix.l=Изменить на корректный суффикс 'L' для long
change.to.correct.primitive.type=Изменить на корректный примитивный тип
change.to.kotlin.class=Изменить на класс Kotlin
change.to.val=Изменить на 'val'
change.to.var=Изменить на 'var'
change.type.of.0.to.1=Изменить тип {0} на ''{1}''
change.type.to.0=Изменить тип на ''{0}''
change.type.to.mutable.fix.text=Изменить тип на изменяемый
change.visibility=Изменить видимость
change.visibility.modifier=Изменить модификатор видимости
change.visibility.popup=Изменить видимость
checkbox.collapse.to.expression.body=Свернуть в тело выражения
checkbox.text.declare.with.var=Объявить через var [&V]
checkbox.text.delete.empty.source.files=Удалить пустые исходные файлы [&D]
checkbox.text.extension.property=Свойство-расширение [&X]\:
checkbox.text.introduce.default.value=Добавить значение по умолчанию [&D]
checkbox.text.open.moved.files.in.editor=Открыть перемещенный элемент в редакторе
checkbox.text.replace.all.occurrences.0=Заменить все вхождения ({0}) [&R]
checkbox.text.search.references=Искать ссылки [&R]
checkbox.text.specify.type.explicitly=Явно указать тип [&T]
checkbox.text.update.package.directive=Обновить директиву package (файлы Kotlin)
checking.data.class.0.of.1=Проверка класса данных {0} из {1}…
checking.data.classes=Проверка классов данных
choose.actual.members.title=Выберите актуальные члены
choose.an.appropriate.kotlin.class=Выберите подходящий класс Kotlin
choose.class.container=Выберите контейнер класса
choose.target.class.or.interface=Выберите целевой класс или интерфейс
class=Класс
class.0.already.contains.1=Класс ''{0}'' уже содержит {1}
class.name.prompt=Имя класса [&N]\:
class.should.be.external.interface=Класс должен быть external интерфейсом
clipboard.content.copied.from.java.file.do.you.want.to.convert.it.to.kotlin.code=Содержимое буфера обмена скопировано из Java файла. Преобразовать его в код Kotlin?
code.insight.workspace.settings.title=Kotlin
codestyle.layout.import.aliases.separately=Импортовать псевдонимы отдельно
codestyle.name.kotlin=Kotlin
column.name.default.parameter=Параметр по умолчанию\:
column.name.receiver=Получатель\:
column.name.val.var=Val/Var
command.generate.test.support.generate.test.function=Сгенерировать тестовую функцию
command.move.declarations=Переместить объявления
comment=Комментарий
companion.object.already.contains.0=Объект-компаньон уже содержит {0}
compiling.project=Компиляция проекта…
condition.is.always.0=Условие всегда ''{0}''
configuration.kotlin.code.style.group.name=Доступен официальный стиль кода Kotlin
configuration.maven.group.name=Импорт проекта Kotlin Maven
configuration.message.enter.fully.qualified.method.name=Введите полное имя метода\:
configuration.migration.group.name=Kotlin\: Доступны миграции на более новую версию
configuration.name.method=Метод
configuration.status.text.installing=Установка…
configuration.title.add.exclusion=Добавить исключение
configuration.title.edit.exclusion=Редактировать исключение
const.might.be.used.instead.of.jvmfield='const' может использоваться вместо '@JvmField'
const.property=Свойство const
constructor=Конструктор
constructor.has.non.null.self.reference.parameter=Конструктор имеет ненулевой параметр самоссылки
constructor.parameter.is.never.used.as.a.property=Параметр конструктора никогда не используется как свойство
context.default=По умолчанию
context.property.getter.or.setter=Свойство с явным Getter/Setter
convert.0.to.1=Преобразовать ''{0}'' в ''{1}''
convert.anonymous.function.to.lambda.expression=Преобразовать анонимную функцию в лямбда-выражение
convert.argument.to.set.fix.text=Преобразовать аргумент в 'Set'
convert.body.to.expression=Преобразовать тело в выражение
convert.boolean.const.to.elvis=Преобразовать Boolean? \=\= const в elvis
convert.call.chain.into.sequence.fix.text=Преобразовать цепочку вызовов в 'Sequence'
convert.class.0.to.kotlin=Преобразовать класс ''{0}'' в Kotlin
convert.collection.constructor.to.function=Преобразовать конструктор коллекции в функцию
convert.concatenation.to.build.string=Преобразовать конкатенацию в вызов 'buildString'
convert.concatenation.to.raw.string=Преобразовать конкатенацию в сырую строку
convert.concatenation.to.template=Преобразовать конкатенацию в шаблон
convert.concatenation.to.template.before.text=Конкатенация строк может быть преобразована в шаблон
convert.expression.to.0=Преобразовать выражение в ''{0}''
convert.expression.to.0.by.inserting.1=Преобразовать выражение в ''{0}'' вставкой ''.{1}''
convert.extension.function.type.to.regular.function.type=Преобразовать тип функции-расширения в обычный тип функции
convert.extension.property.initializer.to.getter=Преобразовать инициализатор свойства-расширения в getter
convert.from.class.to.kclass=Преобразовать 'KClass' в 'Class'
convert.function.to.property=Преобразовать функцию в свойство
convert.function.type.parameter.to.receiver=Преобразовать параметр типа функции в получателя
convert.function.type.receiver.to.parameter=Преобразовать получателя типа функции в параметр
convert.lambda.expression.to.anonymous.function=Преобразовать лямбда-выражение в анонимную функцию
convert.lambda.to.reference=Преобразовать лямбду в ссылку
convert.lambda.to.reference.before.text=Лямбда может быть преобразована в ссылку
convert.left.hand.side.to.0=Преобразовать левую часть в ''{0}''
convert.member.to.extension=Преобразовать член в расширение
convert.na.n.equality.quick.fix.text=Заменить на 'isNaN()'
convert.object.literal.to.class=Преобразовать литерал объекта в класс
convert.object.literal.to.lambda=Преобразовать литерал объекта в лямбду
convert.pair.constructor.to.to.fix.text=Заменить на инфиксный 'to'
convert.parameter.to.receiver=Преобразовать параметр в получателя
convert.property.getter.to.initializer=Преобразовать getter свойства в инициализатор
convert.property.initializer.to.getter=Преобразовать инициализатор свойства в getter
convert.property.to.function=Преобразовать свойство в функцию
convert.put.to.assignment=Преобразовать put в присваивание
convert.receiver.to.parameter=Преобразовать получателя в параметр
convert.reference.to.lambda=Преобразовать ссылку в лямбду
convert.reference.to.lambda.before.text=Ссылка может быть преобразована в лямбду
convert.right.hand.side.to.0=Преобразовать правую часть в ''{0}''
convert.scope.function.fix.family.name=Преобразовать в ''{0}''
convert.sealed.subclass.to.object.fix.family.name=Преобразовать sealed подкласс в объект
convert.string.template.to.build.string=Преобразовать в вызов 'buildString'
convert.string.to.character.literal=Преобразовать строку в символьный литерал
convert.supertype.to.0=Преобразовать супертип в ''{0}''
convert.template.to.concatenated.string=Преобразовать шаблон в конкатенацию строк
convert.to.0=Преобразовать в {0}
convert.to.0.as.1=Преобразовать в ''{0} as {1}''
convert.to.0.unsafecast.1=Преобразовать в ''{0}.unsafeCast<{1}>()''
convert.to.a.range.check=Преобразовать в проверку диапазона
convert.to.anonymous.function=Преобразовать в анонимную функцию
convert.to.anonymous.object=Преобразовать в анонимный объект
convert.to.array.parameter=Преобразовать в параметр массива
convert.to.assignment.expression=Преобразовать оператор присваивания в выражение
convert.to.block.body=Преобразовать в блочное тело
convert.to.comparisons=Преобразовать в сравнения
convert.to.concatenated.string.statement.analyzing.entry.type=Анализ типа элемента…
convert.to.data.object=Преобразовать в 'data object'
convert.to.enum.class=Преобразовать в enum класс
convert.to.expression.body.fix.text=Преобразовать в тело-выражение
convert.to.indexed.function.call=Преобразовать в вызов индексированной функции
convert.to.lambda=Преобразовать в лямбду
convert.to.lambda.expression=Преобразовать в лямбда-выражение
convert.to.lateinit.var=Преобразовать в lateinit var
convert.to.lazy.property=Преобразовать в lazy свойство
convert.to.multi.dollar.string=Преобразовать в строку с несколькими знаками доллара
convert.to.notnull.delegate=Преобразовать в notNull делегат
convert.to.nullable.type=Преобразовать в nullable тип
convert.to.nullable.type.fix.text=Преобразовать в nullable тип
convert.to.nullable.var=Преобразовать в nullable var
convert.to.object.declaration=Преобразовать в объявление объекта
convert.to.ordinary.property=Преобразовать в обычное свойство
convert.to.ordinary.string.literal=Преобразовать в обычный строковый литерал
convert.to.primary.constructor=Преобразовать в первичный конструктор
convert.to.primary.constructor.before.text=Вторичный конструктор должен быть преобразован в первичный
convert.to.raw.string.literal=Преобразовать в сырой строковый литерал
convert.to.sealed.class=Преобразовать в sealed класс
convert.to.secondary.constructor=Преобразовать во вторичный конструктор
convert.to.trim.indent=Преобразовать в вызов 'trimIndent()'
convert.to.trim.margin=Преобразовать в вызов 'trimMargin()'
convert.to.unicode.escape=Преобразовать в Unicode-последовательность
convert.to.unsafe.cast=Преобразовать в небезопасное приведение типов
convert.to.unsafecast.call=Преобразовать в вызов unsafeCast()
convert.to.vararg.parameter=Преобразовать в vararg параметр
convert.too.long.character.literal.to.string=Преобразовать слишком длинный символьный литерал в строку
convert.try.finally.to.use=Заменить 'try-finally' на 'use()'
convert.try.finally.to.use.before.text=try-finally может быть заменен на 'use()'
copy.concatenation.text.to.clipboard=Скопировать текст конкатенации в буфер обмена
copy.method.of.data.class.is.called.without.named.arguments=Имена параметров должны быть явно указаны для вызова метода 'copy()'
copy.paste.reference.notification=Добавлено {0} {0, choice, 1\#импорт|2\#импорта}<p><span><a href\='show'>Просмотреть добавленные импорты...</a></span>
copy.paste.resolve.pasted.references=Разрешить вставленные ссылки
copy.paste.restore.pasted.references=Восстановить вставленные ссылки
copy.paste.restore.pasted.references.capitalized=Восстановить вставленные ссылки
copy.paste.select.imports.to.remove.dialog=Выберите импорты для удаления
copy.paste.select.imports.to.remove.text=<html>Вставленный фрагмент кода использует элементы, недоступные в новом контексте. Были добавлены необходимые импорты.<br/>Выберите, какие из добавленных импортов вы хотите удалить из файла.</html>
copy.text.adding.imports=Добавление импортов…
copy.text.clipboard.content.seems.to.be.java.code.do.you.want.to.convert.it.to.kotlin=Содержимое буфера обмена похоже на Java код. Хотите конвертировать его в Kotlin?
copy.text.convert.java.to.kotlin.title=Конвертировать Java в Kotlin
copy.text.copied.kotlin.code=Скопированный код Kotlin
copy.text.resolving.references=Разрешение ссылок…
copy.title.convert.code.from.java=Конвертировать код из Java
could.be.replaced.with.size=Может быть заменено на 'size'
could.be.replaced.with.unboxed.first=Может быть заменено на распакованный 'first'
could.be.replaced.with.unboxed.last=Может быть заменено на распакованный 'last'
create.0=Создать {0}
create.0.1=Создать {0} ''{1}''
create.0.in.1=Создать {0} в {1}
create.actual=Создать actual
create.actual.0.for.module.1.2=Создать actual {0} для модуля {1} ({2})
create.actual.in.0=Создать actual в ''{0}''
create.expected.0.in.common.module.1=Создать expected {0} в общем модуле {1}
create.kotlin.file=Создать файл Kotlin
create.kotlin.subclass=Создать подкласс Kotlin
create.label=Создать метку
create.label.0=Создать метку {0}@
create.package.0=Создать пакет ''{0}''
create.parameter.0=Создать параметр ''{0}''
create.property.0.as.constructor.parameter=Создать свойство ''{0}'' как параметр конструктора
create.subclass=Создать подкласс
create.test=Создать тест
dangerous.array.comparison=Опасное сравнение массивов
declaration.has.type.inferred.from.a.platform.call.which.can.lead.to.unchecked.nullability.issues=Тип объявления выведен из платформенного вызова, что может привести к непроверенным проблемам с null. Явно укажите тип как nullable или non-nullable.
declarations.are.used.outside.of.selected.code.fragment=Следующие объявления используются вне выбранного фрагмента кода\:
declarations.will.move.out.of.scope=Следующие объявления будут недоступны вне тела извлеченной функции\:
deferred.result.is.never.used=Результат 'Deferred' не используется
delegating.to.var.property.does.not.take.its.changes.into.account=Делегирование свойству 'var' не учитывает его изменения
delete.0=удалить {0}
delete.equals.and.hash.code.fix.text=Удалить equals()/hashCode()
delete.fix.family.name=Удалить стрелку
delete.redundant.extension.property=Удалить избыточное свойство-расширение
delete.with.usage.search=удалить (с поиском использований)
demorgan.law=Закон де Моргана
deprecated.annotation.without.replacewith.argument=Аннотация '@Deprecated' без аргумента 'replaceWith'
description.a.reference.to.extracted.type.parameter=ссылка на извлеченный параметр типа
destination.not.found.for.package.0=Не найдено назначение для пакета ''{0}''
diagnostic.name.should.be.replaced.by.the.new.one=Имя диагностики должно быть заменено на новое
dialog.message.incorrect.target.path.directory.not.specified=Неверный целевой путь. Каталог не указан.
dialog.message.none.elements.were.selected=Не выбрано ни одного элемента
dialog.progress.collect.members.to.generate=Сбор членов…
dialog.title.build.super.types.hierarchy=Построение иерархии супертипов для {0}
dialog.title.resolving.inheritable.status=Определение наследуемого статуса…
difference.found.for.data.class.0.found.1.2=Найдено различие для data класса {0}. Найдено {1} использований, но ожидалось {2}
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=Хотите удалить ожидаемое объявление вместе со всеми связанными фактическими?
do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=Хотите удалить этот параметр в ожидаемом объявлении и всех связанных фактических?
do.you.want.to.make.new.extension.an.expected.declaration=Хотите сделать новое расширение expected объявлением?
doesn.t.match.regex.0=не соответствует регулярному выражению ''{0}''
don.t.show.this.dialog.next.time=&Не показывать этот диалог в следующий раз
double.negation.fix.text=Удалить избыточные отрицания
editor.checkbox.title.auto.add.val.keyword.to.data.value.class.constructor.parameters=Автоматически добавлять ключевое слово 'val' к параметрам конструктора data/value класса
editor.checkbox.title.convert.pasted.java.code.to.kotlin=Конвертировать вставленный Java код в Kotlin
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=Не показывать диалог конвертации Java в Kotlin при вставке
editor.title.kotlin=Kotlin
enter.package.fqname=Введите полное имя пакета
enum.entry=Элемент enum
equality.check.0.be.used.instead.of.elvis.for.nullable.boolean.check=Проверка на равенство {0} должна использоваться вместо elvis для проверки nullable boolean
equality.check.with.nan.should.be.replaced.with.isnan=Проверка на равенство с NaN должна быть заменена на 'isNaN()'
equals.between.objects.of.inconvertible.types='equals()' между объектами несовместимых типов
equals.hashcode.in.object.declaration='equals()'/'hashCode()' в объявлении объекта
equals.should.take.any.as.its.argument='equals' должен принимать 'Any?' в качестве аргумента
equals.text=Сгенерировать 'equals()'
error.cant.refactor.vararg.functions=Невозможно рефакторить функцию с переменным числом аргументов
error.context.getter.or.setter=Этот контекст только для свойств с явным getter/setter. (установите тип файла как Kotlin)
error.expected.an.expression=Ожидается выражение
error.expected.catch.or.finally=Ожидается 'catch' или 'finally'
error.hint.cannot.modify.0.declaration.from.1.file=Невозможно изменить объявление ''{0}'' из файла ''{1}''
error.hint.library.declarations.cannot.be.changed=Объявления библиотеки не могут быть изменены
error.hint.text.cannot.inline.0.from.a.decompiled.file=Невозможно встроить ''{0}'' из декомпилированного файла
error.param.can.t.be.null.at.index.0.in.1=Параметр не может быть null по индексу {0} в {1}.
error.text.can.t.change.signature.of.method=Невозможно изменить сигнатуру метода {0}
error.text.can.t.copy.class.to.the.containing.file=Невозможно скопировать класс в содержащий файл
error.text.can.t.generate.0.1=Невозможно сгенерировать {0}\: {1}
error.text.can.t.introduce.constant.for.this.expression=Невозможно создать константу для этого выражения
error.text.can.t.introduce.constant.for.this.expression.because.not.constant=Невозможно создать константу для некостантного выражения
error.text.can.t.introduce.lambda.parameter.for.this.expression=Невозможно создать лямбда-параметр для этого выражения
error.text.can.t.introduce.property.for.this.expression=Невозможно создать свойство для этого выражения
error.text.different.name.expected=Ожидается другое имя
error.text.expression.has.no.type=У выражения отсутствует тип
error.text.extraction.from.expect.class.is.not.yet.supported=Извлечение из expect-класса пока не поддерживается
error.text.extraction.from.non.jvm.class.is.not.yet.supported=Извлечение из не-JVM класса пока не поддерживается
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=Встраивание функции не поддерживается для функций с несколькими операторами return.
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=Встраивание функции не поддерживается для функций с операторами return не в конце тела.
error.text.interface.cannot.be.extracted.from.an.annotation.class=Невозможно извлечь интерфейс из класса аннотации
error.text.introduce.parameter.is.not.available.for.default.value="Создать параметр" недоступно для значения по умолчанию
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries="Создать параметр" недоступно внутри элементов аннотации
error.text.invalid.name=Недопустимое имя
error.text.invalid.parameter.name=Недопустимое имя параметра
error.text.invalid.parameter.type=Недопустимый тип параметра
error.text.invalid.receiver.type=Недопустимый тип получателя
error.text.invalid.return.type=Недопустимый тип возвращаемого значения
error.text.no.type.to.refactor=Нет типа для рефакторинга
error.text.refactoring.is.not.applicable.in.the.current.context=Рефакторинг неприменим в текущем контексте
error.text.superclass.cannot.be.extracted.from.an.annotation.class=Невозможно извлечь суперкласс из класса аннотации
error.text.type.reference.is.expected=Ожидается ссылка на тип
error.types.in.generated.function=Невозможно сгенерировать функцию с ошибочным типом возвращаемого значения
error.wrong.caret.position.function.or.constructor.name=Курсор должен быть установлен на имени функции или конструктора для рефакторинга.
evaluate.compile.time.expression=Вычислить выражение времени компиляции
excluded.methods=Исключенные методы\:
existing.backing.field.is.not.assigned.by.the.setter=Существующее поле не присваивается сеттером
expand.boolean.expression.to.if.else=Развернуть логическое выражение в 'if else'
experimental.coroutines.usages.are.obsolete.since.1.3=Экспериментальное использование корутин устарело с версии 1.3
explicit.0.call=Явный вызов ''{0}''
explicit.this.expression.fix.family.name=Удалить избыточное ''{0}''
explicitly.given.type.is.redundant.here=Явно указанный тип здесь избыточен
expression=Выражение
external.interface.contains.non.nullable.property.name=Внешний интерфейс содержит non-nullable булево свойство
external.interface.contains.val.property.name=Внешний интерфейс содержит свойство val
extract.function=Извлечь функцию
extract.new.parameter.name.receiver=<приемник>
failed.to.create.a.wrapper.for.inlining.to.kotlin=Не удалось создать обертку для встраивания в Kotlin
family.name.update.usages.on.declarations.cut.paste=Обновить использования при вырезании/вставке объявлений
file.entity=Файл
file.lines=Строки файла
files.to.visit=Файлы для обработки
find.declaration.constructor.usages.checkbox=Использования &конструктора [&C]
find.declaration.derived.classes.checkbox=&Производные классы [&D]
find.declaration.derived.interfaces.checkbox=Производные &интерфейсы [&I]
find.declaration.functions.usages.checkbox=Использования &функций [&F]
find.declaration.implementing.methods.checkbox=&Реализующие функции [&I]
find.declaration.implementing.properties.checkbox=&Реализующие свойства [&I]
find.declaration.include.overloaded.methods.checkbox=Включая пере&груженные функции и расширения [&V]
find.declaration.overriding.methods.checkbox=Пере&определяющие функции [&R]
find.declaration.overriding.properties.checkbox=Пере&определяющие свойства [&R]
find.declaration.properties.usages.checkbox=Использования с&войств [&P]
find.declaration.property.readers.checkbox=Геттеры
find.declaration.property.writers.checkbox=Сеттеры
find.usages.checkbox.name.expected.classes=Ожидаемые классы
find.usages.checkbox.name.expected.functions=Ожидаемые функции
find.usages.checkbox.name.expected.properties=Ожидаемые свойства
find.usages.checkbox.text.fast.data.class.component.search=Быстрый поиск компонентов data-класса
find.usages.class=класс
find.usages.class.name.anonymous=Анонимный
find.usages.companion.object=объект-компаньон
find.usages.constructor=конструктор
find.usages.facade.class=фасадный класс
find.usages.for.property={0} для свойства
find.usages.function=функция
find.usages.getter=геттер
find.usages.import.alias=псевдоним импорта
find.usages.interface=интерфейс
find.usages.label=метка
find.usages.lambda=лямбда
find.usages.object=объект
find.usages.parameter=параметр
find.usages.prepare.dialog.progress=Подготовка диалога
find.usages.progress.text.declaration.superMethods=Определение super методов…
find.usages.property=свойство
find.usages.property.accessor=аксессор свойства
find.usages.setter=сеттер
find.usages.text.find.usages.for.data.class.components.and.destruction.declarations=<p>Поиск использований компонентов data-класса и деструктурирующих объявлений<br/>может быть <a href\="{0}">отключен однократно</a> или <a href\="{1}">отключен для проекта</a>.</p>
find.usages.tool.tip.text.disable.search.for.data.class.components.and.destruction.declarations.project.wide.setting=Отключить поиск компонентов data-класса и деструктурирующих объявлений. (Настройка для всего проекта)
find.usages.type.alias=псевдоним типа
find.usages.type.callable.reference=Ссылка на вызываемый объект
find.usages.type.class.object=Вложенный класс/объект
find.usages.type.companion.object=Объект-компаньон
find.usages.type.constructor.delegation.reference=Ссылка на делегирование конструктора
find.usages.type.delegate=Делегат
find.usages.type.extension.receiver.type=Тип получателя расширения
find.usages.type.function.call=Вызов функции
find.usages.type.function.return.type=Типы возвращаемых значений функции
find.usages.type.implicit.get=Неявный 'get'
find.usages.type.implicit.invoke=Неявный 'invoke'
find.usages.type.implicit.iteration=Неявная итерация
find.usages.type.implicit.set=Неявный 'set'
find.usages.type.is=Целевой тип операции 'is'
find.usages.type.named.argument=Именованный аргумент
find.usages.type.nonLocal.property.type=Тип свойства класса/объекта
find.usages.type.packageDirective=Директива пакета
find.usages.type.packageMemberAccess=Доступ к члену пакета
find.usages.type.parameter=параметр типа
find.usages.type.property.delegation=Делегирование свойства
find.usages.type.receiver=Получатель
find.usages.type.super.type.qualifier=Квалификатор супертипа
find.usages.type.superType=Супертип
find.usages.type.type.alias=Псевдоним типа
find.usages.type.type.constraint=Ограничение типа
find.usages.type.value.parameter.type=Тип параметра
find.usages.variable=переменная
fix.add.annotation.family=Добавить аннотацию
fix.add.annotation.target=Добавить цель аннотации
fix.add.annotation.text.constructor=Добавить аннотацию ''@{0}'' к конструктору
fix.add.annotation.text.containing.class=Добавить аннотацию ''@{0}'' к содержащему классу ''{1}''
fix.add.annotation.text.containing.file=Добавить аннотацию ''@{0}'' к содержащему файлу ''{1}''
fix.add.annotation.text.declaration=Добавить аннотацию ''@{0}'' к ''{1}''
fix.add.annotation.text.self=Добавить аннотацию ''@{0}''
fix.add.annotation.with.arguments.text.copy=Скопировать аннотацию ''@{0}'' из ''{1}'' в ''{2}''
fix.add.argument.name.family=Добавить имя к аргументу
fix.add.argument.name.step.choose.parameter.title=Выбрать имя параметра
fix.add.argument.name.text=Добавить имя к аргументу\: ''{0}''
fix.add.argument.name.text.generic=Добавить имя к аргументу…
fix.add.array.of.type.family=Добавить обертку 'arrayOf'
fix.add.array.of.type.text=Добавить обертку {0}
fix.add.constructor.parameter=Добавить параметр конструктора ''{0}''
fix.add.default.constructor=Добавить конструктор по умолчанию в класс 'expect'
fix.add.else.branch.when=Добавить ветку else
fix.add.eq.eq.true=Добавить '\=\= true'
fix.add.exception.to.throws=Добавить ''{0}''
fix.add.explicit.import=Добавить явный импорт
fix.add.function.body=Добавить тело функции
fix.add.function.parameters.add.parameter.constructor=Добавить {0,number,ordinal} {1,choice,1\#параметр|2\#параметра} в конструктор ''{2}''
fix.add.function.parameters.add.parameter.function=Добавить {0,number,ordinal} {1,choice,1\#параметр|2\#параметра} в функцию ''{2}''
fix.add.function.parameters.add.parameter.generic.constructor=Добавить {0,choice,1\#параметр|2\#параметра} в конструктор ''{1}''
fix.add.function.parameters.add.parameter.generic.function=Добавить {0,choice,1\#параметр|2\#параметра} в функцию ''{1}''
fix.add.function.parameters.change.signature.constructor=Изменить сигнатуру конструктора ''{0}''
fix.add.function.parameters.change.signature.function=Изменить сигнатуру функции ''{0}''
fix.add.generic.upperbound.family=Добавить верхнюю границу для дженерика
fix.add.generic.upperbound.text=Добавить ''{0}'' как верхнюю границу для {1}
fix.add.is.to.when=Добавить ''is'' перед ''{0}''
fix.add.loop.label.text=Добавить ''{0}'' к {1}
fix.add.loop.label.text.generic=Добавить метку к циклу
fix.add.member.supertype.add.to=Добавить ''{0}'' в ''{1}''
fix.add.member.supertype.choose.type=Выбрать тип
fix.add.member.supertype.family=Добавить {0} в супертип
fix.add.member.supertype.progress=Добавить {0} в тип
fix.add.member.supertype.text=Добавить {0} в супертип…
fix.add.modifier.family=Добавить модификатор
fix.add.modifier.inline.function.family=Добавить 'inline' к функции
fix.add.modifier.inline.function.text=Добавить ''inline'' к функции ''{0}''
fix.add.modifier.inline.parameter.family=Добавить ''{0}'' к параметру
fix.add.modifier.inline.parameter.text=Добавить ''{0}'' к параметру ''{1}''
fix.add.modifier.text=Сделать {0} ''{1}''
fix.add.modifier.text.generic=Добавить модификатор ''{0}''
fix.add.new.line.after.annotations=Добавить новую строку после аннотаций
fix.add.remaining.branches=Добавить оставшиеся ветки
fix.add.remaining.branches.with.star.import=Добавить оставшиеся ветки с импортом *
fix.add.return.before.expression=Добавить 'return' перед выражением
fix.add.return.before.lambda.expression=Добавить 'run' перед лямбда-выражением
fix.add.return.last.expression=Добавить 'return' к последнему выражению
fix.add.semicolon.lambda.expression=Завершить предыдущий вызов точкой с запятой
fix.add.spread.operator.after.sam=Добавить оператор распространения перед массивом, передаваемым как 'vararg'
fix.add.star.projection.family=Добавить проекции со звездочкой
fix.add.star.projection.text=Добавить ''{0}''
fix.add.suspend.modifier.function=Сделать {0} suspend
fix.add.suspend.modifier.function.generic=Сделать содержащую функцию suspend
fix.add.suspend.modifier.receiver=Сделать тип {0} suspend
fix.add.suspend.modifier.receiver.generic=Сделать тип получателя suspend
fix.add.tostring.call.family=Добавить вызов 'toString()'
fix.add.tostring.call.text=Добавить вызов 'toString()'
fix.add.tostring.call.text.safe=Добавить безопасный вызов '?.toString()'
fix.add.type.annotation.family=Добавить аннотацию типа
fix.add.type.annotation.text=Добавить тип ''{0}'' к параметру ''{1}''
fix.assign.to.property=Присвоить свойству
fix.cast.expression.family=Привести выражение
fix.cast.expression.text=Привести выражение ''{0}'' к типу ''{1}''
fix.change.accessor.family=Изменить тип аксессора
fix.change.accessor.getter=Изменить тип геттера на {0}
fix.change.accessor.setter.parameter=Изменить тип параметра сеттера на {0}
fix.change.jvm.name=Изменить имя JVM
fix.change.mutability.change.to.val=Изменить ''{0}'' на val
fix.change.object.to.class=Изменить 'object' на 'class'
fix.change.package.family=Изменить пакет файла в соответствии с директорией
fix.change.package.text=Изменить пакет файла на {0}
fix.change.progress.analyzing.class.hierarchy=Анализ иерархии классов…
fix.change.progress.looking.inheritors=Поиск наследников класса {0}…
fix.change.return.type.command.function=Изменить тип параметра ''{0}'' функции ''{1}'' на ''{2}''
fix.change.return.type.command.primary.constructor=Изменить тип параметра ''{0}'' первичного конструктора класса ''{1}'' на ''{2}''
fix.change.return.type.family=Изменить тип
fix.change.return.type.lambda=Изменить тип возвращаемого значения лямбда-выражения на {0}
fix.change.return.type.presentation.accessed=доступ к {0}
fix.change.return.type.presentation.base=базовый {0}
fix.change.return.type.presentation.called=вызываемый {0}
fix.change.return.type.presentation.called.function=вызываемая функция
fix.change.return.type.presentation.enclosing=охватывающий {0}
fix.change.return.type.presentation.enclosing.function=охватывающая функция
fix.change.return.type.presentation.function=функция {0}
fix.change.return.type.presentation.property=свойство {0}
fix.change.return.type.remove.explicit.return.type=Удалить явно указанный тип возвращаемого значения
fix.change.return.type.remove.explicit.return.type.of=Удалить явно указанный тип возвращаемого значения для {0}
fix.change.return.type.return.type.text=Изменить тип возвращаемого значения на ''{0}''
fix.change.return.type.return.type.text.of=Изменить тип возвращаемого значения {0} на ''{1}''
fix.change.return.type.text.function=Изменить тип параметра ''{0}'' функции ''{1}'' на ''{2}''
fix.change.return.type.text.primary.constructor=Изменить тип параметра ''{0}'' первичного конструктора класса ''{1}'' на ''{2}''
fix.change.return.type.type.text=Изменить тип на ''{0}''
fix.change.return.type.type.text.of=Изменить тип {0} на ''{1}''
fix.change.signature.error=<ошибка>
fix.change.signature.family=Изменить сигнатуру функции/конструктора
fix.change.signature.function.family=Изменить сигнатуру функции
fix.change.signature.function.popup.title=Выберите сигнатуру
fix.change.signature.function.text=Изменить сигнатуру функции на ''{0}''
fix.change.signature.function.text.generic=Изменить сигнатуру функции…
fix.change.signature.lambda=Изменить сигнатуру лямбда-выражения
fix.change.signature.lambda.command=Изменить сигнатуру лямбда-выражения
fix.change.signature.prepare=Подготовка…
fix.change.signature.remove.parameter=Удалить параметр ''{0}''
fix.change.signature.remove.parameter.command=Удалить параметр ''{0}''
fix.change.signature.unavailable=<недоступно>
fix.change.signature.unnamed.parameter=параметр
fix.change.suspend.hierarchy.add=Добавить модификатор 'suspend' ко всем функциям в иерархии
fix.change.suspend.hierarchy.remove=Удалить модификатор 'suspend' из всех функций в иерархии
fix.change.to.function.invocation=Изменить на вызов функции
fix.change.to.labeled.return.family=Изменить на return с меткой
fix.change.to.labeled.return.text=Изменить на ''{0}''
fix.change.to.mutable.type.family=Изменить тип на изменяемый
fix.change.to.mutable.type.text=Изменить тип на {0}
fix.change.to.property.access.family.change=Изменить на доступ к свойству
fix.change.to.property.access.family.remove=Удалить вызов
fix.change.to.star.projection.family=Изменить на star-проекцию
fix.change.to.star.projection.text=Изменить аргументы типа на {0}
fix.change.to.use.spread.operator.family=Изменить на использование spread-оператора
fix.change.to.use.spread.operator.text=Изменить ''{0}'' на ''{1}''
fix.change.type.argument=Изменить аргумент типа на {0}
fix.change.type.family=Изменить тип
fix.change.type.text=Изменить тип с ''{0}'' на ''{1}''
fix.convert.to.is.array.of.call=Преобразовать в вызов 'isArrayOf'
fix.copy.mismatched.annotation.to.actual.declaration.may.change.semantics=Скопировать несоответствующую аннотацию ''{0}'' из ''expect'' в ''actual''-объявление (может изменить семантику)
fix.create.declaration.error=Невозможно сгенерировать {0}\: {1}
fix.create.declaration.error.inaccessible.type=Недоступный тип
fix.create.declaration.error.some.types.inaccessible=Некоторые типы недоступны\:
fix.create.expect.actual=Создать expect/actual объявление
fix.create.from.usage.dialog.title=Создать из использования
fix.create.from.usage.family=Создать из использования
fix.create.from.usage.local.variable=Создать локальную переменную ''{0}''
fix.create.from.usage.property=Создать свойство ''{0}''
fix.create.missing.actual.declarations=Добавить отсутствующие actual-объявления
fix.create.missing.actual.declarations.title=Добавить отсутствующие actual-объявления
fix.create.missing.actual.members=Добавить отсутствующие actual-члены
fix.import=Импортовать
fix.import.exclude=Исключить ''{0}'' из автоимпорта
fix.import.kind.0.name.1.2=Импортовать {0} ''{1}''{2,choice,0\#|1\# и ещё {2}}
fix.import.kind.0.name.1.and.name.2=Импортовать {0} ''{1}'', ''{2}''
fix.import.kind.component.functions=Функции-компоненты
fix.import.kind.delegate.accessors=Методы доступа делегата
fix.import.question=Импортовать {0}?
fix.insert.delegation.call=Вставить вызов ''{0}()''
fix.introduce.non.null.assertion=Добавить проверку на non-null ({0}\!\!)
fix.make.data.class=Сделать ''{0}'' data-классом
fix.make.field.public=Сделать поле ''{0}'' публичным
fix.make.type.parameter.reified=Сделать {0} reified и {1} inline
fix.make.upperbound.not.nullable.any.text=Добавить ''Any'' как верхнюю границу для {0}, чтобы сделать его non-nullable
fix.make.upperbound.not.nullable.family=Сделать параметр обобщенного типа non-nullable
fix.make.upperbound.not.nullable.remove.nullability.text=Изменить верхнюю границу {0} на ''{1}'', чтобы сделать {0} non-nullable
fix.move.file.to.package.dir.name.text=корень исходников
fix.move.file.to.package.family=Переместить файл в директорию, соответствующую пакету
fix.move.file.to.package.text=Переместить файл в {0}
fix.move.to.sealed.family=Переместить элемент иерархии в пакет/модуль его sealed-родителя
fix.move.to.sealed.text=Переместить {0} в пакет/модуль {1}
fix.move.typealias.to.top.level=Переместить typealias на верхний уровень
fix.opt_in.annotation.family=Аннотировать использование opt-in функционала
fix.opt_in.migrate.experimental.annotation.remove=Удалить устаревшую аннотацию '@Experimental'
fix.opt_in.migrate.experimental.annotation.replace=Заменить устаревшую аннотацию '@Experimental' на '@RequiresOptIn'
fix.opt_in.move.requirement.from.getter.to.property=Переместить требование opt-in ''{0}'' с геттера на свойство
fix.opt_in.move.requirement.from.value.parameter.to.property=Переместить требование opt-in ''{0}'' с параметра-значения на свойство
fix.opt_in.remove.all.forbidden.targets=Удалить запрещенные цели аннотации opt-in
fix.opt_in.remove.forbidden.retention=Удалить запрещенное сохранение аннотации opt-in
fix.opt_in.text.propagate.constructor=Распространить требование opt-in ''{0}'' на конструктор
fix.opt_in.text.propagate.containing.class=Распространить требование opt-in ''{0}'' на содержащий класс ''{1}''
fix.opt_in.text.propagate.containing.object=Распространить требование opt-in ''{0}'' на содержащий объект ''{1}''
fix.opt_in.text.propagate.declaration=Распространить требование opt-in ''{0}'' на ''{1}''
fix.opt_in.text.use.constructor=Включить ''{0}'' для конструктора
fix.opt_in.text.use.containing.anonymous.object=Включить ''{0}'' для содержащего объекта
fix.opt_in.text.use.containing.class=Включить ''{0}'' для содержащего класса ''{1}''
fix.opt_in.text.use.containing.file=Включить ''{0}'' в содержащем файле ''{1}''
fix.opt_in.text.use.containing.object=Включить ''{0}'' для содержащего объекта ''{1}''
fix.opt_in.text.use.declaration=Включить ''{0}'' для ''{1}''
fix.opt_in.text.use.module=Включить ''{0}'' в модуле ''{1}''
fix.opt_in.text.use.statement=Включить ''{0}'' для выражения
fix.potentially.broken.inheritance.message=Это изменение может нарушить работу наследников.\nПродолжить?
fix.potentially.broken.inheritance.title=Возможно нарушение наследования
fix.remove.annotation.text=Удалить аннотацию
fix.remove.argument.text=Удалить аргумент
fix.remove.mismatched.annotation.from.expect.declaration.may.change.semantics=Удалить несоответствующую аннотацию ''{0}'' из ''expect''-объявления (может изменить семантику)
fix.remove.non.null.assertion=Удалить ненужную проверку на non-null (\!\!)
fix.remove.redundant.star.text=Удалить лишнюю *
fix.replace.annotation.family=Заменить аннотацию
fix.replace.annotation.text=Заменить аннотацию на ''@{0}''
fix.replace.mismatched.annotation.args.on.actual.declaration.may.change.semantics=Заменить аргументы несоответствующей аннотации ''{0}'' в ''actual''-объявлении (может изменить семантику)
fix.replace.mismatched.annotation.args.on.expect.declaration.may.change.semantics=Заменить аргументы несоответствующей аннотации ''{0}'' в ''expect''-объявлении (может изменить семантику)
fix.replace.with.assign.function.call=Заменить на вызов ''{0}''
fix.replace.with.declaring.java.class=Заменить на 'declaringJavaClass'
fix.text=Удалить лишнюю точку с запятой
fix.unused.receiver.parameter.remove=Удалить избыточный параметр-получатель
fix.use.fully.qualified.call=Использовать полностью определённый вызов
fix.with.asdynamic=Исправить с помощью 'asDynamic'
flatten.when.expression=Сгладить выражение 'when'
flip.0=Инвертировать ''{0}''
flip.binary.expression=Инвертировать бинарное выражение
flip.equals=Инвертировать 'equals'
floating.point.literal.precision.inspection=Литерал с плавающей точкой не может быть представлен с требуемой точностью
floating.point.literal.precision.inspection.display.name=Литерал с плавающей точкой превышает доступную точность
foldable.if.then=Сворачиваемый if-then
following.expression.won.t.be.processed.since.refactoring.can.t.preserve.its.semantics.0=Следующее выражение не будет обработано, так как рефакторинг не может сохранить его семантику\: {0}
following.problems.are.found=Обнаружены следующие проблемы\:\n
for.0=для ''{0}''
for.api.stability.it.s.recommended.to.specify.explicitly.declaration.types=Для стабильности API рекомендуется явно указывать типы объявлений
for.api.stability.it.s.recommended.to.specify.explicitly.public.protected.declaration.types=Для стабильности API рекомендуется явно указывать типы public и protected объявлений
for.loop.over.indices.could.be.replaced.with.loop.over.elements=Цикл по индексам может быть заменен циклом по элементам
formatter.button.text.use.import.with=Использовать import с '*'
formatter.button.text.use.import.with.when.at.least=Использовать import с '*' когда как минимум
formatter.button.text.use.single.name.import=Использовать импорт одиночного имени
formatter.checkbox.text.insert.imports.for.nested.classes=Вставлять импорты для вложенных классов
formatter.checkbox.text.use.trailing.comma=Использовать замыкающую запятую
formatter.settings.title=Настройки форматования Kotlin
formatter.text.names.used=\ использованных имен
formatter.text.use.defaults.from=Использовать значения по умолчанию из\:
formatter.title.after.colon.before.declaration.type=После двоеточия, перед типом объявления
formatter.title.after.colon.in.new.type.definition=После двоеточия в определении нового типа
formatter.title.align.when.branches.in.columns=Выравнивать ветви 'when' в столбцах
formatter.title.around.arrow.in=Вокруг стрелки в конструкции "when"
formatter.title.around.arrow.in.function.types=Вокруг стрелки в типах функций
formatter.title.around.when.branches.with=Вокруг ветвей 'when' с {}
formatter.title.before.colon.after.declaration.name=Перед двоеточием, после имени объявления
formatter.title.before.colon.in.new.type.definition=Перед двоеточием в определении нового типа
formatter.title.before.declaration.with.comment.or.annotation=Перед объявлением с комментарием или аннотацией
formatter.title.before.lambda.arrow=Перед стрелкой lambda
formatter.title.chained.function.calls=Цепочки вызовов функций
formatter.title.elvis.expressions=Elvis-выражения
formatter.title.elvis.operator=Оператор Elvis (?\:)
formatter.title.expression.body.functions=Функции с телом-выражением
formatter.title.function.annotations=Аннотации функций
formatter.title.function.call.arguments=Аргументы вызова функции
formatter.title.function.declaration.parameters=Параметры объявления функции
formatter.title.function.parentheses=Скобки функции
formatter.title.in.simple.one.line.methods=В простых однострочных методах
formatter.title.indent.before.arrow.on.new.line=Отступ перед '->' на новой строке
formatter.title.java.statics.and.enum.members=Статические члены Java и члены enum
formatter.title.line.break.after.multiline.when.entry=Новая строка после многострочной записи
formatter.title.load.save=Загрузка/Сохранение
formatter.title.other=Прочее
formatter.title.property.annotations=Аннотации свойств
formatter.title.put.left.brace.on.new.line=Поместить левую фигурную скобку на новую строку
formatter.title.range.operator=Операторы диапазона (.., ..<)
formatter.title.top.level.symbols=Символы верхнего уровня
formatter.title.trailing.comma=Замыкающая запятая
formatter.title.use.continuation.indent=Использовать отступ продолжения
formatter.title.use.continuation.indent.in.conditions=Использовать отступ продолжения в условиях
formatter.title.when.parentheses=Скобки 'when'
formatter.title.when.statements=Выражения 'when'
function=Функция
function.0=функция ''{0}''
function.0.returning.1.without.the.corresponding=Функция ''{0}'', возвращающая ''{1}'', без соответствующей функции ''{2}'', возвращающей ''{3}''
function.01=Функция "{0}"
function.name.is.invalid=Недопустимое имя функции
function.returning.0.with.a.name.that.does.not.end.with.1=Функция, возвращающая {0}, с именем, не оканчивающимся на {1}
function.should.have.operator.modifier=Функция должна иметь модификатор 'operator'
generate.equals.and.hashcode.fix.text=Сгенерировать equals() и hashCode()
generate.identity.equals.fix.family.name=Сгенерировать equals и hashCode по идентичности
goto.related.provider.in.module.0=(в модуле {0})
goto.super.chooser.class.title=Выберите суперкласс или интерфейс
goto.super.chooser.function.title=Выберите супер-функцию
goto.super.chooser.property.title=Выберите супер-свойство
group.InternalKotlin.text=Внутренние действия Kotlin
group.KotlinCompletionBenchmarkGroup.text=Тестование производительности автодополнения
group.KotlinInternalGroup.text=Kotlin
group.KotlinRefactoringTesting.text=Тестование рефакторинга Kotlin
group.KotlinToolsGroup.text=Kotlin
group.advanced.settings.kotlin=Kotlin
group.names.code.migration=Миграция кода
group.names.coroutine=Инспекции корутин
group.names.gradle=Gradle
group.names.java.interop.issues=Проблемы взаимодействия с Java
group.names.kotlin=Kotlin
group.names.logging=Логирование
group.names.maven=Maven
group.names.migration=Миграция
group.names.naming.conventions=Соглашения об именовании
group.names.other.problems=Другие проблемы
group.names.probable.bugs=Возможные ошибки
group.names.redundant.constructs=Избыточные конструкции
group.names.style.issues=Проблемы стиля
group.path.kotlin.migration=Kotlin,Миграция
hash.code.text=Сгенерировать 'hashCode()'
hierarchy.legend.member.defined.in.superclass=Член не определен в классе, но определен в суперклассе
hierarchy.legend.member.is.defined.in.class=Член определен в классе
hierarchy.legend.member.should.be.defined=Член должен быть определен, так как класс не abstract
hierarchy.text.anonymous=[анонимный]
hierarchy.text.in=\ в {0}
highlight.usages.of.receiver=Подсветить использования получателя
highlighter.action.text.go.to.actual.declarations=Перейти к фактическим объявлениям
highlighter.action.text.go.to.expected.declaration=Перейти к ожидаемому объявлению
highlighter.action.text.go.to.implementations=Перейти к реализациям
highlighter.action.text.go.to.overridden.methods=Перейти к переопределённым методам
highlighter.action.text.go.to.overridden.properties=Перейти к переопределённым свойствам
highlighter.action.text.go.to.subclasses=Перейти к подклассам
highlighter.action.text.go.to.super.method=Перейти к super методу
highlighter.action.text.go.to.super.property=Перейти к super свойству
highlighter.descriptor.text.android.extensions.property=Свойства и переменные//Синтетические свойства Android Extensions
highlighter.descriptor.text.annotation=Аннотация//Имя аннотации
highlighter.descriptor.text.annotation.attribute.name=Аннотация//Имя атрибута аннотации
highlighter.descriptor.text.arrow=Скобки и операторы//Стрелка
highlighter.descriptor.text.builtin.annotation=Ключевые слова//Модификатор
highlighter.descriptor.text.builtin.keyword=Ключевые слова//Ключевое слово
highlighter.descriptor.text.builtin.keyword.val=Ключевые слова//'val'
highlighter.descriptor.text.builtin.keyword.var=Ключевые слова//'var'
highlighter.descriptor.text.captured.variable=Свойства и переменные//Переменные и значения, захваченные в замыкании
highlighter.descriptor.text.closure.braces=Скобки и операторы//Фигурные скобки и стрелка лямбда-выражения
highlighter.descriptor.text.colon=Скобки и операторы//Двоеточие
highlighter.descriptor.text.constructor.call=Функции//Вызов конструктора
highlighter.descriptor.text.double.colon=Скобки и операторы//Двойное двоеточие
highlighter.descriptor.text.dynamic.fun.call=Функции//Динамический вызов функции
highlighter.descriptor.text.dynamic.property=Свойства и переменные//Динамическое свойство
highlighter.descriptor.text.enum=Классы и интерфейсы//Перечисление
highlighter.descriptor.text.enumEntry=Классы и интерфейсы//Элемент перечисления
highlighter.descriptor.text.exclexcl=Скобки и операторы//Утверждение non-null
highlighter.descriptor.text.extension.fun.call=Функции//Вызов функции-расширения
highlighter.descriptor.text.extension.property=Свойства и переменные//Свойство-расширение
highlighter.descriptor.text.field=Свойства и переменные//Переменная backing field
highlighter.descriptor.text.fun=Функции//Объявление функции
highlighter.descriptor.text.fun.call=Функции//Вызов функции
highlighter.descriptor.text.instance.property=Свойства и переменные//Свойство экземпляра
highlighter.descriptor.text.instance.property.custom.property.declaration=Свойства и переменные//Свойство экземпляра с пользовательскими объявлениями свойств
highlighter.descriptor.text.it=Параметры//Параметр по умолчанию лямбда-выражения
highlighter.descriptor.text.kdoc.comment=Комментарии//KDoc//KDoc комментарий
highlighter.descriptor.text.kdoc.tag=Комментарии//KDoc//KDoc тег
highlighter.descriptor.text.kdoc.value=Комментарии//KDoc//Ссылка в KDoc теге
highlighter.descriptor.text.label=Метка
highlighter.descriptor.text.local.variable=Свойства и переменные//Локальная переменная или значение
highlighter.descriptor.text.named.argument=Именованный аргумент
highlighter.descriptor.text.object=Классы и интерфейсы//Объект
highlighter.descriptor.text.package.fun.call=Функции//Вызов функции уровня пакета
highlighter.descriptor.text.package.property=Свойства и переменные//Свойство уровня пакета
highlighter.descriptor.text.package.property.custom.property.declaration=Свойства и переменные//Свойство уровня пакета с пользовательскими объявлениями свойств
highlighter.descriptor.text.quest=Скобки и операторы//Маркер nullable типа
highlighter.descriptor.text.safe.access=Скобки и операторы//Точка безопасного доступа
highlighter.descriptor.text.smart.cast=Smart-приведения//Smart-приведение значения
highlighter.descriptor.text.smart.cast.receiver=Smart-приведения//Smart-приведение неявного получателя
highlighter.descriptor.text.smart.constant=Smart-приведения//Smart-константа
highlighter.descriptor.text.string.escape=Строка//Экранирование в строке и фигурные скобки шаблона
highlighter.descriptor.text.suspend.fun.call=Функции//Вызов suspend-функции
highlighter.descriptor.text.synthetic.extension.property=Свойства и переменные//Синтетическое свойство-расширение
highlighter.descriptor.text.typeAlias=Классы и интерфейсы//Псевдоним типа
highlighter.descriptor.text.var=Свойства и переменные//Var (изменяемая переменная, параметр или свойство)
highlighter.descriptor.text.variable.as.function.call=Свойства и переменные//Переменная как вызов функции
highlighter.descriptor.text.variable.as.function.like.call=Свойства и переменные//Переменная как функциональный вызов
highlighter.message.suspend.function.call=Вызов suspend-функции
highlighter.message.suspending.iteration=Приостанавливаемая итерация
highlighter.name.dsl=Dsl//
highlighter.name.dsl.markers=DSL маркеры
highlighter.name.expect.actual.line.markers=Kotlin 'expect'//'actual' маркеры строк
highlighter.name.implemented.declaration=Реализованное объявление
highlighter.name.implementing.declaration=Реализующее объявление
highlighter.name.kotlin.line.markers=Kotlin маркеры строк
highlighter.name.multiplatform.actual.declaration=Actual-объявление мультиплатформы
highlighter.name.multiplatform.expect.declaration=Expect-объявление мультиплатформы
highlighter.name.overridden.declaration=Переопределённое объявление
highlighter.name.overriding.declaration=Переопределяющее объявление
highlighter.name.style=Стиль {0}
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=Навигация к переопределяющим классам невозможна во время обновления индекса
highlighter.prefix.text.has.actuals.in=Имеет actual в {0} {1, choice, 0\#модуле|1\#модулях}
highlighter.text.click.for.navigate=Нажмите {0} для навигации
highlighter.text.has.functional.implementations=Имеет функциональные реализации
highlighter.text.implements=Реализует
highlighter.text.in={0} в ''{1}''
highlighter.text.or.press=\ или нажмите {0}
highlighter.text.overrides=Переопределяет
highlighter.title.overriding.declarations.of=Переопределяющие объявления для {0}
highlighter.title.searching.for.overriding.declarations=Поиск переопределяющих объявлений
highlighter.title.searching.for.overriding.methods=Поиск переопределяющих методов
highlighter.tool.tip.has.expect.declaration.in=Имеет expect в {0} {1, choice, 0\#модуле|1\#модулях}
highlighter.tool.tip.marker.annotation.for.dsl=Маркерная аннотация для DSL
highlighter.tool.tip.text.function=функция
highlighter.tool.tip.text.property=свойство
highlighter.tool.tip.text.recursive.call=Рекурсивный вызов
hint.text.no.expression.found=Выражение не найдено
hints.codevision.implementations.format={0, choice, 1\#1 реализация|2\#{0,number} реализации|5\#{0,number} реализаций}
hints.codevision.implementations.too_many.format={0,number}+ реализаций
hints.codevision.inheritors.format={0, choice, 1\#1 наследник|2\#{0,number} наследника|5\#{0,number} наследников}
hints.codevision.inheritors.to_many.format={0,number}+ наследников
hints.codevision.overrides.format={0, choice, 1\#1 переопределение|2\#{0,number} переопределения|5\#{0,number} переопределений}
hints.codevision.overrides.to_many.format={0,number}+ переопределений
hints.codevision.settings=Настройки…
hints.codevision.usages.format={0, choice, 1\#1 использование|2\#{0,number} использования|5\#{0,number} использований}
hints.codevision.usages.too_many.format={0,number}+ использований
hints.ranges.greaterOrEqual=≥
hints.ranges.less=<
hints.ranges.lessOrEqual=≤
hints.settings.common.items=Показывать подсказки для\:
hints.settings.dont.show.lambda.receivers.parameters=Не показывать подсказки неявных получателей и параметров
hints.settings.dont.show.lambda.return=Не показывать подсказки возвращаемых выражений
hints.settings.dont.show.ranges=Не показывать подсказки диапазонов
hints.settings.dont.show.suspending=Не показывать подсказки приостанавливаемых вызовов
hints.settings.dont.show.types.parameter=Не показывать подсказки типов параметров функций
hints.settings.dont.show.types.property=Не показывать подсказки типов свойств
hints.settings.dont.show.types.return=Не показывать подсказки возвращаемых типов функций
hints.settings.dont.show.types.variable=Не показывать подсказки типов локальных переменных
hints.settings.excluded.parameters=Исключенные имена параметров
hints.settings.lambda.receivers.parameters=Неявные получатели и параметры
hints.settings.lambda.return=Выражения return
hints.settings.lambdas=Лямбды
hints.settings.parameters=Параметры
hints.settings.ranges=Диапазоны
hints.settings.show.lambda.receivers.parameters=Показывать подсказки неявных получателей и параметров
hints.settings.show.lambda.return=Показывать подсказки выражений return
hints.settings.show.ranges=Показывать подсказки диапазонов
hints.settings.show.suspending=Показывать подсказки приостанавливающих вызовов
hints.settings.show.types.parameter=Показывать подсказки типов параметров функций
hints.settings.show.types.property=Показывать подсказки типов свойств
hints.settings.show.types.return=Показывать подсказки возвращаемых типов функций
hints.settings.show.types.variable=Показывать подсказки типов локальных переменных
hints.settings.suspending=Приостанавливающие вызовы
hints.settings.types=Типы
hints.settings.types.parameter=Типы параметров функций
hints.settings.types.property=Типы свойств
hints.settings.types.return=Возвращаемые типы функций
hints.settings.types.variable=Типы локальных переменных
hints.settings.values.ranges=Диапазоны
hints.title.argument.name.enabled=Имя аргумента
hints.title.codevision=Code Vision
hints.title.dont.show.argument.name.enabled=Не показывать подсказки имен аргументов
hints.title.show.argument.name.enabled=Показывать подсказки имен аргументов
hints.types=Подсказки типов
if.null.return.break.foldable.to=If-Null return/break/... можно свернуть в '?\:'
if.then.foldable.to=If-Then можно свернуть в '?\:'
implement.abstract.class=Реализовать абстрактный класс
implement.abstract.function=Реализовать абстрактную функцию
implement.abstract.member=Реализовать абстрактный член
implement.abstract.property=Реализовать абстрактное свойство
implement.as.constructor.parameter=Реализовать как параметр конструктора
implement.interface=Реализовать интерфейс
implement.sealed.class=Реализовать sealed класс
implicit.nothing.s=Неявные Nothing
implicit.parameter.it.of.enclosing.lambda.is.shadowed=Неявный параметр 'it' внешней лямбды перекрыт
implicit.unsafe.cast.from.dynamic.to.0=Неявное (небезопасное) приведение из dynamic к {0}
import.members.from.0=Импортовать члены из ''{0}''
import.members.with=Импортовать члены с '*'
import.optimizer.notification.text.unused.imports.not.found=Неиспользуемые импорты не найдены
import.optimizer.progress.indicator.text.collect.imports.for=Сбор импортов для {0}
import.optimizer.text.import={0, choice, 0\#импорт|2\#импорта}
import.optimizer.text.non.zero=Удалено {0} {1}{2, choice, 0\#|1\#, добавлено {2} {3}}
import.optimizer.text.zero=Импорты переупорядочены
import.order.button.text.add.package=Добавить пакет
import.order.button.text.down=Вниз
import.order.button.text.remove=Удалить
import.order.button.text.up=Вверх
import.progress.text.resolve.imports=Поиск всех импортов…
import.text.all.alias.imports=все импорты с псевдонимами
import.text.all.other.imports=все остальные импорты
import.text.import=импорт
in.class.0=в классе ''{0}''
inaccessible.declaration=Недоступное объявление
incomplete.destructuring.declaration.text=Неполное деструктурирующее объявление
incomplete.destructuring.fix.family.name=Добавить отсутствующие переменные в деструктурирующее объявление
indent.raw.string=Отступ для raw-строки
index.is.not.used.in.the.loop.body=Индекс не используется в теле цикла
infix.call.may.be.dot.call=Инфиксный вызов может быть точечным вызовом
inheritance.of.kotlin.sealed=Java {0,choice,0\#интерфейс|1\#класс} не может быть частью иерархии sealed в Kotlin
initialize.with.constructor.parameter=Инициализовать параметром конструктора
initialize.with.constructor.parameter.analyzing.existing.variables=Анализ существующих переменных…
inlay.kotlin.call.chains.hints=Показывать встроенные подсказки для цепочек вызовов
inlay.kotlin.lambdas.hints=Показывать встроенные подсказки для лямбд
inlay.kotlin.lambdas.hints.hints.lambda.receivers.parameters=Показывать встроенные подсказки для неявных получателей и параметров
inlay.kotlin.lambdas.hints.hints.lambda.return=Показывать встроенные подсказки для выражений return
inlay.kotlin.parameters.hints=Показывать имена параметров в местах вызова функций.
inlay.kotlin.parameters.hints.excluded=Показывать исключенные имена параметров
inlay.kotlin.references.types.hints=Показывать встроенные подсказки для типов
inlay.kotlin.references.types.hints.hints.type.function.parameter=Показывать встроенные подсказки для типов параметров функций
inlay.kotlin.references.types.hints.hints.type.function.return=Показывать встроенные подсказки для возвращаемых типов функций
inlay.kotlin.references.types.hints.hints.type.property=Показывать встроенные подсказки для типов свойств
inlay.kotlin.references.types.hints.hints.type.variable=Показывать встроенные подсказки для типов локальных переменных
inlay.kotlin.values.hints=Показывать встроенные подсказки для значений
inlay.kotlin.values.hints.kotlin.values.ranges=Показывать встроенные подсказки для диапазонов
inline.type.parameter=Встроить параметр типа
inline.variable=Встроить переменную
inline.when.argument=Встроить аргумент 'when'
insert.curly.braces.around.variable=Вставить фигурные скобки вокруг переменной
insert.explicit.delegation.call=Вставить явный вызов делегирования
insert.number.conversion=Вставить преобразование числа
inspection.add.conversion.call.display.name=Требуется явное преобразование из `Int` с версии 1.9
inspection.add.kotlin.coroutines.display.name=Добавить библиотеку Kotlin Coroutines
inspection.add.operator.modifier.display.name=Функция должна иметь модификатор 'operator'
inspection.add.variance.modifier.display.name=Параметр типа может иметь вариантность 'in' или 'out'
inspection.ambiguous.expression.when.branch.migration.display.name=Неоднозначные логические выражения в ветках 'when' с версии 1.7
inspection.array.in.data.class.display.name=Свойство массива в data классе
inspection.boolean.literal.argument.display.name=Аргумент-литерал логического типа без имени параметра
inspection.can.be.parameter.display.name=Параметр конструктора никогда не используется как свойство
inspection.can.be.primary.constructor.property.display.name=Свойство явно присваивается параметру конструктора
inspection.can.be.val.display.name=Локальная 'var' никогда не изменяется и может быть объявлена как 'val'
inspection.can.sealed.subclass.be.object.display.name=Sealed подкласс без состояния и переопределённого equals
inspection.cascade.if.display.name=Каскадный 'if' можно заменить на 'when'
inspection.class.name.display.name=Соглашение об именовании классов
inspection.complex.redundant.let.display.name=Избыточный вызов 'let' на основе аргумента
inspection.conflicting.extension.property.display.name=Конфликт расширения свойства с синтетическим
inspection.const.property.name.display.name=Соглашение об именовании const-свойств
inspection.constant.condition.if.display.name=Условие выражения 'if' является константой
inspection.control.flow.with.empty.body.display.name=Управляющая конструкция с пустым телом
inspection.convert.argument.to.set.display.name=Аргумент можно преобразовать в 'Set' для повышения производительности
inspection.convert.call.chain.into.sequence.display.name=Цепочку вызовов коллекции можно преобразовать в 'Sequence' для повышения производительности
inspection.convert.lambda.to.reference.display.name=Можно заменить на ссылку на функцию
inspection.convert.na.n.equality.display.name=Преобразовать проверку равенства с 'NaN' в вызов 'isNaN'
inspection.convert.object.to.data.object.display.name=Преобразовать 'object' в 'data object'
inspection.convert.pair.constructor.to.to.function.display.name=Преобразовать конструктор Pair в функцию 'to'
inspection.convert.reference.to.lambda.display.name=Можно заменить на лямбду
inspection.convert.secondary.constructor.to.primary.display.name=Преобразовать во вторичный конструктор
inspection.convert.to.string.template.display.name=Конкатенацию строк можно преобразовать в строковый шаблон
inspection.convert.try.finally.to.use.call.display.name=Преобразовать try / finally в вызов use()
inspection.convert.two.comparisons.to.range.check.display.name=Два сравнения следует преобразовать в проверку диапазона
inspection.copy.without.named.arguments.display.name=Метод 'copy' класса данных вызывается без именованных аргументов
inspection.data.class.private.constructor.display.name=Приватный конструктор класса данных раскрывается через метод 'copy'
inspection.deferred.is.result.display.name=Функция напрямую возвращает Deferred
inspection.deferred.result.unused.display.name=Результат '@Deferred' не используется
inspection.delegation.to.var.property.display.name=Делегирование свойству 'var'
inspection.deprecated.callable.add.replace.with.display.name=Аннотация @Deprecated без аргумента 'replaceWith'
inspection.deprecated.enum.declaring.class.property=Устаревшее свойство 'Enum.declaringClass'
inspection.deprecated.gradle.dependency.display.name=В Gradle используется устаревшая библиотека
inspection.deprecated.inline.class.text=Устаревший inline-класс
inspection.deprecated.inline.classes.migration.display.name=Inline-классы устарели с версии 1.5
inspection.deprecated.maven.dependency.display.name=В Maven используется устаревшая библиотека
inspection.destructure.display.name=Использовать деструктурирующее объявление
inspection.destructuring.wrong.name.display.name=Переменная в деструктурирующем объявлении использует имя неправильного свойства класса данных
inspection.different.kotlin.gradle.version.display.name=Версии плагинов Kotlin Gradle и ИСР различаются
inspection.different.kotlin.maven.version.display.name=Версии плагинов Maven и ИСР различаются
inspection.different.maven.stdlib.version.display.name=Версии библиотеки и плагина Maven различаются
inspection.different.stdlib.gradle.version.display.name=Версии библиотеки Kotlin и плагина Gradle различаются
inspection.do.not.propagate.method.deprecation.through.overrides=Не распространять устаревание метода через переопределения с версии 1.9
inspection.empty.range.display.name=Диапазон с началом больше endInclusive пуст
inspection.enum.entry.name.display.name=Соглашение об именовании элементов enum
inspection.enum.values.method.soft.deprecate.in.java.display.name=С Kotlin 1.9 рекомендуется заменить 'Enum.values()' на 'Enum.getEntries()'
inspection.enum.values.method.soft.deprecate.migration.display.name=С версии 1.9 рекомендуется заменить 'Enum.values()' на 'Enum.entries'
inspection.equals.or.hash.code.display.name='equals()' и 'hashCode()' не в паре
inspection.explicit.this.display.name=Избыточный явный 'this'
inspection.fake.jvm.field.constant.display.name=Не-const свойство Kotlin используется как константа Java
inspection.filter.is.instance.call.with.class.literal.argument.display.name=Вызов 'filterIsInstance' с литералом класса в качестве аргумента
inspection.filter.is.instance.call.with.class.literal.argument.quick.fix.text=Заменить литерал класса на reified параметр типа
inspection.fold.initializer.and.if.to.elvis.display.name=If-Null return/break/... можно свернуть в '?\:'
inspection.for.each.parameter.not.used.display.name=Итерируемые элементы не используются в forEach
inspection.from.closed.range.migration.display.name=MIN_VALUE шаг в fromClosedRange() с версии 1.3
inspection.function.name.display.name=Соглашение об именовании функций
inspection.function.with.lambda.expression.body.display.name=Функция с '\= { ... }' и выведенным типом возврата
inspection.gradle.kotlinx.coroutines.deprecation.display.name=Несовместимая зависимость kotlinx.coroutines используется с Kotlin 1.3+ в Gradle
inspection.has.platform.type.display.name=Функция или свойство имеет платформенный тип
inspection.if.then.to.elvis.display.name=If-Then можно свернуть в '?\:'
inspection.if.then.to.safe.access.display.name=If-Then можно свернуть в '?.'
inspection.implicit.nullable.nothing.type.display.name=Неявный тип 'Nothing?'
inspection.implicit.this.action.name=Добавить явный 'this'
inspection.implicit.this.display.name=Неявный 'this'
inspection.incomplete.destructuring.declaration.display.name=Неполное деструктурирующее объявление
inspection.inconsistent.comment.for.java.parameter.display.name=Несогласованный комментарий для параметра Java
inspection.introduce.when.subject.display.name='when', который можно упростить введением аргумента
inspection.java.collections.static.method.display.name=Статический метод Java Collections можно заменить на stdlib Kotlin
inspection.java.collections.static.method.on.immutable.list.display.name=Вызов мутирующего метода Java на неизменяемой коллекции Kotlin
inspection.java.io.serializable.object.must.have.read.resolve.display.name=Serializable объект должен реализовывать 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.quick.fix.name=Реализовать 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.warning=Serializable объект должен реализовывать 'readResolve'
inspection.java.map.for.each.display.name=Вызов метода Java Map.forEach следует заменить на forEach из Kotlin
inspection.join.declaration.and.assignment.display.name=Объединить объявление и присваивание
inspection.join.declaration.and.assignment.option.report.with.complex.initialization.of.member.properties=Сообщать о сложной инициализации свойств-членов
inspection.k.doc.missing.documentation.display.name=Отсутствуют KDoc комментарии для публичных объявлений
inspection.k.doc.unresolved.reference.display.name=Неразрешённая ссылка в KDoc
inspection.kotlin.catch.may.ignore.exception.display.name=Блок 'catch' может игнорировать исключение
inspection.kotlin.constant.conditions.display.name=Константные условия
inspection.kotlin.covariant.equals.display.name=Ковариантный 'equals()'
inspection.kotlin.deprecation.display.name=Использование избыточного или устаревшего синтаксиса или устаревших символов
inspection.kotlin.double.negation.action.name=Удалить избыточное двойное отрицание
inspection.kotlin.double.negation.display.name=Избыточное двойное отрицание
inspection.kotlin.equals.between.inconvertible.types.display.name='equals()' между объектами несовместимых типов
inspection.kotlin.internal.in.java.display.name=Использование internal-объявлений Kotlin из Java
inspection.kotlin.invalid.bundle.or.property.display.name=Недействительный ключ свойства
inspection.kotlin.jvm.annotation.in.java.description=Аннотация Kotlin JVM ''{0}'' не имеет эффекта в Java
inspection.kotlin.jvm.annotation.in.java.display.name=Аннотация Kotlin JVM в Java
inspection.kotlin.maven.plugin.phase.display.name=Неправильная конфигурация плагина Kotlin Maven
inspection.kotlin.options.to.compiler.options.display.name=Использование устаревшего DSL 'kotlinOptions'
inspection.kotlin.redundant.override.display.name=Избыточный переопределяющий метод
inspection.kotlin.redundant.suppression.display.name=Избыточное подавление диагностики
inspection.kotlin.sealed.in.java.display.name=Наследование sealed интерфейса/класса Kotlin из Java
inspection.kotlin.test.j.unit.display.name=Можно использовать kotlin-test-junit
inspection.kotlin.throwable.not.thrown.display.name=Throwable не выброшен
inspection.kotlin.unused.import.display.name=Неиспользуемая директива import
inspection.kotlin.unused.variable.display.name=Неиспользуемая переменная
inspection.lateinit.var.overrides.lateinit.var.display.name=Свойство 'lateinit var' переопределяет свойство 'lateinit var'
inspection.leaking.this.display.name=Утечка 'this' в конструкторе
inspection.lift.return.or.assignment.display.name=Return или присваивание можно вынести
inspection.lift.return.or.assignment.option.only.single.statement=Сообщать только если каждая ветвь - одиночный оператор
inspection.local.variable.name.display.name=Соглашение об именовании локальных переменных
inspection.logger.initialized.with.foreign.class.display.name=Логгер инициализован чужим классом
inspection.logger.placeholder.count.matches.argument.count.display.name=Количество плейсхолдеров не соответствует количеству аргументов в вызове логгера
inspection.loop.to.call.chain.display.name=Цикл можно заменить операциями stdlib
inspection.main.function.return.unit.display.name=Функция main должна возвращать 'Unit'
inspection.map.get.with.not.null.assertion.operator.display.name='map.get()' с оператором утверждения не-null (\!\!)
inspection.maven.coroutines.deprecation.display.name=Несовместимая зависимость kotlinx.coroutines используется с Kotlin 1.3+ в Maven
inspection.may.be.constant.display.name=Может быть 'const'
inspection.member.visibility.can.be.private.display.name=Член класса может иметь модификатор 'private'
inspection.message.cast.will.always.fail=Приведение типа всегда будет неудачным
inspection.message.condition.always.false=Условие ''{0}'' всегда false
inspection.message.condition.always.false.when.reached=Условие ''{0}'' всегда false при достижении
inspection.message.condition.always.true=Условие ''{0}'' всегда true
inspection.message.condition.always.true.when.reached=Условие ''{0}'' всегда true при достижении
inspection.message.empty.catch.block=Пустой блок catch
inspection.message.for.never.visited=Диапазон 'for' всегда пуст
inspection.message.inconsistent.parameter.name.for.0=Несогласованное имя параметра для ''{0}''
inspection.message.index.out.of.bounds=Индекс всегда выходит за границы
inspection.message.nonnull.cast.will.always.fail=Операция всегда будет неудачной, так как операнд всегда null
inspection.message.object.with.manual.tostring.can.be.converted.to.data.object='object' с ручным 'toString' можно преобразовать в 'data object'
inspection.message.sealed.object.can.be.converted.to.data.object='sealed' подобъект можно преобразовать в 'data object'
inspection.message.value.always.false=Значение ''{0}'' всегда false
inspection.message.value.always.null=Значение ''{0}'' всегда null
inspection.message.value.always.true=Значение ''{0}'' всегда true
inspection.message.value.always.zero=Значение ''{0}'' всегда равно нулю
inspection.message.when.condition.always.false=Ветка 'when' никогда не достижима
inspection.migrate.diagnostic.suppression.display.name=Имя диагностики должно быть заменено
inspection.move.lambda.outside.parentheses.display.name=Аргумент-лямбда внутри скобок
inspection.move.suspicious.callable.reference.into.parentheses.display.name=Подозрительная ссылка на вызываемый объект используется как результат лямбды
inspection.move.variable.declaration.into.when.display.name=Объявление переменной можно переместить внутрь 'when'
inspection.nested.lambda.shadowed.implicit.parameter.display.name=Вложенная лямбда имеет затененный неявный параметр
inspection.no.actual.for.expect.display.name=Нет actual для expect-объявления
inspection.non.exhaustive.when.statement.migration.display.name=Неполные выражения 'when' будут запрещены с версии 1.7
inspection.null.checks.to.safe.call.display.name=Проверки на null можно заменить безопасными вызовами
inspection.nullable.boolean.elvis.action.name=Использовать проверку на равенство вместо elvis для проверки nullable boolean
inspection.nullable.boolean.elvis.display.name=Проверка на равенство может использоваться вместо elvis для проверки nullable boolean
inspection.object.literal.to.lambda.display.name=Литерал объекта можно преобразовать в лямбду
inspection.object.private.property.name.display.name=Соглашение об именовании private-свойств object
inspection.object.property.name.display.name=Соглашение об именовании свойств object
inspection.obsolete.experimental.coroutines.display.name=Экспериментальные корутины устарели с версии 1.3
inspection.obsolete.kotlin.js.packages.display.name=Пакеты 'kotlin.browser' и 'kotlin.dom' устарели с версии 1.4
inspection.optional.expectation.display.name=Опциональная ожидаемая аннотация не имеет фактической аннотации
inspection.package.directory.mismatch.display.name=Имя пакета не соответствует содержащей директории
inspection.package.name.display.name=Соглашение об именовании пакетов
inspection.platform.extension.receiver.of.inline.display.name='inline fun' с nullable-получателем до Kotlin 1.2
inspection.private.property.name.display.name=Соглашение об именовании private-свойств
inspection.progression.resolution.change.migration.display.name=Изменение разрешения прогрессии с версии 1.9
inspection.prohibit.jvm.overloads.on.constructors.of.annotation.classes.migration.display.name=Аннотация '@JvmOverloads' не может использоваться на конструкторах классов аннотаций с версии 1.4
inspection.prohibit.repeated.use.site.target.annotations.migration.display.name=Повторяющаяся аннотация, не помеченная как '@Repeatable'
inspection.prohibit.type.parameters.for.local.variables.migration.display.name=Локальная переменная с параметрами типа
inspection.prohibit.use.site.target.annotations.on.super.types.migration.display.name=Бессмысленные цели аннотаций на суперклассе
inspection.property.name.display.name=Соглашение об именовании свойств
inspection.protected.in.final.display.name=Видимость 'protected' фактически является 'private' в final-классе
inspection.public.api.implicit.type.display.name=Объявление публичного API с неявным возвращаемым типом
inspection.recursive.equals.call.display.name=Рекурсивный вызов equals
inspection.recursive.property.accessor.display.name=Рекурсивный аксессор свойства
inspection.redundant.anonymous.function.description=Избыточное создание анонимной функции
inspection.redundant.assequence.call=Избыточный вызов 'asSequence'
inspection.redundant.async.display.name=Избыточный вызов 'async'
inspection.redundant.companion.reference.display.name=Избыточная ссылка на 'Companion'
inspection.redundant.else.in.if.display.name=Избыточный 'else' в 'if'
inspection.redundant.elvis.return.null.descriptor=Избыточное '?\: return null'
inspection.redundant.elvis.return.null.display.name=Избыточное '?\: return null'
inspection.redundant.empty.initializer.block.display.name=Избыточный пустой блок инициализации
inspection.redundant.enum.constructor.invocation.display.name=Избыточный вызов конструктора enum
inspection.redundant.explicit.type.display.name=Очевидный явный тип
inspection.redundant.getter.display.name=Избыточный геттер свойства
inspection.redundant.if.display.name=Избыточный оператор 'if'
inspection.redundant.inner.class.modifier.descriptor=Избыточный модификатор 'inner'
inspection.redundant.inner.class.modifier.display.name=Избыточный модификатор 'inner'
inspection.redundant.label.migration.display.name=Избыточная метка
inspection.redundant.label.text=Избыточная метка
inspection.redundant.labeled.return.on.last.expression.in.lambda.display.name=Избыточный помеченный return в последнем выражении лямбды
inspection.redundant.lambda.arrow.display.name=Избыточная стрелка лямбды
inspection.redundant.lambda.description=Избыточное создание лямбды
inspection.redundant.lambda.or.anonymous.function.display.name=Избыточное создание лямбды или анонимной функции
inspection.redundant.lambda.or.anonymous.function.fix=Встроить тело
inspection.redundant.modality.modifier.display.name=Избыточный модификатор модальности
inspection.redundant.not.null.extension.receiver.of.inline.display.name=Расширение 'inline fun' может быть явно nullable до Kotlin 1.2
inspection.redundant.nullable.return.type.display.name=Избыточный nullable тип возвращаемого значения
inspection.redundant.object.type.check.display.name=Неидиоматическая проверка типа 'is' для объекта
inspection.redundant.require.not.null.call.display.name=Избыточный вызов 'requireNotNull' или 'checkNotNull'
inspection.redundant.return.label.display.name=Избыточная метка 'return'
inspection.redundant.run.catching.display.name=Избыточный вызов 'runCatching'
inspection.redundant.sam.constructor.display.name=Избыточный SAM-конструктор
inspection.redundant.semicolon.display.name=Избыточная точка с запятой
inspection.redundant.setter.display.name=Избыточный сеттер свойства
inspection.redundant.suspend.modifier.display.name=Избыточный модификатор 'suspend'
inspection.redundant.unit.expression.display.name=Избыточный 'Unit'
inspection.redundant.unit.return.type.action.name=Удалить избыточный возвращаемый тип 'Unit'
inspection.redundant.unit.return.type.display.name=Избыточный возвращаемый тип 'Unit'
inspection.redundant.value.argument.annotation=Значение аргумента совпадает со значением по умолчанию параметра ''{0}''
inspection.redundant.value.argument.display.name=Избыточный аргумент значения
inspection.redundant.visibility.modifier.display.name=Избыточный модификатор видимости
inspection.redundant.with.display.name=Избыточный вызов 'with'
inspection.remove.curly.braces.from.template.display.name=Избыточные фигурные скобки в строковом шаблоне
inspection.remove.empty.class.body.display.name=Заменить пустое тело класса
inspection.remove.empty.parentheses.from.annotation.entry.display.name=Удалить ненужные скобки
inspection.remove.empty.parentheses.from.lambda.call.action.name=Удалить ненужные скобки из вызова функции с лямбдой
inspection.remove.empty.parentheses.from.lambda.call.display.name=Ненужные скобки в вызове функции с лямбдой
inspection.remove.empty.primary.constructor.display.name=Избыточный пустой первичный конструктор
inspection.remove.empty.secondary.constructor.body.display.name=Избыточное тело конструктора
inspection.remove.explicit.super.qualifier.display.name=Ненужная квалификация супертипа
inspection.remove.explicit.type.arguments.display.name=Ненужный аргумент типа
inspection.remove.for.loop.indices.display.name=Неиспользуемый индекс цикла
inspection.remove.redundant.backticks.display.name=Избыточные обратные кавычки
inspection.remove.redundant.calls.of.conversion.methods.display.name=Избыточный вызов метода преобразования
inspection.remove.redundant.qualifier.name.display.name=Избыточное имя квалификатора
inspection.remove.redundant.spread.operator.display.name=Избыточный оператор spread
inspection.remove.setter.parameter.type.display.name=Избыточный тип параметра сеттера
inspection.remove.single.expression.string.template.display.name=Избыточный строковый шаблон
inspection.remove.to.string.in.string.template.display.name=Избыточный вызов 'toString()' в строковом шаблоне
inspection.replace.array.equality.op.with.arrays.equals.display.name=Сравнение массивов через '\=\=' и '\!\='
inspection.replace.array.of.with.literal.display.name=Вызов 'arrayOf' может быть заменен литералом массива [...]
inspection.replace.assert.boolean.with.assert.equality.display.name=Проверка булева значения может быть заменена на проверку равенства
inspection.replace.associate.function.display.name='associate' может быть заменен на 'associateBy' или 'associateWith'
inspection.replace.call.with.binary.operator.display.name=Может быть заменено бинарным оператором
inspection.replace.collection.count.with.size.display.name=Подсчет элементов коллекции может быть преобразован в размер
inspection.replace.get.or.set.display.name=Явный вызов 'get' или 'set'
inspection.replace.guard.clause.with.function.call.display.name=Защитное условие может быть заменено вызовом функции Kotlin
inspection.replace.isempty.with.ifempty.display.name=Условие 'if' может быть заменено вызовом лямбды
inspection.replace.java.static.method.with.kotlin.analog.display.name=Java-методы следует заменить аналогами Kotlin
inspection.replace.manual.range.with.indices.calls.display.name=Диапазон может быть преобразован в индексы или итерацию
inspection.replace.mapIndexed.with.list.generator.display.name=Заменить 'mapIndexed' на генератор List
inspection.replace.negated.is.empty.with.is.not.empty.display.name=Отрицание может быть упрощено
inspection.replace.not.null.assertion.with.elvis.return.display.name=Проверка на not-null может быть заменена на 'return'
inspection.replace.put.with.assignment.display.name='map.put()' может быть преобразован в присваивание
inspection.replace.range.start.end.inclusive.with.first.last.display.name=Упакованные свойства следует заменить на распакованные
inspection.replace.range.to.with.rangeUntil.display.name=Вызов 'rangeTo' или '..' следует заменить на '..<'
inspection.replace.range.to.with.until.display.name=Вызов 'rangeTo' или '..' следует заменить на 'until'
inspection.replace.readline.with.readln.display.name='readLine' может быть заменен на 'readln' или 'readlnOrNull'
inspection.replace.size.check.with.is.not.empty.display.name=Проверка размера может быть заменена на 'isNotEmpty()'
inspection.replace.size.zero.check.with.is.empty.display.name=Проверка на нулевой размер может быть заменена на 'isEmpty()'
inspection.replace.string.format.with.literal.display.name=Вызов 'String.format' может быть заменен строковыми шаблонами
inspection.replace.substring.with.drop.last.display.name=Вызов 'substring' следует заменить вызовом 'dropLast'
inspection.replace.substring.with.indexing.operation.display.name=Вызов 'substring' следует заменить оператором индексирования
inspection.replace.substring.with.substring.after.display.name=Вызов 'substring' следует заменить на 'substringAfter'
inspection.replace.substring.with.substring.before.display.name=Вызов 'substring' следует заменить на 'substringBefore'
inspection.replace.substring.with.take.display.name=Вызов 'substring' следует заменить вызовом 'take'
inspection.replace.to.string.with.string.template.display.name=Вызов 'toString' может быть заменен строковым шаблоном
inspection.replace.to.with.infix.form.display.name=Вызов 'to' следует заменить инфиксной формой
inspection.replace.until.with.rangeUntil.operator.display.name=Заменить 'until' на оператор '..<'
inspection.replace.with.enum.map.display.name='HashMap' может быть заменен на 'EnumMap'
inspection.replace.with.ignore.case.equals.display.name=Следует заменить на 'equals(..., ignoreCase \= true)'
inspection.replace.with.import.alias.display.name=Полное имя может быть заменено существующим псевдонимом импорта
inspection.replace.with.operator.assignment.display.name=Присваивание может быть заменено составным присваиванием
inspection.replace.with.string.builder.append.range.display.name=Вызов 'StringBuilder.append(CharArray, offset, len)' на JVM
inspection.restrict.return.statement.target.migration.display.name=Целевая метка не обозначает функцию начиная с 1.4
inspection.runblocking.analysis.found.runblocking=--> runBlocking
inspection.runblocking.analysis.graphbuilding.progress=Обработка {0}
inspection.runblocking.presentation.descriptor=Анализ runBlocking\:
inspection.runblocking.presentation.display.name=RunBlocking в корутине
inspection.runblocking.presentation.settings.exploration.option.all=Да, включая переопределения
inspection.runblocking.presentation.settings.exploration.option.declaration=Да, исключая переопределения
inspection.runblocking.presentation.settings.exploration.option.strict=Нет
inspection.runblocking.presentation.settings.exploration.title=Исследовать функции с переопределениями
inspection.runblocking.presentation.text=RunBlocking builder вызван из корутины
inspection.safe.cast.with.return.display.name=Безопасное приведение типа с 'return' следует заменить на проверку типа 'if'
inspection.scope.function.conversion.display.name=Функция области видимости может быть преобразована в другую
inspection.self.assignment.display.name=Избыточное присваивание
inspection.self.reference.constructor.parameter.display.name=Конструктор никогда не может быть завершен
inspection.setter.backing.field.assignment.display.name=Существующее теневое поле без присваивания
inspection.simple.redundant.let.display.name=Избыточный вызов 'let' на основе приёмника
inspection.simplifiable.call.chain.display.name=Цепочка вызовов для типа коллекции может быть упрощена
inspection.simplifiable.call.display.name=Вызов библиотечной функции может быть упрощен
inspection.simplifiable.scope.function.display.name=Функция области видимости с вложенным forEach может быть упрощена
inspection.simplify.assert.not.null.display.name=Вызов 'assert' может быть заменен на '\!\!' или '?\:'
inspection.simplify.boolean.with.constants.display.name=Булево выражение может быть упрощено
inspection.simplify.negated.binary.expression.display.name=Отрицание булева выражения может быть упрощено
inspection.simplify.when.with.boolean.constant.condition.display.name=Упрощаемое выражение 'when'
inspection.sort.modifiers.display.name=Неканонический порядок модификаторов
inspection.suspend.function.on.coroutine.scope.display.name=Неоднозначный coroutineContext из-за CoroutineScope-приёмника suspend-функции
inspection.suspicious.as.dynamic.display.name=Подозрительный вызов члена 'asDynamic'
inspection.suspicious.collection.reassignment.display.name=Составное присваивание создает новую коллекцию под капотом
inspection.suspicious.equals.combination.display.name=Подозрительная комбинация \=\= и \=\=\=
inspection.suspicious.var.property.display.name=Подозрительное свойство 'var'\: его сеттер не влияет на результат геттера
inspection.test.function.name.display.name=Соглашение об именовании тестовых функций
inspection.this.class.does.not.have.a.constructor=Запрещенный вызов конструктора
inspection.trailing.comma.add.line.break=Добавить перенос строки
inspection.trailing.comma.add.trailing.comma=Добавить замыкающую запятую
inspection.trailing.comma.comma.loses.the.advantages.in.this.position=Запятая теряет преимущества в этой позиции
inspection.trailing.comma.display.name=Рекомендации по замыкающим запятым
inspection.trailing.comma.fix.comma.position=Исправить положение запятой
inspection.trailing.comma.missing.line.break=Отсутствует перенос строки
inspection.trailing.comma.missing.trailing.comma=Отсутствует замыкающая запятая
inspection.trailing.comma.remove.trailing.comma=Удалить замыкающую запятую
inspection.trailing.comma.report.also.a.missing.comma=Также сообщать об отсутствующей запятой или переносе строки
inspection.trailing.comma.useless.trailing.comma=Бесполезная замыкающая запятая
inspection.unlabeled.return.inside.lambda.display.name=Неотмеченный return внутри lambda
inspection.unnecessary.opt_in.annotation.display.name=Ненужная аннотация '@OptIn'
inspection.unnecessary.opt_in.redundant.annotation=Аннотация opt-in избыточна\: не используется соответствующий экспериментальный API
inspection.unnecessary.opt_in.redundant.marker=Маркер opt-in избыточен\: не используется экспериментальный API с маркировкой '{0}'
inspection.unnecessary.opt_in.remove.annotation.fix.family.name=Удалить аннотацию
inspection.unnecessary.opt_in.remove.marker.fix.family.name=Удалить маркер opt-in
inspection.unnecessary.variable.display.name=Ненужная локальная переменная
inspection.unnecessary.variable.option.report.immediately.returned.variables=Сообщать о немедленно возвращаемых переменных
inspection.unsafe.cast.from.dynamic.display.name=Неявное (небезопасное) приведение из динамического типа
inspection.unused.equals.display.name=Неиспользуемое выражение equals
inspection.unused.lambda.expression.body.display.name=Неиспользуемое возвращаемое значение функции с телом лямбда-выражения
inspection.unused.main.parameter.display.name=Параметр main не требуется
inspection.unused.receiver.parameter=Параметр-приёмник никогда не используется
inspection.unused.receiver.parameter.display.name=Неиспользуемый параметр-приёмник
inspection.unused.result.of.data.class.copy=Неиспользуемый результат копирования data class
inspection.unused.symbol.display.name=Неиспользуемый символ
inspection.unused.unary.operator.display.name=Неиспользуемый унарный оператор
inspection.use.expression.body.display.name=Здесь предпочтительнее синтаксис тела-выражения
inspection.use.property.access.syntax.display.name=Вызов аксессора может быть заменен синтаксисом доступа к свойству
inspection.use.with.index.display.name=Вручную инкрементируемая индексная переменная может быть заменена использованием 'withIndex()'
inspection.useless.call.on.collection.display.name=Бесполезный вызов для типа коллекции
inspection.useless.call.on.not.null.display.name=Бесполезный вызов для not-null типа
inspection.verbose.nullability.and.emptiness.call=Заменить последовательные проверки вызовом ''{0}()''
inspection.verbose.nullability.and.emptiness.display.name=Подробная проверка на null и пустоту
inspection.warning.on.main.unused.parameter.migration.display.name=Неиспользуемый 'args' в 'main' начиная с 1.4
inspection.when.with.only.else.action.name=Упростить 'when' с единственной веткой 'else'
inspection.when.with.only.else.display.name='when' имеет только ветку 'else' и может быть упрощен
inspection.wrap.unary.operator.display.name=Неоднозначное использование унарного оператора с числовой константой
intention.add.import.alias.group.name=Добавить псевдоним импорта
intention.change.package.text=Изменить пакет
intention.convert.lambda.line=Преобразовать в {0,choice,0\#однострочную|1\#многострочную} лямбду
intention.create.test.dialog.kotlin=Kotlin
intention.error.cannot.create.class.message=Невозможно создать класс ''{0}''
intention.error.cannot.create.class.title=Не удалось создать класс
intention.extract.declarations.from.file.text=Извлечь объявление из текущего файла
intention.extract.declarations.from.file.text.details=Извлечь ''{0}'' {1, choice, 0\#|1\#и подклассы }из текущего файла
intention.flow.on.dispatchers.io=Flow на 'Dispatchers.IO'
intention.implement.abstract.method.command.name=Реализовать метод
intention.implement.abstract.method.searching.for.descendants.progress=Поиск наследников…
intention.name.specify.supertype=Указать супертип
intention.name.use.correct.parameter.name=Использовать правильное имя параметра
intention.switch.context.to.dispatchers.io=Переключить на контекст 'Dispatchers.IO'
intention.trailing.comma.custom.text={0,choice,0\#Включить|1\#Отключить} замыкающую запятую по умолчанию в форматовщике
intention.trailing.comma.text=Включить/отключить замыкающую запятую в форматовщике
intention.wrap.in.with.context=Обернуть вызов в 'withContext'
interface=Интерфейс
interface.member.dependency.required.by.interfaces=требуется {0,choice,1\#интерфейсом|2\#интерфейсами}
interface.should.be.external=Интерфейс должен быть external
internal.toggle.throwing.cached.pce.title=Внутреннее\: Переключить выброс кэшированного PCE
introduce.0.as.subject.0.when=Создать ''{0}'' как субъект ''when''
introduce.anonymous.parameter.fix.family.name=Создать анонимный параметр
introduce.backing.property=Создать backing-свойство
introduce.constant=Создать константу
introduce.import.alias=Создать псевдоним импорта
introduce.property=Создать свойство
introduce.type.parameter=Создать типовой параметр
introduce.type.parameter.to.declaration=Добавить типовой параметр в объявление
introduce.variable=Создать переменную
introduce.when.subject=Создать субъект 'when'
invert.if.condition=Инвертировать условие 'if'
it.s.prohibited.to.call.0.with.min.value.step.since.1.3=Запрещено вызывать {0} с шагом MIN_VALUE начиная с версии 1.3
iterate.over.0=Итерировать по ''{0}''
iterate.over.collection=Итерировать по коллекции
java.collections.static.method.call.should.be.replaced.with.kotlin.stdlib=Статический метод Java Collections следует заменить на Kotlin stdlib
java.map.foreach.method.call.should.be.replaced.with.kotlin.s.foreach=Метод Java Map.forEach следует заменить на forEach из Kotlin
join.declaration.and.assignment=Объединить объявление и присваивание
join.with.initializer.fix.text=Объединить с инициализатором
junit.static.methods=Статические методы JUnit
kdoc.comment.unresolved=Неразрешённый
kdoc.section.title.author=Авторы
kdoc.section.title.constructor=Конструктор
kdoc.section.title.parameters=Параметры
kdoc.section.title.properties=Свойства
kdoc.section.title.receiver=Получатель
kdoc.section.title.returns=Возвращает
kdoc.section.title.samples=Примеры
kdoc.section.title.see.also=См. также
kdoc.section.title.since=С версии
kdoc.section.title.suppress=Подавить
kdoc.section.title.throws=Выбрасывает
kotlin.call.chains.hints=Kotlin\: Показывать встроенные подсказки для цепочек вызовов
kotlin.compiler.configurable=Компилятор Kotlin
kotlin.dist.downloading.failed.group.name=Не удалось загрузить дистрибутив Kotlin
kotlin.external.compiler.updates.notification.group.name=Доступны обновления внешнего компилятора Kotlin
kotlin.jps.plugin.group.name=Плагин Kotlin JPS
kotlin.lambdas.hints=Kotlin\: Показывать встроенные подсказки для лямбд
kotlin.lambdas.hints.hints.lambda.receivers.parameters=Kotlin\: Показывать встроенные подсказки для неявных получателей и параметров
kotlin.lambdas.hints.hints.lambda.return=Kotlin\: Показывать встроенные подсказки для выражений return
kotlin.references.types.hints=Kotlin\: Показывать встроенные подсказки для типов
kotlin.references.types.hints.hints.type.function.parameter=Kotlin\: Показывать встроенные подсказки для типов параметров функций
kotlin.references.types.hints.hints.type.function.return=Kotlin\: Показывать встроенные подсказки для возвращаемых типов функций
kotlin.references.types.hints.hints.type.property=Kotlin\: Показывать встроенные подсказки для типов свойств
kotlin.references.types.hints.hints.type.variable=Kotlin\: Показывать встроенные подсказки для типов локальных переменных
kotlin.script.definitions.model.name.autoReloadScriptDependencies=Автоперезагрузка
kotlin.script.definitions.model.name.autoReloadScriptDependencies.description=Включите автоперезагрузку, если хотите автоматически загружать конфигурации скриптов при изменении файла
kotlin.script.definitions.model.name.is.enabled=Включено
kotlin.script.definitions.model.name.name=Имя
kotlin.script.definitions.model.name.pattern.extension=Шаблон/Расширение
kotlin.script.definitions.title=Управление определениями скриптов\:
kotlin.script.in.beta.stage=Kotlin Scripting сейчас находится в стадии Beta
kotlin.script.in.beta.stage.link=https\://kotlinlang.org/docs/components-stability.html\#stability-levels-explained
kotlin.script.in.project.sources=<html>Этот скрипт не должен находиться внутри корня исходников. После Kotlin 1.9 он будет игнорироваться при компиляции модуля.</html>
kotlin.script.in.project.sources.1.9=<html>Этот скрипт не должен находиться внутри корня исходников. Начиная с Kotlin 1.9 он игнорируется при компиляции модуля.</html>
kotlin.script.in.project.sources.allow=Разрешить…
kotlin.script.in.project.sources.hide=Скрыть
kotlin.script.in.project.sources.later=Решить позже
kotlin.script.in.project.sources.link=https\://youtrack.jetbrains.com/issue/KT-52735
kotlin.script.in.project.sources.move=Переместить в…
kotlin.script.lookup.definitions=Поиск определений скриптов Kotlin…
kotlin.script.sources.index=Индексировать
kotlin.script.sources.not.yet.indexed=Исходные файлы не были проиндексированы для уменьшения времени запуска проекта
kotlin.script.warning.more.info=Подробнее
kotlin.scripting.configurable=Скрипты Kotlin
kotlin.values.hints=Показывать встроенные подсказки для значений
kotlin.values.hints.kotlin.values.ranges=Kotlin\: Показывать встроенные подсказки для диапазонов
label.text.default.receiver.value=&Значение получателя по умолчанию\:
label.text.destination=&Назначение\:
label.text.destination.directory=&Целевая директория\:
label.text.file=&Файл\:
label.text.file.name=&Имя файла\:
label.text.introduce.as=&Создать как\:
label.text.move.expect.actual.counterparts=&Переместить expect/actual пары
label.text.name=&Имя\:
label.text.package=П&акет\:
label.text.package.name=Имя паке&та\:
label.text.receiver.type=&Тип получателя\:
label.text.source.sets=Source sets\:
label.text.target.file.name=Имя целевого файла\:
label.text.to.class=В класс\:
label.text.to.file=В &файл\:
label.text.to.object=В объект\:
label.text.to.package=В п&акет\:
label.text.type=&Тип\:
label.text.visibility=&Видимость\:
lambda.argument.0.be.moved.out=Lambda-аргумент {0,choice,0\#может|1\#должен} быть вынесен из скобок
leaking.this.in.constructor.of.enum.class.0.with.overridable.members=Утечка ''this'' в конструкторе enum класса {0} (с переопределяемыми членами)
leaking.this.in.constructor.of.non.final.class.0=Утечка ''this'' в конструкторе не-final класса {0}
let.0.1=Пусть {0} {1}
let.type.implement.interface=Реализовать интерфейс для типа
lift.assignment.out.fix.text.0=Вынести присваивание из ''{0}''
lift.assignment.out.of.try.expression=Вынести присваивание из выражения 'try'
lift.function.call.out.of.if=Вынести вызов функции из 'if'
lift.function.call.out.of.when=Вынести вызов функции из 'when'
lift.return.out.fix.text.0=Вынести return из ''{0}''
lift.return.out.of.if.expression=Вынести return из выражения 'if'
listbox.import.package=Пакет
listbox.import.with.subpackages=С подпакетами
livetemplate.description.anonymous=Анонимный класс
livetemplate.description.closure=Замыкание (функция без имени)
livetemplate.description.exfun=Функция-расширение
livetemplate.description.exval=Свойство-расширение только для чтения
livetemplate.description.exvar=Свойство-расширение для чтения и записи
livetemplate.description.fun0=Функция без параметров
livetemplate.description.fun1=Функция с одним параметром
livetemplate.description.fun2=Функция с двумя параметрами
livetemplate.description.ifn=Вставляет выражение 'if null'
livetemplate.description.inn=Вставляет выражение 'if not null'
livetemplate.description.interface=Интерфейс
livetemplate.description.iter=Итерация по элементам iterable (цикл for-in)
livetemplate.description.main=функция main()
livetemplate.description.maina=функция main(args)
livetemplate.description.singleton=Синглтон
livetemplate.description.soutp=Выводит имена и значения параметров функции в System.out
livetemplate.description.void=Функция, не возвращающая значение
local.variable=Локальная переменная
logger.initialized.with.foreign.class=Логгер инициализован чужим классом ''{0}''
looking.for.usages.and.conflicts=Поиск использований и конфликтов…
looking.for.usages.in.java.files=Поиск использований в Java файлах…
loop.can.be.replaced.with.stdlib.operations=Цикл может быть заменен операциями stdlib
loop.parameter.0.is.unused=Параметр цикла ''{0}'' не используется
loop.to.call.fix.family.name=Заменить операциями stdlib
loop.to.call.fix.family.name2=Заменить операциями stdlib с использованием 'asSequence()'
make.0=Сделать {0}
make.0.1=Сделать ''{0}'' {1}
make.0.1.explicitly=Явно сделать ''{0}'' {1}
make.0.an.annotation.class=Сделать ''{0}'' аннотацией
make.0.explicitly=Явно сделать {0}
make.0.in.1.open=Сделать ''{0}'' в {1} открытым
make.0.not.1=Сделать {0} не {1}
make.class.an.annotation.class=Сделать класс аннотацией
make.constructor.parameter.a.property.0=Сделать параметр конструктора свойством{0}
make.member.static.quickfix=Сделать ''{0}'' статическим
make.not.nullable=Сделать not-nullable
make.open=Сделать 'open'
make.open.fix.text=Сделать класс открытым
make.primary.constructor.0=Сделать основным конструктором {0}
make.private.and.0.1=Сделать private и {0} ''{1}''
make.private.fix.text=Сделать private
make.type.parameter.reified.and.function.inline=Сделать параметр типа reified и функцию inline
making.member.static=Делаем член статическим…
map.get.with.not.null.assertion.operator='map.get()' с оператором проверки на not-null '(\!\!)'
map.put.should.be.converted.to.assignment=map.put() следует преобразовать в присваивание
mark.as.deprecated.level.deprecationlevel.hidden=Пометить как '@Deprecated(..., level \= DeprecationLevel.HIDDEN)'
max.functions.to.visit=Максимальное количество функций для обхода
maximum.count.of.applied.refactoring.before.validity.check=Максимальное количество применённых рефакторингов перед проверкой валидности
may.contain.only.letters.and.digits=может содержать только буквы и цифры
may.contain.only.letters.digits.or.underscores=может содержать только буквы, цифры или подчеркивания
member.info.abstract.0=abstract {0}
member.info.companion.0=companion {0}
merge.else.if=Объединить 'else if'
merge.if.s=Объединить 'if'
message.change.signature.is.not.applicable.to.dynamically.invoked.functions="Изменение сигнатуры" не применимо к динамически вызываемым функциям
message.do.not.show.for.local.variables.in.future=Не показывать для локальных переменных в будущем
message.text.property.receiver.type.cannot.be.resolved=Не удаётся разрешить тип получателя свойства ''{0}''.\nПродолжить?
message.text.property.type.cannot.be.resolved=Не удаётся разрешить тип свойства ''{0}''.\nПродолжить?
message.text.return.type.cannot.be.resolved=Не удаётся разрешить тип возвращаемого значения ''{0}''.\nПродолжить?
message.type.for.cannot.be.resolved=Не удаётся разрешить тип ''{0}'' для {1}.\nПродолжить?
methods.are.absent.in.coroutines.class.since.1.3=Методы отсутствуют в классе корутин начиная с версии 1.3
microservices.url.path.inlay.hints=Kotlin\: Показывать встроенные подсказки для URL-путей
might.be.const=Может быть 'const'
migrate.type.parameter.list.syntax=Мигрировать синтаксис списка параметров типа
migrate.unsupported.yield.syntax=Мигрировать неподдерживаемый синтаксис yield
minimal.line.count=Минимальное количество строк
missing.documentation=Отсутствует документация
modifiers.should.follow.annotations=Модификаторы должны следовать за аннотациями
move.annotation.to.receiver.type=Переместить аннотацию к типу получателя
move.else.branch.to.the.end=Переместить ветку else в конец
move.lambda.argument.into.parentheses=Поместить lambda-аргумент в скобки
move.lambda.argument.out.of.parentheses=Вынести lambda-аргумент из скобок
move.members.from=Переместить члены из\:
move.out.of.companion.object=Вынести из companion object
move.refactoring.error.text.cannot.perform.refactoring.since.the.following.files.already.exist=Невозможно выполнить рефакторинг, так как следующие файлы уже существуют\:\n\n
move.refactoring.test=Тест рефакторинга перемещения
move.refactoring.testing=Тестование рефакторинга перемещения
move.reference.into.parentheses=Переместить ссылку в скобки
move.to.class.body=Переместить в тело класса
move.to.companion.object=Переместить в companion object
move.to.companion.object.command=Переместить в companion object
move.to.constructor=Переместить в конструктор
move.to.constructor.parameters=Переместить в параметры конструктора
move.to.top.level=Переместить на верхний уровень
move.type.parameter.constraint.to.where.clause=Переместить ограничение параметра типа в условие 'where'
move.unary.operator.to.previous.line.fix.text=Переместить унарный оператор на предыдущую строку
move.variable.declaration.into.when=Переместить объявление переменной в 'when'
moving.to.companion.object=Перемещение в companion object…
name=Имя [&N]\:
name.extract.interface=Извлечь интерфейс
name.introduce.import.alias=Создать псевдоним импорта
name.introduce.lambda.parameter=Создать параметр лямбды
name.introduce.parameter1=Создать параметр
name.introduce.type.alias=Создать псевдоним типа
name.specify.supertype.command.title=Указать супертип
naming.convention.will.be.violated.after.rename=После переименования будут нарушены соглашения об именовании
negated.operation.can.be.simplified=Отрицание можно упростить
nested.1.call.in.0.could.be.simplified.to.2=Вложенный вызов ''{1}'' в ''{0}'' можно упростить до {2}
no.actual.for.expect.declaration=Нет actual для expect-объявления в модуле(ях)\: {0}
non.canonical.modifiers.order=Нестандартный порядок модификаторов
non.external.classifier.extending.state.or.props.name=Не-external классификатор, расширяющий State или Props
not.found.in.0.files=Не найдено в {0} файле(ах)
nothing.to.do=Нечего выполнять
notification.navigation.to.overriding.classes=Навигация к переопределяющим классам невозможна во время обновления индекса
notification.text.kotlin.js.compiler.body=Используйте новый компилятор Kotlin/JS IR для уменьшения размера бандла вашего приложения и автоматической генерации TypeScript-определений (d.ts).
notification.text.kotlin.js.compiler.learn.more=Узнать больше
notification.text.kotlin.js.compiler.link=https\://kotl.in/jsirstable
notification.text.kotlin.js.compiler.title=Kotlin/JS IR стабилен в версиях 1.8.0 и выше\!
null.checks.replaceable.with.safe.calls=Проверки на null можно заменить безопасными вызовами
null.checks.to.safe.call.check.fix.text=Заменить цепочку проверок на null безопасными вызовами
number.of.attempts.then.files.in.project.0=Количество попыток > количества файлов в проекте, {0}
object.0=Объект "{0}"
object.or.top.level.property=Объект или свойство верхнего уровня
object.private.property=Приватное свойство объекта
object.should.be.external.interface=Объект должен быть external-интерфейсом
obsolete.coroutine.usage.fix.family.name=Исправить использование экспериментальных корутин
obsolete.coroutine.usage.in.whole.fix.family.name=Исправить использование экспериментальных корутин в проекте
obsolete.kotlin.js.packages.usage.in.whole.fix.family.name=Исправить использование пакетов 'kotlin.dom' и 'kotlin.browser' в проекте
obsolete.package.usage.fix.family.name=Исправить использование пакета ''{0}''
one.line.return=однострочный return
open.moved.members.in.editor=Открыть перемещенные члены в редакторе
open.moved.method.in.editor=Открыть перемещенный метод в редакторе
optimize.imports=Оптимизовать импорты
optimize.imports.collect.unused.imports=Сбор неиспользуемых импортов
optimize.imports.task.removing.redundant.imports=Удаление избыточных импортов
optionally.expected.annotation.has.no.actual.annotation.in.module.0.for.platform.1=Опционально ожидаемая аннотация не имеет actual-аннотации в модуле {0} для платформы {1}
overridden.marker.implementation=Реализуется в\:
overridden.marker.implementations.choose.implementation.find.usages=Переопределяющие свойства {0}
overridden.marker.implementations.choose.implementation.title=Выберите реализацию {0}
overridden.marker.implementations.multiple=Имеет реализации
overridden.marker.overrides=Переопределяется в\:
overridden.marker.overrides.choose.implementation.find.usages=Super-реализации {0}
overridden.marker.overrides.choose.implementation.title=Выберите super-реализацию {0}
overridden.marker.overrides.multiple=Переопределяется в подклассах
override.declaration.choose.to.delete=Выберите объявления для удаления.
override.declaration.delete.multiple.parameters={0} является частью иерархии методов. Удалить несколько параметров?
override.declaration.member=Член
override.declaration.unused.overriding.methods.description=Есть неиспользуемые члены, которые переопределяют удаляемые методы.
override.declaration.unused.overriding.methods.title=Неиспользуемые переопределяющие члены
override.declaration.x.implements.y={0} реализует {1}.
override.declaration.x.in.y={0} в {1}
override.declaration.x.overrides.y.in.class.list={0} переопределяет объявления в следующих классах/интерфейсах\: {1} Вы хотите {2} базовые объявления?
package.0.already.contains.1=Пакет ''{0}'' уже содержит {1}
package.name=Имя пакета
package.usages.are.obsolete.since.1.4=Использование пакета ''{0}'' устарело с версии 1.4
parameter.0=Параметр "{0}"
parameter.hints.old=Kotlin\: Показывать встроенные подсказки для параметров
parameter.name.is.invalid=Недопустимое имя параметра ''{0}''
parameter.name.prompt=Имя параметра [&M]\:
parameter.type.is.invalid=Недопустимый тип параметра ''{0}''
parameter.types.are.not.denotable=Невозможно извлечь метод, так как следующие типы не могут быть обозначены в целевой области видимости\:
parameter.used.in.declaration.body.warning=''{0}'' используется в теле объявления
parentheses.should.be.removed=Скобки следует удалить
pass.outer.class.instance.as.parameter=Передавать экземпляр внешнего класса как параметр [&O]
perform.refactoring=Выполнить рефакторинг…
placeholder.count.matches.argument.count.fewer.problem.descriptor=Предоставлено меньше аргументов ({0}), чем указано заполнителей ({1}) \#loc
placeholder.count.matches.argument.count.more.problem.descriptor=Предоставлено больше аргументов ({0}), чем указано заполнителей ({1}) \#loc
popup.title.choose.supertype=Выберите супертип
popup.title.elements=Элементы
popup.title.expressions=Выражения
popup.title.types=Типы
predefined.configuration.all.methods.of.the.class=Все методы класса
predefined.configuration.all.vars.of.the.class=Все var класса
predefined.configuration.all.vars.of.the.object=Все var объекта
predefined.configuration.also.match.vals=Искать и var, и val
predefined.configuration.annotations=Аннотации
predefined.configuration.anonymous.class=Анонимный класс
predefined.configuration.array.access=Доступ к массиву
predefined.configuration.assert.not.null=Операторы проверки на not-null
predefined.configuration.assignments=Присваивания
predefined.configuration.casts=Приведения типов
predefined.configuration.class.annotation=Аннотированные классы
predefined.configuration.comments.containing.word=Комментарии, содержащие заданное слово
predefined.configuration.companion.object.method.calls=Вызовы методов из companion object
predefined.configuration.do.while=Циклы do...while
predefined.configuration.elvis=Операторы Elvis
predefined.configuration.for=Циклы For
predefined.configuration.function.annotation=Аннотированные функции
predefined.configuration.function.explicit.inferred.type=Явный и выведенный тип
predefined.configuration.function.signature=Сигнатура функции
predefined.configuration.ifs=Операторы If
predefined.configuration.instance=Экземпляры
predefined.configuration.kdoc.tag=Теги KDoc
predefined.configuration.lambda=Lambda-выражения
predefined.configuration.method.calls=Вызовы методов
predefined.configuration.object.companion.object=Объект и companion object
predefined.configuration.properties.getter=Свойства с явным getter
predefined.configuration.safe.call.operator=Операторы безопасного вызова
predefined.configuration.string.literals=Строковые литералы
predefined.configuration.strings=Строки
predefined.configuration.strings.with.long.template=Строки с длинным шаблоном
predefined.configuration.trys=Блоки Try
predefined.configuration.vars.of.given.type=Переменные var заданного типа
predefined.configuration.when=Выражения when
predefined.configuration.while=Циклы While
premature.end.of.template=Преждевременное окончание шаблона
preparing.move.descriptor=Подготовка дескриптора перемещения
presentation.text.for.receiver.in.container.paren=(для {0} в {1})
presentation.text.for.receiver.in.container.paren.no.brackets=для {0} в {1}
presentation.text.in.container={0} ({1} внутри)
presentation.text.in.container.paren=(в {0})
presentation.text.in.container.paren.no.brackets=в {0}
presentation.text.object.in.container=объект в {0}
presentation.text.paren=({0})
presentation.text.paren.no.brackets={0}
print.should.be.replaced.with.logging.display.name=Вызов 'print()' или 'println()'
private.data.class.constructor.is.exposed.via.the.generated.copy.method=Приватный первичный конструктор доступен через сгенерированный метод 'copy()' класса 'data'.
private.property=Приватное свойство
progress.finding.implicit.nothing.s=Поиск неявных nothing
progress.looking.up.add.annotation.usage=Поиск использования аннотации…
progress.looking.up.sealed.subclass.usage=Поиск использования sealed подкласса…
progress.title.analyze.extraction.data=Анализ данных извлечения…
progress.title.calculate.occurrences=Подсчет вхождений…
progress.title.calculating.type=Вычисление типа…
progress.title.check.for.conflicts=Проверка конфликтов…
progress.title.collect.hierarchy=Сбор иерархии ''{0}''…
progress.title.collect.members.to.generate=Сбор членов…
progress.title.converting.to.if.then.else.expression=Преобразование в выражение if-then-else…
progress.title.introducing.value.for.condition=Введение значения для условия…
progress.title.searching.for.expected.actual=Поиск expect/actual…
project.view.class.error.name=имя не указано
project.view.class.initializer=инициализатор класса
project.view.expression=выражение
property=Свойство
property.0=Свойство "{0}"
property.has.an.actual.declaration.in.the.class.constructor=Свойство имеет фактическое объявление в конструкторе класса
property.in.external.interface.should.be.var=Свойство в external интерфейсе должно быть var
property.is.explicitly.assigned.to.parameter.0.can=Свойство явно присвоено параметру {0}, поэтому может быть объявлено непосредственно в конструкторе
property.overloaded.in.child.class.constructor=Свойство перегружено в конструкторе дочернего класса
protected.visibility.is.effectively.private.in.a.final.class=Видимость 'protected' фактически является 'private' в final классе
provide.return.value=Укажите возвращаемое значение
put.arguments.on.one.line=Разместить аргументы на одной строке
put.arguments.on.separate.lines=Разместить аргументы на отдельных строках
put.calls.on.separate.lines=Разместить вызовы на отдельных строках
put.expressions.on.separate.lines=Разместить выражения на отдельных строках
put.parameters.on.one.line=Разместить параметры на одной строке
put.parameters.on.separate.lines=Разместить параметры на отдельных строках
quick.doc.no.documentation=Документация отсутствует
quick.doc.section.deprecated=Устарело\:
quick.doc.section.java.declaration=Java объявление\:
quick.doc.section.replace.with=Заменить на\:
quick.doc.text.enum.ordinal=Порядковый номер константы перечисления\: {0}
quick.doc.text.lateinit='lateinit' позволяет инициализовать <a href\="https\://kotlinlang.org/docs/reference/properties.html\#late-initialized-properties-and-variables">not-null свойство вне конструктора</a>
quick.doc.text.tailrec='tailrec' помечает функцию как <a href\="https\://kotlinlang.org/docs/reference/functions.html\#tail-recursive-functions">хвостовую рекурсию</a> (позволяя компилятору заменить рекурсию итерацией)
quickFix.add.property.text=Добавить свойство ''{0}{1}'' ''{2}'' в ''{3}''
quickfix.add.property.familyName=Добавить свойство
quickfix.text.suffix.may.change.semantics=\ (может изменить семантику)
random.seed=Случайное начальное значение
range.could.be.replaced.with.indices.call=Диапазон может быть заменен вызовом '.indices'
recursive.equals.call=Рекурсивный вызов equals
recursive.property.accessor=Рекурсивный аксессор свойства
recursive.synthetic.property.accessor=Рекурсивный синтетический аксессор свойства
redundant.0=Избыточная ''@{0}''
redundant.0.call=Избыточный вызов ''{0}''
redundant.0.modifier=Избыточный модификатор ''{0}''
redundant.async.call.may.be.reduced.to.0=Избыточный вызов ''async'' может быть сокращен до ''{0}''
redundant.companion.reference=Избыточная ссылка на Companion
redundant.constructor.keyword=Избыточное ключевое слово 'constructor'
redundant.curly.braces.in.string.template=Избыточные фигурные скобки в строковом шаблоне
redundant.double.negation=Избыточное двойное отрицание
redundant.else=Избыточный 'else'
redundant.empty.class.body=Избыточное пустое тело класса
redundant.empty.initializer.block=Избыточный пустой блок инициализации
redundant.enum.constructor.invocation=Избыточный вызов конструктора enum
redundant.explicit.this=Избыточное явное this
redundant.getter=Избыточный getter
redundant.getter.body=Избыточное тело getter
redundant.if.option.ignore.chained=Игнорировать цепочки операторов 'if'
redundant.if.statement=Избыточный оператор 'if'
redundant.if.statement.analyzing.type=Анализ типа условия…
redundant.lambda.arrow=Избыточная стрелка lambda
redundant.let.call.could.be.removed=Избыточный вызов 'let' может быть удален
redundant.modality.modifier=Избыточный модификатор модальности
redundant.override.fix.text=Удалить избыточный переопределяющий метод
redundant.overriding.method=Избыточный переопределяющий метод
redundant.qualifier.name=Избыточное имя квалификатора
redundant.qualifier.unnecessary.non.direct.parent.class.qualifier=Ненужные квалификаторы непрямых родительских классов
redundant.runcatching.call.may.be.reduced.to.0=Избыточный вызов ''runCatching'' может быть сокращен до ''{0}''
redundant.sam.constructor=Избыточный SAM конструктор
redundant.sam.constructors=Избыточные SAM конструкторы
redundant.semicolon=Избыточная точка с запятой
redundant.setter=Избыточный сеттер
redundant.setter.body=Избыточное тело сеттера
redundant.setter.parameter.type=Избыточный тип параметра сеттера
redundant.string.template=Избыточный строковый шаблон
redundant.suspend.modifier=Избыточный модификатор 'suspend'
redundant.tostring.call.in.string.template=Избыточный вызов 'toString()' в строковом шаблоне
redundant.type.checks.for.object=Избыточные проверки типа для объекта
redundant.unit=Избыточный 'Unit'
redundant.unit.return.type=Избыточный возвращаемый тип 'Unit'
redundant.visibility.modifier=Избыточный модификатор видимости
refactoring.cannot.be.applied.no.sources.attached=Рефакторинг "{0}" не может быть применен\: не прикреплены исходники
refactoring.cannot.be.applied.to.abstract.declaration=Рефакторинг {0} не может быть применен к abstract объявлению
refactoring.cannot.be.applied.to.anonymous.function.without.invocation=Рефакторинг {0} не может быть применен к анонимной функции без вызова
refactoring.cannot.be.applied.to.expect.declaration=Рефакторинг {0} не может быть применен к expect объявлению
refactoring.cannot.be.applied.to.lambda.expression.without.invocation=Рефакторинг {0} не может быть применен к лямбда-выражению без вызова
refactoring.extract.to.separate.file.text=Извлечь в отдельный файл
refactoring.move.non.kotlin.file=Целью должен быть файл Kotlin
refactoring.the.function.cannot.be.converted.to.anonymous.function=Функция не может быть преобразована в анонимную функцию
refactoring.the.function.not.found=Функция не найдена
refactoring.the.invocation.cannot.be.resolved=Вызов не может быть разрешен
remove.0=Удалить ''.{0}''
remove.0.from.parameter=Удалить ''{0}'' из параметра
remove.0.from.property=Удалить {0} из свойства
remove.0.modifier=Удалить модификатор ''{0}''
remove.0.variance.from.1=Удалить вариантность ''{0}'' из ''{1}''
remove.all.argument.names=Удалить все имена аргументов
remove.annotation.doesnt.have.any.effect=Удалить аннотацию, так как она не имеет эффекта. См.\: https\://youtrack.jetbrains.com/issue/KT-48141
remove.argument.name=Удалить имя аргумента
remove.as.dynamic.call.fix.text=Удалить вызов 'asDynamic'
remove.assequence.call.fix.text=Удалить вызов 'asSequence'
remove.braces=Удалить фигурные скобки
remove.braces.fix.text=Удалить фигурные скобки
remove.braces.from.0.statement=Удалить фигурные скобки из оператора ''{0}''
remove.braces.from.all.branches=Удалить фигурные скобки из всех веток
remove.braces.from.if.all.statements=Удалить фигурные скобки из всех операторов 'if'
remove.braces.from.when.all.entries=Удалить фигурные скобки из всех элементов 'when'
remove.braces.from.when.entry=Удалить фигурные скобки из элемента 'when'
remove.branch=Удалить ветку
remove.condition=Удалить условие
remove.conflicting.import.0=Удалить конфликтующий импорт {0}
remove.constructor.call=Удалить вызов конструктора
remove.conversion.from.kclass.to.class=Удалить преобразование из 'KClass' в 'Class'
remove.curly.braces=Удалить фигурные скобки
remove.default.parameter.value=Удалить значение параметра по умолчанию
remove.deprecated.symbol.import=Удалить импорт устаревшего символа
remove.element=Удалить элемент
remove.else=Удалить else в ''{0}''
remove.else.branch=Удалить ветку else
remove.empty.constructor.body=Удалить пустое тело конструктора
remove.empty.parentheses.from.annotation.entry.fix.text=Удалить ненужные скобки
remove.empty.primary.constructor=Удалить пустой первичный конструктор
remove.enum.constructor.invocation.fix.text=Удалить вызов конструктора enum
remove.explicit.lambda.parameter.types.may.break.code=Удалить явные типы параметров лямбды (может нарушить код)
remove.explicit.supertype.qualification=Удалить явную квалификацию супертипа
remove.explicit.type.arguments=Удалить явные аргументы типа
remove.explicit.type.specification=Удалить явное указание типа
remove.explicit.type.specification.from.0=Удалить явное указание типа из ''{0}''
remove.expression=Удалить ''{0}''
remove.expression.target=Удалить цель выражения
remove.extension.function.type.annotation=Удалить неприменимую аннотацию @ExtensionFunctionType
remove.final.upper.bound=Удалить финальную верхнюю границу
remove.fix.text=Удалить выражение
remove.from.annotation.argument=Удалить @ из аргумента аннотации
remove.function.body=Удалить тело функции
remove.identifier.from.anonymous.function=Удалить идентификатор из анонимной функции
remove.indices.in.for.loop=Удалить индексы в цикле 'for'
remove.initializer.block.fix.text=Удалить блок инициализатора
remove.jvmfield.annotation=Удалить аннотацию @JvmField
remove.jvmoverloads.annotation=Удалить аннотацию @JvmOverloads
remove.labeled.return.from.last.expression.in.a.lambda=Удалить помеченный return из последнего выражения в лямбде
remove.let.call=Удалить вызов 'let'
remove.modifier=Удалить модификатор
remove.modifier.fix=Сделать ''{0}'' не {1}
remove.modifier.fix.family=Сделать не {0}
remove.parameter.0=Удалить параметр ''{0}''
remove.parts.from.property=Удалить части из свойства
remove.redundant=Удалить избыточный '?'
remove.redundant.0.modifier=Удалить избыточный модификатор ''{0}''
remove.redundant.assignment=Удалить избыточное присваивание
remove.redundant.backticks.quick.fix.text=Удалить избыточные обратные кавычки
remove.redundant.call.fix.text=Удалить избыточный вызов
remove.redundant.calls.of.the.conversion.method=Удалить избыточные вызовы метода преобразования
remove.redundant.companion.reference.fix.text=Удалить избыточную ссылку на Companion
remove.redundant.constructor.keyword.fix.text=Удалить избыточное ключевое слово 'constructor'
remove.redundant.else.fix.text=Удалить избыточный 'else'
remove.redundant.elvis.return.null.text=Удалить избыточное '?\: return null'
remove.redundant.empty.class.body=Удалить избыточное пустое тело класса
remove.redundant.getter.body.fix.text=Удалить избыточное тело геттера
remove.redundant.getter.fix.text=Удалить избыточный геттер
remove.redundant.if.expression=Удалить избыточное выражение 'if'
remove.redundant.if.may.change.semantics.with.floating.point.types=Удалить избыточный оператор 'if' (может изменить семантику с типами с плавающей точкой)
remove.redundant.if.text=Удалить избыточный оператор 'if'
remove.redundant.initializer=Удалить избыточный инициализатор
remove.redundant.label=Удалить избыточную метку
remove.redundant.modality.modifier=Удалить избыточный модификатор модальности
remove.redundant.qualifier.name.quick.fix.text=Удалить избыточное имя квалификатора
remove.redundant.sam.constructor=Удалить избыточный SAM-конструктор
remove.redundant.sam.constructors=Удалить избыточные SAM-конструкторы
remove.redundant.setter.body.fix.text=Удалить избыточное тело сеттера
remove.redundant.setter.fix.text=Удалить избыточный сеттер
remove.redundant.spread.operator.quickfix.text=Удалить избыточный оператор spread
remove.redundant.unit.fix.text=Удалить избыточный 'Unit'
remove.redundant.visibility.modifier=Удалить избыточный модификатор видимости
remove.redundant.with.fix.text=Удалить избыточный вызов 'with'
remove.require.not.null.call.fix.text=Удалить вызов ''{0}''
remove.return.0=Удалить return@{0}
remove.return.label.fix.family=Удалить избыточную метку
remove.return.label.fix.text=Удалить избыточную метку ''@{0}''
remove.self.assignment.fix.text=Удалить самоприсваивание
remove.single.expression.string.template=Удалить строковый шаблон с одним выражением
remove.single.lambda.parameter.declaration=Удалить объявление единственного параметра лямбды
remove.star=Удалить '*'
remove.supertype=Удалить супертип
remove.to.string.fix.text=Удалить вызов 'toString()'
remove.token.from.function.declaration=Удалить токен '\=' из объявления функции
remove.type.arguments=Удалить аргументы типа
remove.type.parameters=Удалить параметры типа
remove.unary.operator.fix.text=Удалить неиспользуемый унарный оператор
remove.underscores=Удалить подчеркивания
remove.unnecessary.parentheses=Удалить ненужные скобки
remove.unnecessary.parentheses.from.function.call.with.lambda=Удалить ненужные скобки из вызова функции с лямбдой
remove.use.site.get.target=Удалить 'get\:' чтобы аннотация вступила в силу. (изменит семантику. См.\: https\://youtrack.jetbrains.com/issue/KT-48141)
remove.useless=Удалить ненужный '?'
remove.useless.cast=Удалить ненужное приведение типа
remove.useless.elvis.operator=Удалить ненужный оператор elvis
remove.useless.is.check=Удалить ненужную проверку is
remove.val.or.var.from.parameter=Удалить 'val' или 'var' из параметра
remove.var.keyword.text=Удалить 'var'
remove.variable=Удалить переменную
remove.variable.0=Удалить переменную ''{0}''
rename.base.0=Переименовать базовые {0,choice,1\#функцию|2\#свойство|3\#член|4\#метод|11\#функции|12\#свойства|13\#члены|14\#методы}
rename.class.to.0=Переименовать класс в {0}
rename.class.to.containing.file.name=Переименовать класс по имени содержащего файла
rename.declaration.title.0.implements.1.2.of.3={0} {1,choice,1\#реализует|2\#переопределяет} {2} из {3}
rename.file=Переименовать файл
rename.file.0=Переименовать файл в ''{0}''
rename.file.to.0.1=Переименовать файл в {0}.{1}
rename.file.to.match.top.level.class.name=Переименовать файл в соответствии с именем класса верхнего уровня
rename.identifier.fix.text=Переименовать
rename.only.current.0=Переименовать только текущую {0,choice,1\#функцию|2\#свойство}
rename.parameter.to.match.overridden.method=Переименовать параметр в соответствии с переопределённым методом
rename.searching.for.all.overrides=Поиск всех переопределений
rename.searching.for.super.declaration=Поиск самого глубокого super-объявления
rename.to.0=Переименовать в ''{0}''
rename.to.01=Переименовать в {0}
rename.to.fix.text=Переименовать в ''{0}''
rename.to.underscore=Переименовать в _
rename.useless.call.fix.text=Изменить вызов на ''{0}''
reorder.parameters=Изменить порядок параметров
reorder.parameters.command=Изменить порядок параметров
repair.actual.members=Исправить актуальные члены
replace.&&.with.||=Заменить '&&' на '||'
replace.0.call.with.indexing.operator=Заменить вызов ''{0}'' оператором индексации
replace.0.name.with.spaces=Заменить имя {0} пробелами
replace.0.with=Заменить ''{0}()'' на ''+\='
replace.0.with.1=Заменить ''{0}'' на ''{1}''
replace.0.with.1.and.vice.versa=Заменить ''{0}'' на ''{1}'' и наоборот
replace.and.with.when.guard=Заменить '&&' на 'if'
replace.annotation=Заменить аннотацию
replace.annotation.with.0=Заменить аннотацию на {0}
replace.array.of.boxed.with.array.of.primitive=Заменить массив упакованных значений массивом примитивов
replace.assert.boolean.with.assert.equality=Заменить логическое утверждение утверждением равенства
replace.assert.with.operator=Заменить утверждение оператором
replace.assignment.with.if.expression=Заменить присваивание выражением 'if'
replace.assignment.with.when.expression=Заменить присваивание выражением 'when'
replace.by.0=Заменить на ''{0}''
replace.by.reconstructed.type=Заменить реконструированным типом
replace.call.with.unary.operator=Заменить вызов унарным оператором
replace.cast.with.call.to.to.0=Заменить приведение типа вызовом ''to{0}()''
replace.cast.with.primitive.conversion.method=Заменить приведение типа методом преобразования примитива
replace.collection.count.with.size.quick.fix.text=Заменить 'count' на 'size'
replace.contains.call.with.in.operator=Заменить вызов 'contains' оператором 'in'
replace.deprecated.symbol.usage=Заменить использование устаревшего символа
replace.deprecated.symbol.usage.in.whole.project=Заменить использование устаревшего символа во всем проекте
replace.diagnostic.name.fix.family.name=Заменить имя диагностики
replace.diagnostic.name.fix.text=Заменить {0} на {1}
replace.elvis.expression.with.if.expression=Заменить выражение elvis выражением 'if'
replace.explicit.lambda.parameter.with.it=Заменить явный параметр лямбды на 'it'
replace.explicit.parameter.0.with.it=Заменить явный параметр ''{0}'' на ''it''
replace.expression.with.if.expression=Заменить выражение '\!\!' выражением 'if'
replace.function.call.with.if=Заменить вызов функции на 'if'
replace.function.call.with.the.opposite=Заменить вызов функции на противоположный
replace.function.call.with.when=Заменить вызов функции на 'when'
replace.get.or.set.call.with.indexing.operator=Заменить вызов get или set оператором индексации
replace.guard.clause.with.kotlin.s.function.call=Заменить guard-выражение вызовом функции Kotlin
replace.if.expression.with.elvis.expression=Заменить выражение 'if' выражением elvis
replace.if.expression.with.return=Заменить выражение 'if' оператором return
replace.if.expression.with.safe.access.expression=Заменить выражение 'if' выражением безопасного доступа
replace.if.expression.with.safe.cast.expression=Заменить выражение 'if' выражением безопасного приведения типа
replace.if.with.elvis.operator=Заменить 'if' оператором elvis
replace.if.with.when=Заменить 'if' на 'when'
replace.index.loop.with.collection.loop.quick.fix.text=Заменить на цикл по элементам
replace.infix.call.with.ordinary.call=Заменить инфиксный вызов обычным вызовом
replace.int.range.end.inclusive.with.last.quick.fix.text=Заменить 'endInclusive' на 'last'
replace.int.range.start.with.first.quick.fix.text=Заменить 'start' на 'first'
replace.invalid.positioned.arguments.for.annotation=Заменить некорректные позиционные аргументы аннотации
replace.invoke.with.direct.call=Заменить 'invoke' на прямой вызов
replace.it.with.explicit.parameter=Заменить 'it' на явный параметр
replace.jvmfield.with.const=Заменить '@JvmField' на 'const'
replace.kotlin.options.with.compiler.options=Заменить 'kotlinOptions' на 'compilerOptions'
replace.manual.range.with.indices.call.quick.fix.text=Заменить на indices
replace.modifier=Заменить модификатор
replace.negated.0.operation.with.1=Заменить отрицание операции ''{0}'' на ''{1}''
replace.negated.0.operation.with.1.may.change.semantics.with.floating.point.types=Заменить отрицание операции ''{0}'' на ''{1}'' (может изменить семантику для чисел с плавающей точкой)
replace.negated.0.with.1=Заменить отрицание ''{0}'' на ''{1}''
replace.overloaded.operator.with.function.call=Заменить перегруженный оператор на вызов функции
replace.property.initializer.with.if.expression=Заменить инициализатор свойства на выражение 'if'
replace.property.initializer.with.when.expression=Заменить инициализатор свойства на выражение 'when'
replace.return.with.if.expression=Заменить return на выражение 'if'
replace.return.with.when.expression=Заменить return на выражение 'when'
replace.safe.access.expression.with.if.expression=Заменить безопасный доступ на выражение 'if'
replace.scope.function.with.safe.call=Заменить функцию области видимости на безопасный вызов (?.)
replace.size.check.with.0=Заменить проверку размера на ''{0}''
replace.size.check.with.isnotempty=Заменить проверку размера на 'isNotEmpty'
replace.size.zero.check.with.isempty=Заменить проверку на нулевой размер на 'isEmpty'
replace.substring.call.with.droplast.call=Заменить вызов 'substring' на вызов 'dropLast'
replace.substring.call.with.indexing.operation.call=Заменить вызов 'substring' на операцию индексирования
replace.substring.call.with.substringafter.call=Заменить вызов 'substring' на вызов 'substringAfter'
replace.substring.call.with.substringbefore.call=Заменить вызов 'substring' на вызов 'substringBefore'
replace.substring.call.with.take.call=Заменить вызов 'substring' на вызов 'take'
replace.to.with.infix.form.quickfix.text=Заменить 'to' на инфиксную форму
replace.tostring.with.string.template=Заменить 'toString' на строковый шаблон
replace.total.order.equality.with.ieee.754.equality=Заменить полное равенство на равенство IEEE 754
replace.usages.of.0.in.whole.project=Заменить использования ''{0}'' во всем проекте
replace.when.with.if=Заменить 'when' на 'if'
replace.with.0=Заменить на ''{0}''
replace.with.0.1.2=Заменить на {0}[{1}] ?\: {2}
replace.with.0.call=Заменить на вызов ''{0}()''
replace.with.0.operator=Заменить на оператор ''{0}''
replace.with.a.for.loop=Заменить на цикл 'for'
replace.with.a.foreach.function.call=Заменить на вызов функции ''{0}''
replace.with.array.call=Заменить на вызов массива
replace.with.array.literal.fix.family.name=Заменить на [...]
replace.with.arrayof=Заменить на 'arrayOf'
replace.with.assignment.fix.text=Заменить на присваивание (оригинал пуст)
replace.with.binary.operator=Заменить на бинарный оператор
replace.with.block.comment=Заменить на блочный комментарий
replace.with.contentequals=Заменить '\!\=' на 'contentEquals'
replace.with.contentequals2=Заменить '\=\=' на 'contentEquals'
replace.with.contentequals3=Заменить на 'contentEquals'
replace.with.dot.call=Заменить на вызов через точку
replace.with.elvis.error.fix.text=Заменить на '?\: error("")'
replace.with.elvis.return.fix.text=Заменить на ''?\: return{0}''
replace.with.end.of.line.comment=Заменить на однострочный комментарий
replace.with.enum.map.fix.text=Заменить на 'EnumMap'
replace.with.equality.check.fix.text=Заменить на проверку равенства
replace.with.equality.fix.text=Заменить ''{0}'' на ''{1}''
replace.with.error=Заменить на '?\: error(...)'
replace.with.explicit.type=Заменить '_' на явный тип
replace.with.field.fix.text=Заменить на 'field'
replace.with.filter.fix.text=Заменить на filter
replace.with.generated.publishedapi.bridge.call.0=Заменить на сгенерированный вызов моста @PublishedApi ''{0}''
replace.with.get.or.else.fix.text=Заменить на вызов 'getOrElse'
replace.with.get.value.call.fix.text=Заменить на вызов 'getValue'
replace.with.if.fix.text=Заменить на проверку типа через 'if'
replace.with.import.alias=Заменить на псевдоним импорта
replace.with.in.when=Заменить ',' на '||' в when
replace.with.indexing.and.elvis.operator=Заменить на индексацию и оператор elvis
replace.with.infix.function.call=Заменить на инфиксный вызов функции
replace.with.kotlin.analog.function.family.name=Заменить на аналог Kotlin
replace.with.kotlin.analog.function.text=Заменить на функцию ''{0}''
replace.with.kotlin.s.foreach=Заменить на forEach из Kotlin
replace.with.kotlin.s.function.call=Заменить на вызов функции Kotlin
replace.with.label.0.at=Заменить на метку {0}@
replace.with.list.generator.fix.text=Заменить на генератор List
replace.with.operator.assignment=Заменить на оператор присваивания
replace.with.ordinary.assignment=Заменить на обычное присваивание
replace.with.parameter.name=Заменить '_' на имя параметра
replace.with.publishedapi.bridge.call=Заменить на вызов моста @PublishedApi
replace.with.rangeUntil.quick.fix.text=Заменить на '..<'
replace.with.repeat.fix.family.name=Заменить на 'repeat()'
replace.with.return=Заменить '\!\!' на '?\: return'
replace.with.safe.call=Заменить на безопасный вызов (?.)
replace.with.safe.this.call=Заменить на безопасный вызов (this?.)
replace.with.std.lib.fix.text=Заменить на {0}.{1}
replace.with.stdlib.operations=Заменить на операции stdlib
replace.with.stdlib.operations.with.use.of.assequence=Заменить на операции stdlib с использованием 'asSequence()'
replace.with.string.literal.fix.family.name=Заменить на строковые шаблоны
replace.with.underscore=Заменить явный тип на '_'
replace.with.until.quick.fix.text=Заменить на 'until'
replace.with1=Заменить на '+\='
replace.||.with.&&=Заменить '||' на '\\&\\&'
replaceable.with.enummap=Можно заменить на 'EnumMap'
replaceable.with.operator.assignment=Можно заменить на оператор присваивания
report.also.for.a.variables.without.a.whitespace.around=Также сообщать о переменных без пробелов вокруг
report.also.on.call.with.single.boolean.literal.argument=Также сообщать о вызове с единственным булевым литералом
report.also.on.statement=Также сообщать о выражении
report.for.types.with.platform.arguments=Сообщать для типов с платформенными аргументами
reports.only.function.calls.from.kotlinx.coroutines=Сообщать только о вызовах функций из 'kotlinx.coroutines'
reset.files=Сбросить файлы…
resolve.pasted.references=разрешить вставленные ссылки
result.of.0.call.is.not.thrown=Результат вызова ''{0}'' не выброшен
retargeting.usages.progress=Перенаправление использований
rethrow.stored.pce.as.a.new.runtime.exception=Перевыбросить сохранённое PCE как новое исключение времени выполнения
return.type=&Тип возвращаемого значения\:
return.type.is.invalid=Недопустимый тип возвращаемого значения
return.when='return when'
revert.applied.imports.command=Отменить примененные импорты
roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=Обновить корни исходного кода для не-JVM модулей в проекте Kotlin
round.using.0=Округлить с помощью {0}()
safe.delete.constructor=Безопасно удалить конструктор
saving.files=Сохранение файлов…
scanning.files.0.fo.1.file.2.occurrences.found=Сканирование файлов\: {0} из {1}. Найдено совпадений\: {2}
script.action.text.ignore=Игнорировать
script.action.text.open.settings=Открыть настройки
script.action.text.show.all=Показать все
script.name.kotlin.scripting=Скрипты Kotlin
script.text.multiple.script.definitions.are.applicable.for.this.script=К этому скрипту применимы несколько определений. Используется {0}
sealed.sub.class.has.no.state.and.no.overridden.equals='sealed' подкласс не имеет состояния и не переопределяет 'equals()'
search.for.not.property.candidates=Поиск кандидатов не-свойств
search.for.text.occurrences=Искать вхождения &текста
search.in.comments.and.strings=Искать в &комментариях и строках
searching.0=Поиск {0}…
searching.for.0=Поиск {0}
searching.for.imports.to.delete.title=Поиск импортов для удаления
searching.for.not.property.candidates=Поиск кандидатов не-свойств
searching.for.overriding.methods=Поиск переопределяющих методов
searching.inheritors=Поиск наследников…
searching.usages.of.0.parameter=Поиск использований параметра ''{0}''
select.lambda.to.label=Выберите лямбду для метки
select.loop.statement.to.label=Выберите оператор цикла для метки
select.target.code.block.file=Выберите целевой блок кода / файл
select.target.file=Выберите целевой файл
selected.code.fragment.has.multiple.exit.points=Выбранный фрагмент кода имеет несколько точек выхода
selected.code.fragment.has.multiple.output.values=Выбранный фрагмент кода имеет более 3 выходных значений\:
selected.code.fragment.has.output.values.and.exit.points=Выбранный фрагмент кода имеет как выходные значения, так и альтернативные точки выхода
setter.of.0.will.become.invisible.after.extraction=Сеттер {0} станет невидимым после извлечения
shortening.usages.progress=Сокращение использований
should.be.replaced.with.if.type.check=Следует заменить на проверку типа 'if'
should.be.replaced.with.indexing=Следует заменить на индексацию
should.be.replaced.with.kotlin.function=Следует заменить на функцию Kotlin
should.be.replaced.with.list.generator=Следует заменить на генератор списка
should.not.contain.lowercase.letter=не должно содержать строчные буквы
should.not.contain.underscores=не должно содержать подчеркивания
should.not.contain.underscores.in.the.middle.or.the.end=не должно содержать подчеркивания в середине или конце
should.not.contain.underscores.with.camel.case=не должно содержать подчеркивания при использовании camelCase
should.not.start.with.an.underscore=не должно начинаться с подчеркивания
should.not.start.with.an.uppercase.letter=не должно начинаться с заглавной буквы
should.start.with.a.lowercase.letter=должно начинаться со строчной буквы
should.start.with.an.uppercase.letter=должно начинаться с заглавной буквы
signature.preview=Предпросмотр сигнатуры
simplify.0.to.1=Упростить ''{0}'' до ''{1}''
simplify.boolean.expression=Упростить логическое выражение
simplify.call.chain.fix.text=Объединить цепочку вызовов в ''{0}''
simplify.call.fix.text=Преобразовать вызов ''{0}'' в ''{1}''
simplify.comparison=Упростить сравнение
simplify.fix.text=Упростить выражение
simplify.foldable.if.then=Упростить сворачиваемый if-then
simplify.negated.operation=Упростить операцию отрицания
simplify.when.fix.text=Упростить 'when'
since.kotlin.1.3.main.parameter.is.not.necessary=Начиная с Kotlin 1.3 параметр main не требуется
slicer.text.in=в
slicer.text.tracking.enclosing.lambda=\ (Отслеживание внешней лямбды)
slicer.text.tracking.lambda.argument=\ (Отслеживание параметра лямбды)
slicer.text.tracking.lambda.calls=\ (Отслеживание вызовов лямбды)
slicer.text.tracking.lambda.receiver=\ (Отслеживание приемника лямбды)
slicer.title.dataflow.from.here=Поток данных отсюда
slicer.title.dataflow.to.here=Поток данных сюда
slicer.tool.tip.text.variable.dereferenced=Переменная разыменована
some.types.are.not.accessible.from.0.1=Некоторые типы недоступны из {0}\:\n{1}
sort.modifiers=Отсортировать модификаторы
specify.all.remaining.arguments.by.name=Указать все оставшиеся аргументы по имени
specify.all.types.explicitly.in.destructuring.declaration=Явно указать все типы в деструктурирующем объявлении
specify.explicit.lambda.signature=Указать явную сигнатуру лямбды
specify.override.explicitly=Явно указать переопределение
specify.override.for.0.explicitly=Явно указать переопределение для ''{0}''
specify.remaining.required.arguments.by.name=Указать оставшиеся обязательные аргументы по имени
specify.return.type.explicitly=Явно указать тип возвращаемого значения
specify.super.type=Явно указать супертип ''{0}''
specify.type.explicitly=Явно указать тип
split.if.into.two=Разделить 'if' на две части
split.property.declaration=Разделить объявление свойства
spring.secured.urls.inlay.hints=Kotlin\: Показывать встроенные подсказки для защищенных URL-адресов Spring
ssr.modifier.match.call.semantically=Сопоставить вызов семантически
ssr.modifier.match.companion.object=Сопоставить companion object
ssr.modifier.match.val=Сопоставить val
ssr.modifier.match.var=Сопоставить var
start.import.button.text.add=Добавить
start.import.button.text.remove=Удалить
statement=Оператор
status=(статус)
status.text.no.definitions=Нет определений
step.1.collecting.0.1.2=Шаг 1\: Сбор {0}\:{1}\:{2}
step.2.0.of.1=Шаг 2\: {0} из {1}
step.3.0.of.1=Шаг 3\: {0} из {1}
surround.with.0=Обернуть в {0}(...)
surround.with.array.of=Обернуть в arrayOf(...)
surround.with.lambda=Обернуть в лямбду
surround.with.null.check=Обернуть в проверку на null
surround.with.star.0=Обернуть в *{0}(...)
suspicious.asdynamic.member.invocation=Подозрительный вызов члена 'asDynamic'
suspicious.callable.reference.as.the.only.lambda.element=Подозрительная вызываемая ссылка как единственный элемент лямбды
suspicious.combination.of.and=Подозрительная комбинация \=\= и \=\=\=
suspicious.var.property.its.setter.does.not.influence.its.getter.result=Подозрительное свойство 'var'\: его сеттер не влияет на результат геттера
test.function=Тестовая функция
test.integration.button.text.cancel=Отмена
test.integration.button.text.rewrite=Перезаписать
test.integration.message.text.create.test.in.the.same.source.root=Создать тест в том же корневом каталоге исходного кода?
test.integration.message.text.kotlin.class=Класс Kotlin ''{0}'' уже существует. Хотите обновить его?
test.integration.title.no.test.roots.found=Не найдены корневые каталоги тестов
test.result.log.file.will.be.placed.here=Файл журнала результатов тестования будет размещен здесь
text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}'' должен быть перемещен вместе с sealed родительским классом и всеми его подклассами
text.0.already.contains.1={0} уже содержит {1}
text.0.already.contains.nested.class.1={0} уже содержит вложенный класс с именем {1}
text.0.already.declared.in.1={0} уже объявлен в {1}
text.0.have.no.inheritors.warning={0} не имеет наследников\nПеремещение членов вниз приведет к их удалению. Хотите продолжить?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={0} в {1} будет переопределять соответствующий член {2} после рефакторинга
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0} наследуется от {1}.\nРефакторинг не повлияет на него
text.0.is.invalid.destination.package=''{0}'' является недопустимым именем целевого пакета
text.0.is.not.allowed.in.the.target.context=''{0}'' не разрешен в целевом контексте
text.0.is.not.valid.package.name={0} не является допустимым именем пакета
text.0.to.inline=Встроить {0}
text.0.uses.1.which.is.not.accessible.from.2={0} использует {1}, который недоступен из {2}
text.0.uses.1.which.will.be.inaccessible.after.move={0} использует {1}, который станет недоступным после перемещения
text.0.uses.1.which.will.not.be.accessible.from.subclass={0} использует {1}, который будет недоступен из подкласса.
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0} использует internal {1}, который станет недоступным после перемещения
text.0.will.be.shadowed.by.1={0} будет скрыт {1}
text.0.will.clash.with.existing.1.in.2={0} после переименования будет конфликтовать с существующим {1} в {2}
text.0.will.no.longer.be.accessible.after.signature.change={0} станет недоступным после изменения сигнатуры
text.Assignment=Присваивание
text.Function=Функция
text.Name=Имя
text.Package=Пакет
text.Property=Свойство
text.Return=Возврат
text.abstract=абстрактный
text.actual.moved.to.common.modules.target=Фактическое объявление ''{0}'' будет перемещено в общий модуль.
text.add.getter=Добавить геттер
text.add.getter.and.setter=Добавить геттер и сеттер
text.add.setter=Добавить сеттер
text.add.use.site.target.0=Добавить целевой сайт использования ''{0}''
text.all.declarations.must.belong.to.the.same.directory.or.class=Все объявления должны принадлежать одному каталогу или классу
text.annotation=аннотация
text.annotation.class=класс аннотации
text.anonymous=[Анонимный]
text.anonymous.function=анонимная функция
text.at.least.one.file.must.be.selected=Необходимо выбрать хотя бы один элемент
text.callee.text.would.be.shown.here=Здесь будет показан текст вызываемого метода
text.caller.text.with.highlighted.callee.call.would.be.shown.here=Здесь будет показан текст вызывающего метода\nс подсвеченным вызовом вызываемого метода
text.can=может
text.cannot.create.target.directory.0=Невозможно создать целевой каталог {0}
text.cannot.determine.source.directory=Невозможно определить каталог с исходным кодом
text.cannot.find.package.corresponding.to.0=Не удалось найти пакет, соответствующий {0}
text.cannot.find.target.package.name=Не удалось найти имя целевого пакета
text.cannot.inline.reference.from.0.to.1=Невозможно встроить ссылку из {0} в {1}
text.cannot.move.expect.actual.declaration.to.file=Невозможно переместить expect/actual объявление в файл
text.cannot.move.for.current.project=Невозможно выполнить перемещение для текущего проекта
text.cannot.move.inner.class.0.into.itself=Невозможно переместить вложенный класс {0} в самого себя
text.cannot.move.to.original.file=Невозможно переместить в исходный файл
text.change.file.package.to.0=Изменить пакет файла на ''{0}''
text.choose.containing.file=Выберите содержащий файл
text.class=класс
text.class.0={0,choice,1\#класс|2\#класса}
text.class.0.already.contains.member.1={0} уже содержит {1}
text.class.0.already.exists.in.package.1=Класс {0} уже существует в пакете {1}
text.class.0.already.exists.in.the.target.scope=Класс {0} уже существует в целевой области видимости
text.class.0.is.final={0} является final
text.constructor=конструктор
text.convert._it_.to.explicit.lambda.parameter=Преобразовать 'it' в явный параметр лямбды
text.create=Создать
text.create.destructuring.declaration=Создать деструктурирующее объявление
text.create.single.variable=Создать одиночную переменную
text.declaration=объявление
text.declarations.clash.move.0.destination.1.declared.in.scope.2=Следующие объявления будут конфликтовать\: перемещаемое {0} и целевое {1}, объявленное в области видимости {2}
text.default.value=\ // значение по умолчанию \= {0}
text.destination.class.should.be.kotlin.class=Целевой класс должен быть классом Kotlin
text.do.you.want.to.rename.0.as.well=Хотите также переименовать {0}()?
text.do.you.want.to.rename.base.property=Хотите переименовать базовое свойство?
text.do.you.want.to.rename.base.property.from.0=Хотите переименовать базовое свойство из \n{0}
text.done=Готово
text.duplicating.local.variable=Дублирование локальной переменной ''{0}''
text.duplicating.parameter=Дублирование параметра ''{0}''
text.duplicating.property=Дублирование свойства ''{0}''
text.enum=перечисление
text.enum.class=класс-перечисление
text.enum.constant=константа перечисления
text.expected.moved.to.platform.modules.target=Ожидаемое объявление ''{0}'' будет перемещено в платформенный модуль.
text.explicit.receiver.is.already.present.in.call.element.0=Явный получатель уже присутствует в элементе вызова\: {0}
text.extend=расширить
text.extension=расширение
text.extension.function=функция-расширение
text.extension.function.0={0,choice,1\#функция-расширение|2\#функции-расширения}
text.extension.property=свойство-расширение
text.extension.property.0={0,choice,1\#свойство-расширение|2\#свойства-расширения}
text.extract.superclass=Извлечь суперкласс
text.file.0.already.exists.in.1=Файл {0} уже существует в {1}
text.file.name.cannot.be.empty=Имя файла не может быть пустым
text.first.definition.that.matches.script.pattern.extension.applied.starting.from.top=Применяется первое определение, соответствующее шаблону/расширению скрипта, начиная сверху
text.function=функция
text.function.0={0,choice,1\#функция|2\#функции}
text.function.already.exists=Функция уже существует\: ''{0}''
text.function.in.ticks.0=функция ''{0}''
text.getter=геттер
text.implement=реализовать
text.implements=реализует
text.implicit.companion.object.will.be.inaccessible.0=Неявный companion object будет недоступен\: {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=Неверный целевой путь. Директория {0} не принадлежит текущему проекту.
text.indirect.outer.instances.will.not.be.extracted.0=Внешние экземпляры не будут извлечены\: {0}
text.initializer=инициализатор
text.inline.0=Встроить {0}
text.inline.all.references.and.verb.0.the.kind.1.occurrences.2=Встроить все ссылки и {0} {1} {2}
text.inline.function.not.supported=Встраивание функции пока не поддерживается
text.inline.recursive.function.is.supported.only.on.references=Встраивание рекурсивной функции поддерживается только для ссылок
text.inline.this.reference.and.keep.the.0=Встроить эту ссылку и сохранить {0}
text.inlined.0.overrides.0.1=Встроенный {0} переопределяет {0} {1}
text.inlining.0.1=Встраивание {0} {1}
text.inner.class.0.cannot.be.moved.to.interface={0} является внутренним классом. Его нельзя переместить в интерфейс
text.interface=интерфейс
text.introduce.default.value=Добавить значение по умолчанию [&D]
text.invalid.target.path.0=Неверный целевой путь {0}
text.invalid.target.specified=Указана неверная цель
text.keep=сохранить
text.lambda.parameter=параметр lambda
text.lambda.parameters=Параметры Lambda [&P]\:
text.lambda.return.type=Возвращаемый тип Lambda [&T]
text.lazy.property=ленивое свойство
text.local.property=свойство
text.local.variable=локальная переменная
text.looking.for.usages=Поиск использований
text.member=член
text.member.0.in.super.class.will.clash.with.existing.member.of.1={0} в суперклассе будет конфликтовать с существующим членом {1}
text.member.extension.call.will.not.be.processed.0=Вызов расширения члена не будет обработан\: {0}
text.move.declaration.no.support.for.companion.objects=Перемещение объявления не поддерживается для companion objects
text.move.declaration.no.support.for.enums=Перемещение объявления не поддерживается для элементов перечисления
text.move.declaration.no.support.for.multi.file=Перемещение объявлений из разных файлов не поддерживается
text.move.declaration.no.support.for.nested.declarations=Перемещение объявления не поддерживается для вложенных объявлений
text.move.declaration.proceed.move.without.mpp.counterparts.text=Это рефакторинг переместит выбранное объявление без его expect/actual пар, что может привести к ошибкам компиляции.\nПродолжить?
text.move.declaration.proceed.move.without.mpp.counterparts.title=Невозможно выполнить рефакторинг. MPP объявления не поддерживаются этим рефакторингом.
text.move.declaration.supports.only.top.levels.and.nested.classes=Перемещение объявления поддерживается только для объявлений верхнего уровня и вложенных классов
text.move.declarations=Переместить объявления
text.move.file.0=Переместить {0}
text.move.file.no.support.for.file.target=Перемещение файлов не поддерживается для цели, не являющейся директорией
text.move.method.is.not.supported.for.generic.classes=Перемещение метода не поддерживается для обобщенных классов
text.move.method.is.not.supported.for.non.project.methods=Перемещение метода не поддерживается для методов вне проекта
text.move.method.is.not.supported.when.method.is.a.part.of.inheritance.hierarchy=Перемещение метода не поддерживается, когда метод является частью иерархии наследования
text.move.refactoring.not.available.during.indexing=Рефакторинг перемещения недоступен во время индексации
text.moving.multiple.nested.classes.to.top.level.not.supported=Перемещение нескольких вложенных классов на верхний уровень не поддерживается
text.name=имя
text.nested.classes.to.upper.level=Вложенные классы на уровень выше
text.no.destination.object.specified=Не указан целевой объект
text.no.elements.to.move.are.selected=Не выбраны элементы для перемещения
text.no.files.to.move=Нет файлов для перемещения
text.no.name.provided.for.type.alias=Не указано имя для псевдонима типа
text.no.package.corresponds.to.directory=Нет пакета, соответствующего этой директории
text.non.kotlin.0.will.not.be.affected.by.refactoring=Не-Kotlin {0} не будет затронут рефакторингом
text.object=объект
text.object.0={0,choice,1\#объект|2\#объекта}
text.operator.0={0,choice,1\#оператор|2\#оператора}
text.overload=Перегрузить
text.overrides=переопределяет
text.package.directive.dont.match.file.location=Директива package не соответствует расположению файла
text.parameter=Параметр
text.parameter.0=параметр ''{0}''
text.parameter.name=Имя параметра [&N]\:
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context=Ссылка на параметр не может быть безопасно заменена на {0}, так как {1} неоднозначен в этом контексте
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=Ссылка на параметр не может быть безопасно заменена на {0}, так как целевая функция не может быть использована в этом контексте
text.parameter.type=Тип параметра [&T]\:
text.parameters=Параметры [&P]
text.part=часть
text.pattern=Шаблон\:
text.primary=основной
text.primary.constructor=основной конструктор
text.proceed.with.extraction=Все равно продолжить извлечение
text.process.duplicates=Обработать дубликаты
text.processing.file.0=Обработка {0}
text.property=свойство
text.property.0={0,choice,1\#свойство|2\#свойства}
text.property.in.ticks.0=свойство ''{0}''
text.property.with.getter=свойство с геттером
text.property.with.initializer=свойство с инициализатором
text.pushed.member.will.not.be.available.in.0=Перемещенный член не будет доступен в ''{0}''
text.qualified.call.will.not.be.processed.0=Квалифицированный вызов не будет обработан\: {0}
text.receiver=получатель
text.receiver.can.t.be.safely.transformed.to.value.argument=Получатель не может быть безопасно преобразован в аргумент\: {0}
text.refactoring.can.t.be.performed.on.the.selected.code.element=Рефакторинг не может быть выполнен для выбранного элемента кода
text.refactoring.is.not.applicable.to.this.code.fragment=Рефакторинг не применим к этому фрагменту кода
text.reference.cannot.be.converted.to.a.lambda=Ссылка не может быть преобразована в lambda
text.references.in.code.to.0.1.and.its.declarations=Ссылки в коде на {0} {1} и его объявления
text.references.to.outer.classes.have.to.be.added.manually=Ссылки на внешние классы нужно будет добавить вручную после перемещения
text.remove=удалить
text.remove.0.no.longer.used=Удалить неиспользуемый {0}
text.remove.question=Удалить '?'
text.rename.as.part.of.phrase=переименовать
text.rename.is.not.applicable.to.compiler.plugin.generated.declarations=Переименование не применимо к объявлению, сгенерированному плагином компилятора
text.rename.is.not.applicable.to.secondary.constructors=Переименование не применимо к вторичным конструкторам
text.rename.is.not.applicable.to.synthetic.declarations=Переименование не применимо к синтетическому объявлению
text.rename.not.applicable.to.backing.field.reference=Переименование не применимо к ссылке на backing field
text.rename.not.applicable.to.dynamically.invoked.methods=Переименование не применимо к динамически вызываемым членам
text.rename.overloads.title=Переименовать перегрузки
text.rename.parameters.title=Переименовать параметры
text.return=возврат
text.sealed.broken.hierarchy.none.in.target=Иерархия sealed класса ''{0}'' будет разделена. Ни один из его членов не находится в пакете ''{1}'' модуля ''{2}''\: {3}.
text.sealed.broken.hierarchy.still.in.source=Иерархия sealed класса ''{0}'' будет разделена. Пакет ''{1}'' модуля ''{2}'' все еще будет содержать его члены\: {3}.
text.sealed.class.0.must.be.moved.with.all.its.subclasses=Sealed класс ''{0}'' должен быть перемещен со всеми его подклассами
text.secondary=вторичный
text.secondary.constructor=вторичный конструктор
text.select.target.code.block=Выберите целевой блок кода
text.select.target.code.block.file=Выберите целевой блок кода / файл
text.select.target.file=Выберите целевой файл
text.setter=сеттер
text.should=должен
text.there.is.already.a.parameter=В {1} уже существует параметр ''{0}''. Он будет конфликтовать с новым параметром.
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter=В {1} уже существует переменная ''{0}''. Она будет конфликтовать с новым параметром.
text.type=Тип
text.type.alias=псевдоним типа
text.type.alias.0={0,choice,1\#псевдоним|2\#псевдонима} типа
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=Псевдоним типа не может ссылаться на типы, недоступные в области видимости, где он определен
text.type.alias.name.must.be.a.valid.identifier.0=Имя псевдонима типа должно быть корректным идентификатором\: {0}
text.type.already.exists.in.the.target.scope=Тип {0} уже существует в целевой области видимости
text.type.parameter={0, choice, 0\#параметр|2\#параметра} типа
text.type.parameter.names.must.be.distinct=Имена параметров типа должны быть уникальными
text.type.parameters=&Параметры типа [&P]
text.unexpected.element.type.0=Неожиданный тип элемента\: {0}
text.update.usages.to.reflect.declaration.0.move=Обновить использования для отражения перемещения {0, choice, 0\#объявления|1\#объявлений}
text.updating.usages.progress=Обновление использований…
the.anonymous.object=анонимный объект
the.declaration.has.0.modifier=Объявление имеет модификатор ''{0}''
the.function.declaration.shouldn.t.have.a.default.implementation=Объявление функции не должно иметь реализации по умолчанию
there.are.possible.side.effects.found.in.expressions.assigned.to.the.variable.0=В выражениях, присваиваемых переменной ''{0}'', обнаружены возможные побочные эффекты<br>Вы можете\:<br>-\\&nbsp;<b>Удалить</b> всё присваивание, или<br>-\\&nbsp;<b>Преобразовать</b> правую часть присваивания в отдельный оператор.<br>
there.is.own.replacewith.on.0.that.is.used.through.this.alias.please.replace.usages.first=У ''{0}'', используемого через этот псевдоним, есть собственный ''ReplaceWith''. Сначала замените использования.
these.declarations.cannot.be.transformed=Эти объявления нельзя преобразовать\:
this.call.is.useless.with=Этот вызов бесполезен с ?.
this.property.conflicts.with.synthetic.extension.and.should.be.removed.or.renamed.to.avoid.breaking.code.by.future.changes.in.the.compiler=Свойство конфликтует с синтетическим расширением и должно быть удалено или переименовано во избежание поломки кода в будущих версиях компилятора Kotlin
this.range.is.empty=Этот диапазон пуст.
this.range.is.empty.did.you.mean.to.use.0=Этот диапазон пуст. Возможно, вы имели в виду ''{0}''?
this.type.probably.can.be.changed.to.nullable=Этот тип, вероятно, можно изменить на допускающий null
this.when.is.simplifiable=Этот 'when' можно упростить
throwable.instance.0.is.not.thrown=Экземпляр Throwable ''{0}'' не выбрасывается
titile.not.found=Не найдено
title.choose.destination.object=Выберите целевой объект
title.choose.logger.factory.class=Выберите фабричный класс логгера
title.choose.use.site.target=Выберите Use-Site цель
title.done=Готово
title.error=Ошибка
title.import.layout=Компоновка импортов
title.inline.function=Встроить функцию
title.inline.property=Встроить свойство
title.inline.type.alias=Встроить псевдоним типа
title.introduce.parameter.to.declaration=Добавить параметр в объявление
title.kdoc.for.abstracts=KDoc для абстрактных элементов
title.lateinit.var.overrides.lateinit.var='lateinit var' переопределяет родительский 'lateinit var'
title.logger.factory.class.name=Имя фабричного класса логгера
title.logger.factory.method.name=Имя фабричного метода логгера
title.move.method=Переместить метод
title.move.nested.classes.to.upper.level=Переместить вложенные классы на верхний уровень
title.packages.to.use.import.with=Пакеты для использования import с '*'
title.parameters=Параметры
title.rename.file=Переименовать файл
title.rename.file.to=Переименовать файл в\:
title.rename.overloads.to=Переименовать перегрузки в\:
title.rename.warning=Предупреждение переименования
title.select.a.name.for.this.parameter=Выберите имя для параметра ''this@{0}''
title.select.target.code.block=Выберите целевой блок кода
title.success=Успешно
to.fully.qualified.name=В (полное имя)\:
tooltip.implements.function=Реализует функцию в
tooltip.implements.property=Реализует свойство в
tooltip.is.implemented.by=Реализуется
tooltip.is.subclassed.by=Имеет подклассы
tooltip.overrides.function=Переопределяет функцию в
tooltip.overrides.property=Переопределяет свойство в
top.level=Верхний уровень
two.comparisons.should.be.converted.to.a.range.check=Два сравнения следует преобразовать в проверку диапазона
type.0.1.is.not.accessible.from.target.module={0, choice, 0\#Тип|2\#Типы} {1} недоступен из целевого модуля
type.alias.0=Псевдоним типа "{0}"
type.arguments.will.be.lost.after.conversion.0=После преобразования аргументы типа будут потеряны\: {0}
type.parameter.0=Параметр типа "{0}"
type.parameter.can.have.0.variance=Параметр типа может иметь вариантность ''{0}''
type.provider.anonymous.object=анонимный объект
type.provider.no.expression.found=Выражение не найдено
type.provider.smart.cast.from=(умное приведение из {0})
type.provider.unknown.type=Тип неизвестен
unclear.precedence.of.binary.expression.inspection=Выражение должно использовать уточняющие скобки
unclear.precedence.of.binary.expression.inspection.display.name=Несколько операторов с разным приоритетом
unclear.precedence.of.binary.expression.quickfix=Добавить уточняющие скобки
unclear.precedence.of.binary.expression.report.even.obvious.cases.checkbox=Сообщать даже об очевидных случаях
unknown.types.title=Неизвестные типы
unlabeled.return.inside.lambda=Неотмеченный return внутри лямбды
unrecognized.reference.will.be.skipped.0=Нераспознанная ссылка будет пропущена\: {0}
unsupported.usage.0=Неподдерживаемое использование\: {0}
until.can.be.replaced.with.rangeUntil.operator='until' может быть заменен на оператор '..<'
unused.equals.expression=Неиспользуемое выражение equals
unused.import.directive=Неиспользуемая директива import
unused.return.value.of.a.function.with.lambda.expression.body=Неиспользуемое возвращаемое значение функции с телом лямбда-выражения
unused.unary.operator=Неиспользуемый унарный оператор
unwrap.else=Развернуть else в ''{0}''
unwrap.expression=Развернуть ''{0}''
unwrap.parameter=Развернуть ''{0}'' arg ''{1}''
update.indices=Обновить индексы…
update.obsolete.label.syntax=Обновить устаревший синтаксис меток
usage.of.kotlin.internal.declaration.from.different.module=Использование internal-объявления Kotlin из другого модуля
usage.of.redundant.or.deprecated.syntax.or.deprecated.symbols=Использование избыточного или устаревшего синтаксиса или устаревших символов
usage.provider.text.property.of.0={0} из {1}
usage.provider.text.unnamed=<без имени>
usages.of.outer.class.instance.inside.of.property.0.won.t.be.processed=Использования экземпляра внешнего класса внутри свойства ''{0}'' не будут обработаны
use.destructuring.declaration=Использовать деструктурирующее объявление
use.expression.body.instead.of.0=Использовать тело-выражение вместо {0}
use.inherited.visibility=Использовать унаследованную видимость
use.of.getter.method.instead.of.property.access.syntax=Использование метода getter вместо синтаксиса доступа к свойству
use.of.non.const.kotlin.property.as.java.constant.is.incorrect.will.be.forbidden.in.1.4=Использование не-const свойства Kotlin как константы Java некорректно. Будет запрещено в 1.4
use.of.setter.method.instead.of.property.access.syntax=Использование метода setter вместо синтаксиса доступа к свойству
use.property.access.syntax=Использовать синтаксис доступа к свойству
use.property.access.syntax.option.report.non.trivial.accessors=Сообщать о нетривиальных акцессорах
use.withindex.instead.of.manual.index.increment=Использовать withIndex() вместо ручного увеличения индекса
useless.call.on.collection.type=Бесполезный вызов для типа коллекции
useless.call.on.not.null.type=Бесполезный вызов для not-null типа
uses.of.should.be.replaced.with.logging=Использование <code>{0}</code> следует заменить на более надежное логование
variable.0.is.assigned.to.itself=Переменной ''{0}'' присваивается она сама
variable.declaration.could.be.inlined=Объявление переменной может быть встроено
variable.declaration.could.be.moved.into.when=Объявление переменной может быть перемещено в 'when'
variable.is.never.modified.and.can.be.declared.immutable.using.val=Переменная никогда не изменяется, поэтому может быть объявлена через 'val'
variable.is.same.as.0.and.should.be.inlined=Переменная совпадает с ''{0}'' и может быть встроена
variable.name.0.matches.the.name.of.a.different.component=Имя переменной ''{0}'' совпадает с именем другого компонента
variable.used.only.in.following.return.and.should.be.inlined=Переменная используется только в следующем return и может быть встроена
vcs.code.author=Kotlin\: Показывать встроенные подсказки с автором кода
version={version}
visibility=&Видимость\: [&V]
when.has.only.else.branch.and.should.be.simplified='when' имеет только ветку 'else' и должен быть упрощен
when.with.subject.should.be.used=Следует использовать 'when' с субъектом
wrap.argument.with.parentheses=Обернуть аргумент в круглые скобки
wrap.element.with.0.call=Обернуть элемент в вызов ''{0}()''
wrap.expression.in.parentheses=Обернуть выражение в круглые скобки
wrap.run.fix.text=Преобразовать в run { ... }
wrap.unary.operator.quickfix.text=Обернуть унарный оператор и значение в ()
wrap.with=Обернуть в []
wrap.with.array.literal=Обернуть в литерал массива
wrap.with.collection.literal.call=Обернуть в вызов литерала коллекции
wrap.with.coroutine.scope.fix.family.name=Обернуть в coroutineScope
wrap.with.coroutine.scope.fix.text=Обернуть тело функции в 'coroutineScope { ... }'
wrap.with.coroutine.scope.fix.text2=Обернуть вызов в 'coroutineScope { ... }'
wrap.with.coroutine.scope.fix.text3=Удалить получателя и обернуть в 'coroutineScope { ... }'
wrap.with.let.call=Обернуть в вызов '?.let { ... }'