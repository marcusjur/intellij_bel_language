DFAStrings.CppDFAArrayIndexOutOfBoundsDescription=Сообщает о выражениях доступа к массиву или указателю, где индекс может выйти за границы массива или выделенного буфера
DFAStrings.CppDFAArrayIndexOutOfBoundsTitle=Выражения доступа к массиву, где индекс может выйти за границы
DFAStrings.CppDFAConstantConditionsDescription=Сообщает об условиях, которые всегда истинны или ложны, и выражениях, значение которых статически доказано константным
DFAStrings.CppDFAConstantConditionsTitle=Условия, которые всегда истинны или ложны
DFAStrings.CppDFAConstantFunctionResultDescription=Сообщает о функциях, где возвращаемое значение всегда одна и та же константа
DFAStrings.CppDFAConstantFunctionResultTitle=Функции, возвращаемое значение которых всегда одна и та же константа
DFAStrings.CppDFAConstantParameterDescription=Сообщает о параметрах функции, которые всегда имеют одно и то же значение
DFAStrings.CppDFAConstantParameterTitle=Параметры функции, которые всегда имеют одно и то же значение
DFAStrings.CppDFADeletedPointerDescription=Сообщает об использовании указателей, ссылающихся на память, уже удалённую оператором delete или функцией free(void* ptr)
DFAStrings.CppDFADeletedPointerTitle=Использование указателей, ссылающихся на удалённую память
DFAStrings.CppDFAEndlessLoopDescription=Сообщает об операторах 'for', 'while', 'do-while' и 'goto', которые завершаются только путем выброса исключения
DFAStrings.CppDFAEndlessLoopTitle=Бесконечные циклы
DFAStrings.CppDFAInfiniteRecursionDescription=Сообщает о функциях, которые бесконечно вызывают сами себя, если не выбрасывается исключение
DFAStrings.CppDFAInfiniteRecursionTitle=Функции, которые бесконечно вызывают сами себя
DFAStrings.CppDFAInvalidatedMemoryDescription=Сообщает о ссылках на содержимое недействительных контейнеров
DFAStrings.CppDFAInvalidatedMemoryTitle=Ссылки на содержимое недействительных контейнеров
DFAStrings.CppDFALocalValueEscapesFunctionDescription=Сообщает о ссылках на локальные значения, которые выходят за пределы функции через возвраты, присваивания глобальным переменным или полям
DFAStrings.CppDFALocalValueEscapesFunctionTitle=Ссылки на локальные значения, которые выходят за пределы функции
DFAStrings.CppDFALocalValueEscapesScopeDescription=Сообщает о переменных со ссылками на локальные переменные, которые выходят за пределы своей области видимости
DFAStrings.CppDFALocalValueEscapesScopeTitle=Ссылки на локальные переменные, которые выходят за пределы своей области видимости
DFAStrings.CppDFALoopConditionNotUpdatedDescription=Сообщает об условиях цикла, которые не обновляются внутри цикла
DFAStrings.CppDFALoopConditionNotUpdatedTitle=Условия цикла, которые не обновляются внутри цикла
DFAStrings.CppDFAMemoryLeakDescription=Сообщает о выделениях памяти (с использованием 'new' или 'malloc()'), которые не были освобождены до того, как стали недоступны
DFAStrings.CppDFAMemoryLeakTitle=Выделения памяти, которые не были освобождены
DFAStrings.CppDFANotInitializedFieldDescription=Сообщает о полях, которые могут быть не инициализованы перед использованием. Инициализация и использование могут происходить в разных функциях.
DFAStrings.CppDFANotInitializedFieldTitle=Поля, которые могут быть не инициализованы перед использованием
DFAStrings.CppDFANullDereferenceDescription=Сообщает о разыменованиях указателей, которые могут содержать nullptr
DFAStrings.CppDFANullDereferenceTitle=Разыменования указателей, которые могут содержать nullptr
DFAStrings.CppDFATimeOverDescription=Анализ потока данных достиг ограничения по времени или памяти и не может быть выполнен ни в контекстно-зависимом, ни в контекстно-независимом режиме
DFAStrings.CppDFATimeOverTitle=Анализ потока данных превысил время выполнения
DFAStrings.CppDFAUnreachableCodeDescription=Сообщает о фрагментах кода, которые никогда не выполняются в любом потоке управления и могут быть безопасно удалены
DFAStrings.CppDFAUnreachableCodeTitle=Недостижимый код
DFAStrings.CppDFAUnreachableFunctionCallDescription=Сообщает о функциях, вызовы которых никогда не используются. Такие функции также никогда не выполняются.
DFAStrings.CppDFAUnreachableFunctionCallTitle=Функции, вызовы которых никогда не используются
DFAStrings.CppDFAUnreadVariableDescription=Сообщает о локальных переменных, которые объявлены, но никогда не читаются
DFAStrings.CppDFAUnreadVariableTitle=Локальные переменные, которые объявлены, но никогда не читаются
DFAStrings.CppDFAUnusedValueDescription=Сообщает о значениях переменных, которые никогда не используются после присваивания
DFAStrings.CppDFAUnusedValueTitle=Значения переменных, которые никогда не используются после присваивания
Strings.AClassDefinitionCanBeMarkedAsFinalSoItCannotBeInheritedFrom=Определение класса может быть помечено как final, чтобы от него нельзя было наследоваться
Strings.AClassIsNeverUsed=Класс никогда не используется
Strings.ACoroutineRelatedFunctionWhichIsRequiredByTheCStandardCannotBeResolved=Не удаётся разрешить функцию, связанную с сопрограммой, которая требуется стандартом C++20
Strings.ADeclarationDoesNotDeclareAnything=Объявление ничего не объявляет
Strings.ADeclarationSpecifierIsIgnoredWhenThereAreNoDeclarators=Спецификатор объявления игнорируется при отсутствии объявителей
Strings.ADeclaratorIsNeverUsed=Объявитель никогда не используется
Strings.ADeclaratorIsOnlyAssignedButNeverAccessed=Объявителю только присваивается значение, но он никогда не используется
Strings.ADeclaratorIsUsedOnlyInUnevaluatedContext=Объявитель используется только в невычисляемом контексте
Strings.AEnumeratorIsNeverUsed=Перечислитель никогда не используется
Strings.AFormatStringOfBoostFormatContainsALegacyPrintfLikeCodeTypeSpecifierIsNotTakenIntoAccount=Строка форматования boost\:\:format содержит устаревший код в стиле printf; спецификатор типа не учитывается
Strings.AFormatStringOfBoostFormatContainsAnErroneousFormatCode=Строка форматования boost\:\:format содержит ошибочную директиву форматования
Strings.AFunctionDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=Определение функции в заголовочном файле приведет к ошибке линковки из-за множественного определения
Strings.AFunctionIsNotImplemented=Функция не реализована
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue=Функция или лямбда с возвращаемым типом, отличным от void, должна возвращать значение
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue8=Функция или лямбда с возвращаемым типом, отличным от void, должна возвращать значение
Strings.ALambdaCaptureIsNeverUsed=Захват лямбды никогда не используется
Strings.ALocalDeclarationHidesAnotherLocalDeclaration=Локальное объявление скрывает другое локальное объявление
Strings.ALocalDeclarationInsideALambdaHidesAnUncapturedLocalDeclaration=Локальное объявление внутри лямбды скрывает незахваченное локальное объявление
Strings.ALocalVariableMightNotBeInitialized=Локальная переменная может быть не инициализована
Strings.ANonOverridingVirtualFunctionInAFinalOrSealedClassCannotBeOverriddenSoThevirtualSpecifierIsRedundant=Невиртуальная функция в final или sealed классе не может быть переопределена, поэтому спецификатор 'virtual' избыточен
Strings.ANumericTypeCanBeReplacedWithauto=Числовой тип может быть заменен на 'auto'
Strings.APolymorphicClassWithANonVirtualPublicDestructor=Полиморфный класс с невиртуальным публичным деструктором
Strings.APrivateSpecialMemberFunctionShouldBeDefinedOrDeleted=Приватная специальная функция-член должна быть определена или удалена
Strings.AStandardAlgorithmAcceptingRangeIteratorsIsUsedInsteadOfTheVariantAcceptingAnIteratorAndACount=Используется стандартный алгоритм, принимающий итераторы диапазона, вместо варианта с итератором и счетчиком
Strings.ATemplateParameterFromAnOuterScopeIsShadowedByADeclarationWithTheSameName=Параметр шаблона из внешней области видимости затенен объявлением с тем же именем
Strings.ATypeAliasIsNeverUsed=Псевдоним типа никогда не используется
Strings.ATypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=Type trait может быть упрощен с помощью псевдонима шаблона или шаблона переменной
Strings.AVariableDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=Определение переменной в заголовочном файле приведет к ошибке линковки из-за множественного определения
Strings.AVirtualFunctionIsMarkedfinalAndDoesNotOverrideABaseFunction=Виртуальная функция помечена как 'final' и не переопределяет базовую функцию
Strings.AbstractFinalClass=Абстрактный final класс
Strings.AccessSpecifierDoesNotAffectAnyDeclaration=Спецификатор доступа не влияет ни на одно объявление
Strings.AccessSpecifierDoesNotChangeAccessibilityLevel=Спецификатор доступа не изменяет уровень доступности
Strings.AddingCvQualifiersToReferencesHasNoEffect=Добавление cv-квалификаторов к ссылкам не имеет эффекта
Strings.AddingCvQualifiersToReferencesHasNoEffect9=Добавление cv-квалификаторов к ссылкам не имеет эффекта
Strings.AlgorithmAcceptingAnIteratorAndACountCanBeUsed=Может быть использован алгоритм, принимающий итератор и счетчик
Strings.AlgorithmAcceptingIteratorsIsUsedInsteadOfTheCorrespondingAlgorithmFromStdRanges=Используется алгоритм, принимающий итераторы, вместо соответствующего алгоритма из std\:\:ranges
Strings.AlgorithmOperatingOnRangesCanBeUsed=Может быть использован алгоритм, работающий с диапазонами
Strings.AnAbstractFinalClassIsMarkedAsfinalOrsealed=Абстрактный final класс помечен как 'final' или 'sealed'
Strings.AnAccessSpecifierDoesNotAffectAnyDeclarationAndIsRedundant=Спецификатор доступа не влияет ни на одно объявление и является избыточным
Strings.AnAccessSpecifierDoesNotChangeAccessibilityLevelAndIsRedundant=Спецификатор доступа не изменяет уровень доступности и является избыточным
Strings.AnArgumentOfBoostFormatShouldContainEitherPositionalNNOrSerialsArgumentsNotBoth=Аргумент boost\:\:format должен содержать либо позиционные (%N%, %|N$...|), либо последовательные (%|...|, %s) аргументы, но не оба
Strings.AnIncompleteTypeIsUsedInsideATemplateDeclarationOrDefinition=Неполный тип используется внутри объявления или определения шаблона
Strings.AnObjectMemberMightNotBeInitialized=Член объекта может быть не инициализован
Strings.AnOverrideFunctionRedefinesADefaultParameterArgumentPreviouslyDefinedInABaseFunction=Переопределяющая функция переопределяет аргумент параметра по умолчанию, ранее определённый в базовой функции
Strings.AwaiterTypeIsNotAClass=Тип awaiter не является классом
Strings.BackslashAndNewlineAreSeparatedBySpace=Обратный слеш и перевод строки разделены пробелом
Strings.BackslashIsNotALineContinuatorBecauseThereIsASpaceBetweenItAndTheEndOfTheLine=Обратный слеш не является продолжателем строки, так как между ним и концом строки есть пробел
Strings.BadFormatCodeForBoostFormat=Некорректная директива форматования в boost\:\:format
Strings.BinaryOperatorActsOnEqualOperands=Бинарный оператор действует на равные операнды
Strings.BinaryOperatorActsOnEqualOperands40=Бинарный оператор действует на равные операнды
Strings.BinaryOperatorActsOnIdenticalOperands=Бинарный оператор действует на идентичные операнды
Strings.BinaryOperatorActsOnIdenticalOperands39=Бинарный оператор действует на идентичные операнды
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension=Привязка r-value к l-value ссылке является нестандартным расширением Microsoft C++
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension2=Привязка r-value к l-value ссылке является нестандартным расширением Microsoft C++
Strings.BracesCanBeSafelyRemovedWithoutChangingCodeSemantics=Фигурные скобки можно безопасно удалить без изменения семантики кода
Strings.CStyleCastIsUsedInsteadOfACCast=Используется приведение типов в стиле C вместо приведения C++
Strings.CStyleCastIsUsedInsteadOfACCast1=Используется приведение типов в стиле C вместо приведения C++
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=Вызов удалённого конструктора копирования опущен при инициализации копированием. Это нестандартное расширение Microsoft C++.
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension5=Вызов удалённого конструктора копирования опущен при инициализации копированием. Это нестандартное расширение Microsoft C++.
Strings.CallToAVirtualFunctionInsideAConstructorDestructorIsResolvedAtCompileTime=Вызов виртуальной функции внутри конструктора/деструктора разрешается во время компиляции
Strings.CallToAVirtualFunctionInsideAConstructorDestructorWillResultInAPureVirtualFunctionCall=Вызов виртуальной функции внутри конструктора/деструктора приведет к вызову чисто виртуальной функции
Strings.CallsToPureVirtualFunctionsInsideConstructorsAndDestructorsAreARuntimeError=Вызовы чисто виртуальных функций внутри конструкторов и деструкторов приведут к ошибкам времени выполнения
Strings.CannotResolveARequiredCoroutineFunction=Не удаётся разрешить требуемую функцию сопрограммы
Strings.CastIsRedundantAndCanBeDeleted=Приведение типа избыточно и может быть удалено
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension=Приведение от nullptr к типу указателя с помощью reinterpret_cast является нестандартным расширением Microsoft C++
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension1=Приведение от nullptr к типу указателя с помощью reinterpret_cast является нестандартным расширением Microsoft C++
Strings.ClassCanBeMadeFinal=Класс может быть сделан final
Strings.ClassConstructorDoesntInitializeAFieldExplicitlyOrImplicitly=Конструктор класса не инициализует поле явно или неявно
Strings.ClassIsAbstractButNotExplicitlyDeclaredAsSuch=Класс является абстрактным, но явно не объявлен как таковой
Strings.ClassIsNeverUsed=Класс никогда не используется
Strings.ClassMemberFunctionHidesANonVirtualFunctionFromABaseClass=Метод класса скрывает невиртуальную функцию из базового класса
Strings.ClassMemberFunctionHidingANonVirtualFunctionFromABaseClass=Метод класса скрывает невиртуальную функцию из базового класса
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember=Класс должен иметь пользовательский конструктор из-за неинициализованного члена данных
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember25=Класс должен иметь пользовательский конструктор из-за неинициализованного члена данных
Strings.ComparisonOfUnsignedExpressionWith=Сравнение беззнакового выражения с 0
Strings.ComparisonOfUnsignedExpressionWith41=Сравнение беззнакового выражения с 0
Strings.CompileTimeConstantExpressionCanBeReplacedByEithertrueOrfalse=Константное выражение времени компиляции может быть заменено на 'true' или 'false'
Strings.CompileTimeIntegralConstantExpressionOrNullptrIsConvertedToBoolAndCanBeReplacedBytrueOrfalse=Целочисленное константное выражение времени компиляции или nullptr преобразуется в bool и может быть заменено на 'true' или 'false'
Strings.ConceptIsNeverUsed=Концепт никогда не используется
Strings.ConstQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=Квалификатор const для параметров имеет эффект только в определениях функций
Strings.ConstQualifiedParameterInAFunctionDeclaration=Параметр с квалификатором const в объявлении функции
Strings.ConstevalIfIsAlwaysConstantDescription=consteval if всегда константно
Strings.ConstevalIfIsAlwaysConstantTitle=consteval if всегда константно
Strings.ConstructorOfASmartPointerBoostStdSharedPtrUniquePtrIsUsedInsteadOfTheCorrespondingMakeSharedMakeUniqueMakeFunctionsAreExceptionSafeAndMoreEfficient=Используется конструктор умного указателя (boost/std\:\:shared_ptr/unique_ptr) вместо соответствующих make_shared/make_unique. Функции make являются исключение-безопасными и более эффективными.
Strings.ConstructorOfSmartPointerIsUsedInsteadOfItsMakeFunction=Используется конструктор умного указателя вместо его функции make
Strings.CppConditionalExpressionCanBeSimplifiedDescription=Условное выражение может быть упрощено
Strings.CppConditionalExpressionCanBeSimplifiedTitle=Условное выражение может быть упрощено
Strings.CppEvaluationFailureDescription=Выражение или значение объявителя не вычислилось в константу из-за ошибки во время вычислений 'constexpr'.
Strings.CppEvaluationFailureTitle=Ошибка вычисления времени компиляции
Strings.CppEvaluationInternalFailureTitle=[INTERNAL] Ошибка вычисления времени компиляции
Strings.CppRedundantComplexityInComparison=Выражение может быть упрощено
Strings.CppRedundantConditionalExpressionDescription=Избыточное условное выражение
Strings.CppRedundantConditionalExpressionTitle=Избыточное условное выражение
Strings.CppRedundantDereferencingAndTakingAddressDescription=Избыточное разыменование и взятие адреса
Strings.CppRedundantDereferencingAndTakingAddressTitle=Избыточное разыменование и взятие адреса
Strings.DeclarationAndAssignmentCanBeJoined=Объявление и присваивание могут быть объединены
Strings.DeclarationDoesNotDeclareAnything=Объявление ничего не объявляет
Strings.DeclarationOfANonOverridingVirtualFunctionInAFinalOrSealedClass=Объявление не переопределяющей виртуальной функции в final или sealed классе
Strings.DeclarationOfAVariableAndAssignmentToItCanBeJoined=Объявление переменной и присваивание ей значения могут быть объединены
Strings.DeclarationSpecifierWithNoDeclarators=Спецификатор объявления без объявителей
Strings.DeclarationSpecifierlongCanNotBeCombinedWithfloat=Спецификатор объявления 'long' не может быть скомбинирован с 'float'
Strings.DeclaratorDisambiguatedAsAFunctionDeclaration=Объявитель интерпретирован как объявление функции
Strings.DeclaratorIsDisambiguatedAsAFunctionDeclarationMakeSureAVariableDefinitionIsNotIntendedInstead=Объявитель интерпретирован как объявление функции. Убедитесь, что не подразумевалось определение переменной.
Strings.DeclaratorIsNeverUsed=Объявитель никогда не используется
Strings.DeclaratorIsOnlyAssignedButNeverAccessed=Объявителю только присваивается значение, но он никогда не используется
Strings.DeclaratorIsUsedOnlyInUnevaluatedContext=Объявитель используется только в невычисляемом контексте
Strings.DefaultCaseIsNotHandledInASwitchStatement=В операторе switch не обработан случай по умолчанию
Strings.DefaultCaseIsNotHandledInASwitchStatement20=В операторе switch не обработан случай по умолчанию
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor=Инициализация по умолчанию const-квалифицированного объекта типа без пользовательского конструктора по умолчанию
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor3=Инициализация по умолчанию const-квалифицированного объекта типа без пользовательского конструктора по умолчанию
Strings.DefaultedSpecialMemberFunctionIsImplicitlyDeleted=Специальная функция-член по умолчанию неявно удалена
Strings.DeletingAVoidPointer=Удаление void указателя
Strings.DeletingAVoidPointerIsUndefinedBehavior=Удаление void указателя является неопределённым поведением
Strings.DependentTemplateWithouttemplateKeyword=Зависимый шаблон без ключевого слова 'template'
Strings.DependentTemplateWithouttemplateKeyword24=Зависимый шаблон без ключевого слова 'template'
Strings.DependentTypeWithouttypenameKeyword=Зависимый тип без ключевого слова 'typename'
Strings.DependentTypeWithouttypenameKeyword23=Зависимый тип без ключевого слова 'typename'
Strings.DeprecatedregisterStorageClassSpecifier=Устаревший спецификатор класса хранения 'register'
Strings.DereferenceOperatorLimitIsExceeded=Превышен лимит операторов разыменования
Strings.DereferenceOperatorLimitIsExceeded10=Превышен лимит операторов разыменования
Strings.DetectsLeakProneResourceAcquisitionFreeingConstructs=Обнаруживает конструкции получения/освобождения ресурсов, склонные к утечкам
Strings.DontIntroduceANamespaceDefinitionOnlyForClassSpecializationSpecializationCanBeDefinedUsingQualifiedClassName=Не вводите определение пространства имён только для специализации класса, специализация может быть определена с использованием полного имени класса
Strings.DontIntroduceAVariableBeforeYouNeedToUseIt=Не объявляйте переменную до того, как она понадобится
Strings.ElaboratedTypeSpecifierIsRedundantAndCanBeDeleted=Уточненный спецификатор типа избыточен и может быть удален
Strings.EmptyParameterListInLambdaDeclaratorCanBeDeleted=Пустой список параметров в объявлении лямбды может быть удален
Strings.EnforceBracesIndoWhileStatement=Требовать фигурные скобки в операторе 'do-while'
Strings.EnforceBracesInforStatement=Требовать фигурные скобки в операторе 'for'
Strings.EnforceBracesInifStatement=Требовать фигурные скобки в операторе 'if'
Strings.EnforceBracesInwhileStatement=Требовать фигурные скобки в операторе 'while'
Strings.EnforceFunctionDeclarationStyle=Требовать стиль объявления функций
Strings.EnforceNestedNamespacesStyle=Требовать стиль вложенных пространств имён
Strings.EnforceOverridingDestructorStyle=Требовать стиль переопределения деструкторов
Strings.EnforceOverridingFunctionStyle=Требовать стиль переопределения функций
Strings.EnforceTheOrderOfCvQualifiers=Требовать порядок cv-квалификаторов
Strings.EnforceTheOrderOfCvQualifiers_Description=Требовать порядок cv-квалификаторов
Strings.EnforceThePlacementOfCvQualifiers=Требовать размещение cv-квалификаторов
Strings.EnforceThePlacementOfCvQualifiers_Description=Требовать размещение cv-квалификаторов
Strings.EnforceTheSyntaxUsedToDefineNestedNamespaces=Требовать синтаксис, используемый для определения вложенных пространств имён
Strings.EnforceThevirtualAndoverrideSpecifiersOnOverridingDestructors=Требовать спецификаторы 'virtual' и 'override' для переопределяющих деструкторов
Strings.EnforceThevirtualAndoverrideSpecifiersOnOverridingFunctions=Требовать спецификаторы 'virtual' и 'override' для переопределяющих функций
Strings.EnforceTypeAliasCodeStyle=Требовать стиль кода для псевдонимов типов
Strings.EnforceUsageOfTheTrailingReturnTypeOrTheRegularReturnTypeSyntax=Требовать использование синтаксиса возвращаемого типа в конце или обычного синтаксиса возвращаемого типа
Strings.EnforceUsageOfTypedefsOrTypeAliasesDependingOnTheSyntaxStyleSetting=Требовать использование typedef или псевдонимов типов в зависимости от настройки стиля синтаксиса
Strings.EntityIsDeprecated=Сущность устарела
Strings.EntityIsDeprecated37=Сущность устарела
Strings.EnumeratorIsNeverUsed=Перечислитель никогда не используется
Strings.ExplicitSpecializationInNonNamespaceScope=Явная специализация вне пространства имён
Strings.ExplicitSpecializationsOfATemplateInNonNamespaceScope=Явные специализации шаблона вне пространства имён
Strings.ExplicitlyDefaultedSpecialMemberFunctionIsImplicitlyDeleted=Явно заданная по умолчанию специальная функция-член неявно удалена
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant=Выражение, вычисляемое в ноль, используется как константа нулевого указателя
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant27=Выражение, вычисляемое в ноль, используется как константа нулевого указателя
Strings.FinalFunctionInAFinalClass=Final функция в final классе
Strings.FinalNonOverridingVirtualFunction=Final невиртуальная функция без переопределения
Strings.ForExampleWhenIteratingOnKeyValuePairsStdViewsKeysAllowsToIgnoreTheValues=Например, при итерации по парам ключ-значение, std\:\:views\:\:keys позволяет игнорировать значения.
Strings.ForLoopCanBeReplacedWithWhileLoop=Цикл for может быть заменен на цикл while
Strings.ForLoopWithoutInitStatementAndUpdateExpressionIsEquivalentToWhileLoop=Цикл for без инициализации и выражения обновления эквивалентен циклу while
Strings.FormatStringContainsAPotentialError=Строка форматования содержит потенциальную ошибку
Strings.FormatStringContainsAnInvalidPrintfFormatSpecifier=Строка форматования содержит недопустимый спецификатор формата printf
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeDescription=ISO C++ запрещает предварительные объявления enum без базового типа
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeTitle=Предварительное объявление enum без базового типа
Strings.FunctionIsNotImplemented=Функция не реализована
Strings.FunctionParameterIsNeverUsed=Параметр функции никогда не используется
Strings.FunctionResultShouldBeUsedDescription=Функция возвращает значение типа, которое должно быть обработано в месте вызова
Strings.FunctionResultShouldBeUsedTitle=Результат функции должен быть использован
Strings.FunctionReturnsByConstValue=Функция возвращает значение по const
Strings.FunctionalStyleCastIsUsedInsteadOfACCast=Используется функциональный стиль приведения типов вместо приведения C++
Strings.FunctionalStyleCastIsUsedInsteadOfACCast2=Используется функциональный стиль приведения типов вместо приведения C++
Strings.GuardedHeaderHasAlreadyBeenIncluded=Защищенный заголовочный файл уже был включен
Strings.GuardedHeaderHasAlreadyBeenIncluded50=Защищенный заголовочный файл уже был включен
Strings.HidingAnUncapturedLocalDeclaration=Скрытие незахваченного локального объявления
Strings.HidingLocalDeclaration=Скрытие локального объявления
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr=Оператор if с константным условием может быть заменен на 'if constexpr'
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr14=Оператор if с константным условием может быть заменен на 'if constexpr'
Strings.IfStdIsConstantEvaluatedCanBeReplacedDescription='if' может быть заменен на 'if consteval'
Strings.IfStdIsConstantEvaluatedCanBeReplacedTitle='if' может быть заменен на 'if consteval'
Strings.ImplicitConversionToIncompatiblePointerType=Неявное преобразование в несовместимый тип указателя
Strings.ImplicitConversionToIncompatiblePointerType32=Неявное преобразование в несовместимый тип указателя
Strings.ImplicitConversionToLessQualifiedPointerType=Неявное преобразование в тип указателя с потерей квалификаторов
Strings.ImplicitConversionToLessQualifiedPointerType33=Неявное преобразование в тип указателя с потерей квалификаторов
Strings.ImplicitDefaultConstructorIsNotAvailable=Неявный конструктор по умолчанию недоступен
Strings.ImplicitDefaultConstructorIsNotAvailableBecauseABaseClassOrAClassMemberDoesNotHaveAnAccessibleDefaultConstructor=Неявный конструктор по умолчанию недоступен, так как базовый класс или член класса не имеет доступного конструктора по умолчанию
Strings.ImplicitIntegerToPointerConversion=Неявное преобразование целого числа в указатель
Strings.ImplicitIntegerToPointerConversion30=Неявное преобразование целого числа в указатель
Strings.ImplicitPointerToIntegerConversion=Неявное преобразование указателя в целое число
Strings.ImplicitPointerToIntegerConversion31=Неявное преобразование указателя в целое число
Strings.InHLSLoutParametersMustBeAssignedBeforeExitingTheFunction=В HLSL параметры 'out' должны быть присвоены перед выходом из функции
Strings.IncludeGuardIsNotFoundAtTheBeginningOfAHeaderFile=Защита включения не найдена в начале заголовочного файла
Strings.InconsistentNaming_Description=Имя не соответствует стилю именования, определённому для этого типа символов
Strings.InconsistentNaming_Text=Несогласованное именование
Strings.IncorrectSpacing=Неправильные пробелы
Strings.IncrementingExpressionOfTypeBool=Инкремент выражения типа bool
Strings.IncrementingExpressionOfTypeBoolIsDeprecatedInCAndRemovedInC=Инкремент выражения типа bool устарел в C++11 и удален в C++17
Strings.InvalidPrintfFormatSpecifier=Неверный спецификатор формата printf
Strings.KeyworddefaultIsUsedAsIdentifier=Ключевое слово 'default' используется как идентификатор
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters=Лямбда может быть переписана с использованием явных шаблонных параметров
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters19=Лямбда может быть переписана с использованием явных шаблонных параметров
Strings.LambdaCaptureIsNeverUsed=Захват лямбды никогда не используется
Strings.LegacyFormatCodeForBoostFormat=Устаревшая директива формата в boost\:\:format
Strings.LocalVariableCanBeMadeConst=Локальная переменная может быть объявлена как const
Strings.LocalVariableCanBeMadeConst8=Локальная переменная может быть объявлена как const
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor=Локальная переменная никогда не используется, но может иметь побочные эффекты в деструкторе
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor4=Локальная переменная никогда не используется, но может иметь побочные эффекты в деструкторе
Strings.LocalVariableMightNotBeInitialized=Локальная переменная может быть не инициализована
Strings.LocalVariableUsedWithoutBeingInitialized=Локальная переменная используется без инициализации
Strings.LocalVariableUsedWithoutBeingInitialized5=Локальная переменная используется без инициализации
Strings.MayBeMissingKeywordthrow=Возможно пропущено ключевое слово 'throw'
Strings.MemberFunctionCanBeMadeConst=Метод класса может быть объявлен как const
Strings.MemberFunctionCanBeMadeConst6=Метод класса может быть объявлен как const
Strings.MemberFunctionCanBeMadeStatic=Метод класса может быть объявлен как static
Strings.MemberFunctionCanBeMadeStatic7=Метод класса может быть объявлен как static
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember=Метод должен быть public и virtual для реализации члена интерфейса C++/CLI
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember29=Метод должен быть public и virtual для реализации члена интерфейса C++/CLI
Strings.MismatchedClassTags=Несоответствующие теги классов
Strings.MissingFunctionParameterDescriptionInADocumentationComment=Отсутствует описание параметра функции в документирующем комментарии
Strings.MissingFunctionParameterDescriptionInADocumentationComment38=Отсутствует описание параметра функции в документирующем комментарии
Strings.MissingIncludeGuard=Отсутствует защита включения
Strings.MixedSerialAndPositionalArgumentsForBoostFormat=Позиционные и непозиционные аргументы в одном вызове boost\:\:format
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=При инициализации копированием применено более одного неявного преобразования. Это нестандартное расширение Microsoft C++.
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension4=При инициализации копированием применено более одного неявного преобразования. Это нестандартное расширение Microsoft C++.
Strings.MultiCharacterLiteralDescription=Многосимвольный символьный литерал
Strings.MultiCharacterLiteralTitle=Многосимвольный символьный литерал
Strings.MultiCharacterWideLiteralDescription=Многосимвольный широкий символьный литерал
Strings.MultiCharacterWideLiteralTitle=Многосимвольный широкий символьный литерал
Strings.NamespaceDefinitionContainingSingleClassSpecialization=Определение пространства имён, содержащее единственную специализацию класса
Strings.NoCorrespondingFileWithThePrecompiledHeaderPropertySetToCreateYcIsFound=Не найден соответствующий файл со свойством 'Precompiled Header' установленным в 'Create' (/Yc)
Strings.NoReturnStatementInAFunctionOrALambdaReturningNonVoid=Отсутствует оператор return в функции или лямбде, возвращающей не void
Strings.NoReturnStatementInAFunctionOrALambdaWithNonVoidReturnType=Отсутствует оператор return в функции или лямбде с возвращаемым типом не void
Strings.NoTypeSpecifierFoundInADeclarationDefaultsToint=Спецификатор типа не найден в объявлении. По умолчанию используется 'int'.
Strings.NodiscardCannotBeAppliedToFunctionsWithoutAReturnValue=[[nodiscard]] не может быть применен к функциям без возвращаемого значения
Strings.NonExplicitConversionOperator=Неявный оператор преобразования
Strings.NonExplicitConversionOperator5=Неявный оператор преобразования
Strings.NonExplicitConvertingConstructor=Неявный конструктор преобразования
Strings.NonExplicitConvertingConstructor4=Неявный конструктор преобразования
Strings.NonInlineFunctionDefinitionInAHeaderFile=Определение не-inline функции в заголовочном файле
Strings.NonInlineVariableDefinitionInAHeaderFile=Определение не-inline переменной в заголовочном файле
Strings.NonSafeResourceAcquisition=Небезопасное получение ресурса
Strings.NonStaticDataMemberIsUninitialized=Нестатический член данных не инициализован
Strings.NonStaticDataMemberIsUninitialized26=Нестатический член данных не инициализован
Strings.NonVirtualClassMemberFunctionHiddenInADerivedClass=Не-virtual метод класса скрыт в производном классе
Strings.NonVirtualClassMemberFunctionIsHiddenInADerivedClass=Не-virtual метод класса скрыт в производном классе
Strings.NotAllControlPathsInsideAFunctionOrALambdaReturnAValue=Не все пути выполнения внутри функции или лямбды возвращают значение
Strings.NotAllControlPathsReturnAValue=Не все пути выполнения возвращают значение
Strings.NotEnoughArgumentsInACallToBoostFormat=Недостаточно аргументов в вызове boost\:\:format
Strings.NotEnoughArgumentsInACallToBoostFormat36=Недостаточно аргументов в вызове boost\:\:format
Strings.NotEnoughArgumentsInACallToPrintf=Недостаточно аргументов в вызове printf
Strings.NotEnoughArgumentsInACallToPrintfSomeFormatCodesDoNotHaveAMatchingArgument=Недостаточно аргументов в вызове printf. Некоторые директивы формата не имеют соответствующих аргументов.
Strings.NotInitializedStaticConstLocalVariableOfScalarTypeThisIsNonStandardMicrosoftCExtension=Неинициализованная static const локальная переменная скалярного типа. Это нестандартное расширение Microsoft C++.
Strings.NumericTypeCanBeReplacedWithAuto=Числовой тип может быть заменен на auto
Strings.ObjectMemberMightNotBeInitialized=Член объекта может быть не инициализован
Strings.ObjectOfExceptionTypeIsCreatedButIsNotThrown=Создан объект типа исключения, но не выброшен
Strings.OrderOfIncludeDirectivesDoesNotMatchCodeStyleSettings=Порядок директив \#include не соответствует настройкам стиля кода
Strings.OrderOfIncludeDirectivesDoesNotMatchCodeStyleSettings1=Порядок директив \#include не соответствует настройкам стиля кода
Strings.OrderOfMemberInitializersDoesNotMatchTheInitializationOrder=Порядок инициализаторов членов не соответствует порядку инициализации
Strings.OrderOfMemberInitializersDoesNotMatchTheInitializationOrder3=Порядок инициализаторов членов не соответствует порядку инициализации
Strings.OverrideFunctionRedefinesADefaultParameterArgument=Переопределённая функция переопределяет аргумент параметра по умолчанию
Strings.ParameterCanBeMadeConst=Параметр может быть объявлен как const
Strings.ParameterCanBeMadeConst9=Параметр может быть объявлен как const
Strings.ParameterCanBeMadePointerReferenceToConst=Параметр может быть объявлен как указатель/ссылка на const
Strings.ParameterCanBeMadePointerReferenceToConst11=Параметр может быть объявлен как указатель/ссылка на const
Strings.ParameterIsNeverUsed=Параметр никогда не используется
Strings.ParameterNamesDifferInDifferentDeclarationsOfTheSameFunction=Имена параметров различаются в разных объявлениях одной и той же функции
Strings.ParameterNamesDoNotMatch=Имена параметров не совпадают
Strings.ParenthesesDontChangeOrderOfOperationsAndCanBeDeleted=Скобки не меняют порядок операций и могут быть удалены
Strings.PassValueParameterByConstReferenceDescription=Параметр типа с высокой стоимостью копирования передается по значению, но может быть передан по константной ссылке
Strings.PassValueParameterByConstReferenceTitle=Передача параметров-значений по константной ссылке
Strings.PolymorphicClassWithNonVirtualPublicDestructor=Полиморфный класс с невиртуальным публичным деструктором
Strings.PossiblyErroneousEmptyStatement=Возможно ошибочный пустой оператор
Strings.PossiblyErroneousEmptyStatementUsedInAControlStatement=Возможно ошибочный пустой оператор используется в управляющей конструкции
Strings.PossiblyErroneousExpressionWithoutSideEffects=Возможно ошибочное выражение без побочных эффектов
Strings.PossiblyErroneousExpressionWithoutSideEffects21=Возможно ошибочное выражение без побочных эффектов
Strings.PossiblyErroneousIncompleteSwitchStatement=Возможно ошибочный неполный оператор switch
Strings.PossiblyInvalidPrintfFormatSpecifier=Возможно некорректный спецификатор формата printf
Strings.PossiblyUninitializedClassMember=Возможно неинициализованный член класса
Strings.PossiblyUninitializedDependentBaseClass=Возможно неинициализованный зависимый базовый класс
Strings.PossiblyUnintendedIncompatibleReferenceTypeInRangeDeclaration=Возможно непреднамеренный несовместимый тип ссылки в объявлении диапазона
Strings.PossiblyUnintendedObjectSlicing=Возможно непреднамеренное срезание объекта
Strings.PossiblyUnintendedObjectSlicing28=Возможно непреднамеренное срезание объекта
Strings.PossiblyUnusedIncludeDirective=Возможно неиспользуемая директива \#include
Strings.PossiblyUnusedIncludeDirective7=Возможно неиспользуемая директива \#include
Strings.PragmaEndRegionIsMissingAMatchingEndRegionDescription=Для директивы '\#pragma endregion' отсутствует соответствующая директива '\#pragma region'
Strings.PragmaEndRegionIsMissingAMatchingEndRegionTitle=Отсутствует соответствующая директива '\#pragma region'
Strings.PragmaRegionIsMissingAMatchingEndRegionDescription=Для директивы '\#pragma region' отсутствует соответствующая директива '\#pragma endregion'
Strings.PragmaRegionIsMissingAMatchingEndRegionTitle=Отсутствует соответствующая директива '\#pragma endregion'
Strings.PrecompiledHeaderIsNotFound=Предкомпилированный заголовок не найден
Strings.PrecompiledHeaderIsNotIncluded=Предкомпилированный заголовок не включен
Strings.PrecompiledHeaderMustBeIncludedAtTheTopOfSourceFile=Предкомпилированный заголовок должен быть включен в начале исходного файла
Strings.PrivateSpecialMemberFunctionIsNotImplemented=Приватная специальная функция-член не реализована
Strings.ProhibitsTheUseOfTabulationCharacterEverywhereInFile=Запрещает использование символов табуляции во всем файле
Strings.QualifierIsRedundantAndCanBeDeleted=Квалификатор избыточен и может быть удален
Strings.RedeclarationOfATemplateParameterFromAnOuterScope=Повторное объявление параметра шаблона из внешней области видимости
Strings.RedundantArgumentInConditionalExpression=Избыточный аргумент в условном выражении
Strings.RedundantArgumentInConditionalExpression54=Избыточный аргумент в условном выражении
Strings.RedundantBaseClassAccessSpecifier=Избыточный спецификатор доступа базового класса
Strings.RedundantBaseClassAccessSpecifier53=Избыточный спецификатор доступа базового класса
Strings.RedundantBaseClassInitializerDescription=Избыточный инициализатор базового класса в списке инициализации членов
Strings.RedundantBaseClassInitializerTitle=Избыточный инициализатор базового класса
Strings.RedundantCastExpression=Избыточное приведение типов
Strings.RedundantControlFlowJumpStatement=Избыточный оператор перехода в потоке управления
Strings.RedundantControlFlowJumpStatement47=Избыточный оператор перехода в потоке управления
Strings.RedundantElaboratedTypeSpecifier=Избыточный уточненный спецификатор типа
Strings.RedundantEmptyDeclaration=Избыточное пустое объявление
Strings.RedundantEmptyDeclaration49=Избыточное пустое объявление
Strings.RedundantEmptyStatement=Избыточный пустой оператор
Strings.RedundantEmptyStatement48=Избыточный пустой оператор
Strings.RedundantExportKeywordMessage=Ключевое слово 'export' избыточно, так как существует охватывающее объявление export
Strings.RedundantMemberInitializerInConstructorInitializationList=Избыточный инициализатор члена в списке инициализации конструктора
Strings.RedundantMemberInitializerInConstructorInitializationList56=Избыточный инициализатор члена в списке инициализации конструктора
Strings.RedundantParameterListInLambdaDeclarator=Избыточный список параметров в объявлении лямбды
Strings.RedundantParentheses=Избыточные скобки
Strings.RedundantQualifier=Избыточный квалификатор
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableDescription=Избыточный спецификатор 'static' для локальной переменной 'thread_local'
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableTitle=Избыточный спецификатор 'static' для локальной переменной 'thread_local'
Strings.RedundantTemplateArguments=Избыточные аргументы шаблона
Strings.RedundantVoidArgumentList=Избыточный список аргументов void
Strings.RedundantVoidArgumentList55=Избыточный список аргументов void
Strings.RedundantWhitespaceCharactersAtTheEndOfALine=Избыточные символы пробела в конце строки
Strings.RedundantWhitespacesAtTheEndOfALine=Избыточные пробелы в конце строки
Strings.RedundantZeroInitializerInAggregateInitializationMessage=Избыточный нулевой инициализатор в агрегатной инициализации
Strings.RedundantconstSpecifier=Избыточный спецификатор 'const'
Strings.RedundantelseKeyword=Избыточное ключевое слово 'else'
Strings.RedundantelseKeyword45=Избыточное ключевое слово 'else'
Strings.RedundantelseKeywordInsideCompoundStatement=Избыточное ключевое слово 'else' внутри составного оператора
Strings.RedundantelseKeywordInsideCompoundStatement46=Избыточное ключевое слово 'else' внутри составного оператора
Strings.RedundantfinalSpecifierOnAFunctionInAFinalClass=Избыточный спецификатор 'final' для функции в final-классе
Strings.RedundantinlineSpecifier=Избыточный спецификатор 'inline'
Strings.RedundantstaticSpecifierOnAMemberAllocationDeallocationFunction=Избыточный спецификатор 'static' для функции выделения/освобождения памяти
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember=Избыточный спецификатор 'static' для члена анонимного пространства имён
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember52=Избыточный спецификатор 'static' для члена анонимного пространства имён
Strings.RedundanttemplateKeyword=Избыточное ключевое слово 'template'
Strings.RedundanttemplateKeyword43=Избыточное ключевое слово 'template'
Strings.RedundanttypenameKeyword=Избыточное ключевое слово 'typename'
Strings.RedundanttypenameKeyword42=Избыточное ключевое слово 'typename'
Strings.ReferenceClassMemberWithmutableSpecifier=Ссылочный член класса со спецификатором 'mutable'
Strings.ReferenceClassMembersCannotHavemutableSpecifier=Ссылочные члены класса не могут иметь спецификатор 'mutable'
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast=Используется reinterpret_cast вместо static_cast
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast3=Используется reinterpret_cast вместо static_cast
Strings.RemoveRedundantBraces=Удалить избыточные фигурные скобки
Strings.ResultOfAPostfixOperatorIsDiscarded=Результат постфиксного оператора отброшен
Strings.ResultOfAPostfixOperatorIsDiscardedItMightBeMoreEfficientToUseAPrefixFormOfTheOperator=Результат постфиксного оператора отброшен. Использование префиксной формы оператора может быть эффективнее.
Strings.ResultOfAssignmentIsUsedAsCondition=Результат присваивания используется как условие
Strings.ResultOfNodiscardFunctionIsNotUsed=Результат функции с атрибутом nodiscard не используется
Strings.ResultOfNodiscardFunctionIsNotUsed22=Результат функции с атрибутом nodiscard не используется
Strings.ReturningFromAFunctionByConstValueIsUsuallyNotBeneficialConsiderReturningValuesAsNonConstToTakeAdvantageOfMoveSemantics=Возврат из функции по константному значению обычно не выгоден. Рассмотрите возврат значений как не-const для использования семантики перемещения.
Strings.SlashSymbolUsedInIncludeDirectiveDoesntMatchCodeStyleSettings=Символ слеша в директиве \#include не соответствует настройкам стиля кода
Strings.SlashSymbolUsedInIncludeDirectiveDoesntMatchCodeStyleSettings2=Символ слеша в директиве \#include не соответствует настройкам стиля кода
Strings.SomeObjectMembersMightNotBeInitialized=Некоторые члены объекта могут быть не инициализованы
Strings.SpecialFunctionDoesntHaveAnyNoexceptSpecification=Специальная функция не имеет спецификации noexcept
Strings.SpecialFunctionWithoutNoexceptSpecification=Специальная функция без спецификации noexcept
Strings.StaticAssertFailedDescription=Ошибка static_assert
Strings.StaticAssertFailedTitle=Ошибка static_assert
Strings.StaticDataMemberInAnAnonymousClassIsNotAllowedByTheCStandard=Статический член данных в анонимном классе не разрешен стандартом C++
Strings.StaticDataMembersAreNotAllowedInAnonymousClasses=Статические члены данных не разрешены в анонимных классах
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantDescription='std\:\:is_constant_evaluated' всегда будет вычисляться как константа
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantTitle='std\:\:is_constant_evaluated' всегда будет вычисляться как константа
Strings.StdSizeCanBeUsed=Можно использовать std\:\:size
Strings.StdSizeIsTypeSafeAlternativeToCIdiomForArraySizeCalculation=std\:\:size является типобезопасной альтернативой идиоме C для вычисления размера массива
Strings.StdViewsKeysValuesCanBeUsed=Можно использовать std\:\:views\:\:keys/values
Strings.StringLiteralToCharPointerConversion=Преобразование строкового литерала в указатель на char
Strings.StringLiteralToCharPointerConversion34=Преобразование строкового литерала в указатель на char
Strings.StructuredBindingCanBeUsed=Можно использовать структурное связывание
Strings.StructuredBindingCanBeUsed15=Можно использовать структурное связывание
Strings.StructuredBindingCanBeUsedInsteadOfTie=Можно использовать структурное связывание вместо tie(..)
Strings.SyntaxErrorInADoxygenComment=Синтаксическая ошибка в комментарии doxygen
Strings.SyntaxErrorInDoxygenComment=Синтаксическая ошибка в комментарии doxygen
Strings.TabsAreProhibited=Использование табуляции запрещено
Strings.TagsOfTheDeclaredClassDoNotMatchPreviousDeclarations=Теги объявленного класса не соответствуют предыдущим объявлениям
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension=Взятие адреса r-value класса является нестандартным расширением Microsoft C++
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension3=Взятие адреса r-value класса является нестандартным расширением Microsoft C++
Strings.TemplateArgumentsCanBeDeduced=Аргументы шаблона могут быть выведены
Strings.TemplateParameterIsNeverUsedDescription=Параметр шаблона никогда не используется
Strings.TemplateParameterIsNeverUsedTitle=Параметр шаблона никогда не используется
Strings.TheAwaiterTypeMustBeAAClassAccordingToTheCStandard=Согласно стандарту C++20, тип awaiter должен быть классом
Strings.TheClassIsAbstractButNotExplicitlyDeclaredAsSuch=Класс является абстрактным, но явно не объявлен как таковой
Strings.TheNodiscardAttributeCannotBeAppliedToFunctionsWithoutAReturnValue=Атрибут [[nodiscard]] нельзя применять к функциям без возвращаемого значения
Strings.TheSwitchStatementDoesntCoverTheWholeRangeOfTheEnumerationUsed=Оператор switch не охватывает весь диапазон используемого перечисления
Strings.TheconstSpecifierOnAVariableDefinitionIsRedundant=Спецификатор 'const' в определении переменной избыточен
Strings.TheinlineSpecifierOnAFunctionDefinitionIsRedundant=Спецификатор 'inline' в определении функции избыточен
Strings.TheoutParameterMustBeAssigned=Параметру 'out' должно быть присвоено значение
Strings.TheregisterStorageClassSpecifierIsDeprecatedInCAndRemovedInC=Спецификатор класса хранения 'register' устарел в C++11 и удален в C++17
Strings.ThestaticSpecifierIsOptionalForMemberAllocationDeallocationFunctions=Спецификатор 'static' является необязательным для функций выделения/освобождения памяти
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression=Выражение throw может быть заменено на выражение rethrow
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression12=Выражение throw может быть заменено на выражение rethrow
Strings.TooManyArgumentsInACallToBoostFormat=Слишком много аргументов в вызове boost\:\:format
Strings.TooManyArgumentsInACallToBoostFormatSomeOfTheArgumentsAreNotUsed=Слишком много аргументов в вызове boost\:\:format. Некоторые аргументы не используются.
Strings.TooManyArgumentsInACallToPrintf=Слишком много аргументов в вызове printf
Strings.TooManyArgumentsInACallToPrintfSomeOfTheArgumentsAreNotUsed=Слишком много аргументов в вызове printf. Некоторые аргументы не используются.
Strings.TypeAliasIsNeverUsed=Псевдоним типа никогда не используется
Strings.TypeCanBeReplacedWithAuto=Тип может быть заменен на auto
Strings.TypeCanBeReplacedWithauto4=Тип может быть заменен на 'auto'
Strings.TypeSpecifierMissingDefaultsToInt=Отсутствует спецификатор типа, по умолчанию используется int
Strings.TypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=Type trait может быть упрощен с помощью псевдонима шаблона или шаблона переменной
Strings.UninitializedDependentBaseClass=Неинициализованный зависимый базовый класс
Strings.UnionMemberOfReferenceType=Член объединения ссылочного типа
Strings.UnionsCannotContainNonStaticDataMembersOfReferenceTypes=Объединения не могут содержать нестатические члены данных ссылочных типов
Strings.UnnamedNamespaceInAHeaderFile=Безымянное пространство имён в заголовочном файле
Strings.UnnamedNamespacesShouldNotBeUsedInHeaderFiles=Безымянные пространства имён не следует использовать в заголовочных файлах
Strings.UnresolvedReferenceInADoxygenComment=Неразрешённая ссылка в комментарии doxygen
Strings.UnresolvedReferenceInDoxygenComment=Неразрешённая ссылка в комментарии doxygen
Strings.UseBracesToSeparatedoWhileStatementBody=Используйте фигурные скобки для выделения тела оператора 'do-while'
Strings.UseBracesToSeparateforStatementBody=Используйте фигурные скобки для выделения тела оператора 'for'
Strings.UseBracesToSeparateifStatementBody=Используйте фигурные скобки для выделения тела оператора 'if'
Strings.UseBracesToSeparatewhileStatementBody=Используйте фигурные скобки для выделения тела оператора 'while'
Strings.UseOfAnIncompleteTypeInsideATemplate=Использование неполного типа внутри шаблона
Strings.UsePreferredBracesStyle=Используйте предпочтительный стиль фигурных скобок
Strings.UsePreferredCvQualifiersStyle=Используйте предпочтительный стиль cv-квалификаторов
Strings.UsePreferredDeclarationStyle=Используйте предпочтительный стиль объявления
Strings.UsePreferredIncludeDirectiveStyle=Используйте предпочтительный стиль директивы include
Strings.UsePreferredInitializationStyle=Используйте предпочтительный стиль инициализации
Strings.UsePreferredOverridingFunctionStyle=Используйте предпочтительный стиль переопределения функций
Strings.UsePreferredautoStyle=Используйте предпочтительный стиль 'auto'
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscore=Пользовательские суффиксы литералов должны начинаться с подчеркивания
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscoreTheSuffixesThatDoNotBeginWithAnUnderscoreAreReservedForTheLiteralOperatorsProvidedByTheStandardLibrary=Пользовательские суффиксы литералов должны начинаться с подчеркивания. Суффиксы, не начинающиеся с подчеркивания, зарезервированы для операторов литералов стандартной библиотеки.
Strings.UsingAnIncompatibleReferenceTypeInTheRangeDeclarationIsLikelyToCauseUnwantedObjectCopying=Использование несовместимого ссылочного типа в объявлении диапазона может привести к нежелательному копированию объектов
Strings.VariableCanBeMadeConstexpr=Переменная может быть объявлена как constexpr
Strings.VariableCanBeMadeConstexpr10=Переменная может быть объявлена как constexpr
Strings.VariableCanBeMovedToInitStatement=Переменная может быть перемещена в init-выражение
Strings.VariableCanBeMovedToInnerScope=Переменная может быть перемещена во внутреннюю область видимости
Strings.VolatileQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=Квалификатор volatile для параметров имеет эффект только в определениях функций
Strings.VolatileQualifiedParameterInAFunctionDeclaration=Параметр с квалификатором volatile в объявлении функции
Strings.WarningDirectiveDescription=Директива препроцессора \#warning
Strings.WarningDirectiveTitle=Директива \#warning
Strings.ZeroConstantCanBeReplacedWithNullptr=Нулевая константа может быть заменена на nullptr
Strings.ZeroConstantCanBeReplacedWithNullptr13=Нулевая константа может быть заменена на nullptr
Strings.ZeroInitializationCanBeUsedInsteadOfMemset=Вместо memset можно использовать инициализацию нулем
Strings.ZeroInitializationCanBeUsedInsteadOfMemset16=Вместо memset можно использовать инициализацию нулем
Strings.containsMemberFunctionCanBeUsed=Можно использовать функцию-член 'contains'
Strings.containsMemberFunctionCanBeUsed17=Можно использовать функцию-член 'contains'
Strings.defaultIsAKeywordInTheCStandardAndCannotBeUsedAsAnIdentifier='default' является ключевым словом в стандарте C++ и не может использоваться как идентификатор
Strings.longFloatsAreNotAllowedByTheCStandard=Стандарт C++ не допускает использование 'long' с типом float
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom=Вместо идиомы remove-erase можно использовать 'std\:\:erase'/'std\:\:erase_if'
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom18=Вместо идиомы remove-erase можно использовать 'std\:\:erase'/'std\:\:erase_if'