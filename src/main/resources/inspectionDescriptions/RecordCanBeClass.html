<html>
<body>
Сообщает о записях (records) и предлагает преобразовать их в обычные классы.
<p>Эта проверка может преобразовать Java-записи в код, совместимый с более ранними версиями Java, применяя быстрое исправление.</p>
<p>
  Обратите внимание, что сгенерированные классы не полностью эквивалентны исходным записям:
</p>
<ul>
  <li>Полученный класс больше не наследует <code>java.lang.Record</code>, поэтому <code>instanceof Record</code> возвращает <code>false</code>.</li>
  <li>Методы рефлексии, такие как <code>Class.isRecord()</code> и <code>Class.getRecordComponents()</code>, будут давать другие результаты.</li>
  <li>Сгенерированная реализация <code>hashCode()</code> может давать другие результаты, так как формула вычисления <code>hashCode</code> для записей намеренно не специфицирована.</li>
  <li>Механизм сериализации записей отличается от механизма сериализации обычных классов.
    Подробности см. в <i>спецификации сериализации объектов Java</i>.</li>
</ul>
<p>Пример:</p>
<pre><code>
  record Point(int x, int y) {}
</code></pre>
<p>После применения быстрого исправления:</p>
<pre><code>
  final class Point {
    private final int x;
    private final int y;
    Point(int x, int y) {
      this.x = x;
      this.y = y;
    }
    public int x() { return x; }
    public int y() { return y; }
    @Override
    public boolean equals(Object obj) {
      if (obj == this) return true;
      if (obj == null || obj.getClass() != this.getClass()) return false;
      var that = (Point)obj;
      return this.x == that.x &&
             this.y == that.y;
    }
    @Override
    public int hashCode() {
      return Objects.hash(x, y);
    }
    @Override
    public String toString() {
      return "Point[" +
             "x=" + x + ", " +
             "y=" + y + ']';
    }
  }
</code></pre>
<p><small>Новое в версии 2020.3</small></p>
</body>
</html>
