<html>
<body>
Сообщает о избыточной квалификации родительского типа при вызове членов через <code>super</code>.
<p>
    Код в производном классе может вызывать реализации функций и свойств родительского класса с помощью ключевого слова <code>super</code>.
    Чтобы указать родительский тип, от которого наследуется реализация, можно квалифицировать <code>super</code> именем родительского типа в угловых скобках, например <code>super&lt;Base&gt;</code>. Иногда такая квалификация избыточна и может быть опущена.
    Используйте быстрое исправление "Удалить явную квалификацию родительского типа" для очистки кода.
</p>
<p><b>Пример:</b></p>
<pre><code>
  open class B {
      open fun foo(){}
  }
  class A : B() {
      override fun foo() {
         super&lt;B&gt;.foo() // &lt;== Избыточно, так как 'B' является единственным родительским типом
      }
  }
  interface I {
      fun foo() {}
  }
  class C : B(), I {
      override fun foo() {
          super&lt;B&gt;.foo() // &lt;== Здесь квалификатор &lt;B&gt; необходим для различения 'B.foo()' и 'I.foo()'
      }
  }
</code></pre>
<p>После применения быстрого исправления:</p>
<pre><code>
  open class B {
      open fun foo(){}
  }
  class A : B() {
      override fun foo() {
         super.foo() // &lt;== Обновлено
      }
  }
  interface I {
      fun foo() {}
  }
  class C : B(), I {
      override fun foo() {
          super&lt;B&gt;.foo()
      }
  }
</code></pre>
</body>
</html>
