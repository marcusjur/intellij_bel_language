<html>
<body>
Сообщает о любых объявлениях переменных, которые можно переместить в более узкую область видимости.
<p>Эта проверка особенно полезна для объявлений в стиле <i>Pascal</i> в начале метода. Кроме того, переменные со слишком широкой областью видимости часто остаются после рефакторинга.</p>
<p><b>Пример:</b></p>
<pre><code>
  StringBuilder sb = new StringBuilder();
  System.out.println();
  sb.append(1);
</code></pre>
<p>После применения быстрого исправления:</p>
<pre><code>
  System.out.println();
  StringBuilder sb = new StringBuilder();
  sb.append(1);
</code></pre>
<p>Настройка проверки:</p>
<ul>
  <li>Опция <b>Сообщать только о переменных, которые можно переместить во внутренний блок</b> позволяет отображать только те переменные, которые можно переместить в более глубокий блок кода.
    Например, когда эта опция включена, перемещение переменной <code>sb</code> из примера выше не будет предложено.
    Однако это будет предложено для следующего кода:
<pre><code>
  StringBuilder sb = new StringBuilder(a);
  if (flag) {
    sb.append(1);
  }
</code></pre></li>
  <li>Опция <b>Сообщать о переменных с инициализаторами new (потенциально небезопасно)</b> позволяет отображать переменные, инициализованные с помощью выражения new. Это может быть небезопасно, когда конструктор имеет нелокальные побочные эффекты. Например, когда эта опция включена, будет предложено переместить переменную <code>foo</code>:
<pre><code>
  class Foo {
    static List&lt;Foo&gt; fooList = new ArrayList&lt;&gt;();
    String bar;
    Foo(String bar) {
        this.bar = bar;
        fooList.add(this);
    }
    public static void main(String[] args) {
      // Небезопасно, но перемещение возможно
      Foo foo = new Foo("bar");
      System.out.println(fooList.size());
      System.out.println(foo.bar);
    }
  }
</code></pre></li>
</ul>
</body>
</html>
