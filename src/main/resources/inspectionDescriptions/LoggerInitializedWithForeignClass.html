<html>
<body>
Сообщает об экземплярах <code>Logger</code>, где класс, указанный в литерале <code>class</code> для инициализации, отличается от класса, которому принадлежит <code>Logger</code>. Это часто происходит при копировании и вставке кода из другого класса и может привести к регистрации событий в неправильной категории и некорректному применению фильтров.
<p>Доступно быстрое исправление для замены литерала внешнего класса на литерал текущего класса.</p>
<p><b>Пример:</b></p>
<pre><code>
  <b>public class</b> Paramount {
    <b>protected static final</b> Logger LOG = Logger.getLogger(Critical.class);
    // …другие поля и методы
  }
</code></pre>
<p>После применения быстрого исправления:</p>
<pre><code>
  <b>public class</b> Paramount {
    <b>protected static final</b> Logger LOG = Logger.getLogger(Paramount.class);
    // …другие поля и методы
  }
</code></pre>
<p>
  Настройка проверки:
</p>
<ul>
  <li>Используйте таблицу для указания классов и методов фабрики логгера, которые должна распознавать эта проверка.</li>
  <li>Используйте опцию <b>Игнорировать логгеры, инициализованные суперклассом</b>, чтобы пропускать логгеры, инициализованные суперклассом содержащего их класса.</li>
  <li>Используйте опцию <b>Игнорировать логгеры в непубличных классах</b>, чтобы выдавать предупреждения только для логгеров в классах с модификатором <code>public</code>.</li>
  <li>Используйте опцию <b>Игнорировать логгеры, не инициализованные в final полях</b>, чтобы проверять только логгеры, инициализованные в final полях, игнорируя остальные случаи.</li>
</ul>
</body>
</html>
