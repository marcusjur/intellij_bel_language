<html>
<body>
Сообщает о множественных эквивалентных вхождениях одного и того же выражения в методе (или конструкторе, или инициализаторе класса), если результат выражения может быть переиспользован.
<p>
  Выражение отмечается, если оно не имеет побочных эффектов и его результат всегда одинаков (в смысле <code>Object.equals()</code>).
  Примеры таких выражений: <code>a + b</code>, <code>Math.max(a, b)</code>, <code>a.equals(b)</code>, <code>s.substring(a,b)</code>. Для гарантии неизменности результата проверяется, что переменные, используемые в выражении, не изменяют своих значений между вхождениями выражения.</p>
<p>
  Такие выражения могут включать методы неизменяемых классов (таких как <code>String</code>, <code>BigDecimal</code> и т.д.) и служебных классов (таких как <code>Objects</code>, <code>Math</code>, за исключением <code>random()</code>).
  Также можно использовать распространенные методы, такие как <code>Object.equals()</code>, <code>Object.hashCode()</code>, <code>Object.toString()</code>,
   <code>Comparable.compareTo()</code> и <code>Comparator.compare()</code>, поскольку они не имеют видимых побочных эффектов.
</p>
<p>
  Используйте опцию <b>порог сложности выражения</b> для указания минимального порога сложности выражений. Указание большего числа уберет сообщения о коротких выражениях.
</p>
<p>
  Вызовы <code>Path.of</code> и <code>Paths.get</code> считаются эквивалентными, если они имеют одинаковые аргументы. Эти вызовы всегда будут отмечаться независимо от сложности их аргументов. Это поведение можно настроить, используя различные пороги сложности.
</p>
<p><small>Новое в версии 2018.3</small></p>
</body>
</html>
