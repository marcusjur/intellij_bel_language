<html>
<body>
<p>Сообщает о потенциально небезопасных вызовах встраиваемых функций с гибким nullable-расширением получателя (платформенный тип с неизвестной nullability).</p>
<p>
    До Kotlin 1.2 вызовы <code>inline fun</code> с гибким nullable-расширением получателя (платформенный тип с неизвестной nullability) не включали проверки на null в байткоде. Начиная с Kotlin 1.2, проверки на null включены в байткод (см. <a href="https://youtrack.jetbrains.com/issue/KT-12899">KT-12899</a>).
</p>
<p>
    Рекомендуется добавить явный оператор <code>!!</code> для выброса исключения или рассмотреть возможность изменения типа получателя функции на nullable (если функция может работать без исключений).
</p>
<p><b>Пример:</b></p>
<pre><code>
  inline fun String.removePrefix(prefix: String): String {
      return this.substring(prefix.length)
  }
  fun main() {
      // `System.getProperty` возвращает непредставимый тип `String!`
      val property = System.getProperty("user.dir")
      println(property.removePrefix("/home"))
  }
</code></pre>
<p>После применения быстрого исправления:</p>
<pre><code>
  inline fun String.removePrefix(prefix: String): String {
      return this.substring(prefix.length)
  }
  fun main() {
      // `System.getProperty` возвращает непредставимый тип `String!`
      val property = System.getProperty("user.dir")
      println(property!!.removePrefix("/home"))
  }
</code></pre>
<p>Эта проверка выполняется только если уровень языка Kotlin в проекте или модуле ниже 1.2.</p>
</body>
</html>
