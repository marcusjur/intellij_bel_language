<html>
<body>
Сообщает о циклах <code>while</code>, которые выполняют спин на не-<code>volatile</code> полях, ожидая их изменения другим потоком.
<p>
Помимо того, что такие циклы могут потреблять значительные ресурсы CPU при выполнении минимальной работы внутри цикла, они также могут иметь семантику, отличную от ожидаемой.
Модель памяти Java допускает, что такие циклы могут никогда не завершиться, даже если другой поток изменит значение поля.
</p>
<p>
Кроме того, начиная с Java 9, рекомендуется вызывать <code>Thread.onSpinWait()</code> в циклах спина на <code>volatile</code> полях, что может значительно улучшить производительность на определённых аппаратных платформах.
</p>
<p><b>Пример:</b></p>
<pre><code>
  class SpinsOnField {
    boolean ready = false;
    void run() {
      while (!ready) {
      }
      // выполнить некоторую работу
    }
    void markAsReady() {
      ready = true;
    }
  }
</code></pre>
<p>После применения быстрого исправления:</p>
<pre><code>
  class SpinsOnField {
    volatile boolean ready = false;
    void run() {
      while (!ready) {
        Thread.onSpinWait();
      }
      // выполнить некоторую работу
    }
    void markAsReady() {
      ready = true;
    }
  }
</code></pre>
<p>
Используйте опцию проверки, чтобы сообщать только о пустых циклах <code>while</code>.
<p>
</body>
</html>
